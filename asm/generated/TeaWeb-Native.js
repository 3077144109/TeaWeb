/*
  vim: set ts=8 sts=2 et sw=2 tw=79:
  Copyright (C) 2013

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
*/

// A conforming SIMD.js implementation may contain the following deviations to
// normal JS numeric behavior:
//  - Subnormal numbers may or may not be flushed to zero on input or output of
//    any SIMD operation.

// Many of the operations in SIMD.js have semantics which correspond to scalar
// operations in JS, however there are a few differences:
//  - Vector shifts don't mask the shift count.
//  - Conversions from float to int32 throw on error.
//  - Load and store operations throw when out of bounds.

(function(global) {

if (typeof global.SIMD === "undefined") {
  // SIMD module.
  global.SIMD = {};
}

if (typeof module !== "undefined") {
  // For CommonJS modules
  module.exports = global.SIMD;
}

var SIMD = global.SIMD;

// Buffers for bit casting and coercing lane values to those representable in
// the underlying lane type.
var _f32x4 = new Float32Array(4);
var _f64x2 = new Float64Array(_f32x4.buffer);
var _i32x4 = new Int32Array(_f32x4.buffer);
var _i16x8 = new Int16Array(_f32x4.buffer);
var _i8x16 = new Int8Array(_f32x4.buffer);
var _ui32x4 = new Uint32Array(_f32x4.buffer);
var _ui16x8 = new Uint16Array(_f32x4.buffer);
var _ui8x16 = new Uint8Array(_f32x4.buffer);

function convertValue(buffer, value) {
  buffer[0] = value;
  return buffer[0];
}

function convertArray(buffer, array) {
  for (var i = 0; i < array.length; i++)
    array[i] = convertValue(buffer, array[i]);
  return array;
}

// Utility functions.

function isInt32(o) {
  return (o | 0) === o;
}

function isTypedArray(o) {
  return (o instanceof Int8Array) ||
         (o instanceof Uint8Array) ||
         (o instanceof Uint8ClampedArray) ||
         (o instanceof Int16Array) ||
         (o instanceof Uint16Array) ||
         (o instanceof Int32Array) ||
         (o instanceof Uint32Array) ||
         (o instanceof Float32Array) ||
         (o instanceof Float64Array);
}

function minNum(x, y) {
  return x != x ? y :
         y != y ? x :
         Math.min(x, y);
}

function maxNum(x, y) {
  return x != x ? y :
         y != y ? x :
         Math.max(x, y);
}

function clamp(a, min, max) {
  if (a < min)
    return min;
  if (a > max)
    return max;
  return a;
}

// SIMD implementation functions

function simdCheckLaneIndex(index, lanes) {
  if (!isInt32(index))
    throw new TypeError('Lane index must be an int32');
  if (index < 0 || index >= lanes)
    throw new RangeError('Lane index must be in bounds');
}

// Global lanes array for constructing SIMD values.
var lanes = [];

function simdCreate(type) {
  return type.fn.apply(type.fn, lanes);
}

function simdToString(type, a) {
  a = type.fn.check(a);
  var str = "SIMD." + type.name + "(";
  str += type.fn.extractLane(a, 0);
  for (var i = 1; i < type.lanes; i++) {
    str += ", " + type.fn.extractLane(a, i);
  }
  return str + ")";
}

function simdToLocaleString(type, a) {
  a = type.fn.check(a);
  var str = "SIMD." + type.name + "(";
  str += type.fn.extractLane(a, 0).toLocaleString();
  for (var i = 1; i < type.lanes; i++) {
    str += ", " + type.fn.extractLane(a, i).toLocaleString();
  }
  return str + ")";
}

function simdSplat(type, s) {
  for (var i = 0; i < type.lanes; i++)
    lanes[i] = s;
  return simdCreate(type);
}

function simdReplaceLane(type, a, i, s) {
  a = type.fn.check(a);
  simdCheckLaneIndex(i, type.lanes);
  for (var j = 0; j < type.lanes; j++)
    lanes[j] = type.fn.extractLane(a, j);
  lanes[i] = s;
  return simdCreate(type);
}

function simdFrom(toType, fromType, a) {
  a = fromType.fn.check(a);
  for (var i = 0; i < fromType.lanes; i++) {
    var v = Math.trunc(fromType.fn.extractLane(a, i));
    if (toType.minVal !== undefined &&
        !(toType.minVal <= v && v <= toType.maxVal)) {
      throw new RangeError("Can't convert value");
    }
    lanes[i] = v;
  }
  return simdCreate(toType);
}

function simdFromBits(toType, fromType, a) {
  a = fromType.fn.check(a);
  var newValue = new toType.fn();
  newValue.s_ = new toType.view(a.s_.buffer);
  return newValue;
}

function simdSelect(type, selector, a, b) {
  selector = type.boolType.fn.check(selector);
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < type.lanes; i++) {
    lanes[i] = type.boolType.fn.extractLane(selector, i) ?
               type.fn.extractLane(a, i) : type.fn.extractLane(b, i);
  }
  return simdCreate(type);
}

function simdSwizzle(type, a, indices) {
  a = type.fn.check(a);
  for (var i = 0; i < indices.length; i++) {
    simdCheckLaneIndex(indices[i], type.lanes);
    lanes[i] = type.fn.extractLane(a, indices[i]);
  }
  return simdCreate(type);
}

function simdShuffle(type, a, b, indices) {
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < indices.length; i++) {
    simdCheckLaneIndex(indices[i], 2 * type.lanes);
    lanes[i] = indices[i] < type.lanes ?
               type.fn.extractLane(a, indices[i]) :
               type.fn.extractLane(b, indices[i] - type.lanes);
  }
  return simdCreate(type);
}

function unaryNeg(a) { return -a; }
function unaryBitwiseNot(a) { return ~a; }
function unaryLogicalNot(a) { return !a; }

function simdUnaryOp(type, op, a) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++)
    lanes[i] = op(type.fn.extractLane(a, i));
  return simdCreate(type);
}

function binaryAnd(a, b) { return a & b; }
function binaryOr(a, b) { return a | b; }
function binaryXor(a, b) { return a ^ b; }
function binaryAdd(a, b) { return a + b; }
function binarySub(a, b) { return a - b; }
function binaryMul(a, b) { return a * b; }
function binaryDiv(a, b) { return a / b; }

var binaryImul;
if (typeof Math.imul !== 'undefined') {
  binaryImul = Math.imul;
} else {
  binaryImul = function(a, b) {
    var ah = (a >>> 16) & 0xffff;
    var al = a & 0xffff;
    var bh = (b >>> 16) & 0xffff;
    var bl = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0)|0);
  };
}

function simdBinaryOp(type, op, a, b) {
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < type.lanes; i++)
    lanes[i] = op(type.fn.extractLane(a, i), type.fn.extractLane(b, i));
  return simdCreate(type);
}

function binaryEqual(a, b) { return a == b; }
function binaryNotEqual(a, b) { return a != b; }
function binaryLess(a, b) { return a < b; }
function binaryLessEqual(a, b) { return a <= b; }
function binaryGreater(a, b) { return a > b; }
function binaryGreaterEqual(a, b) { return a >= b; }

function simdRelationalOp(type, op, a, b) {
  a = type.fn.check(a);
  b = type.fn.check(b);
  for (var i = 0; i < type.lanes; i++)
    lanes[i] = op(type.fn.extractLane(a, i), type.fn.extractLane(b, i));
  return simdCreate(type.boolType);
}

function simdAnyTrue(type, a) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++)
    if (type.fn.extractLane(a, i)) return true;
  return false;
}

function simdAllTrue(type, a) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++)
    if (!type.fn.extractLane(a, i)) return false;
  return true;
}

function binaryShiftLeft(a, bits) { return a << bits; }
function binaryShiftRightArithmetic(a, bits) { return a >> bits; }
function binaryShiftRightLogical(a, bits) { return a >>> bits; }

function simdShiftOp(type, op, a, bits) {
  a = type.fn.check(a);
  for (var i = 0; i < type.lanes; i++)
    lanes[i] = op(type.fn.extractLane(a, i), bits);
  return simdCreate(type);
}

function simdLoad(type, tarray, index, count) {
  if (!isTypedArray(tarray))
    throw new TypeError("The 1st argument must be a typed array.");
  if (!isInt32(index))
    throw new TypeError("The 2nd argument must be an Int32.");
  var bpe = tarray.BYTES_PER_ELEMENT;
  var bytes = count * type.laneSize;
  if (index < 0 || (index * bpe + bytes) > tarray.byteLength)
    throw new RangeError("The value of index is invalid.");

  var newValue = type.fn();
  var dst = new Uint8Array(newValue.s_.buffer);
  var src = new Uint8Array(tarray.buffer, tarray.byteOffset + index * bpe, bytes);

  for (var i = 0; i < bytes; i++) {
    dst[i] = src[i];
  }
  var typeBytes = type.lanes * type.laneSize;
  for (var i = bytes; i < typeBytes; i++) {
    dst[i] = 0;
  }
  return newValue;
}

function simdStore(type, tarray, index, a, count) {
  if (!isTypedArray(tarray))
    throw new TypeError("The 1st argument must be a typed array.");
  if (!isInt32(index))
    throw new TypeError("The 2nd argument must be an Int32.");
  var bpe = tarray.BYTES_PER_ELEMENT;
  var bytes = count * type.laneSize;
  if (index < 0 || (index * bpe + bytes) > tarray.byteLength)
    throw new RangeError("The value of index is invalid.");

  a = type.fn.check(a);

  // The underlying buffers are copied byte by byte, to avoid float
  // canonicalization.
  var src = new Uint8Array(a.s_.buffer);
  var dst = new Uint8Array(tarray.buffer, tarray.byteOffset + index * bpe, bytes);
  for (var i = 0; i < bytes; i++) {
    dst[i] = src[i];
  }
  return a;
}

// Constructors and extractLane functions are closely related and must be
// polyfilled together.

// Float32x4
if (typeof SIMD.Float32x4 === "undefined" ||
    typeof SIMD.Float32x4.extractLane === "undefined") {
  SIMD.Float32x4 = function(s0, s1, s2, s3) {
    if (!(this instanceof SIMD.Float32x4)) {
      return new SIMD.Float32x4(s0, s1, s2, s3);
    }
    this.s_ = convertArray(_f32x4, new Float32Array([s0, s1, s2, s3]));
  }

  SIMD.Float32x4.extractLane = function(v, i) {
    v = SIMD.Float32x4.check(v);
    simdCheckLaneIndex(i, 4);
    return v.s_[i];
  }
}

// Miscellaneous functions that aren't easily parameterized on type.

if (typeof SIMD.Float32x4.swizzle === "undefined") {
  SIMD.Float32x4.swizzle = function(a, s0, s1, s2, s3) {
    return simdSwizzle(float32x4, a, [s0, s1, s2, s3]);
  }
}

if (typeof SIMD.Float32x4.shuffle === "undefined") {
  SIMD.Float32x4.shuffle = function(a, b, s0, s1, s2, s3) {
    return simdShuffle(float32x4, a, b, [s0, s1, s2, s3]);
  }
}

// Int32x4
if (typeof SIMD.Int32x4 === "undefined" ||
    typeof SIMD.Int32x4.extractLane === "undefined") {
  SIMD.Int32x4 = function(s0, s1, s2, s3) {
    if (!(this instanceof SIMD.Int32x4)) {
      return new SIMD.Int32x4(s0, s1, s2, s3);
    }
    this.s_ = convertArray(_i32x4, new Int32Array([s0, s1, s2, s3]));
  }

  SIMD.Int32x4.extractLane = function(v, i) {
    v = SIMD.Int32x4.check(v);
    simdCheckLaneIndex(i, 4);
    return v.s_[i];
  }
}

if (typeof SIMD.Int32x4.swizzle === "undefined") {
  SIMD.Int32x4.swizzle = function(a, s0, s1, s2, s3) {
    return simdSwizzle(int32x4, a, [s0, s1, s2, s3]);
  }
}

if (typeof SIMD.Int32x4.shuffle === "undefined") {
  SIMD.Int32x4.shuffle = function(a, b, s0, s1, s2, s3) {
    return simdShuffle(int32x4, a, b, [s0, s1, s2, s3]);
  }
}

// Int16x8
if (typeof SIMD.Int16x8 === "undefined" ||
    typeof SIMD.Int16x8.extractLane === "undefined") {
  SIMD.Int16x8 = function(s0, s1, s2, s3, s4, s5, s6, s7) {
    if (!(this instanceof SIMD.Int16x8)) {
      return new SIMD.Int16x8(s0, s1, s2, s3, s4, s5, s6, s7);
    }
    this.s_ = convertArray(_i16x8, new Int16Array([s0, s1, s2, s3, s4, s5, s6, s7]));
  }

  SIMD.Int16x8.extractLane = function(v, i) {
    v = SIMD.Int16x8.check(v);
    simdCheckLaneIndex(i, 8);
    return v.s_[i];
  }
}

if (typeof SIMD.Int16x8.swizzle === "undefined") {
  SIMD.Int16x8.swizzle = function(a, s0, s1, s2, s3, s4, s5, s6, s7) {
    return simdSwizzle(int16x8, a, [s0, s1, s2, s3, s4, s5, s6, s7]);
  }
}

if (typeof SIMD.Int16x8.shuffle === "undefined") {
  SIMD.Int16x8.shuffle = function(a, b, s0, s1, s2, s3, s4, s5, s6, s7) {
    return simdShuffle(int16x8, a, b, [s0, s1, s2, s3, s4, s5, s6, s7]);
  }
}

// Int8x16
if (typeof SIMD.Int8x16 === "undefined" ||
    typeof SIMD.Int8x16.extractLane === "undefined") {
  SIMD.Int8x16 = function(s0, s1, s2, s3, s4, s5, s6, s7,
                          s8, s9, s10, s11, s12, s13, s14, s15) {
    if (!(this instanceof SIMD.Int8x16)) {
      return new SIMD.Int8x16(s0, s1, s2, s3, s4, s5, s6, s7,
                              s8, s9, s10, s11, s12, s13, s14, s15);
    }
    this.s_ = convertArray(_i8x16, new Int8Array([s0, s1, s2, s3, s4, s5, s6, s7,
                                    s8, s9, s10, s11, s12, s13, s14, s15]));
  }

  SIMD.Int8x16.extractLane = function(v, i) {
    v = SIMD.Int8x16.check(v);
    simdCheckLaneIndex(i, 16);
    return v.s_[i];
  }
}

if (typeof SIMD.Int8x16.swizzle === "undefined") {
  SIMD.Int8x16.swizzle = function(a, s0, s1, s2, s3, s4, s5, s6, s7,
                                     s8, s9, s10, s11, s12, s13, s14, s15) {
    return simdSwizzle(int8x16, a, [s0, s1, s2, s3, s4, s5, s6, s7,
                                    s8, s9, s10, s11, s12, s13, s14, s15]);
  }
}

if (typeof SIMD.Int8x16.shuffle === "undefined") {
  SIMD.Int8x16.shuffle = function(a, b, s0, s1, s2, s3, s4, s5, s6, s7,
                                        s8, s9, s10, s11, s12, s13, s14, s15) {
    return simdShuffle(int8x16, a, b, [s0, s1, s2, s3, s4, s5, s6, s7,
                                       s8, s9, s10, s11, s12, s13, s14, s15]);
  }
}

// Uint32x4
if (typeof SIMD.Uint32x4 === "undefined" ||
    typeof SIMD.Uint32x4.extractLane === "undefined") {
  SIMD.Uint32x4 = function(s0, s1, s2, s3) {
    if (!(this instanceof SIMD.Uint32x4)) {
      return new SIMD.Uint32x4(s0, s1, s2, s3);
    }
    this.s_ = convertArray(_ui32x4, new Uint32Array([s0, s1, s2, s3]));
  }

  SIMD.Uint32x4.extractLane = function(v, i) {
    v = SIMD.Uint32x4.check(v);
    simdCheckLaneIndex(i, 4);
    return v.s_[i];
  }
}

if (typeof SIMD.Uint32x4.swizzle === "undefined") {
  SIMD.Uint32x4.swizzle = function(a, s0, s1, s2, s3) {
    return simdSwizzle(uint32x4, a, [s0, s1, s2, s3]);
  }
}

if (typeof SIMD.Uint32x4.shuffle === "undefined") {
  SIMD.Uint32x4.shuffle = function(a, b, s0, s1, s2, s3) {
    return simdShuffle(uint32x4, a, b, [s0, s1, s2, s3]);
  }
}

// Uint16x8
if (typeof SIMD.Uint16x8 === "undefined" ||
    typeof SIMD.Uint16x8.extractLane === "undefined") {
  SIMD.Uint16x8 = function(s0, s1, s2, s3, s4, s5, s6, s7) {
    if (!(this instanceof SIMD.Uint16x8)) {
      return new SIMD.Uint16x8(s0, s1, s2, s3, s4, s5, s6, s7);
    }
    this.s_ = convertArray(_ui16x8, new Uint16Array([s0, s1, s2, s3, s4, s5, s6, s7]));
  }

  SIMD.Uint16x8.extractLane = function(v, i) {
    v = SIMD.Uint16x8.check(v);
    simdCheckLaneIndex(i, 8);
    return v.s_[i];
  }
}

if (typeof SIMD.Uint16x8.swizzle === "undefined") {
  SIMD.Uint16x8.swizzle = function(a, s0, s1, s2, s3, s4, s5, s6, s7) {
    return simdSwizzle(uint16x8, a, [s0, s1, s2, s3, s4, s5, s6, s7]);
  }
}

if (typeof SIMD.Uint16x8.shuffle === "undefined") {
  SIMD.Uint16x8.shuffle = function(a, b, s0, s1, s2, s3, s4, s5, s6, s7) {
    return simdShuffle(uint16x8, a, b, [s0, s1, s2, s3, s4, s5, s6, s7]);
  }
}

// Uint8x16
if (typeof SIMD.Uint8x16 === "undefined" ||
    typeof SIMD.Uint8x16.extractLane === "undefined") {
  SIMD.Uint8x16 = function(s0, s1, s2, s3, s4, s5, s6, s7,
                           s8, s9, s10, s11, s12, s13, s14, s15) {
    if (!(this instanceof SIMD.Uint8x16)) {
      return new SIMD.Uint8x16(s0, s1, s2, s3, s4, s5, s6, s7,
                               s8, s9, s10, s11, s12, s13, s14, s15);
    }
    this.s_ = convertArray(_ui8x16, new Uint8Array([s0, s1, s2, s3, s4, s5, s6, s7,
                                     s8, s9, s10, s11, s12, s13, s14, s15]));
  }

  SIMD.Uint8x16.extractLane = function(v, i) {
    v = SIMD.Uint8x16.check(v);
    simdCheckLaneIndex(i, 16);
    return v.s_[i];
  }
}

if (typeof SIMD.Uint8x16.swizzle === "undefined") {
  SIMD.Uint8x16.swizzle = function(a, s0, s1, s2, s3, s4, s5, s6, s7,
                                      s8, s9, s10, s11, s12, s13, s14, s15) {
    return simdSwizzle(uint8x16, a, [s0, s1, s2, s3, s4, s5, s6, s7,
                                     s8, s9, s10, s11, s12, s13, s14, s15]);
  }
}

if (typeof SIMD.Uint8x16.shuffle === "undefined") {
  SIMD.Uint8x16.shuffle = function(a, b, s0, s1, s2, s3, s4, s5, s6, s7,
                                         s8, s9, s10, s11, s12, s13, s14, s15) {
    return simdShuffle(uint8x16, a, b, [s0, s1, s2, s3, s4, s5, s6, s7,
                                        s8, s9, s10, s11, s12, s13, s14, s15]);
  }
}

// Bool32x4
if (typeof SIMD.Bool32x4 === "undefined" ||
    typeof SIMD.Bool32x4.extractLane === "undefined") {
  SIMD.Bool32x4 = function(s0, s1, s2, s3) {
    if (!(this instanceof SIMD.Bool32x4)) {
      return new SIMD.Bool32x4(s0, s1, s2, s3);
    }
    this.s_ = [!!s0, !!s1, !!s2, !!s3];
  }

  SIMD.Bool32x4.extractLane = function(v, i) {
    v = SIMD.Bool32x4.check(v);
    simdCheckLaneIndex(i, 4);
    return v.s_[i];
  }
}

// Bool16x8
if (typeof SIMD.Bool16x8 === "undefined" ||
    typeof SIMD.Bool16x8.extractLane === "undefined") {
  SIMD.Bool16x8 = function(s0, s1, s2, s3, s4, s5, s6, s7) {
    if (!(this instanceof SIMD.Bool16x8)) {
      return new SIMD.Bool16x8(s0, s1, s2, s3, s4, s5, s6, s7);
    }
    this.s_ = [!!s0, !!s1, !!s2, !!s3, !!s4, !!s5, !!s6, !!s7];
  }

  SIMD.Bool16x8.extractLane = function(v, i) {
    v = SIMD.Bool16x8.check(v);
    simdCheckLaneIndex(i, 8);
    return v.s_[i];
  }
}

// Bool8x16
if (typeof SIMD.Bool8x16 === "undefined" ||
    typeof SIMD.Bool8x16.extractLane === "undefined") {
  SIMD.Bool8x16 = function(s0, s1, s2, s3, s4, s5, s6, s7,
                           s8, s9, s10, s11, s12, s13, s14, s15) {
    if (!(this instanceof SIMD.Bool8x16)) {
      return new SIMD.Bool8x16(s0, s1, s2, s3, s4, s5, s6, s7,
                               s8, s9, s10, s11, s12, s13, s14, s15);
    }
    this.s_ = [!!s0, !!s1, !!s2, !!s3, !!s4, !!s5, !!s6, !!s7,
               !!s8, !!s9, !!s10, !!s11, !!s12, !!s13, !!s14, !!s15];
  }

  SIMD.Bool8x16.extractLane = function(v, i) {
    v = SIMD.Bool8x16.check(v);
    simdCheckLaneIndex(i, 16);
    return v.s_[i];
  }
}

// Type data to generate the remaining functions.

var float32x4 = {
  name: "Float32x4",
  fn: SIMD.Float32x4,
  lanes: 4,
  laneSize: 4,
  buffer: _f32x4,
  view: Float32Array,
  mulFn: binaryMul,
  fns: ["check", "splat", "replaceLane", "select",
        "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual",
        "add", "sub", "mul", "div", "neg", "abs", "min", "max", "minNum", "maxNum",
        "reciprocalApproximation", "reciprocalSqrtApproximation", "sqrt",
        "load", "load1", "load2", "load3", "store", "store1", "store2", "store3"],
}

var int32x4 = {
  name: "Int32x4",
  fn: SIMD.Int32x4,
  lanes: 4,
  laneSize: 4,
  minVal: -0x80000000,
  maxVal: 0x7FFFFFFF,
  buffer: _i32x4,
  notFn: unaryBitwiseNot,
  view: Int32Array,
  mulFn: binaryImul,
  fns: ["check", "splat", "replaceLane", "select",
        "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual",
        "and", "or", "xor", "not",
        "add", "sub", "mul", "neg",
        "shiftLeftByScalar", "shiftRightByScalar",
        "load", "load1", "load2", "load3", "store", "store1", "store2", "store3"],
}

var int16x8 = {
  name: "Int16x8",
  fn: SIMD.Int16x8,
  lanes: 8,
  laneSize: 2,
  minVal: -0x8000,
  maxVal: 0x7FFF,
  buffer: _i16x8,
  notFn: unaryBitwiseNot,
  view: Int16Array,
  mulFn: binaryMul,
  fns: ["check", "splat", "replaceLane", "select",
        "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual",
        "and", "or", "xor", "not",
        "add", "sub", "mul", "neg",
        "shiftLeftByScalar", "shiftRightByScalar",
        "addSaturate", "subSaturate",
        "load", "store"],
}

var int8x16 = {
  name: "Int8x16",
  fn: SIMD.Int8x16,
  lanes: 16,
  laneSize: 1,
  minVal: -0x80,
  maxVal: 0x7F,
  buffer: _i8x16,
  notFn: unaryBitwiseNot,
  view: Int8Array,
  mulFn: binaryMul,
  fns: ["check", "splat", "replaceLane", "select",
        "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual",
        "and", "or", "xor", "not",
        "add", "sub", "mul", "neg",
        "shiftLeftByScalar", "shiftRightByScalar",
        "addSaturate", "subSaturate",
        "load", "store"],
}

var uint32x4 = {
  name: "Uint32x4",
  fn: SIMD.Uint32x4,
  lanes: 4,
  laneSize: 4,
  minVal: 0,
  maxVal: 0xFFFFFFFF,
  unsigned: true,
  buffer: _ui32x4,
  notFn: unaryBitwiseNot,
  view: Uint32Array,
  mulFn: binaryImul,
  fns: ["check", "splat", "replaceLane", "select",
        "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual",
        "and", "or", "xor", "not",
        "add", "sub", "mul",
        "shiftLeftByScalar", "shiftRightByScalar",
        "load", "load1", "load2", "load3", "store", "store1", "store2", "store3"],
}

var uint16x8 = {
  name: "Uint16x8",
  fn: SIMD.Uint16x8,
  lanes: 8,
  laneSize: 2,
  unsigned: true,
  minVal: 0,
  maxVal: 0xFFFF,
  buffer: _ui16x8,
  notFn: unaryBitwiseNot,
  view: Uint16Array,
  mulFn: binaryMul,
  fns: ["check", "splat", "replaceLane", "select",
        "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual",
        "and", "or", "xor", "not",
        "add", "sub", "mul",
        "shiftLeftByScalar", "shiftRightByScalar",
        "addSaturate", "subSaturate",
        "load", "store"],
}

var uint8x16 = {
  name: "Uint8x16",
  fn: SIMD.Uint8x16,
  lanes: 16,
  laneSize: 1,
  unsigned: true,
  minVal: 0,
  maxVal: 0xFF,
  buffer: _ui8x16,
  notFn: unaryBitwiseNot,
  view: Uint8Array,
  mulFn: binaryMul,
  fns: ["check", "splat", "replaceLane", "select",
        "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual",
        "and", "or", "xor", "not",
        "add", "sub", "mul",
        "shiftLeftByScalar", "shiftRightByScalar",
        "addSaturate", "subSaturate",
        "load", "store"],
}

var bool32x4 = {
  name: "Bool32x4",
  fn: SIMD.Bool32x4,
  lanes: 4,
  laneSize: 4,
  notFn: unaryLogicalNot,
  fns: ["check", "splat", "replaceLane",
        "allTrue", "anyTrue", "and", "or", "xor", "not"],
}

var bool16x8 = {
  name: "Bool16x8",
  fn: SIMD.Bool16x8,
  lanes: 8,
  laneSize: 2,
  notFn: unaryLogicalNot,
  fns: ["check", "splat", "replaceLane",
        "allTrue", "anyTrue", "and", "or", "xor", "not"],
}

var bool8x16 = {
  name: "Bool8x16",
  fn: SIMD.Bool8x16,
  lanes: 16,
  laneSize: 1,
  notFn: unaryLogicalNot,
  fns: ["check", "splat", "replaceLane",
        "allTrue", "anyTrue", "and", "or", "xor", "not"],
}

// Each SIMD type has a corresponding Boolean SIMD type, which is returned by
// relational ops.
float32x4.boolType = int32x4.boolType = uint32x4.boolType = bool32x4;
int16x8.boolType = uint16x8.boolType = bool16x8;
int8x16.boolType = uint8x16.boolType = bool8x16;

// SIMD from<type> types.
float32x4.from = [int32x4, uint32x4];
int32x4.from = [float32x4, uint32x4];
int16x8.from = [uint16x8];
int8x16.from = [uint8x16];
uint32x4.from = [float32x4, int32x4];
uint16x8.from = [int16x8];
uint8x16.from = [int8x16];

// SIMD from<type>Bits types.
float32x4.fromBits = [int32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16];
int32x4.fromBits = [float32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16];
int16x8.fromBits = [float32x4, int32x4, int8x16, uint32x4, uint16x8, uint8x16];
int8x16.fromBits = [float32x4, int32x4, int16x8, uint32x4, uint16x8, uint8x16];
uint32x4.fromBits = [float32x4, int32x4, int16x8, int8x16, uint16x8, uint8x16];
uint16x8.fromBits = [float32x4, int32x4, int16x8, int8x16, uint32x4, uint8x16];
uint8x16.fromBits = [float32x4, int32x4, int16x8, int8x16, uint32x4, uint16x8];

var simdTypes = [float32x4,
                 int32x4, int16x8, int8x16,
                 uint32x4, uint16x8, uint8x16,
                 bool32x4, bool16x8, bool8x16];

// XXX Emscripten: Enable SIMD phase 2 types for Float64x2 and Bool64x2 to enable targeting SSE2 support.
var simdPhase2 = true;

// SIMD Phase2 types.

if (typeof simdPhase2 !== 'undefined' && simdPhase2) {
  // Float64x2
  if (typeof SIMD.Float64x2 === "undefined" ||
      typeof SIMD.Float64x2.extractLane === "undefined") {
    SIMD.Float64x2 = function(s0, s1) {
      if (!(this instanceof SIMD.Float64x2)) {
        return new SIMD.Float64x2(s0, s1);
      }
      this.s_ = convertArray(_f64x2, new Float64Array([s0, s1]));
    }

    SIMD.Float64x2.extractLane = function(v, i) {
      v = SIMD.Float64x2.check(v);
      simdCheckLaneIndex(i, 2);
      return v.s_[i];
    }
  }

  if (typeof SIMD.Float64x2.swizzle === "undefined") {
    SIMD.Float64x2.swizzle = function(a, s0, s1) {
      return simdSwizzle(float64x2, a, [s0, s1]);
    }
  }

  if (typeof SIMD.Float64x2.shuffle === "undefined") {
    SIMD.Float64x2.shuffle = function(a, b, s0, s1) {
      return simdShuffle(float64x2, a, b, [s0, s1]);
    }
  }

  // Bool64x2
  if (typeof SIMD.Bool64x2 === "undefined" ||
      typeof SIMD.Bool64x2.extractLane === "undefined") {
    SIMD.Bool64x2 = function(s0, s1) {
      if (!(this instanceof SIMD.Bool64x2)) {
        return new SIMD.Bool64x2(s0, s1);
      }
      this.s_ = [!!s0, !!s1];
    }

    SIMD.Bool64x2.extractLane = function(v, i) {
      v = SIMD.Bool64x2.check(v);
      simdCheckLaneIndex(i, 2);
      return v.s_[i];
    }
  }

  var float64x2 = {
    name: "Float64x2",
    fn: SIMD.Float64x2,
    lanes: 2,
    laneSize: 8,
    buffer: _f64x2,
    view: Float64Array,
    mulFn: binaryMul,
    fns: ["check", "splat", "replaceLane", "select",
          "equal", "notEqual", "lessThan", "lessThanOrEqual", "greaterThan", "greaterThanOrEqual",
          "add", "sub", "mul", "div", "neg", "abs", "min", "max", "minNum", "maxNum",
          "reciprocalApproximation", "reciprocalSqrtApproximation", "sqrt",
          "load", "store"],
  }

  // XXX Emscripten: Need these functions for intrinsics, see https://github.com/tc39/ecmascript_simd/issues/316.
  float64x2.fns.push("load1");
  float64x2.fns.push("store1");
  // XXX Emscripten

  var bool64x2 = {
    name: "Bool64x2",
    fn: SIMD.Bool64x2,
    lanes: 2,
    laneSize: 8,
    notFn: unaryLogicalNot,
    fns: ["check", "splat", "replaceLane",
          "allTrue", "anyTrue", "and", "or", "xor", "not"],
  }

  float64x2.boolType = bool64x2;

  float32x4.fromBits.push(float64x2);
  int32x4.fromBits.push(float64x2);
  int16x8.fromBits.push(float64x2);
  int8x16.fromBits.push(float64x2);
  uint32x4.fromBits.push(float64x2);
  uint16x8.fromBits.push(float64x2);
  uint8x16.fromBits.push(float64x2);

  float64x2.fromBits = [float32x4, int32x4, int16x8, int8x16,
                        uint32x4, uint16x8, uint8x16];

/*
  // XXX Emscripten: Removed to fix https://github.com/tc39/ecmascript_simd/issues/314
  int32x4.fromBits = [float32x4, int16x8, int8x16, uint32x4, uint16x8, uint8x16];
  int16x8.fromBits = [float32x4, int32x4, int8x16, uint32x4, uint16x8, uint8x16];
  int8x16.fromBits = [float32x4, int32x4, int16x8, uint32x4, uint16x8, uint8x16];
  uint32x4.fromBits = [float32x4, int32x4, int16x8, int8x16, uint16x8, uint8x16];
  uint16x8.fromBits = [float32x4, int32x4, int16x8, int8x16, uint32x4, uint8x16];
  uint8x16.fromBits = [float32x4, int32x4, int16x8, int8x16, uint32x4, uint16x8];
*/

  simdTypes.push(float64x2);
  simdTypes.push(bool64x2);
}

// SIMD prototype functions.
var prototypeFns = {
  valueOf:
    function(type) {
      return function() {
        throw new TypeError(type.name + " cannot be converted to a number");
      }
    },

  toString:
    function(type) {
      return function() {
        return simdToString(type, this);
      }
    },

  toLocaleString:
    function(type) {
      return function() {
        return simdToLocaleString(type, this);
      }
    },
};

// SIMD constructor functions.

var simdFns = {
  check:
    function(type) {
      return function(a) {
        if (!(a instanceof type.fn)) {
          throw new TypeError("Argument is not a " + type.name + ".");
        }
        return a;
      }
    },

  splat:
    function(type) {
      return function(s) { return simdSplat(type, s); }
    },

  replaceLane:
    function(type) {
      return function(a, i, s) { return simdReplaceLane(type, a, i, s); }
    },

  allTrue:
    function(type) {
      return function(a) { return simdAllTrue(type, a); }
    },

  anyTrue:
    function(type) {
      return function(a) { return simdAnyTrue(type, a); }
    },

  and:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, binaryAnd, a, b);
      }
    },

  or:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, binaryOr, a, b);
      }
    },

  xor:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, binaryXor, a, b);
      }
    },

  not:
    function(type) {
      return function(a) {
        return simdUnaryOp(type, type.notFn, a);
      }
    },

  equal:
    function(type) {
      return function(a, b) {
        return simdRelationalOp(type, binaryEqual, a, b);
      }
    },

  notEqual:
    function(type) {
      return function(a, b) {
        return simdRelationalOp(type, binaryNotEqual, a, b);
      }
    },

  lessThan:
    function(type) {
      return function(a, b) {
        return simdRelationalOp(type, binaryLess, a, b);
      }
    },

  lessThanOrEqual:
    function(type) {
      return function(a, b) {
        return simdRelationalOp(type, binaryLessEqual, a, b);
      }
    },

  greaterThan:
    function(type) {
      return function(a, b) {
        return simdRelationalOp(type, binaryGreater, a, b);
      }
    },

  greaterThanOrEqual:
    function(type) {
      return function(a, b) {
        return simdRelationalOp(type, binaryGreaterEqual, a, b);
      }
    },

  add:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, binaryAdd, a, b);
      }
    },

  sub:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, binarySub, a, b);
      }
    },

  mul:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, type.mulFn, a, b);
      }
    },

  div:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, binaryDiv, a, b);
      }
    },

  neg:
    function(type) {
      return function(a) {
        return simdUnaryOp(type, unaryNeg, a);
      }
    },

  abs:
    function(type) {
      return function(a) {
        return simdUnaryOp(type, Math.abs, a);
      }
    },

  min:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, Math.min, a, b);
      }
    },

  max:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, Math.max, a, b);
      }
    },

  minNum:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, minNum, a, b);
      }
    },

  maxNum:
    function(type) {
      return function(a, b) {
        return simdBinaryOp(type, maxNum, a, b);
      }
    },

  load:
    function(type) {
      return function(tarray, index) {
        return simdLoad(type, tarray, index, type.lanes);
      }
    },

  load1:
    function(type) {
      return function(tarray, index) {
        return simdLoad(type, tarray, index, 1);
      }
    },

  load2:
    function(type) {
      return function(tarray, index) {
        return simdLoad(type, tarray, index, 2);
      }
    },

  load3:
    function(type) {
      return function(tarray, index) {
        return simdLoad(type, tarray, index, 3);
      }
    },

  store:
    function(type) {
      return function(tarray, index, a) {
        return simdStore(type, tarray, index, a, type.lanes);
      }
    },

  store1:
    function(type) {
      return function(tarray, index, a) {
        return simdStore(type, tarray, index, a, 1);
      }
    },

  store2:
    function(type) {
      return function(tarray, index, a) {
        return simdStore(type, tarray, index, a, 2);
      }
    },

  store3:
    function(type) {
      return function(tarray, index, a) {
        return simdStore(type, tarray, index, a, 3);
      }
    },

  select:
    function(type) {
      return function(selector, a, b) {
        return simdSelect(type, selector, a, b);
      }
    },


  reciprocalApproximation:
    function(type) {
      return function(a) {
        a = type.fn.check(a);
        return type.fn.div(type.fn.splat(1.0), a);
      }
    },

  reciprocalSqrtApproximation:
    function(type) {
      return function(a) {
        a = type.fn.check(a);
        return type.fn.reciprocalApproximation(type.fn.sqrt(a));
      }
    },

  sqrt:
    function(type) {
      return function(a) {
        return simdUnaryOp(type, Math.sqrt, a);
      }
    },

  shiftLeftByScalar:
    function(type) {
      return function(a, bits) {
        bits &= type.laneSize * 8 - 1;
        return simdShiftOp(type, binaryShiftLeft, a, bits);
      }
    },

  shiftRightByScalar:
    function(type) {
      if (type.unsigned) {
        return function(a, bits) {
          bits &= type.laneSize * 8 - 1;
          return simdShiftOp(type, binaryShiftRightLogical, a, bits);
        }
      } else {
        return function(a, bits) {
          bits &= type.laneSize * 8 - 1;
          return simdShiftOp(type, binaryShiftRightArithmetic, a, bits);
        }
      }
    },

  addSaturate:
    function(type) {
      function addSaturate(a, b) {
        return clamp(a + b, type.minVal, type.maxVal);
      }
      return function(a, b) { return simdBinaryOp(type, addSaturate, a, b); }
    },

  subSaturate:
    function(type) {
      function subSaturate(a, b) {
        return clamp(a - b, type.minVal, type.maxVal);
      }
      return function(a, b) { return simdBinaryOp(type, subSaturate, a, b); }
    },
}

// Install functions.

simdTypes.forEach(function(type) {
  // Install each prototype function on each SIMD prototype.
  var simdFn = type.fn;
  var proto = simdFn.prototype;
  for (var name in prototypeFns) {
    if (!proto.hasOwnProperty(name))
      proto[name] = prototypeFns[name](type);
  }
  // Install regular functions.
  type.fns.forEach(function(name) {
    if (typeof simdFn[name] === "undefined")
      simdFn[name] = simdFns[name](type);
  });
  // Install 'fromTIMD' functions.
  if (type.from) {
    type.from.forEach(function(fromType) {
      var name = "from" + fromType.name;
      var toType = type;  // pull type into closure.
      if (typeof type.fn[name] === "undefined") {
        type.fn[name] =
            function(a) { return simdFrom(toType, fromType, a); }
      }
    });
  }
  // Install 'fromTIMDBits' functions.
  if (type.fromBits) {
    type.fromBits.forEach(function(fromType) {
      var name = "from" + fromType.name + "Bits";
      var toType = type;  // pull type into closure.
      if (typeof type.fn[name] === "undefined") {
        type.fn[name] =
            function(a) { return simdFromBits(toType, fromType, a); }
      }
    });
  }
});

// If we're in a browser, the global namespace is named 'window'. If we're
// in node, it's named 'global'. If we're in a web worker, it's named
// 'self'. If we're in a shell, 'this' might work.
})(typeof window !== "undefined"
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : typeof self === 'object'
       ? self
       : this);


// XXX Emscripten-specific below XXX

// Work around Firefox Nightly bug that Float64x2 comparison return a Int32x4 instead of a Bool64x2.
try {
  if (SIMD.Int32x4.check(SIMD.Float64x2.equal(SIMD.Float64x2.splat(5.0), SIMD.Float64x2.splat(5.0)))) {
    SIMD.Float64x2.prevEqual = SIMD.Float64x2.equal;
    SIMD.Float64x2.equal = function(a, b) {
      var int32x4 = SIMD.Float64x2.prevEqual(a, b);
      return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
    }
    console.error('Warning: Patching up SIMD.Float64x2.equal to return a Bool64x2 instead of Int32x4!');
  }
} catch(e) {}
try {
  if (SIMD.Int32x4.check(SIMD.Float64x2.notEqual(SIMD.Float64x2.splat(5.0), SIMD.Float64x2.splat(5.0)))) {
    SIMD.Float64x2.prevNotEqual = SIMD.Float64x2.notEqual;
    SIMD.Float64x2.notEqual = function(a, b) {
      var int32x4 = SIMD.Float64x2.prevNotEqual(a, b);
      return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
    } 
    console.error('Warning: Patching up SIMD.Float64x2.notEqual to return a Bool64x2 instead of Int32x4!');
  }
} catch(e) {}
try {
  if (SIMD.Int32x4.check(SIMD.Float64x2.greaterThan(SIMD.Float64x2.splat(5.0), SIMD.Float64x2.splat(5.0)))) {
    SIMD.Float64x2.prevGreaterThan = SIMD.Float64x2.greaterThan;
    SIMD.Float64x2.greaterThan = function(a, b) {
      var int32x4 = SIMD.Float64x2.prevGreaterThan(a, b);
      return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
    } 
    console.error('Warning: Patching up SIMD.Float64x2.greaterThan to return a Bool64x2 instead of Int32x4!');
  }
} catch(e) {}
try {
  if (SIMD.Int32x4.check(SIMD.Float64x2.greaterThanOrEqual(SIMD.Float64x2.splat(5.0), SIMD.Float64x2.splat(5.0)))) {
    SIMD.Float64x2.prevGreaterThanOrEqual = SIMD.Float64x2.greaterThanOrEqual;
    SIMD.Float64x2.greaterThanOrEqual = function(a, b) {
      var int32x4 = SIMD.Float64x2.prevGreaterThanOrEqual(a, b);
      return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
    } 
    console.error('Warning: Patching up SIMD.Float64x2.greaterThanOrEqual to return a Bool64x2 instead of Int32x4!');
  }
} catch(e) {}
try {
  if (SIMD.Int32x4.check(SIMD.Float64x2.lessThan(SIMD.Float64x2.splat(5.0), SIMD.Float64x2.splat(5.0)))) {
    SIMD.Float64x2.prevLessThan = SIMD.Float64x2.lessThan;
    SIMD.Float64x2.lessThan = function(a, b) {
      var int32x4 = SIMD.Float64x2.prevLessThan(a, b);
      return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
    } 
    console.error('Warning: Patching up SIMD.Float64x2.lessThan to return a Bool64x2 instead of Int32x4!');
  }
} catch(e) {}
try {
  if (SIMD.Int32x4.check(SIMD.Float64x2.lessThanOrEqual(SIMD.Float64x2.splat(5.0), SIMD.Float64x2.splat(5.0)))) {
    SIMD.Float64x2.prevLessThanOrEqual = SIMD.Float64x2.lessThanOrEqual;
    SIMD.Float64x2.lessThanOrEqual = function(a, b) {
      var int32x4 = SIMD.Float64x2.prevLessThanOrEqual(a, b);
      return SIMD.Bool64x2(SIMD.Int32x4.extractLane(int32x4, 1) != 0, SIMD.Int32x4.extractLane(int32x4, 3) != 0);
    } 
    console.error('Warning: Patching up SIMD.Float64x2.lessThanOrEqual to return a Bool64x2 instead of Int32x4!');
  }
} catch(e) {}


if (!SIMD.Int32x4.fromBool64x2Bits) {
  SIMD.Int32x4.fromBool64x2Bits = function(bool64x2) {
    var lane0 = SIMD.Bool64x2.extractLane(bool64x2, 0)?-1:0;
    var lane1 = SIMD.Bool64x2.extractLane(bool64x2, 1)?-1:0;
    return SIMD.Int32x4(lane0, lane0, lane1, lane1);
  }
}


// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

Module['arguments'] = [];
Module['thisProgram'] = './this.program';
Module['quit'] = function(status, toThrow) {
  throw toThrow;
};
Module['preRun'] = [];
Module['postRun'] = [];

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;

// Three configurations we can be running in:
// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)

if (Module['ENVIRONMENT']) {
  if (Module['ENVIRONMENT'] === 'WEB') {
    ENVIRONMENT_IS_WEB = true;
  } else if (Module['ENVIRONMENT'] === 'WORKER') {
    ENVIRONMENT_IS_WORKER = true;
  } else if (Module['ENVIRONMENT'] === 'NODE') {
    ENVIRONMENT_IS_NODE = true;
  } else if (Module['ENVIRONMENT'] === 'SHELL') {
    ENVIRONMENT_IS_SHELL = true;
  } else {
    throw new Error('Module[\'ENVIRONMENT\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.');
  }
} else {
  ENVIRONMENT_IS_WEB = typeof window === 'object';
  ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
  ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
}


if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  var nodeFS;
  var nodePath;

  Module['read'] = function shell_read(filename, binary) {
    var ret;
      if (!nodeFS) nodeFS = require('fs');
      if (!nodePath) nodePath = require('path');
      filename = nodePath['normalize'](filename);
      ret = nodeFS['readFileSync'](filename);
    return binary ? ret : ret.toString();
  };

  Module['readBinary'] = function readBinary(filename) {
    var ret = Module['read'](filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };

  if (process['argv'].length > 1) {
    Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
  }

  Module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });
  // Currently node will swallow unhandled rejections, but this behavior is
  // deprecated, and in the future it will exit with error status.
  process['on']('unhandledRejection', function(reason, p) {
    process['exit'](1);
  });

  Module['inspect'] = function () { return '[Emscripten Module object]'; };
}
else if (ENVIRONMENT_IS_SHELL) {
  if (typeof read != 'undefined') {
    Module['read'] = function shell_read(f) {
      return read(f);
    };
  }

  Module['readBinary'] = function readBinary(f) {
    var data;
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof quit === 'function') {
    Module['quit'] = function(status, toThrow) {
      quit(status);
    }
  }
}
else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function shell_read(url) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  };

  if (ENVIRONMENT_IS_WORKER) {
    Module['readBinary'] = function readBinary(url) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(xhr.response);
    };
  }

  Module['readAsync'] = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

  if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  Module['setWindowTitle'] = function(title) { document.title = title };
}

// console.log is checked first, as 'print' on the web will open a print dialogue
// printErr is preferable to console.warn (works better in shells)
// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.
Module['print'] = typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null);
Module['printErr'] = typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || Module['print']);

// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = undefined;



// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;


function staticAlloc(size) {
  assert(!staticSealed);
  var ret = STATICTOP;
  STATICTOP = (STATICTOP + size + 15) & -16;
  return ret;
}

function dynamicAlloc(size) {
  assert(DYNAMICTOP_PTR);
  var ret = HEAP32[DYNAMICTOP_PTR>>2];
  var end = (ret + size + 15) & -16;
  HEAP32[DYNAMICTOP_PTR>>2] = end;
  if (end >= TOTAL_MEMORY) {
    var success = enlargeMemory();
    if (!success) {
      HEAP32[DYNAMICTOP_PTR>>2] = ret;
      return 0;
    }
  }
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  var ret = size = Math.ceil(size / factor) * factor;
  return ret;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 === 0);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    Module.printErr(text);
  }
}



var jsCallStartIndex = 1;
var functionPointers = new Array(0);

// 'sig' parameter is only used on LLVM wasm backend
function addFunction(func, sig) {
  var base = 0;
  for (var i = base; i < base + 0; i++) {
    if (!functionPointers[i]) {
      functionPointers[i] = func;
      return jsCallStartIndex + i;
    }
  }
  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
}

function removeFunction(index) {
  functionPointers[index-jsCallStartIndex] = null;
}

var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

function dynCall(sig, ptr, args) {
  if (args && args.length) {
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    return Module['dynCall_' + sig].call(null, ptr);
  }
}



var Runtime = {
  // FIXME backwards compatibility layer for ports. Support some Runtime.*
  //       for now, fix it there, then remove it from here. That way we
  //       can minimize any period of breakage.
  dynCall: dynCall, // for SDL2 port
};

// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 8;



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html



//========================================
// Runtime essentials
//========================================

var ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

var JSfuncs = {
  // Helpers for cwrap -- it can't refer to Runtime directly because it might
  // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find
  // out what the minified function name is.
  'stackSave': function() {
    stackSave()
  },
  'stackRestore': function() {
    stackRestore()
  },
  // type conversion from js to c
  'arrayToC' : function(arr) {
    var ret = stackAlloc(arr.length);
    writeArrayToMemory(arr, ret);
    return ret;
  },
  'stringToC' : function(str) {
    var ret = 0;
    if (str !== null && str !== undefined && str !== 0) { // null string
      // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
      var len = (str.length << 2) + 1;
      ret = stackAlloc(len);
      stringToUTF8(str, ret, len);
    }
    return ret;
  }
};
// For fast lookup of conversion functions
var toC = {'string' : JSfuncs['stringToC'], 'array' : JSfuncs['arrayToC']};

// C calling interface.
function ccall (ident, returnType, argTypes, args, opts) {
  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  if (returnType === 'string') ret = Pointer_stringify(ret);
  if (stack !== 0) {
    stackRestore(stack);
  }
  return ret;
}

function cwrap (ident, returnType, argTypes) {
  argTypes = argTypes || [];
  var cfunc = getCFunc(ident);
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs) {
    return cfunc;
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments);
  }
}

/** @type {function(number, number, string, boolean=)} */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= (+1) ? (tempDouble > (+0) ? ((Math_min((+(Math_floor((tempDouble)/(+4294967296)))), (+4294967295)))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/(+4294967296))))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @type {function(number, string, boolean=)} */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk
var ALLOC_NONE = 4; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!staticSealed) return staticAlloc(size);
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}

/** @type {function(number, number=)} */
function Pointer_stringify(ptr, length) {
  if (length === 0 || !ptr) return '';
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = 0;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    hasUtf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = '';

  if (hasUtf < 128) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  return UTF8ToString(ptr);
}

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAP8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;
function UTF8ArrayToString(u8Array, idx) {
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  while (u8Array[endPtr]) ++endPtr;

  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
  } else {
    var u0, u1, u2, u3, u4, u5;

    var str = '';
    while (1) {
      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
      u0 = u8Array[idx++];
      if (!u0) return str;
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      u1 = u8Array[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      u2 = u8Array[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u3 = u8Array[idx++] & 63;
        if ((u0 & 0xF8) == 0xF0) {
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
        } else {
          u4 = u8Array[idx++] & 63;
          if ((u0 & 0xFC) == 0xF8) {
            u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;
          } else {
            u5 = u8Array[idx++] & 63;
            u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;
          }
        }
      }
      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function UTF8ToString(ptr) {
  return UTF8ArrayToString(HEAPU8,ptr);
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x1FFFFF) {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x3FFFFFF) {
      if (outIdx + 4 >= endIdx) break;
      outU8Array[outIdx++] = 0xF8 | (u >> 24);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 5 >= endIdx) break;
      outU8Array[outIdx++] = 0xFC | (u >> 30);
      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      ++len;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else if (u <= 0x1FFFFF) {
      len += 4;
    } else if (u <= 0x3FFFFFF) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;
function UTF16ToString(ptr) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

function demangle(func) {
  return func;
}

function demangleAll(text) {
  var regex =
    /__Z[\w\d_]+/g;
  return text.replace(regex,
    function(x) {
      var y = demangle(x);
      return x === y ? x : (x + ' [' + y + ']');
    });
}

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}

function stackTrace() {
  var js = jsStackTrace();
  if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
  return demangleAll(js);
}

// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;
var MIN_TOTAL_MEMORY = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBuffer(buf) {
  Module['buffer'] = buffer = buf;
}

function updateGlobalBufferViews() {
  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
}

var STATIC_BASE, STATICTOP, staticSealed; // static area
var STACK_BASE, STACKTOP, STACK_MAX; // stack area
var DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk

  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;
  staticSealed = false;



function abortOnCannotGrowMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or (4) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
}


function enlargeMemory() {
  abortOnCannotGrowMemory();
}


var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
if (TOTAL_MEMORY < TOTAL_STACK) Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// Initialize the runtime's memory



// Use a provided buffer, if there is one, or else allocate a new one
if (Module['buffer']) {
  buffer = Module['buffer'];
} else {
  // Use a WebAssembly memory where available
  {
    buffer = new ArrayBuffer(TOTAL_MEMORY);
  }
  Module['buffer'] = buffer;
}
updateGlobalBufferViews();


function getTotalMemory() {
  return TOTAL_MEMORY;
}

// Endianness check (note: assumes compiler arch was little-endian)
  HEAP32[0] = 0x63736d65; /* 'emsc' */
HEAP16[1] = 0x6373;
if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the runtime has exited

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
  runtimeExited = true;
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
  __ATEXIT__.unshift(cb);
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
}

function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data



var memoryInitializer = null;






// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return String.prototype.startsWith ?
      filename.startsWith(dataURIPrefix) :
      filename.indexOf(dataURIPrefix) === 0;
}





// === Body ===

var ASM_CONSTS = [];




STATIC_BASE = GLOBAL_BASE;

STATICTOP = STATIC_BASE + 36016;
/* global initializers */  __ATINIT__.push();


memoryInitializer = "TeaWeb-Native.js.mem";





/* no memory initializer */
var tempDoublePtr = STATICTOP; STATICTOP += 16;

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

}

function copyTempDouble(ptr) {

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];

  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];

  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];

  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];

}

// {{PRE_LIBRARY}}


  
  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()
      return !!__ZSt18uncaught_exceptionv.uncaught_exception;
    }
  
  
  
  var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:function (adjusted) {
        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;
        for (var ptr in EXCEPTIONS.infos) {
          var info = EXCEPTIONS.infos[ptr];
          if (info.adjusted === adjusted) {
            return ptr;
          }
        }
        return adjusted;
      },addRef:function (ptr) {
        if (!ptr) return;
        var info = EXCEPTIONS.infos[ptr];
        info.refcount++;
      },decRef:function (ptr) {
        if (!ptr) return;
        var info = EXCEPTIONS.infos[ptr];
        assert(info.refcount > 0);
        info.refcount--;
        // A rethrown exception can reach refcount 0; it must not be discarded
        // Its next handler will clear the rethrown flag and addRef it, prior to
        // final decRef and destruction here
        if (info.refcount === 0 && !info.rethrown) {
          if (info.destructor) {
            Module['dynCall_vi'](info.destructor, ptr);
          }
          delete EXCEPTIONS.infos[ptr];
          ___cxa_free_exception(ptr);
        }
      },clearRef:function (ptr) {
        if (!ptr) return;
        var info = EXCEPTIONS.infos[ptr];
        info.refcount = 0;
      }};
  function ___resumeException(ptr) {
      if (!EXCEPTIONS.last) { EXCEPTIONS.last = ptr; }
      throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";
    }function ___cxa_find_matching_catch() {
      var thrown = EXCEPTIONS.last;
      if (!thrown) {
        // just pass through the null ptr
        return ((setTempRet0(0),0)|0);
      }
      var info = EXCEPTIONS.infos[thrown];
      var throwntype = info.type;
      if (!throwntype) {
        // just pass through the thrown ptr
        return ((setTempRet0(0),thrown)|0);
      }
      var typeArray = Array.prototype.slice.call(arguments);
  
      var pointer = Module['___cxa_is_pointer_type'](throwntype);
      // can_catch receives a **, add indirection
      if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);
      HEAP32[((___cxa_find_matching_catch.buffer)>>2)]=thrown;
      thrown = ___cxa_find_matching_catch.buffer;
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        if (typeArray[i] && Module['___cxa_can_catch'](typeArray[i], throwntype, thrown)) {
          thrown = HEAP32[((thrown)>>2)]; // undo indirection
          info.adjusted = thrown;
          return ((setTempRet0(typeArray[i]),thrown)|0);
        }
      }
      // Shouldn't happen unless we have bogus data in typeArray
      // or encounter a type for which emscripten doesn't have suitable
      // typeinfo defined. Best-efforts match just in case.
      thrown = HEAP32[((thrown)>>2)]; // undo indirection
      return ((setTempRet0(throwntype),thrown)|0);
    }function ___gxx_personality_v0() {
    }

  
    

  function _abort() {
      Module['abort']();
    }

   

   

  var _llvm_ctlz_i32=true;

  var _llvm_pow_f64=Math_pow;

  function _llvm_stackrestore(p) {
      var self = _llvm_stacksave;
      var ret = self.LLVM_SAVEDSTACKS[p];
      self.LLVM_SAVEDSTACKS.splice(p, 1);
      stackRestore(ret);
    }

  function _llvm_stacksave() {
      var self = _llvm_stacksave;
      if (!self.LLVM_SAVEDSTACKS) {
        self.LLVM_SAVEDSTACKS = [];
      }
      self.LLVM_SAVEDSTACKS.push(stackSave());
      return self.LLVM_SAVEDSTACKS.length-1;
    }

  
  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
      return dest;
    } 

   

   

  
    

  
  function ___setErrNo(value) {
      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;
      return value;
    } 

  function _CELT_INNER_PROD_IMPL() {
  Module['printErr']('missing function: CELT_INNER_PROD_IMPL'); abort(-1);
  }

  function _COMB_FILTER_CONST_IMPL() {
  Module['printErr']('missing function: COMB_FILTER_CONST_IMPL'); abort(-1);
  }

  function _DUAL_INNER_PROD_IMPL() {
  Module['printErr']('missing function: DUAL_INNER_PROD_IMPL'); abort(-1);
  }

  function _OP_PVQ_SEARCH_IMPL() {
  Module['printErr']('missing function: OP_PVQ_SEARCH_IMPL'); abort(-1);
  }

  function _XCORR_KERNEL_IMPL() {
  Module['printErr']('missing function: XCORR_KERNEL_IMPL'); abort(-1);
  }
DYNAMICTOP_PTR = staticAlloc(4);

STACK_BASE = STACKTOP = alignMemory(STATICTOP);

STACK_MAX = STACK_BASE + TOTAL_STACK;

DYNAMIC_BASE = alignMemory(STACK_MAX);

HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;

staticSealed = true; // seal the static portion of memory

var ASSERTIONS = false;

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}



function invoke_diii(index,a1,a2,a3) {
  try {
    return Module["dynCall_diii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    Module["setThrew"](1, 0);
  }
}

function invoke_diiiii(index,a1,a2,a3,a4,a5) {
  try {
    return Module["dynCall_diiiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    Module["setThrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return Module["dynCall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    Module["setThrew"](1, 0);
  }
}

function invoke_v(index) {
  try {
    Module["dynCall_v"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    Module["setThrew"](1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  try {
    Module["dynCall_viiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    Module["setThrew"](1, 0);
  }
}

function invoke_viiiiddd(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    Module["dynCall_viiiiddd"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    Module["setThrew"](1, 0);
  }
}

function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    Module["setThrew"](1, 0);
  }
}

function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  try {
    Module["dynCall_viiiiiii"](index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    Module["setThrew"](1, 0);
  }
}

Module.asmGlobalArg = { "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array, "NaN": NaN, "Infinity": Infinity, "SIMD": SIMD };

Module.asmLibraryArg = { "abort": abort, "assert": assert, "enlargeMemory": enlargeMemory, "getTotalMemory": getTotalMemory, "abortOnCannotGrowMemory": abortOnCannotGrowMemory, "invoke_diii": invoke_diii, "invoke_diiiii": invoke_diiiii, "invoke_iii": invoke_iii, "invoke_v": invoke_v, "invoke_viiii": invoke_viiii, "invoke_viiiiddd": invoke_viiiiddd, "invoke_viiiiii": invoke_viiiiii, "invoke_viiiiiii": invoke_viiiiiii, "__ZSt18uncaught_exceptionv": __ZSt18uncaught_exceptionv, "___cxa_find_matching_catch": ___cxa_find_matching_catch, "___gxx_personality_v0": ___gxx_personality_v0, "___resumeException": ___resumeException, "___setErrNo": ___setErrNo, "_abort": _abort, "_emscripten_memcpy_big": _emscripten_memcpy_big, "_llvm_pow_f64": _llvm_pow_f64, "_llvm_stackrestore": _llvm_stackrestore, "_llvm_stacksave": _llvm_stacksave, "DYNAMICTOP_PTR": DYNAMICTOP_PTR, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "_CELT_INNER_PROD_IMPL": _CELT_INNER_PROD_IMPL, "_COMB_FILTER_CONST_IMPL": _COMB_FILTER_CONST_IMPL, "_DUAL_INNER_PROD_IMPL": _DUAL_INNER_PROD_IMPL, "_OP_PVQ_SEARCH_IMPL": _OP_PVQ_SEARCH_IMPL, "_XCORR_KERNEL_IMPL": _XCORR_KERNEL_IMPL };
// EMSCRIPTEN_START_ASM
var asm = (/** @suppress {uselessCode} */ function(global, env, buffer) {
'use asm';


  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);

  var DYNAMICTOP_PTR=env.DYNAMICTOP_PTR|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var _CELT_INNER_PROD_IMPL=env._CELT_INNER_PROD_IMPL|0;
  var _COMB_FILTER_CONST_IMPL=env._COMB_FILTER_CONST_IMPL|0;
  var _DUAL_INNER_PROD_IMPL=env._DUAL_INNER_PROD_IMPL|0;
  var _OP_PVQ_SEARCH_IMPL=env._OP_PVQ_SEARCH_IMPL|0;
  var _XCORR_KERNEL_IMPL=env._XCORR_KERNEL_IMPL|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = global.NaN, inf = global.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntS = 0, tempValue = 0, tempDouble = 0.0;
  var tempRet0 = 0;

  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var Math_min=global.Math.min;
  var Math_max=global.Math.max;
  var Math_clz32=global.Math.clz32;
  var Math_fround=global.Math.fround;
  var abort=env.abort;
  var assert=env.assert;
  var enlargeMemory=env.enlargeMemory;
  var getTotalMemory=env.getTotalMemory;
  var abortOnCannotGrowMemory=env.abortOnCannotGrowMemory;
  var invoke_diii=env.invoke_diii;
  var invoke_diiiii=env.invoke_diiiii;
  var invoke_iii=env.invoke_iii;
  var invoke_v=env.invoke_v;
  var invoke_viiii=env.invoke_viiii;
  var invoke_viiiiddd=env.invoke_viiiiddd;
  var invoke_viiiiii=env.invoke_viiiiii;
  var invoke_viiiiiii=env.invoke_viiiiiii;
  var __ZSt18uncaught_exceptionv=env.__ZSt18uncaught_exceptionv;
  var ___cxa_find_matching_catch=env.___cxa_find_matching_catch;
  var ___gxx_personality_v0=env.___gxx_personality_v0;
  var ___resumeException=env.___resumeException;
  var ___setErrNo=env.___setErrNo;
  var _abort=env._abort;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var _llvm_pow_f64=env._llvm_pow_f64;
  var _llvm_stackrestore=env._llvm_stackrestore;
  var _llvm_stacksave=env._llvm_stacksave;
  var SIMD_Int16x8=global.SIMD.Int16x8;
  var SIMD_Int32x4=global.SIMD.Int32x4;
  var SIMD_Int16x8_splat=SIMD_Int16x8.splat;
  var SIMD_Int16x8_check=SIMD_Int16x8.check;
  var SIMD_Int16x8_extractLane=SIMD_Int16x8.extractLane;
  var SIMD_Int16x8_replaceLane=SIMD_Int16x8.replaceLane;
  var SIMD_Int16x8_add=SIMD_Int16x8.add;
  var SIMD_Int16x8_sub=SIMD_Int16x8.sub;
  var SIMD_Int16x8_neg=SIMD_Int16x8.neg;
  var SIMD_Int16x8_mul=SIMD_Int16x8.mul;
  var SIMD_Int16x8_equal=SIMD_Int16x8.equal;
  var SIMD_Int16x8_lessThan=SIMD_Int16x8.lessThan;
  var SIMD_Int16x8_greaterThan=SIMD_Int16x8.greaterThan;
  var SIMD_Int16x8_notEqual=SIMD_Int16x8.notEqual;
  var SIMD_Int16x8_lessThanOrEqual=SIMD_Int16x8.lessThanOrEqual;
  var SIMD_Int16x8_greaterThanOrEqual=SIMD_Int16x8.greaterThanOrEqual;
  var SIMD_Int16x8_select=SIMD_Int16x8.select;
  var SIMD_Int16x8_swizzle=SIMD_Int16x8.swizzle;
  var SIMD_Int16x8_shuffle=SIMD_Int16x8.shuffle;
  var SIMD_Int16x8_load=SIMD_Int16x8.load;
  var SIMD_Int16x8_store=SIMD_Int16x8.store;
  var SIMD_Int16x8_fromInt32x4Bits=SIMD_Int16x8.fromInt32x4Bits;
  var SIMD_Int16x8_and=SIMD_Int16x8.and;
  var SIMD_Int16x8_xor=SIMD_Int16x8.xor;
  var SIMD_Int16x8_or=SIMD_Int16x8.or;
  var SIMD_Int16x8_not=SIMD_Int16x8.not;
  var SIMD_Int16x8_shiftLeftByScalar=SIMD_Int16x8.shiftLeftByScalar;
  var SIMD_Int16x8_shiftRightByScalar=SIMD_Int16x8.shiftRightByScalar;
  var SIMD_Int16x8_addSaturate=SIMD_Int16x8.addSaturate;
  var SIMD_Int16x8_subSaturate=SIMD_Int16x8.subSaturate;
  var SIMD_Int32x4_splat=SIMD_Int32x4.splat;
  var SIMD_Int32x4_check=SIMD_Int32x4.check;
  var SIMD_Int32x4_extractLane=SIMD_Int32x4.extractLane;
  var SIMD_Int32x4_replaceLane=SIMD_Int32x4.replaceLane;
  var SIMD_Int32x4_add=SIMD_Int32x4.add;
  var SIMD_Int32x4_sub=SIMD_Int32x4.sub;
  var SIMD_Int32x4_neg=SIMD_Int32x4.neg;
  var SIMD_Int32x4_mul=SIMD_Int32x4.mul;
  var SIMD_Int32x4_equal=SIMD_Int32x4.equal;
  var SIMD_Int32x4_lessThan=SIMD_Int32x4.lessThan;
  var SIMD_Int32x4_greaterThan=SIMD_Int32x4.greaterThan;
  var SIMD_Int32x4_notEqual=SIMD_Int32x4.notEqual;
  var SIMD_Int32x4_lessThanOrEqual=SIMD_Int32x4.lessThanOrEqual;
  var SIMD_Int32x4_greaterThanOrEqual=SIMD_Int32x4.greaterThanOrEqual;
  var SIMD_Int32x4_select=SIMD_Int32x4.select;
  var SIMD_Int32x4_swizzle=SIMD_Int32x4.swizzle;
  var SIMD_Int32x4_shuffle=SIMD_Int32x4.shuffle;
  var SIMD_Int32x4_load=SIMD_Int32x4.load;
  var SIMD_Int32x4_store=SIMD_Int32x4.store;
  var SIMD_Int32x4_load1=SIMD_Int32x4.load1;
  var SIMD_Int32x4_store1=SIMD_Int32x4.store1;
  var SIMD_Int32x4_load2=SIMD_Int32x4.load2;
  var SIMD_Int32x4_store2=SIMD_Int32x4.store2;
  var SIMD_Int32x4_fromInt16x8Bits=SIMD_Int32x4.fromInt16x8Bits;
  var SIMD_Int32x4_and=SIMD_Int32x4.and;
  var SIMD_Int32x4_xor=SIMD_Int32x4.xor;
  var SIMD_Int32x4_or=SIMD_Int32x4.or;
  var SIMD_Int32x4_not=SIMD_Int32x4.not;
  var SIMD_Int32x4_shiftLeftByScalar=SIMD_Int32x4.shiftLeftByScalar;
  var SIMD_Int32x4_shiftRightByScalar=SIMD_Int32x4.shiftRightByScalar;
  var tempFloat = Math_fround(0);
  const f0 = Math_fround(0);

// EMSCRIPTEN_START_FUNCS

function _opus_encode_native($st, $pcm, $frame_size, $data, $out_data_bytes, $lsb_depth, $analysis_pcm, $analysis_size, $c1, $c2, $analysis_channels, $downmix, $float_api) {
 $st = $st | 0;
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $data = $data | 0;
 $out_data_bytes = $out_data_bytes | 0;
 $lsb_depth = $lsb_depth | 0;
 $analysis_pcm = $analysis_pcm | 0;
 $analysis_size = $analysis_size | 0;
 $c1 = $c1 | 0;
 $c2 = $c2 | 0;
 $analysis_channels = $analysis_channels | 0;
 $downmix = $downmix | 0;
 $float_api = $float_api | 0;
 var $$sink10$sink = 0, $$sink11$sink = 0, $$sink16 = 0, $$sink22$sink = 0, $$sink27 = 0, $$sink28 = 0, $$sink31 = 0, $$sink7$sink = 0, $$sink8$sink = 0, $1159 = 0, $1166 = 0, $1167 = 0, $1170 = 0, $1171 = 0, $1172 = 0, $1180 = 0, $1182 = 0, $1196 = 0, $1204 = 0, $1209 = 0, $1240 = 0, $1241 = 0, $1242 = 0, $1243 = 0, $1265 = 0, $1280 = 0, $1336 = 0, $170 = 0, $209 = 0, $229 = 0, $25 = 0, $251 = 0, $289 = 0, $400 = 0, $401 = 0, $405 = 0, $488 = 0, $502 = 0, $541 = 0, $628 = 0, $686 = 0, $923 = 0, $926 = 0, $947 = 0, $949 = 0, $952 = 0, $955 = 0, $958 = 0, $964 = 0, $969 = 0, $970 = 0, $971 = 0, $974 = 0, $HB_gain = 0, $N2 = 0, $N4 = 0, $add$ptr1972 = 0, $add$ptr1978 = 0, $add1719 = 0, $add580 = 0, $analysis_bandwidth = 0, $analysis_channels$addr = 0, $analysis_info = 0, $analysis_pcm$addr = 0, $analysis_read_pos_bak = 0, $analysis_read_subframe_bak = 0, $analysis_size$addr = 0, $arrayidx1531 = 0, $arrayidx1566 = 0, $arrayidx1591 = 0, $arrayidx1619 = 0, $arrayidx910 = 0, $arrayidx954 = 0, $arrayidx961 = 0, $arrayidx974 = 0, $arrayidx977 = 0, $arrayidx989 = 0, $bandwidth560 = 0, $bandwidth_thresholds = 0, $bitRate1158 = 0, $bw = 0, $bytes_target = 0, $c = 0, $c1$addr = 0, $c2$addr = 0, $call1025 = 0, $call111 = 0, $call1357 = 0, $call1376 = 0, $call1428 = 0, $call1742 = 0, $call1885 = 0, $call1996 = 0, $call2029 = 0, $call2033 = 0, $call234 = 0, $call767 = 0, $cbrBytes = 0, $celt_enc = 0, $celt_mode = 0, $celt_pred = 0, $celt_rate = 0, $celt_to_silk = 0, $cleanup$dest$slot = 0, $cmp1273 = 0, $cmp1558 = 0, $cmp1738 = 0, $cond1087 = 0.0, $cond1107 = 0.0, $cond1142 = 0, $cond1219 = 0, $cond1237 = 0, $cond1295 = 0, $cond135 = 0, $cond174 = 0, $cond1778 = 0, $cond18 = 0, $cond48 = 0.0, $cond653 = 0, $cond746 = 0, $cond900 = 0, $conv71 = 0, $curr_bandwidth = 0, $cutoff_Hz = 0, $data$addr = 0, $dec = 0, $delay_buffer1561 = 0, $delay_compensation = 0, $div138 = 0, $downmix$addr = 0, $dummy = 0, $dummy1877 = 0, $dummy1953 = 0, $effective_max_rate = 0, $enc = 0, $enc_frame_size = 0, $end = 0, $endband = 0, $equiv_rate = 0, $err = 0, $err1952 = 0, $float_api$addr = 0, $frame_rate = 0, $frame_rate12 = 0, $frame_size$addr = 0, $g1 = 0, $g2 = 0, $hp_freq_smth1 = 0, $hysteresis = 0, $i = 0, $info = 0, $is_silence = 0, $lsb_depth$addr = 0, $mask = 0, $mask_sum = 0, $masking_depth = 0, $maxBitRate = 0, $maxBits1257 = 0, $maxBits1264 = 0, $max_data_bytes = 0, $max_rate = 0, $max_redundancy = 0, $min_detected_bandwidth = 0, $mode_music = 0, $mode_voice = 0, $mul1008 = 0, $mul1280 = 0, $mul1291 = 0, $mul1307 = 0, $mul1318 = 0, $mul1373 = 0, $mul1536 = 0, $mul1572 = 0, $mul1596 = 0, $mul1623 = 0, $mul36 = 0.0, $mul381 = 0, $mul438 = 0, $mul574 = 0, $mul885 = 0, $mul895 = 0, $mul906 = 0, $mul913 = 0, $mul979 = 0, $music_bandwidth_thresholds = 0, $nBytes = 0, $nb_compr_bytes = 0, $nb_frames = 0, $num_multiframes = 0, $out_data_bytes$addr = 0, $packet_code = 0, $pcm$addr = 0, $prefill = 0, $prefill_offset = 0, $prob = 0, $rate_offset = 0, $redundancy = 0, $redundancy_bytes = 0, $redundant_rng = 0, $ret = 0, $retval = 0, $saved_stack = 0, $saved_stack1009 = 0, $silk_enc = 0, $silk_mode1286 = 0, $srate = 0, $st$addr = 0, $start_band = 0, $stereo_threshold = 0, $stereo_width = 0, $sub1675$sink$sink = 0, $sub1741 = 0, $sum = 0, $threshold = 0, $threshold582 = 0, $to_celt = 0, $tobool1473 = 0, $tocmode = 0, $total_bitRate = 0, $total_buffer = 0, $vararg_buffer = 0, $vararg_buffer100 = 0, $vararg_buffer103 = 0, $vararg_buffer105 = 0, $vararg_buffer108 = 0, $vararg_buffer111 = 0, $vararg_buffer114 = 0, $vararg_buffer117 = 0, $vararg_buffer33 = 0, $vararg_buffer36 = 0, $vararg_buffer39 = 0, $vararg_buffer42 = 0, $vararg_buffer45 = 0, $vararg_buffer48 = 0, $vararg_buffer51 = 0, $vararg_buffer54 = 0, $vararg_buffer57 = 0, $vararg_buffer60 = 0, $vararg_buffer63 = 0, $vararg_buffer66 = 0, $vararg_buffer69 = 0, $vararg_buffer72 = 0, $vararg_buffer75 = 0, $vararg_buffer78 = 0, $vararg_buffer81 = 0, $vararg_buffer84 = 0, $vararg_buffer87 = 0, $vararg_buffer89 = 0, $vararg_buffer92 = 0, $vararg_buffer94 = 0, $vararg_buffer97 = 0, $vla = 0, $vla1010 = 0, $vla1509 = 0, $vla1509$alloca_mul = 0, $voice_bandwidth_thresholds = 0, $voice_est = 0, $zero = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 880 | 0;
 $vararg_buffer117 = sp + 240 | 0;
 $vararg_buffer114 = sp + 232 | 0;
 $vararg_buffer111 = sp + 224 | 0;
 $vararg_buffer108 = sp + 216 | 0;
 $vararg_buffer105 = sp + 208 | 0;
 $vararg_buffer103 = sp + 200 | 0;
 $vararg_buffer100 = sp + 192 | 0;
 $vararg_buffer97 = sp + 184 | 0;
 $vararg_buffer94 = sp + 176 | 0;
 $vararg_buffer92 = sp + 168 | 0;
 $vararg_buffer89 = sp + 160 | 0;
 $vararg_buffer87 = sp + 152 | 0;
 $vararg_buffer84 = sp + 144 | 0;
 $vararg_buffer81 = sp + 136 | 0;
 $vararg_buffer78 = sp + 128 | 0;
 $vararg_buffer75 = sp + 120 | 0;
 $vararg_buffer72 = sp + 112 | 0;
 $vararg_buffer69 = sp + 104 | 0;
 $vararg_buffer66 = sp + 96 | 0;
 $vararg_buffer63 = sp + 88 | 0;
 $vararg_buffer60 = sp + 80 | 0;
 $vararg_buffer57 = sp + 72 | 0;
 $vararg_buffer54 = sp + 64 | 0;
 $vararg_buffer51 = sp + 56 | 0;
 $vararg_buffer48 = sp + 48 | 0;
 $vararg_buffer45 = sp + 40 | 0;
 $vararg_buffer42 = sp + 32 | 0;
 $vararg_buffer39 = sp + 24 | 0;
 $vararg_buffer36 = sp + 16 | 0;
 $vararg_buffer33 = sp + 8 | 0;
 $vararg_buffer = sp;
 $retval = sp + 856 | 0;
 $st$addr = sp + 852 | 0;
 $pcm$addr = sp + 848 | 0;
 $frame_size$addr = sp + 844 | 0;
 $data$addr = sp + 840 | 0;
 $out_data_bytes$addr = sp + 836 | 0;
 $lsb_depth$addr = sp + 832 | 0;
 $analysis_pcm$addr = sp + 828 | 0;
 $analysis_size$addr = sp + 824 | 0;
 $c1$addr = sp + 820 | 0;
 $c2$addr = sp + 816 | 0;
 $analysis_channels$addr = sp + 812 | 0;
 $downmix$addr = sp + 808 | 0;
 $float_api$addr = sp + 804 | 0;
 $silk_enc = sp + 800 | 0;
 $celt_enc = sp + 796 | 0;
 $i = sp + 792 | 0;
 $ret = sp + 788 | 0;
 $nBytes = sp + 784 | 0;
 $enc = sp + 736 | 0;
 $bytes_target = sp + 732 | 0;
 $prefill = sp + 728 | 0;
 $start_band = sp + 724 | 0;
 $redundancy = sp + 720 | 0;
 $redundancy_bytes = sp + 716 | 0;
 $celt_to_silk = sp + 712 | 0;
 $nb_compr_bytes = sp + 708 | 0;
 $to_celt = sp + 704 | 0;
 $redundant_rng = sp + 700 | 0;
 $cutoff_Hz = sp + 696 | 0;
 $hp_freq_smth1 = sp + 692 | 0;
 $voice_est = sp + 688 | 0;
 $equiv_rate = sp + 684 | 0;
 $delay_compensation = sp + 680 | 0;
 $frame_rate = sp + 676 | 0;
 $max_rate = sp + 672 | 0;
 $curr_bandwidth = sp + 668 | 0;
 $HB_gain = sp + 664 | 0;
 $max_data_bytes = sp + 660 | 0;
 $total_buffer = sp + 656 | 0;
 $stereo_width = sp + 652 | 0;
 $celt_mode = sp + 648 | 0;
 $analysis_info = sp + 584 | 0;
 $analysis_read_pos_bak = sp + 580 | 0;
 $analysis_read_subframe_bak = sp + 576 | 0;
 $is_silence = sp + 572 | 0;
 $analysis_bandwidth = sp + 568 | 0;
 $prob = sp + 564 | 0;
 $cbrBytes = sp + 560 | 0;
 $frame_rate12 = sp + 556 | 0;
 $tocmode = sp + 552 | 0;
 $bw = sp + 548 | 0;
 $packet_code = sp + 544 | 0;
 $num_multiframes = sp + 540 | 0;
 $stereo_threshold = sp + 536 | 0;
 $mode_voice = sp + 532 | 0;
 $mode_music = sp + 528 | 0;
 $threshold = sp + 524 | 0;
 $dummy = sp + 424 | 0;
 $voice_bandwidth_thresholds = sp + 420 | 0;
 $music_bandwidth_thresholds = sp + 416 | 0;
 $bandwidth_thresholds = sp + 384 | 0;
 $bandwidth560 = sp + 376 | 0;
 $threshold582 = sp + 372 | 0;
 $hysteresis = sp + 368 | 0;
 $min_detected_bandwidth = sp + 364 | 0;
 $enc_frame_size = sp + 360 | 0;
 $nb_frames = sp + 356 | 0;
 $saved_stack = sp + 352 | 0;
 $sum = sp + 348 | 0;
 $total_bitRate = sp + 344 | 0;
 $celt_rate = sp + 340 | 0;
 $saved_stack1009 = sp + 336 | 0;
 $mask_sum = sp + 332 | 0;
 $masking_depth = sp + 328 | 0;
 $rate_offset = sp + 324 | 0;
 $c = sp + 320 | 0;
 $end = sp + 316 | 0;
 $srate = sp + 860 | 0;
 $mask = sp + 312 | 0;
 $effective_max_rate = sp + 308 | 0;
 $maxBitRate = sp + 304 | 0;
 $zero = sp + 300 | 0;
 $prefill_offset = sp + 296 | 0;
 $cleanup$dest$slot = sp + 292 | 0;
 $endband = sp + 288 | 0;
 $celt_pred = sp + 284 | 0;
 $g1 = sp + 280 | 0;
 $g2 = sp + 276 | 0;
 $max_redundancy = sp + 272 | 0;
 $info = sp + 264 | 0;
 $err = sp + 256 | 0;
 $dummy1877 = sp + 864 | 0;
 $err1952 = sp + 252 | 0;
 $dummy1953 = sp + 862 | 0;
 $N2 = sp + 248 | 0;
 $N4 = sp + 244 | 0;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$out_data_bytes$addr >> 2] = $out_data_bytes;
 HEAP32[$lsb_depth$addr >> 2] = $lsb_depth;
 HEAP32[$analysis_pcm$addr >> 2] = $analysis_pcm;
 HEAP32[$analysis_size$addr >> 2] = $analysis_size;
 HEAP32[$c1$addr >> 2] = $c1;
 HEAP32[$c2$addr >> 2] = $c2;
 HEAP32[$analysis_channels$addr >> 2] = $analysis_channels;
 HEAP32[$downmix$addr >> 2] = $downmix;
 HEAP32[$float_api$addr >> 2] = $float_api;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$prefill >> 2] = 0;
 HEAP32[$start_band >> 2] = 0;
 HEAP32[$redundancy >> 2] = 0;
 HEAP32[$redundancy_bytes >> 2] = 0;
 HEAP32[$celt_to_silk >> 2] = 0;
 HEAP32[$to_celt >> 2] = 0;
 HEAP32[$redundant_rng >> 2] = 0;
 HEAP32[$analysis_read_pos_bak >> 2] = -1;
 HEAP32[$analysis_read_subframe_bak >> 2] = -1;
 HEAP32[$is_silence >> 2] = 0;
 HEAP32[$max_data_bytes >> 2] = 1276 < (HEAP32[$out_data_bytes$addr >> 2] | 0) ? 1276 : HEAP32[$out_data_bytes$addr >> 2] | 0;
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18132 >> 2] = 0;
 if ((HEAP32[$frame_size$addr >> 2] | 0) <= 0 | (HEAP32[$max_data_bytes >> 2] | 0) <= 0) {
  HEAP32[$retval >> 2] = -1;
  $1336 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $1336 | 0;
 }
 if ((HEAP32[$max_data_bytes >> 2] | 0) == 1) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) == ((HEAP32[$frame_size$addr >> 2] | 0) * 10 | 0)) {
  HEAP32[$retval >> 2] = -2;
  $1336 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $1336 | 0;
 }
 HEAP32[$silk_enc >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0);
 HEAP32[$celt_enc >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0);
 if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] | 0) == 2051) HEAP32[$delay_compensation >> 2] = 0; else HEAP32[$delay_compensation >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 116 >> 2];
 if ((HEAP32[$lsb_depth$addr >> 2] | 0) < (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 168 >> 2] | 0)) $cond18 = HEAP32[$lsb_depth$addr >> 2] | 0; else $cond18 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 168 >> 2] | 0;
 HEAP32[$lsb_depth$addr >> 2] = $cond18;
 $25 = HEAP32[$celt_enc >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = $celt_mode + ((($celt_mode - $celt_mode | 0) / 4 | 0) << 2);
 _opus_custom_encoder_ctl($25, 10015, $vararg_buffer) | 0;
 HEAP32[$analysis_info >> 2] = 0;
 if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 36 >> 2] | 0) >= 7) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) >= 16e3) {
  if (_is_digital_silence(HEAP32[$pcm$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[$lsb_depth$addr >> 2] | 0) | 0) HEAP32[$is_silence >> 2] = 1; else {
   HEAP32[$analysis_read_pos_bak >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 188 + 7448 >> 2];
   HEAP32[$analysis_read_subframe_bak >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 188 + 7452 >> 2];
   _run_analysis((HEAP32[$st$addr >> 2] | 0) + 188 | 0, HEAP32[$celt_mode >> 2] | 0, HEAP32[$analysis_pcm$addr >> 2] | 0, HEAP32[$analysis_size$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[$c1$addr >> 2] | 0, HEAP32[$c2$addr >> 2] | 0, HEAP32[$analysis_channels$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0, HEAP32[$lsb_depth$addr >> 2] | 0, HEAP32[$downmix$addr >> 2] | 0, $analysis_info);
  }
  if (!(HEAP32[$is_silence >> 2] | 0)) if (+HEAPF32[$analysis_info + 36 >> 2] > .10000000149011612) {
   $mul36 = +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 18124 >> 2] * .9990000128746033;
   if ($mul36 > +_compute_frame_energy(HEAP32[$pcm$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] | 0)) $cond48 = +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 18124 >> 2] * .9990000128746033; else $cond48 = +_compute_frame_energy(HEAP32[$pcm$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] | 0);
   HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 18124 >> 2] = $cond48;
  }
 }
 if (!(HEAP32[$is_silence >> 2] | 0)) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 140 >> 2] = -1;
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] = 0;
 do if (HEAP32[$analysis_info >> 2] | 0) {
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 124 >> 2] | 0) == -1e3) {
   do if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0)) HEAPF32[$prob >> 2] = +HEAPF32[$analysis_info + 20 >> 2]; else if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) == 1002) {
    HEAPF32[$prob >> 2] = +HEAPF32[$analysis_info + 28 >> 2];
    break;
   } else {
    HEAPF32[$prob >> 2] = +HEAPF32[$analysis_info + 24 >> 2];
    break;
   } while (0);
   $conv71 = ~~+Math_floor(+((1.0 - +HEAPF32[$prob >> 2]) * 100.0 + .5));
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 140 >> 2] = $conv71;
  }
  HEAP32[$analysis_bandwidth >> 2] = HEAP32[$analysis_info + 32 >> 2];
  if ((HEAP32[$analysis_bandwidth >> 2] | 0) <= 12) {
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] = 1101;
   break;
  }
  if ((HEAP32[$analysis_bandwidth >> 2] | 0) <= 14) {
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] = 1102;
   break;
  }
  if ((HEAP32[$analysis_bandwidth >> 2] | 0) <= 16) {
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] = 1103;
   break;
  } else {
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] = (HEAP32[$analysis_bandwidth >> 2] | 0) <= 18 ? 1104 : 1105;
   break;
  }
 } while (0);
 if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) == 2) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] | 0) != 1) HEAPF32[$stereo_width >> 2] = +_compute_stereo_width(HEAP32[$pcm$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 14256 | 0); else label = 43; else label = 43;
 if ((label | 0) == 43) HEAPF32[$stereo_width >> 2] = 0.0;
 HEAP32[$total_buffer >> 2] = HEAP32[$delay_compensation >> 2];
 $call111 = _user_bitrate_to_bitrate(HEAP32[$st$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[$max_data_bytes >> 2] | 0) | 0;
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] = $call111;
 HEAP32[$frame_rate >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0;
 if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0)) {
  HEAP32[$frame_rate12 >> 2] = ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) * 12 | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0;
  if ((((((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0) * 12 | 0) / 8 | 0) + ((HEAP32[$frame_rate12 >> 2] | 0) / 2 | 0) | 0) / (HEAP32[$frame_rate12 >> 2] | 0) | 0 | 0) < (HEAP32[$max_data_bytes >> 2] | 0)) $cond135 = ((((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0) * 12 | 0) / 8 | 0) + ((HEAP32[$frame_rate12 >> 2] | 0) / 2 | 0) | 0) / (HEAP32[$frame_rate12 >> 2] | 0) | 0; else $cond135 = HEAP32[$max_data_bytes >> 2] | 0;
  HEAP32[$cbrBytes >> 2] = $cond135;
  $div138 = ((Math_imul(HEAP32[$cbrBytes >> 2] | 0, HEAP32[$frame_rate12 >> 2] | 0) | 0) << 3 | 0) / 12 | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] = $div138;
  HEAP32[$max_data_bytes >> 2] = 1 > (HEAP32[$cbrBytes >> 2] | 0) ? 1 : HEAP32[$cbrBytes >> 2] | 0;
 }
 do if ((HEAP32[$max_data_bytes >> 2] | 0) >= 3) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0) >= ((HEAP32[$frame_rate >> 2] | 0) * 3 << 3 | 0)) {
  if ((HEAP32[$frame_rate >> 2] | 0) < 50) {
   if ((Math_imul(HEAP32[$max_data_bytes >> 2] | 0, HEAP32[$frame_rate >> 2] | 0) | 0) < 300) break;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0) < 2400) break;
  }
  HEAP32[$max_rate >> 2] = (Math_imul(HEAP32[$frame_rate >> 2] | 0, HEAP32[$max_data_bytes >> 2] | 0) | 0) << 3;
  HEAP32[$equiv_rate >> 2] = _compute_equiv_rate(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0, 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 36 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 32 >> 2] | 0) | 0;
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 124 >> 2] | 0) == 3001) HEAP32[$voice_est >> 2] = 127; else {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 124 >> 2] | 0) == 3002) {
    HEAP32[$voice_est >> 2] = 0;
    break;
   }
   $209 = HEAP32[$st$addr >> 2] | 0;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 140 >> 2] | 0) >= 0) {
    HEAP32[$voice_est >> 2] = (HEAP32[$209 + 140 >> 2] | 0) * 327 >> 8;
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] | 0) != 2049) break;
    HEAP32[$voice_est >> 2] = (HEAP32[$voice_est >> 2] | 0) < 115 ? HEAP32[$voice_est >> 2] | 0 : 115;
    break;
   }
   if ((HEAP32[$209 + 108 >> 2] | 0) == 2048) {
    HEAP32[$voice_est >> 2] = 115;
    break;
   } else {
    HEAP32[$voice_est >> 2] = 48;
    break;
   }
  } while (0);
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] | 0) != -1e3) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) == 2) {
   $$sink7$sink = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] | 0;
   $$sink8$sink = HEAP32[$st$addr >> 2] | 0;
  } else label = 93; else label = 93;
  do if ((label | 0) == 93) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) != 2) {
    $$sink7$sink = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0;
    $$sink8$sink = HEAP32[$st$addr >> 2] | 0;
    break;
   }
   HEAP32[$stereo_threshold >> 2] = 17e3 + ((Math_imul(HEAP32[$voice_est >> 2] | 0, HEAP32[$voice_est >> 2] | 0) | 0) * 2e3 >> 14);
   $229 = HEAP32[$stereo_threshold >> 2] | 0;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) == 2) HEAP32[$stereo_threshold >> 2] = $229 - 1e3; else HEAP32[$stereo_threshold >> 2] = $229 + 1e3;
   $$sink7$sink = (HEAP32[$equiv_rate >> 2] | 0) > (HEAP32[$stereo_threshold >> 2] | 0) ? 2 : 1;
   $$sink8$sink = HEAP32[$st$addr >> 2] | 0;
  } while (0);
  HEAP32[$$sink8$sink + 14188 >> 2] = $$sink7$sink;
  HEAP32[$equiv_rate >> 2] = _compute_equiv_rate(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0, 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 36 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 32 >> 2] | 0) | 0;
  $251 = HEAP32[$st$addr >> 2] | 0;
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] | 0) == 2051) {
   $$sink10$sink = 1002;
   $$sink11$sink = $251;
   label = 117;
  } else {
   if ((HEAP32[$251 + 136 >> 2] | 0) != -1e3) {
    $$sink10$sink = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 136 >> 2] | 0;
    $$sink11$sink = HEAP32[$st$addr >> 2] | 0;
    label = 117;
    break;
   }
   HEAP32[$mode_voice >> 2] = ~~((1.0 - +HEAPF32[$stereo_width >> 2]) * +(HEAP32[2] | 0) + +HEAPF32[$stereo_width >> 2] * +(HEAP32[4] | 0));
   HEAP32[$mode_music >> 2] = ~~((1.0 - +HEAPF32[$stereo_width >> 2]) * +(HEAP32[5] | 0) + +HEAPF32[$stereo_width >> 2] * +(HEAP32[5] | 0));
   $mul381 = Math_imul(HEAP32[$voice_est >> 2] | 0, HEAP32[$voice_est >> 2] | 0) | 0;
   HEAP32[$threshold >> 2] = (HEAP32[$mode_music >> 2] | 0) + ((Math_imul($mul381, (HEAP32[$mode_voice >> 2] | 0) - (HEAP32[$mode_music >> 2] | 0) | 0) | 0) >> 14);
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] | 0) == 2048) HEAP32[$threshold >> 2] = (HEAP32[$threshold >> 2] | 0) + 8e3;
   do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) == 1002) HEAP32[$threshold >> 2] = (HEAP32[$threshold >> 2] | 0) - 4e3; else {
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) <= 0) break;
    HEAP32[$threshold >> 2] = (HEAP32[$threshold >> 2] | 0) + 4e3;
   } while (0);
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = (HEAP32[$equiv_rate >> 2] | 0) >= (HEAP32[$threshold >> 2] | 0) ? 1002 : 1e3;
   do if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 40 >> 2] | 0) {
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 32 >> 2] | 0) <= (128 - (HEAP32[$voice_est >> 2] | 0) >> 4 | 0)) break;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = 1e3;
   } while (0);
   if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 184 >> 2] | 0) $289 = (HEAP32[$analysis_info >> 2] | 0 ? 1 : (HEAP32[$is_silence >> 2] | 0) != 0) ^ 1; else $289 = 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 48 >> 2] = $289 & 1;
   if ((HEAP32[$voice_est >> 2] | 0) > 100 ? (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 48 >> 2] | 0) != 0 : 0) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = 1e3;
   $mul438 = Math_imul((HEAP32[$frame_rate >> 2] | 0) > 50 ? 9e3 : 6e3, HEAP32[$frame_size$addr >> 2] | 0) | 0;
   if ((HEAP32[$max_data_bytes >> 2] | 0) >= (($mul438 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] << 3 | 0) | 0 | 0)) break;
   $$sink10$sink = 1002;
   $$sink11$sink = HEAP32[$st$addr >> 2] | 0;
   label = 117;
  } while (0);
  if ((label | 0) == 117) HEAP32[$$sink11$sink + 14220 >> 2] = $$sink10$sink;
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002) if ((HEAP32[$frame_size$addr >> 2] | 0) < ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 100 | 0 | 0)) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = 1002;
  if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 176 >> 2] | 0) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = 1002;
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) > 0) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002) {
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) != 1002) label = 126;
   } else label = 126;
   if ((label | 0) == 126) {
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002) break;
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) == 1002) break;
   }
   HEAP32[$redundancy >> 2] = 1;
   HEAP32[$celt_to_silk >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002 & 1;
   if (HEAP32[$celt_to_silk >> 2] | 0) break;
   if ((HEAP32[$frame_size$addr >> 2] | 0) >= ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 100 | 0 | 0)) {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2];
    HEAP32[$to_celt >> 2] = 1;
    break;
   } else {
    HEAP32[$redundancy >> 2] = 0;
    break;
   }
  } while (0);
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) == 1) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14228 >> 2] | 0) != 2) {
    label = 138;
    break;
   }
   if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 60 >> 2] | 0) {
    label = 138;
    break;
   }
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1002) {
    label = 138;
    break;
   }
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) == 1002) {
    label = 138;
    break;
   }
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 60 >> 2] = 1;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] = 2;
  } else label = 138; while (0);
  if ((label | 0) == 138) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 60 >> 2] = 0;
  HEAP32[$equiv_rate >> 2] = _compute_equiv_rate(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 36 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 32 >> 2] | 0) | 0;
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) != 1002) break;
   _silk_InitEncoder(HEAP32[$silk_enc >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] | 0, $dummy) | 0;
   HEAP32[$prefill >> 2] = 1;
  } while (0);
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1002) label = 145; else {
   if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14248 >> 2] | 0) {
    label = 145;
    break;
   }
   if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 76 >> 2] | 0) label = 145;
  } while (0);
  do if ((label | 0) == 145) {
   HEAP32[$bandwidth560 >> 2] = 1105;
   do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) == 2) {
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] | 0) == 1) {
     label = 148;
     break;
    }
    HEAP32[$voice_bandwidth_thresholds >> 2] = 24;
    HEAP32[$music_bandwidth_thresholds >> 2] = 56;
   } else label = 148; while (0);
   if ((label | 0) == 148) {
    HEAP32[$voice_bandwidth_thresholds >> 2] = 88;
    HEAP32[$music_bandwidth_thresholds >> 2] = 120;
   }
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= 8) break;
    $mul574 = Math_imul(HEAP32[$voice_est >> 2] | 0, HEAP32[$voice_est >> 2] | 0) | 0;
    $add580 = (HEAP32[(HEAP32[$music_bandwidth_thresholds >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + ((Math_imul($mul574, (HEAP32[(HEAP32[$voice_bandwidth_thresholds >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$music_bandwidth_thresholds >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) | 0) | 0) >> 14) | 0;
    HEAP32[$bandwidth_thresholds + (HEAP32[$i >> 2] << 2) >> 2] = $add580;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   do {
    HEAP32[$threshold582 >> 2] = HEAP32[$bandwidth_thresholds + ((HEAP32[$bandwidth560 >> 2] | 0) - 1102 << 1 << 2) >> 2];
    HEAP32[$hysteresis >> 2] = HEAP32[$bandwidth_thresholds + (((HEAP32[$bandwidth560 >> 2] | 0) - 1102 << 1) + 1 << 2) >> 2];
    do if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14248 >> 2] | 0)) {
     $400 = HEAP32[$hysteresis >> 2] | 0;
     $401 = HEAP32[$threshold582 >> 2] | 0;
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14240 >> 2] | 0) >= (HEAP32[$bandwidth560 >> 2] | 0)) {
      HEAP32[$threshold582 >> 2] = $401 - $400;
      break;
     } else {
      HEAP32[$threshold582 >> 2] = $401 + $400;
      break;
     }
    } while (0);
    if ((HEAP32[$equiv_rate >> 2] | 0) >= (HEAP32[$threshold582 >> 2] | 0)) break;
    $dec = (HEAP32[$bandwidth560 >> 2] | 0) + -1 | 0;
    HEAP32[$bandwidth560 >> 2] = $dec;
   } while (($dec | 0) > 1101);
   $405 = HEAP32[$bandwidth560 >> 2] | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14240 >> 2] = $405;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = $405;
   if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14248 >> 2] | 0) break;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1002) break;
   if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 80 >> 2] | 0) break;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) <= 1103) break;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = 1103;
  } while (0);
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) > (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 132 >> 2] | 0)) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 132 >> 2];
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 128 >> 2] | 0) != -1e3) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 128 >> 2];
  if ((HEAP32[$max_rate >> 2] | 0) < 15e3 ? (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002 : 0) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) < 1103) $cond653 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0; else $cond653 = 1103;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = $cond653;
  }
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) <= 24e3) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) <= 1104) break;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = 1104;
  } while (0);
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) <= 16e3) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) <= 1103) break;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = 1103;
  } while (0);
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) <= 12e3) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) <= 1102) break;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = 1102;
  } while (0);
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) <= 8e3) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) <= 1101) break;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = 1101;
  } while (0);
  do if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] | 0) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 128 >> 2] | 0) != -1e3) break;
   do if ((HEAP32[$equiv_rate >> 2] | 0) <= ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) * 18e3 | 0)) {
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002) {
     label = 188;
     break;
    }
    HEAP32[$min_detected_bandwidth >> 2] = 1101;
   } else label = 188; while (0);
   L227 : do if ((label | 0) == 188) {
    do if ((HEAP32[$equiv_rate >> 2] | 0) <= ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) * 24e3 | 0)) {
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002) break;
     HEAP32[$min_detected_bandwidth >> 2] = 1102;
     break L227;
    } while (0);
    if ((HEAP32[$equiv_rate >> 2] | 0) <= ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) * 3e4 | 0)) {
     HEAP32[$min_detected_bandwidth >> 2] = 1103;
     break;
    }
    if ((HEAP32[$equiv_rate >> 2] | 0) <= ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) * 44e3 | 0)) {
     HEAP32[$min_detected_bandwidth >> 2] = 1104;
     break;
    } else {
     HEAP32[$min_detected_bandwidth >> 2] = 1105;
     break;
    }
   } while (0);
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] | 0) > (HEAP32[$min_detected_bandwidth >> 2] | 0)) $cond746 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] | 0; else $cond746 = HEAP32[$min_detected_bandwidth >> 2] | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] = $cond746;
   $488 = HEAP32[$st$addr >> 2] | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = HEAP32[((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) < (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18116 >> 2] | 0) ? $488 + 14236 | 0 : $488 + 18116 | 0) >> 2];
  } while (0);
  $call767 = _decide_fec(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 40 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 32 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 44 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 14236 | 0, HEAP32[$equiv_rate >> 2] | 0) | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 44 >> 2] = $call767;
  $502 = HEAP32[$celt_enc >> 2] | 0;
  HEAP32[$vararg_buffer33 >> 2] = HEAP32[$lsb_depth$addr >> 2];
  _opus_custom_encoder_ctl($502, 4036, $vararg_buffer33) | 0;
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1002) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) != 1102) break;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = 1103;
  } while (0);
  if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 176 >> 2] | 0) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = 1101;
  HEAP32[$curr_bandwidth >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2];
  if ((HEAP32[$curr_bandwidth >> 2] | 0) > 1103 ? (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1e3 : 0) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = 1001;
  if ((HEAP32[$curr_bandwidth >> 2] | 0) <= 1103 ? (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001 : 0) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = 1e3;
  if ((HEAP32[$frame_size$addr >> 2] | 0) > ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 50 | 0 | 0)) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1e3) label = 211;
  } else label = 211;
  do if ((label | 0) == 211) {
   if ((HEAP32[$frame_size$addr >> 2] | 0) > (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) * 3 | 0) / 50 | 0 | 0)) break;
   if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14244 >> 2] | 0) {
    HEAP32[$redundancy >> 2] = 1;
    HEAP32[$celt_to_silk >> 2] = 1;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14244 >> 2] = 0;
    HEAP32[$prefill >> 2] = 1;
   }
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1002) HEAP32[$redundancy >> 2] = 0;
   do if (HEAP32[$redundancy >> 2] | 0) {
    HEAP32[$redundancy_bytes >> 2] = _compute_redundancy_bytes(HEAP32[$max_data_bytes >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0, HEAP32[$frame_rate >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) | 0;
    if (HEAP32[$redundancy_bytes >> 2] | 0) break;
    HEAP32[$redundancy >> 2] = 0;
   } while (0);
   $mul885 = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0;
   if (((HEAP32[$max_data_bytes >> 2] | 0) - (HEAP32[$redundancy_bytes >> 2] | 0) | 0) < (($mul885 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] << 3 | 0) | 0 | 0)) $cond900 = (HEAP32[$max_data_bytes >> 2] | 0) - (HEAP32[$redundancy_bytes >> 2] | 0) | 0; else {
    $mul895 = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0;
    $cond900 = ($mul895 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] << 3 | 0) | 0;
   }
   HEAP32[$bytes_target >> 2] = $cond900 - 1;
   HEAP32[$data$addr >> 2] = (HEAP32[$data$addr >> 2] | 0) + 1;
   _ec_enc_init($enc, HEAP32[$data$addr >> 2] | 0, (HEAP32[$max_data_bytes >> 2] | 0) - 1 | 0);
   $mul906 = Math_imul((HEAP32[$total_buffer >> 2] | 0) + (HEAP32[$frame_size$addr >> 2] | 0) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0;
   HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
   $vla = STACKTOP;
   STACKTOP = STACKTOP + ((1 * ($mul906 << 2) | 0) + 15 & -16) | 0;
   $arrayidx910 = (HEAP32[$st$addr >> 2] | 0) + 14276 + ((Math_imul((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0) - (HEAP32[$total_buffer >> 2] | 0) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2) | 0;
   $mul913 = (Math_imul(HEAP32[$total_buffer >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2;
   _memcpy($vla | 0, $arrayidx910 | 0, $mul913 + 0 | 0) | 0;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1002) HEAP32[$hp_freq_smth1 >> 2] = (_silk_lin2log(60) | 0) << 8; else HEAP32[$hp_freq_smth1 >> 2] = HEAP32[(HEAP32[$silk_enc >> 2] | 0) + 8 >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14196 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14196 >> 2] | 0) + ((((HEAP32[$hp_freq_smth1 >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14196 >> 2] | 0) >> 16) * 983 | 0) + (((HEAP32[$hp_freq_smth1 >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14196 >> 2] | 0) & 65535) * 983 >> 16));
   HEAP32[$cutoff_Hz >> 2] = _silk_log2lin(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14196 >> 2] >> 8) | 0;
   $628 = HEAP32[$pcm$addr >> 2] | 0;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] | 0) == 2048) {
    $arrayidx954 = $vla + ((Math_imul(HEAP32[$total_buffer >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2) | 0;
    _hp_cutoff($628, HEAP32[$cutoff_Hz >> 2] | 0, $arrayidx954, (HEAP32[$st$addr >> 2] | 0) + 14204 | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] | 0);
   } else {
    $arrayidx961 = $vla + ((Math_imul(HEAP32[$total_buffer >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2) | 0;
    _dc_reject($628, 3, $arrayidx961, (HEAP32[$st$addr >> 2] | 0) + 14204 | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0);
   }
   do if (HEAP32[$float_api$addr >> 2] | 0) {
    $arrayidx974 = $vla + ((Math_imul(HEAP32[$total_buffer >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2) | 0;
    $arrayidx977 = $vla + ((Math_imul(HEAP32[$total_buffer >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2) | 0;
    $mul979 = Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0;
    HEAPF32[$sum >> 2] = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] & 7) << 2) >> 2] & 0]($arrayidx974, $arrayidx977, $mul979);
    if (+HEAPF32[$sum >> 2] < 1.0e9) if (!(+HEAPF32[$sum >> 2] != +HEAPF32[$sum >> 2])) break;
    $arrayidx989 = $vla + ((Math_imul(HEAP32[$total_buffer >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2) | 0;
    _memset($arrayidx989 | 0, 0, (Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2 | 0) | 0;
    HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14204 + 12 >> 2] = 0.0;
    HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14204 + 8 >> 2] = 0.0;
    HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14204 + 4 >> 2] = 0.0;
    HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14204 >> 2] = 0.0;
   } while (0);
   HEAPF32[$HB_gain >> 2] = 1.0;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002) {
    $mul1008 = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0;
    HEAP32[$saved_stack1009 >> 2] = _llvm_stacksave() | 0;
    $vla1010 = STACKTOP;
    STACKTOP = STACKTOP + ((1 * ($mul1008 << 1) | 0) + 15 & -16) | 0;
    HEAP32[$total_bitRate >> 2] = Math_imul(HEAP32[$bytes_target >> 2] << 3, HEAP32[$frame_rate >> 2] | 0) | 0;
    $686 = HEAP32[$total_bitRate >> 2] | 0;
    do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001) {
     $call1025 = _compute_silk_rate_for_hybrid($686, HEAP32[$curr_bandwidth >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) == ((HEAP32[$frame_size$addr >> 2] | 0) * 50 | 0) & 1, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 44 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) | 0;
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 28 >> 2] = $call1025;
     if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14252 >> 2] | 0) break;
     HEAP32[$celt_rate >> 2] = (HEAP32[$total_bitRate >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 28 >> 2] | 0);
     HEAPF32[$HB_gain >> 2] = 1.0 - +Math_exp(+(+(0 - (HEAP32[$celt_rate >> 2] | 0) | 0) * .0009765625 * .6931471805599453));
    } else HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 28 >> 2] = $686; while (0);
    do if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14252 >> 2] | 0) {
     if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0)) break;
     if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 176 >> 2] | 0) break;
     HEAPF32[$mask_sum >> 2] = 0.0;
     HEAP32[$end >> 2] = 17;
     HEAP16[$srate >> 1] = 16e3;
     do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) == 1101) {
      HEAP32[$end >> 2] = 13;
      HEAP16[$srate >> 1] = 8e3;
     } else {
      if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) != 1102) break;
      HEAP32[$end >> 2] = 15;
      HEAP16[$srate >> 1] = 12e3;
     } while (0);
     HEAP32[$c >> 2] = 0;
     while (1) {
      if ((HEAP32[$c >> 2] | 0) >= (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0)) break;
      HEAP32[$i >> 2] = 0;
      while (1) {
       if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
       if (+HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14252 >> 2] | 0) + (((HEAP32[$c >> 2] | 0) * 21 | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] < .5) $cond1087 = +HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14252 >> 2] | 0) + (((HEAP32[$c >> 2] | 0) * 21 | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2]; else $cond1087 = .5;
       do if ($cond1087 > -2.0) {
        if (!(+HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14252 >> 2] | 0) + (((HEAP32[$c >> 2] | 0) * 21 | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] < .5)) {
         $cond1107 = .5;
         break;
        }
        $cond1107 = +HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14252 >> 2] | 0) + (((HEAP32[$c >> 2] | 0) * 21 | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
       } else $cond1107 = -2.0; while (0);
       HEAPF32[$mask >> 2] = $cond1107;
       if (+HEAPF32[$mask >> 2] > 0.0) HEAPF32[$mask >> 2] = +HEAPF32[$mask >> 2] * .5;
       HEAPF32[$mask_sum >> 2] = +HEAPF32[$mask_sum >> 2] + +HEAPF32[$mask >> 2];
       HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
      }
      HEAP32[$c >> 2] = (HEAP32[$c >> 2] | 0) + 1;
     }
     HEAPF32[$masking_depth >> 2] = +HEAPF32[$mask_sum >> 2] / +(HEAP32[$end >> 2] | 0) * +(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0);
     HEAPF32[$masking_depth >> 2] = +HEAPF32[$masking_depth >> 2] + .20000000298023224;
     HEAP32[$rate_offset >> 2] = ~~(+(HEAP16[$srate >> 1] | 0) * +HEAPF32[$masking_depth >> 2]);
     if ((HEAP32[$rate_offset >> 2] | 0) > ((Math_imul(-2, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 28 >> 2] | 0) | 0) / 3 | 0 | 0)) $cond1142 = HEAP32[$rate_offset >> 2] | 0; else $cond1142 = (Math_imul(-2, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 28 >> 2] | 0) | 0) / 3 | 0;
     HEAP32[$rate_offset >> 2] = $cond1142;
     do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) == 1104) label = 272; else {
      if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0) == 1105) {
       label = 272;
       break;
      }
      $$sink16 = HEAP32[$rate_offset >> 2] | 0;
      $$sink31 = HEAP32[$st$addr >> 2] | 0;
     } while (0);
     if ((label | 0) == 272) {
      $$sink16 = ((HEAP32[$rate_offset >> 2] | 0) * 3 | 0) / 5 | 0;
      $$sink31 = HEAP32[$st$addr >> 2] | 0;
     }
     $bitRate1158 = $$sink31 + 8 + 28 | 0;
     HEAP32[$bitRate1158 >> 2] = (HEAP32[$bitRate1158 >> 2] | 0) + $$sink16;
    } while (0);
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 24 >> 2] = ((HEAP32[$frame_size$addr >> 2] | 0) * 1e3 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) | 0;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2];
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 4 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2];
    if ((HEAP32[$curr_bandwidth >> 2] | 0) == 1101) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 20 >> 2] = 8e3; else HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 20 >> 2] = (HEAP32[$curr_bandwidth >> 2] | 0) == 1102 ? 12e3 : 16e3;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 16 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001 ? 16e3 : 8e3;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 12 >> 2] = 16e3;
    do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1e3) {
     HEAP32[$effective_max_rate >> 2] = HEAP32[$max_rate >> 2];
     if ((HEAP32[$frame_rate >> 2] | 0) > 50) HEAP32[$effective_max_rate >> 2] = (HEAP32[$effective_max_rate >> 2] << 1 | 0) / 3 | 0;
     if ((HEAP32[$effective_max_rate >> 2] | 0) < 8e3) {
      HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 12 >> 2] = 12e3;
      if (12e3 < (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 20 >> 2] | 0)) $cond1219 = 12e3; else $cond1219 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 20 >> 2] | 0;
      HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 20 >> 2] = $cond1219;
     }
     if ((HEAP32[$effective_max_rate >> 2] | 0) >= 7e3) break;
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 12 >> 2] = 8e3;
     if (8e3 < (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 20 >> 2] | 0)) $cond1237 = 8e3; else $cond1237 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 20 >> 2] | 0;
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 20 >> 2] = $cond1237;
    } while (0);
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 52 >> 2] = ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0) != 0 ^ 1) & 1;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 56 >> 2] = (HEAP32[$max_data_bytes >> 2] | 0) - 1 << 3;
    do if ((HEAP32[$redundancy >> 2] | 0) != 0 & (HEAP32[$redundancy_bytes >> 2] | 0) >= 2) {
     $maxBits1257 = (HEAP32[$st$addr >> 2] | 0) + 8 + 56 | 0;
     HEAP32[$maxBits1257 >> 2] = (HEAP32[$maxBits1257 >> 2] | 0) - ((HEAP32[$redundancy_bytes >> 2] << 3) + 1);
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1001) break;
     $maxBits1264 = (HEAP32[$st$addr >> 2] | 0) + 8 + 56 | 0;
     HEAP32[$maxBits1264 >> 2] = (HEAP32[$maxBits1264 >> 2] | 0) - 20;
    } while (0);
    $cmp1273 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001;
    do if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 52 >> 2] | 0) {
     if (!$cmp1273) break;
     $mul1280 = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 28 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0;
     $silk_mode1286 = (HEAP32[$st$addr >> 2] | 0) + 8 | 0;
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 56 >> 2] | 0) < (($mul1280 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) | 0 | 0)) $cond1295 = HEAP32[$silk_mode1286 + 56 >> 2] | 0; else {
      $mul1291 = Math_imul(HEAP32[$silk_mode1286 + 28 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0;
      $cond1295 = ($mul1291 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) | 0;
     }
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 56 >> 2] = $cond1295;
    } else {
     if (!$cmp1273) break;
     $mul1307 = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 56 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) | 0;
     HEAP32[$maxBitRate >> 2] = _compute_silk_rate_for_hybrid(($mul1307 | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0, HEAP32[$curr_bandwidth >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) == ((HEAP32[$frame_size$addr >> 2] | 0) * 50 | 0) & 1, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 44 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) | 0;
     $mul1318 = Math_imul(HEAP32[$maxBitRate >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0;
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 56 >> 2] = ($mul1318 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) | 0;
    } while (0);
    if (HEAP32[$prefill >> 2] | 0) {
     HEAP32[$zero >> 2] = 0;
     HEAP32[$prefill_offset >> 2] = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 116 >> 2] | 0) - ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 400 | 0) | 0) | 0;
     _gain_fade((HEAP32[$st$addr >> 2] | 0) + 14276 + (HEAP32[$prefill_offset >> 2] << 2) | 0, (HEAP32[$st$addr >> 2] | 0) + 14276 + (HEAP32[$prefill_offset >> 2] << 2) | 0, 0.0, 1.0, HEAP32[(HEAP32[$celt_mode >> 2] | 0) + 4 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 400 | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$celt_mode >> 2] | 0) + 60 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0);
     _memset((HEAP32[$st$addr >> 2] | 0) + 14276 | 0, 0, HEAP32[$prefill_offset >> 2] << 2 | 0) | 0;
     HEAP32[$i >> 2] = 0;
     while (1) {
      if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0)) break;
      $call1357 = _FLOAT2INT16_12(+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14276 + (HEAP32[$i >> 2] << 2) >> 2]) | 0;
      HEAP16[$vla1010 + (HEAP32[$i >> 2] << 1) >> 1] = $call1357;
      HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
     }
     _silk_Encode(HEAP32[$silk_enc >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 8 | 0, $vla1010, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0, 0, $zero, 1) | 0;
    }
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0)) break;
     $mul1373 = Math_imul(HEAP32[$total_buffer >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0;
     $call1376 = _FLOAT2INT16_12(+HEAPF32[$vla + ($mul1373 + (HEAP32[$i >> 2] | 0) << 2) >> 2]) | 0;
     HEAP16[$vla1010 + (HEAP32[$i >> 2] << 1) >> 1] = $call1376;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
    HEAP32[$ret >> 2] = _silk_Encode(HEAP32[$silk_enc >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 8 | 0, $vla1010, HEAP32[$frame_size$addr >> 2] | 0, $enc, $nBytes, 0) | 0;
    do if (HEAP32[$ret >> 2] | 0) {
     HEAP32[$retval >> 2] = -3;
     HEAP32[$cleanup$dest$slot >> 2] = 1;
    } else {
     do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1e3) {
      if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 72 >> 2] | 0) == 8e3) {
       HEAP32[$curr_bandwidth >> 2] = 1101;
       break;
      }
      if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 72 >> 2] | 0) == 12e3) {
       HEAP32[$curr_bandwidth >> 2] = 1102;
       break;
      }
      if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 72 >> 2] | 0) != 16e3) break;
      HEAP32[$curr_bandwidth >> 2] = 1103;
     } while (0);
     if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 88 >> 2] | 0) $923 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18128 >> 2] | 0) != 0 ^ 1; else $923 = 0;
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 64 >> 2] = $923 & 1;
     $926 = HEAP32[$st$addr >> 2] | 0;
     if (!(HEAP32[$nBytes >> 2] | 0)) {
      HEAP32[$926 + 18132 >> 2] = 0;
      $call1428 = _gen_toc(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0, HEAP32[$curr_bandwidth >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) | 0;
      HEAP8[(HEAP32[$data$addr >> 2] | 0) + -1 >> 0] = $call1428;
      HEAP32[$retval >> 2] = 1;
      HEAP32[$cleanup$dest$slot >> 2] = 1;
      break;
     }
     if (HEAP32[$926 + 8 + 64 >> 2] | 0) {
      HEAP32[$redundancy_bytes >> 2] = _compute_redundancy_bytes(HEAP32[$max_data_bytes >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0, HEAP32[$frame_rate >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) | 0;
      HEAP32[$redundancy >> 2] = (HEAP32[$redundancy_bytes >> 2] | 0) != 0 & 1;
      HEAP32[$celt_to_silk >> 2] = 0;
      HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14244 >> 2] = 1;
     }
     HEAP32[$cleanup$dest$slot >> 2] = 0;
    } while (0);
    _llvm_stackrestore(HEAP32[$saved_stack1009 >> 2] | 0);
    if (!(HEAP32[$cleanup$dest$slot >> 2] | 0)) label = 325;
   } else label = 325;
   L404 : do if ((label | 0) == 325) {
    HEAP32[$endband >> 2] = 21;
    switch (HEAP32[$curr_bandwidth >> 2] | 0) {
    case 1101:
     {
      HEAP32[$endband >> 2] = 13;
      break;
     }
    case 1103:
    case 1102:
     {
      HEAP32[$endband >> 2] = 17;
      break;
     }
    case 1104:
     {
      HEAP32[$endband >> 2] = 19;
      break;
     }
    case 1105:
     {
      HEAP32[$endband >> 2] = 21;
      break;
     }
    default:
     {}
    }
    $947 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer36 >> 2] = HEAP32[$endband >> 2];
    _opus_custom_encoder_ctl($947, 10012, $vararg_buffer36) | 0;
    $949 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer39 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2];
    _opus_custom_encoder_ctl($949, 10008, $vararg_buffer39) | 0;
    $952 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer42 >> 2] = -1;
    _opus_custom_encoder_ctl($952, 4002, $vararg_buffer42) | 0;
    do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1e3) {
     HEAPF32[$celt_pred >> 2] = 2.0;
     $955 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer45 >> 2] = 0;
     _opus_custom_encoder_ctl($955, 4006, $vararg_buffer45) | 0;
     if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 68 >> 2] | 0) HEAPF32[$celt_pred >> 2] = 0.0;
     $958 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer48 >> 2] = ~~+HEAPF32[$celt_pred >> 2];
     _opus_custom_encoder_ctl($958, 10002, $vararg_buffer48) | 0;
     $tobool1473 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0) != 0;
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001) {
      if (!$tobool1473) break;
      $964 = HEAP32[$celt_enc >> 2] | 0;
      HEAP32[$vararg_buffer51 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 28 >> 2] | 0);
      _opus_custom_encoder_ctl($964, 4002, $vararg_buffer51) | 0;
      $969 = HEAP32[$celt_enc >> 2] | 0;
      HEAP32[$vararg_buffer54 >> 2] = 0;
      _opus_custom_encoder_ctl($969, 4020, $vararg_buffer54) | 0;
      break;
     } else {
      if (!$tobool1473) break;
      $970 = HEAP32[$celt_enc >> 2] | 0;
      HEAP32[$vararg_buffer57 >> 2] = 1;
      _opus_custom_encoder_ctl($970, 4006, $vararg_buffer57) | 0;
      $971 = HEAP32[$celt_enc >> 2] | 0;
      HEAP32[$vararg_buffer60 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 152 >> 2];
      _opus_custom_encoder_ctl($971, 4020, $vararg_buffer60) | 0;
      $974 = HEAP32[$celt_enc >> 2] | 0;
      HEAP32[$vararg_buffer63 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2];
      _opus_custom_encoder_ctl($974, 4002, $vararg_buffer63) | 0;
      break;
     }
    } while (0);
    $vla1509$alloca_mul = ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) | 0) / 400 | 0) << 2;
    $vla1509 = STACKTOP;
    STACKTOP = STACKTOP + ((1 * $vla1509$alloca_mul | 0) + 15 & -16) | 0;
    do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1e3) {
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0)) break;
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) <= 0) break;
     $arrayidx1531 = (HEAP32[$st$addr >> 2] | 0) + 14276 + ((Math_imul((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0) - (HEAP32[$total_buffer >> 2] | 0) - ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 400 | 0) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2) | 0;
     $mul1536 = ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) | 0) / 400 | 0) << 2;
     _memcpy($vla1509 | 0, $arrayidx1531 | 0, $mul1536 + 0 | 0) | 0;
    } while (0);
    $cmp1558 = (Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0) - ((HEAP32[$frame_size$addr >> 2] | 0) + (HEAP32[$total_buffer >> 2] | 0)) | 0) | 0) > 0;
    $delay_buffer1561 = (HEAP32[$st$addr >> 2] | 0) + 14276 | 0;
    if ($cmp1558) {
     $arrayidx1566 = (HEAP32[$st$addr >> 2] | 0) + 14276 + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0) << 2) | 0;
     $mul1572 = (Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0) - (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$total_buffer >> 2] | 0) | 0) | 0) << 2;
     _memmove($delay_buffer1561 | 0, $arrayidx1566 | 0, $mul1572 + 0 | 0) | 0;
     $arrayidx1591 = (HEAP32[$st$addr >> 2] | 0) + 14276 + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0) - (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$total_buffer >> 2] | 0) | 0) | 0) << 2) | 0;
     $mul1596 = (Math_imul((HEAP32[$frame_size$addr >> 2] | 0) + (HEAP32[$total_buffer >> 2] | 0) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2;
     _memcpy($arrayidx1591 | 0, $vla | 0, $mul1596 + 0 | 0) | 0;
    } else {
     $arrayidx1619 = $vla + ((Math_imul((HEAP32[$frame_size$addr >> 2] | 0) + (HEAP32[$total_buffer >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2) | 0;
     $mul1623 = (Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0) << 2;
     _memcpy($delay_buffer1561 | 0, $arrayidx1619 | 0, $mul1623 + 0 | 0) | 0;
    }
    if (+HEAPF32[$HB_gain >> 2] < 1.0 ? 1 : +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14200 >> 2] < 1.0) _gain_fade($vla, $vla, +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14200 >> 2], +HEAPF32[$HB_gain >> 2], HEAP32[(HEAP32[$celt_mode >> 2] | 0) + 4 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$celt_mode >> 2] | 0) + 60 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0);
    HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14200 >> 2] = +HEAPF32[$HB_gain >> 2];
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1001) label = 349; else if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) == 1) label = 349;
    if ((label | 0) == 349) {
     do if ((HEAP32[$equiv_rate >> 2] | 0) > 32e3) {
      $$sink22$sink = HEAP32[$st$addr >> 2] | 0;
      $sub1675$sink$sink = 16384;
     } else if ((HEAP32[$equiv_rate >> 2] | 0) < 16e3) {
      $$sink22$sink = HEAP32[$st$addr >> 2] | 0;
      $sub1675$sink$sink = 0;
      break;
     } else {
      $$sink22$sink = HEAP32[$st$addr >> 2] | 0;
      $sub1675$sink$sink = 16384 - ((32e3 - (HEAP32[$equiv_rate >> 2] | 0) << 11 | 0) / ((HEAP32[$equiv_rate >> 2] | 0) - 14e3 | 0) | 0) | 0;
      break;
     } while (0);
     HEAP32[$$sink22$sink + 8 + 84 >> 2] = $sub1675$sink$sink;
    }
    do if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14252 >> 2] | 0)) {
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) != 2) break;
     if ((HEAP16[(HEAP32[$st$addr >> 2] | 0) + 14192 >> 1] | 0) >= 16384) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 84 >> 2] | 0) >= 16384) break;
     HEAPF32[$g1 >> 2] = +(HEAP16[(HEAP32[$st$addr >> 2] | 0) + 14192 >> 1] | 0);
     HEAPF32[$g2 >> 2] = +(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 84 >> 2] | 0);
     HEAPF32[$g1 >> 2] = +HEAPF32[$g1 >> 2] * .00006103515625;
     HEAPF32[$g2 >> 2] = +HEAPF32[$g2 >> 2] * .00006103515625;
     _stereo_fade($vla, $vla, +HEAPF32[$g1 >> 2], +HEAPF32[$g2 >> 2], HEAP32[(HEAP32[$celt_mode >> 2] | 0) + 4 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$celt_mode >> 2] | 0) + 60 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0);
     HEAP16[(HEAP32[$st$addr >> 2] | 0) + 14192 >> 1] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 84 >> 2];
    } while (0);
    do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002) {
     $add1719 = (_ec_tell_13($enc) | 0) + 17 | 0;
     if (($add1719 + (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001 & 1) * 20 | 0) | 0) > ((HEAP32[$max_data_bytes >> 2] | 0) - 1 << 3 | 0)) {
      label = 372;
      break;
     }
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001) _ec_enc_bit_logp($enc, HEAP32[$redundancy >> 2] | 0, 12);
     if (!(HEAP32[$redundancy >> 2] | 0)) break;
     _ec_enc_bit_logp($enc, HEAP32[$celt_to_silk >> 2] | 0, 1);
     $cmp1738 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001;
     $sub1741 = (HEAP32[$max_data_bytes >> 2] | 0) - 1 | 0;
     $call1742 = _ec_tell_13($enc) | 0;
     if ($cmp1738) HEAP32[$max_redundancy >> 2] = $sub1741 - ($call1742 + 8 + 3 + 7 >> 3); else HEAP32[$max_redundancy >> 2] = $sub1741 - ($call1742 + 7 >> 3);
     HEAP32[$redundancy_bytes >> 2] = (HEAP32[$max_redundancy >> 2] | 0) < (HEAP32[$redundancy_bytes >> 2] | 0) ? HEAP32[$max_redundancy >> 2] | 0 : HEAP32[$redundancy_bytes >> 2] | 0;
     if (257 < ((2 > (HEAP32[$redundancy_bytes >> 2] | 0) ? 2 : HEAP32[$redundancy_bytes >> 2] | 0) | 0)) $cond1778 = 257; else $cond1778 = 2 > (HEAP32[$redundancy_bytes >> 2] | 0) ? 2 : HEAP32[$redundancy_bytes >> 2] | 0;
     HEAP32[$redundancy_bytes >> 2] = $cond1778;
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1001) break;
     _ec_enc_uint($enc, (HEAP32[$redundancy_bytes >> 2] | 0) - 2 | 0, 256);
    } else label = 372; while (0);
    if ((label | 0) == 372) HEAP32[$redundancy >> 2] = 0;
    if (!(HEAP32[$redundancy >> 2] | 0)) {
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14244 >> 2] = 0;
     HEAP32[$redundancy_bytes >> 2] = 0;
    }
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1002) HEAP32[$start_band >> 2] = 17;
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1e3) {
     HEAP32[$ret >> 2] = (_ec_tell_13($enc) | 0) + 7 >> 3;
     _ec_enc_done($enc);
     HEAP32[$nb_compr_bytes >> 2] = HEAP32[$ret >> 2];
    } else {
     HEAP32[$nb_compr_bytes >> 2] = (HEAP32[$max_data_bytes >> 2] | 0) - 1 - (HEAP32[$redundancy_bytes >> 2] | 0);
     _ec_enc_shrink($enc, HEAP32[$nb_compr_bytes >> 2] | 0);
    }
    if (HEAP32[$redundancy >> 2] | 0) label = 382; else if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1e3) label = 382;
    if ((label | 0) == 382) {
     $1159 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer66 >> 2] = $analysis_info + ((($analysis_info - $analysis_info | 0) / 64 | 0) << 6);
     _opus_custom_encoder_ctl($1159, 10022, $vararg_buffer66) | 0;
    }
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001) {
     HEAP32[$info >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 92 >> 2];
     HEAP32[$info + 4 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 96 >> 2];
     $1166 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer69 >> 2] = $info + ((($info - $info | 0) / 8 | 0) << 3);
     _opus_custom_encoder_ctl($1166, 10028, $vararg_buffer69) | 0;
    } else {
     $1167 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer72 >> 2] = 0;
     _opus_custom_encoder_ctl($1167, 10028, $vararg_buffer72) | 0;
    }
    do if ((HEAP32[$redundancy >> 2] | 0) != 0 & (HEAP32[$celt_to_silk >> 2] | 0) != 0) {
     $1170 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer75 >> 2] = 0;
     _opus_custom_encoder_ctl($1170, 10010, $vararg_buffer75) | 0;
     $1171 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer78 >> 2] = 0;
     _opus_custom_encoder_ctl($1171, 4006, $vararg_buffer78) | 0;
     $1172 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer81 >> 2] = -1;
     _opus_custom_encoder_ctl($1172, 4002, $vararg_buffer81) | 0;
     HEAP32[$err >> 2] = _celt_encode_with_ec(HEAP32[$celt_enc >> 2] | 0, $vla, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 200 | 0, (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$nb_compr_bytes >> 2] | 0) | 0, HEAP32[$redundancy_bytes >> 2] | 0, 0) | 0;
     if ((HEAP32[$err >> 2] | 0) < 0) {
      HEAP32[$retval >> 2] = -3;
      HEAP32[$cleanup$dest$slot >> 2] = 1;
      break L404;
     } else {
      $1180 = HEAP32[$celt_enc >> 2] | 0;
      HEAP32[$vararg_buffer84 >> 2] = $redundant_rng + ((($redundant_rng - $redundant_rng | 0) / 4 | 0) << 2);
      _opus_custom_encoder_ctl($1180, 4031, $vararg_buffer84) | 0;
      _opus_custom_encoder_ctl(HEAP32[$celt_enc >> 2] | 0, 4028, $vararg_buffer87) | 0;
      break;
     }
    } while (0);
    $1182 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer89 >> 2] = HEAP32[$start_band >> 2];
    _opus_custom_encoder_ctl($1182, 10010, $vararg_buffer89) | 0;
    do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1e3) {
     do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0)) {
      if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14224 >> 2] | 0) <= 0) break;
      _opus_custom_encoder_ctl(HEAP32[$celt_enc >> 2] | 0, 4028, $vararg_buffer92) | 0;
      _celt_encode_with_ec(HEAP32[$celt_enc >> 2] | 0, $vla1509, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 400 | 0, $dummy1877, 2, 0) | 0;
      $1196 = HEAP32[$celt_enc >> 2] | 0;
      HEAP32[$vararg_buffer94 >> 2] = 0;
      _opus_custom_encoder_ctl($1196, 10002, $vararg_buffer94) | 0;
     } while (0);
     $call1885 = _ec_tell_13($enc) | 0;
     if (($call1885 | 0) > (HEAP32[$nb_compr_bytes >> 2] << 3 | 0)) break;
     do if ((HEAP32[$redundancy >> 2] | 0) != 0 & (HEAP32[$celt_to_silk >> 2] | 0) != 0) {
      if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1001) break;
      if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0)) break;
      $1204 = HEAP32[$celt_enc >> 2] | 0;
      HEAP32[$vararg_buffer97 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 28 >> 2] | 0);
      _opus_custom_encoder_ctl($1204, 4002, $vararg_buffer97) | 0;
     } while (0);
     $1209 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer100 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2];
     _opus_custom_encoder_ctl($1209, 4006, $vararg_buffer100) | 0;
     HEAP32[$ret >> 2] = _celt_encode_with_ec(HEAP32[$celt_enc >> 2] | 0, $vla, HEAP32[$frame_size$addr >> 2] | 0, 0, HEAP32[$nb_compr_bytes >> 2] | 0, $enc) | 0;
     if ((HEAP32[$ret >> 2] | 0) < 0) {
      HEAP32[$retval >> 2] = -3;
      HEAP32[$cleanup$dest$slot >> 2] = 1;
      break L404;
     }
     if (!((HEAP32[$redundancy >> 2] | 0) != 0 & (HEAP32[$celt_to_silk >> 2] | 0) != 0)) break;
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1001) break;
     if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0)) break;
     _memmove((HEAP32[$data$addr >> 2] | 0) + (HEAP32[$ret >> 2] | 0) | 0, (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$nb_compr_bytes >> 2] | 0) | 0, (HEAP32[$redundancy_bytes >> 2] | 0) + 0 | 0) | 0;
     HEAP32[$nb_compr_bytes >> 2] = (HEAP32[$nb_compr_bytes >> 2] | 0) + (HEAP32[$redundancy_bytes >> 2] | 0);
    } while (0);
    do if (!((HEAP32[$redundancy >> 2] | 0) == 0 | (HEAP32[$celt_to_silk >> 2] | 0) != 0)) {
     HEAP32[$N2 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 200 | 0;
     HEAP32[$N4 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 400 | 0;
     _opus_custom_encoder_ctl(HEAP32[$celt_enc >> 2] | 0, 4028, $vararg_buffer103) | 0;
     $1240 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer105 >> 2] = 0;
     _opus_custom_encoder_ctl($1240, 10010, $vararg_buffer105) | 0;
     $1241 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer108 >> 2] = 0;
     _opus_custom_encoder_ctl($1241, 10002, $vararg_buffer108) | 0;
     $1242 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer111 >> 2] = 0;
     _opus_custom_encoder_ctl($1242, 4006, $vararg_buffer111) | 0;
     $1243 = HEAP32[$celt_enc >> 2] | 0;
     HEAP32[$vararg_buffer114 >> 2] = -1;
     _opus_custom_encoder_ctl($1243, 4002, $vararg_buffer114) | 0;
     if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1001) {
      HEAP32[$nb_compr_bytes >> 2] = HEAP32[$ret >> 2];
      _ec_enc_shrink($enc, HEAP32[$nb_compr_bytes >> 2] | 0);
     }
     $add$ptr1972 = $vla + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$N2 >> 2] | 0) - (HEAP32[$N4 >> 2] | 0) | 0) | 0) << 2) | 0;
     _celt_encode_with_ec(HEAP32[$celt_enc >> 2] | 0, $add$ptr1972, HEAP32[$N4 >> 2] | 0, $dummy1953, 2, 0) | 0;
     $add$ptr1978 = $vla + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$N2 >> 2] | 0) | 0) | 0) << 2) | 0;
     HEAP32[$err1952 >> 2] = _celt_encode_with_ec(HEAP32[$celt_enc >> 2] | 0, $add$ptr1978, HEAP32[$N2 >> 2] | 0, (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$nb_compr_bytes >> 2] | 0) | 0, HEAP32[$redundancy_bytes >> 2] | 0, 0) | 0;
     if ((HEAP32[$err1952 >> 2] | 0) < 0) {
      HEAP32[$retval >> 2] = -3;
      HEAP32[$cleanup$dest$slot >> 2] = 1;
      break L404;
     } else {
      $1265 = HEAP32[$celt_enc >> 2] | 0;
      HEAP32[$vararg_buffer117 >> 2] = $redundant_rng + ((($redundant_rng - $redundant_rng | 0) / 4 | 0) << 2);
      _opus_custom_encoder_ctl($1265, 4031, $vararg_buffer117) | 0;
      break;
     }
    } while (0);
    HEAP32[$data$addr >> 2] = (HEAP32[$data$addr >> 2] | 0) + -1;
    $call1996 = _gen_toc(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0, HEAP32[$curr_bandwidth >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) | 0;
    HEAP8[HEAP32[$data$addr >> 2] >> 0] = $call1996;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18132 >> 2] = HEAP32[$enc + 28 >> 2] ^ HEAP32[$redundant_rng >> 2];
    $1280 = HEAP32[$st$addr >> 2] | 0;
    if (HEAP32[$to_celt >> 2] | 0) {
     $$sink27 = 1002;
     $$sink28 = $1280;
    } else {
     $$sink27 = HEAP32[$1280 + 14220 >> 2] | 0;
     $$sink28 = HEAP32[$st$addr >> 2] | 0;
    }
    HEAP32[$$sink28 + 14224 >> 2] = $$sink27;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14228 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2];
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14232 >> 2] = HEAP32[$frame_size$addr >> 2];
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14248 >> 2] = 0;
    do if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 184 >> 2] | 0) {
     if (!((HEAP32[$analysis_info >> 2] | 0) != 0 | (HEAP32[$is_silence >> 2] | 0) != 0)) break;
     if (!(_decide_dtx_mode(+HEAPF32[$analysis_info + 36 >> 2], (HEAP32[$st$addr >> 2] | 0) + 18120 | 0, +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 18124 >> 2], HEAP32[$pcm$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[$is_silence >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] | 0) | 0)) break;
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18132 >> 2] = 0;
     $call2029 = _gen_toc(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0, HEAP32[$curr_bandwidth >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) | 0;
     HEAP8[HEAP32[$data$addr >> 2] >> 0] = $call2029;
     HEAP32[$retval >> 2] = 1;
     HEAP32[$cleanup$dest$slot >> 2] = 1;
     break L404;
    } while (0);
    $call2033 = _ec_tell_13($enc) | 0;
    L533 : do if (($call2033 | 0) > ((HEAP32[$max_data_bytes >> 2] | 0) - 1 << 3 | 0)) if ((HEAP32[$max_data_bytes >> 2] | 0) < 2) {
     HEAP32[$retval >> 2] = -2;
     HEAP32[$cleanup$dest$slot >> 2] = 1;
     break L404;
    } else {
     HEAP8[(HEAP32[$data$addr >> 2] | 0) + 1 >> 0] = 0;
     HEAP32[$ret >> 2] = 1;
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18132 >> 2] = 0;
     break;
    } else {
     if (!(((HEAP32[$redundancy >> 2] | 0 ? 1 : (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) != 1e3) ^ 1) & (HEAP32[$ret >> 2] | 0) > 2)) break;
     do {
      if (HEAPU8[(HEAP32[$data$addr >> 2] | 0) + (HEAP32[$ret >> 2] | 0) >> 0] | 0) break L533;
      HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + -1;
     } while ((HEAP32[$ret >> 2] | 0) > 2);
    } while (0);
    HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + (1 + (HEAP32[$redundancy_bytes >> 2] | 0));
    do if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0)) if (_opus_packet_pad(HEAP32[$data$addr >> 2] | 0, HEAP32[$ret >> 2] | 0, HEAP32[$max_data_bytes >> 2] | 0) | 0) {
     HEAP32[$retval >> 2] = -3;
     HEAP32[$cleanup$dest$slot >> 2] = 1;
     break L404;
    } else {
     HEAP32[$ret >> 2] = HEAP32[$max_data_bytes >> 2];
     break;
    } while (0);
    HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
    HEAP32[$cleanup$dest$slot >> 2] = 1;
   } while (0);
   _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
   $1336 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $1336 | 0;
  } while (0);
  do if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] | 0) == 1e3) {
   if ((HEAP32[$frame_size$addr >> 2] | 0) == ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] << 1 | 0) / 25 | 0 | 0)) {
    HEAP32[$enc_frame_size >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 25 | 0;
    break;
   }
   $541 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0;
   if ((HEAP32[$frame_size$addr >> 2] | 0) == (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) * 3 | 0) / 25 | 0 | 0)) {
    HEAP32[$enc_frame_size >> 2] = ($541 * 3 | 0) / 50 | 0;
    break;
   } else {
    HEAP32[$enc_frame_size >> 2] = ($541 | 0) / 50 | 0;
    break;
   }
  } else HEAP32[$enc_frame_size >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 50 | 0; while (0);
  HEAP32[$nb_frames >> 2] = (HEAP32[$frame_size$addr >> 2] | 0) / (HEAP32[$enc_frame_size >> 2] | 0) | 0;
  if ((HEAP32[$analysis_read_pos_bak >> 2] | 0) != -1) {
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 188 + 7448 >> 2] = HEAP32[$analysis_read_pos_bak >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 188 + 7452 >> 2] = HEAP32[$analysis_read_subframe_bak >> 2];
  }
  HEAP32[$ret >> 2] = _encode_multiframe_packet(HEAP32[$st$addr >> 2] | 0, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$nb_frames >> 2] | 0, HEAP32[$enc_frame_size >> 2] | 0, HEAP32[$data$addr >> 2] | 0, HEAP32[$out_data_bytes$addr >> 2] | 0, HEAP32[$to_celt >> 2] | 0, HEAP32[$lsb_depth$addr >> 2] | 0, HEAP32[$float_api$addr >> 2] | 0) | 0;
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $1336 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $1336 | 0;
 } while (0);
 HEAP32[$tocmode >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2];
 if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0)) $cond174 = 1101; else $cond174 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] | 0;
 HEAP32[$bw >> 2] = $cond174;
 HEAP32[$packet_code >> 2] = 0;
 HEAP32[$num_multiframes >> 2] = 0;
 if (!(HEAP32[$tocmode >> 2] | 0)) HEAP32[$tocmode >> 2] = 1e3;
 if ((HEAP32[$frame_rate >> 2] | 0) > 100) HEAP32[$tocmode >> 2] = 1002;
 if ((HEAP32[$frame_rate >> 2] | 0) == 25 & (HEAP32[$tocmode >> 2] | 0) != 1e3) {
  HEAP32[$frame_rate >> 2] = 50;
  HEAP32[$packet_code >> 2] = 1;
 }
 do if ((HEAP32[$frame_rate >> 2] | 0) <= 16) {
  if ((HEAP32[$out_data_bytes$addr >> 2] | 0) != 1) if (!((HEAP32[$tocmode >> 2] | 0) == 1e3 & (HEAP32[$frame_rate >> 2] | 0) != 10)) {
   HEAP32[$num_multiframes >> 2] = 50 / (HEAP32[$frame_rate >> 2] | 0) | 0;
   HEAP32[$frame_rate >> 2] = 50;
   HEAP32[$packet_code >> 2] = 3;
   break;
  }
  HEAP32[$tocmode >> 2] = 1e3;
  HEAP32[$packet_code >> 2] = (HEAP32[$frame_rate >> 2] | 0) <= 12 & 1;
  HEAP32[$frame_rate >> 2] = (HEAP32[$frame_rate >> 2] | 0) == 12 ? 25 : 16;
 } while (0);
 do if ((HEAP32[$tocmode >> 2] | 0) == 1e3 & (HEAP32[$bw >> 2] | 0) > 1103) HEAP32[$bw >> 2] = 1103; else {
  if ((HEAP32[$tocmode >> 2] | 0) == 1002 & (HEAP32[$bw >> 2] | 0) == 1102) {
   HEAP32[$bw >> 2] = 1101;
   break;
  }
  if ((HEAP32[$tocmode >> 2] | 0) == 1001 & (HEAP32[$bw >> 2] | 0) <= 1104) HEAP32[$bw >> 2] = 1104;
 } while (0);
 $call234 = _gen_toc(HEAP32[$tocmode >> 2] | 0, HEAP32[$frame_rate >> 2] | 0, HEAP32[$bw >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] | 0) | 0;
 HEAP8[HEAP32[$data$addr >> 2] >> 0] = $call234;
 $170 = HEAP32[$data$addr >> 2] | 0;
 HEAP8[$170 >> 0] = HEAPU8[$170 >> 0] | HEAP32[$packet_code >> 2];
 HEAP32[$ret >> 2] = (HEAP32[$packet_code >> 2] | 0) <= 1 ? 1 : 2;
 HEAP32[$max_data_bytes >> 2] = (HEAP32[$max_data_bytes >> 2] | 0) > (HEAP32[$ret >> 2] | 0) ? HEAP32[$max_data_bytes >> 2] | 0 : HEAP32[$ret >> 2] | 0;
 if ((HEAP32[$packet_code >> 2] | 0) == 3) HEAP8[(HEAP32[$data$addr >> 2] | 0) + 1 >> 0] = HEAP32[$num_multiframes >> 2];
 do if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0)) {
  HEAP32[$ret >> 2] = _opus_packet_pad(HEAP32[$data$addr >> 2] | 0, HEAP32[$ret >> 2] | 0, HEAP32[$max_data_bytes >> 2] | 0) | 0;
  if (!(HEAP32[$ret >> 2] | 0)) {
   HEAP32[$ret >> 2] = HEAP32[$max_data_bytes >> 2];
   break;
  } else {
   HEAP32[$ret >> 2] = -3;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
 $1336 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $1336 | 0;
}

function _celt_encode_with_ec($st, $pcm, $frame_size, $compressed, $nbCompressedBytes, $enc) {
 $st = $st | 0;
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $compressed = $compressed | 0;
 $nbCompressedBytes = $nbCompressedBytes | 0;
 $enc = $enc | 0;
 var $$sink24 = 0, $$sink25 = 0, $$sink30 = 0, $1014 = 0, $1059 = 0, $1104 = 0, $1105 = 0, $1106 = 0, $1107 = 0, $1237 = 0, $178 = 0.0, $226 = 0, $261 = 0, $313 = 0, $332 = 0, $492 = 0.0, $632 = 0, $702 = 0.0, $773 = 0, $794 = 0, $805 = 0, $890 = 0, $891 = 0, $C = 0, $CC = 0, $LM = 0, $M = 0, $N = 0, $_enc = 0, $add$ptr309 = 0, $add408 = 0, $add649$sink = 0, $add789 = 0, $add828 = 0, $add970 = 0, $adjust = 0, $alloc_trim = 0, $allow_weak_transients = 0, $alpha = 0, $anti_collapse_on = 0, $anti_collapse_rsv = 0, $arrayidx = 0, $arrayidx1605$sink = 0, $arrayidx817 = 0, $arrayidx954 = 0, $balance = 0, $base_target = 0, $bits = 0, $boost = 0, $c = 0, $call1023 = 0, $call1128 = 0, $call263 = 0.0, $cleanup$dest$slot = 0, $codedBands = 0, $compressed$addr = 0, $cond1040 = 0, $cond1077 = 0, $cond1137 = 0, $cond1151 = 0, $cond1188 = 0, $cond1209 = 0, $cond1286 = 0, $cond130 = 0, $cond1425 = 0, $cond1448 = 0, $cond1466 = 0, $cond1513 = 0.0, $cond1531 = 0.0, $cond167 = 0, $cond196 = 0, $cond222 = 0, $cond254 = 0.0, $cond272 = 0.0, $cond295 = 0, $cond476 = 0.0, $cond485 = 0.0, $cond507 = 0, $cond529 = 0.0, $cond549 = 0.0, $cond612 = 0.0, $cond696 = 0.0, $cond715 = 0.0, $cond731 = 0.0, $cond746 = 0.0, $cond773 = 0.0, $cond872 = 0, $cond92 = 0, $consec_transient1655 = 0, $count = 0, $count_dynalloc = 0, $delta = 0, $den = 0, $diff = 0, $dual_stereo = 0, $dynalloc_logp = 0, $dynalloc_loop_logp = 0, $eBands = 0, $effEnd = 0, $effectiveBytes = 0, $enable_tf_analysis = 0, $enabled = 0, $enc$addr = 0, $end = 0, $energyError = 0, $equiv_rate = 0, $flag = 0, $follow = 0, $frame_avg = 0, $frame_size$addr = 0, $gain1 = 0, $hybrid = 0, $i = 0, $inc1539 = 0, $inc1647 = 0, $inc315 = 0, $inc961 = 0, $isTransient = 0, $j = 0, $lambda = 0, $lin = 0, $lm_diff = 0, $mask = 0, $mask_avg = 0, $mask_end = 0, $maxDepth = 0, $max_allowed = 0, $midband = 0, $min_allowed = 0, $min_bandwidth = 0, $mode = 0, $mul1056 = 0, $mul1329 = 0, $mul1492 = 0, $mul1577 = 0, $mul1585 = 0, $mul1618 = 0, $mul1621 = 0, $mul1624 = 0, $mul1634 = 0, $mul1637 = 0, $mul1640 = 0, $mul237 = 0, $mul239 = 0, $mul249 = 0, $mul256 = 0, $mul260 = 0, $mul49 = 0, $mul517 = 0, $mul524 = 0, $mul534 = 0, $mul541 = 0, $mul588 = 0, $mul590 = 0, $mul781 = 0, $mul951 = 0.0, $nbAvailableBytes = 0, $nbCompressedBytes$addr = 0, $nbEBands = 0, $nbFilledBytes = 0, $nbits_total = 0, $need_clip = 0, $octave = 0, $offset = 0, $oldBandE = 0, $oldLogE = 0, $oldLogE2 = 0, $overlap = 0, $pcm$addr = 0, $pf_on = 0, $pitch_change = 0, $pitch_index = 0, $prefilter_mem = 0, $prefilter_tapset = 0, $qg = 0, $quanta = 0, $retval = 0, $sample_max = 0, $saved_stack = 0, $secondMdct = 0, $shl1371 = 0, $shortBlocks = 0, $signalBandwidth = 0, $silence = 0, $spec_avg775 = 0, $st$addr = 0, $start = 0, $sub1494 = 0, $sub300 = 0, $surround_masking = 0, $surround_trim = 0, $target = 0, $tell = 0, $tell0_frac = 0, $temporal_vbr = 0, $tf_chan = 0, $tf_estimate = 0, $tf_select = 0, $tmp = 0, $tot_boost = 0, $total_bits = 0, $total_boost = 0, $transient_got_disabled = 0, $unmask = 0, $vbr_bound = 0, $vbr_count1310 = 0, $vbr_drift1336 = 0, $vbr_rate = 0, $vbr_reservoir1322 = 0, $vla = 0, $vla1043 = 0, $vla1367 = 0, $vla1368 = 0, $vla1369 = 0, $vla1472 = 0, $vla1472$alloca_mul = 0, $vla418 = 0, $vla418$alloca_mul = 0, $vla420 = 0, $vla420$alloca_mul = 0, $vla422 = 0, $vla422$alloca_mul = 0, $vla431 = 0, $vla431$alloca_mul = 0, $vla492 = 0, $vla492$alloca_mul = 0, $vla834 = 0, $vla834$alloca_mul = 0, $vla851 = 0, $vla852 = 0, $vla853 = 0, $vla860 = 0, $vla929 = 0, $vla929$alloca_mul = 0, $weak_transient = 0, $width = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 480 | 0;
 $retval = sp + 464 | 0;
 $st$addr = sp + 460 | 0;
 $pcm$addr = sp + 456 | 0;
 $frame_size$addr = sp + 452 | 0;
 $compressed$addr = sp + 448 | 0;
 $nbCompressedBytes$addr = sp + 444 | 0;
 $enc$addr = sp + 440 | 0;
 $i = sp + 436 | 0;
 $c = sp + 432 | 0;
 $N = sp + 428 | 0;
 $bits = sp + 424 | 0;
 $_enc = sp + 376 | 0;
 $prefilter_mem = sp + 368 | 0;
 $oldBandE = sp + 364 | 0;
 $oldLogE = sp + 360 | 0;
 $oldLogE2 = sp + 356 | 0;
 $energyError = sp + 352 | 0;
 $shortBlocks = sp + 348 | 0;
 $isTransient = sp + 344 | 0;
 $CC = sp + 340 | 0;
 $C = sp + 336 | 0;
 $LM = sp + 332 | 0;
 $M = sp + 328 | 0;
 $tf_select = sp + 324 | 0;
 $nbFilledBytes = sp + 320 | 0;
 $nbAvailableBytes = sp + 316 | 0;
 $start = sp + 312 | 0;
 $end = sp + 308 | 0;
 $effEnd = sp + 304 | 0;
 $codedBands = sp + 300 | 0;
 $alloc_trim = sp + 296 | 0;
 $pitch_index = sp + 292 | 0;
 $gain1 = sp + 288 | 0;
 $dual_stereo = sp + 284 | 0;
 $effectiveBytes = sp + 280 | 0;
 $dynalloc_logp = sp + 276 | 0;
 $vbr_rate = sp + 272 | 0;
 $total_bits = sp + 268 | 0;
 $total_boost = sp + 264 | 0;
 $balance = sp + 260 | 0;
 $tell = sp + 256 | 0;
 $tell0_frac = sp + 252 | 0;
 $prefilter_tapset = sp + 248 | 0;
 $pf_on = sp + 244 | 0;
 $anti_collapse_rsv = sp + 240 | 0;
 $anti_collapse_on = sp + 236 | 0;
 $silence = sp + 232 | 0;
 $tf_chan = sp + 228 | 0;
 $tf_estimate = sp + 224 | 0;
 $pitch_change = sp + 220 | 0;
 $tot_boost = sp + 216 | 0;
 $sample_max = sp + 212 | 0;
 $maxDepth = sp + 208 | 0;
 $mode = sp + 204 | 0;
 $nbEBands = sp + 200 | 0;
 $overlap = sp + 196 | 0;
 $eBands = sp + 192 | 0;
 $secondMdct = sp + 188 | 0;
 $signalBandwidth = sp + 184 | 0;
 $transient_got_disabled = sp + 180 | 0;
 $surround_masking = sp + 176 | 0;
 $temporal_vbr = sp + 172 | 0;
 $surround_trim = sp + 168 | 0;
 $equiv_rate = sp + 164 | 0;
 $hybrid = sp + 160 | 0;
 $weak_transient = sp + 156 | 0;
 $enable_tf_analysis = sp + 152 | 0;
 $den = sp + 148 | 0;
 $tmp = sp + 144 | 0;
 $vbr_bound = sp + 140 | 0;
 $max_allowed = sp + 136 | 0;
 $saved_stack = sp + 132 | 0;
 $need_clip = sp + 128 | 0;
 $enabled = sp + 124 | 0;
 $qg = sp + 120 | 0;
 $octave = sp + 116 | 0;
 $allow_weak_transients = sp + 112 | 0;
 $mask_end = sp + 108 | 0;
 $midband = sp + 104 | 0;
 $count_dynalloc = sp + 100 | 0;
 $mask_avg = sp + 96 | 0;
 $diff = sp + 92 | 0;
 $count = sp + 88 | 0;
 $mask = sp + 84 | 0;
 $lin = sp + 80 | 0;
 $unmask = sp + 76 | 0;
 $follow = sp + 72 | 0;
 $frame_avg = sp + 68 | 0;
 $offset = sp + 64 | 0;
 $lambda = sp + 60 | 0;
 $width = sp + 56 | 0;
 $quanta = sp + 52 | 0;
 $dynalloc_loop_logp = sp + 48 | 0;
 $boost = sp + 44 | 0;
 $j = sp + 40 | 0;
 $flag = sp + 36 | 0;
 $alpha = sp + 32 | 0;
 $delta = sp + 28 | 0;
 $target = sp + 24 | 0;
 $base_target = sp + 20 | 0;
 $min_allowed = sp + 16 | 0;
 $lm_diff = sp + 12 | 0;
 $adjust = sp + 8 | 0;
 $min_bandwidth = sp + 4 | 0;
 $cleanup$dest$slot = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$compressed$addr >> 2] = $compressed;
 HEAP32[$nbCompressedBytes$addr >> 2] = $nbCompressedBytes;
 HEAP32[$enc$addr >> 2] = $enc;
 HEAP32[$shortBlocks >> 2] = 0;
 HEAP32[$isTransient >> 2] = 0;
 HEAP32[$CC >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2];
 HEAP32[$C >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2];
 HEAP32[$pitch_index >> 2] = 15;
 HEAPF32[$gain1 >> 2] = 0.0;
 HEAP32[$dual_stereo >> 2] = 0;
 HEAP32[$prefilter_tapset >> 2] = 0;
 HEAP32[$anti_collapse_on >> 2] = 0;
 HEAP32[$silence >> 2] = 0;
 HEAP32[$tf_chan >> 2] = 0;
 HEAP32[$pitch_change >> 2] = 0;
 HEAP32[$transient_got_disabled >> 2] = 0;
 HEAPF32[$surround_masking >> 2] = 0.0;
 HEAPF32[$temporal_vbr >> 2] = 0.0;
 HEAPF32[$surround_trim >> 2] = 0.0;
 HEAP32[$weak_transient >> 2] = 0;
 HEAP32[$mode >> 2] = HEAP32[HEAP32[$st$addr >> 2] >> 2];
 HEAP32[$nbEBands >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 8 >> 2];
 HEAP32[$overlap >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 4 >> 2];
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 32 >> 2];
 HEAP32[$start >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$end >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2];
 HEAP32[$hybrid >> 2] = (HEAP32[$start >> 2] | 0) != 0 & 1;
 HEAPF32[$tf_estimate >> 2] = 0.0;
 if ((HEAP32[$nbCompressedBytes$addr >> 2] | 0) < 2 | (HEAP32[$pcm$addr >> 2] | 0) == 0) {
  HEAP32[$retval >> 2] = -1;
  $1237 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $1237 | 0;
 }
 HEAP32[$frame_size$addr >> 2] = Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] | 0) | 0;
 HEAP32[$LM >> 2] = 0;
 while (1) {
  if ((HEAP32[$LM >> 2] | 0) > (HEAP32[(HEAP32[$mode >> 2] | 0) + 36 >> 2] | 0)) break;
  if ((HEAP32[(HEAP32[$mode >> 2] | 0) + 44 >> 2] << HEAP32[$LM >> 2] | 0) == (HEAP32[$frame_size$addr >> 2] | 0)) break;
  HEAP32[$LM >> 2] = (HEAP32[$LM >> 2] | 0) + 1;
 }
 if ((HEAP32[$LM >> 2] | 0) > (HEAP32[(HEAP32[$mode >> 2] | 0) + 36 >> 2] | 0)) {
  HEAP32[$retval >> 2] = -1;
  $1237 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $1237 | 0;
 }
 HEAP32[$M >> 2] = 1 << HEAP32[$LM >> 2];
 HEAP32[$N >> 2] = Math_imul(HEAP32[$M >> 2] | 0, HEAP32[(HEAP32[$mode >> 2] | 0) + 44 >> 2] | 0) | 0;
 HEAP32[$prefilter_mem >> 2] = (HEAP32[$st$addr >> 2] | 0) + 244 + ((Math_imul(HEAP32[$CC >> 2] | 0, HEAP32[$overlap >> 2] | 0) | 0) << 2);
 HEAP32[$oldBandE >> 2] = (HEAP32[$st$addr >> 2] | 0) + 244 + ((Math_imul(HEAP32[$CC >> 2] | 0, (HEAP32[$overlap >> 2] | 0) + 1024 | 0) | 0) << 2);
 HEAP32[$oldLogE >> 2] = (HEAP32[$oldBandE >> 2] | 0) + ((Math_imul(HEAP32[$CC >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2);
 HEAP32[$oldLogE2 >> 2] = (HEAP32[$oldLogE >> 2] | 0) + ((Math_imul(HEAP32[$CC >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2);
 HEAP32[$energyError >> 2] = (HEAP32[$oldLogE2 >> 2] | 0) + ((Math_imul(HEAP32[$CC >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2);
 if (!(HEAP32[$enc$addr >> 2] | 0)) {
  HEAP32[$tell >> 2] = 1;
  HEAP32[$tell0_frac >> 2] = 1;
  HEAP32[$nbFilledBytes >> 2] = 0;
 } else {
  HEAP32[$tell0_frac >> 2] = _ec_tell_frac(HEAP32[$enc$addr >> 2] | 0) | 0;
  HEAP32[$tell >> 2] = _ec_tell_54(HEAP32[$enc$addr >> 2] | 0) | 0;
  HEAP32[$nbFilledBytes >> 2] = (HEAP32[$tell >> 2] | 0) + 4 >> 3;
 }
 HEAP32[$nbCompressedBytes$addr >> 2] = (HEAP32[$nbCompressedBytes$addr >> 2] | 0) < 1275 ? HEAP32[$nbCompressedBytes$addr >> 2] | 0 : 1275;
 HEAP32[$nbAvailableBytes >> 2] = (HEAP32[$nbCompressedBytes$addr >> 2] | 0) - (HEAP32[$nbFilledBytes >> 2] | 0);
 if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] | 0) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0) != -1) {
  HEAP32[$den >> 2] = HEAP32[HEAP32[$mode >> 2] >> 2] >> 3;
  $mul49 = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0;
  HEAP32[$vbr_rate >> 2] = ($mul49 + (HEAP32[$den >> 2] >> 1) | 0) / (HEAP32[$den >> 2] | 0) | 0;
  HEAP32[$effectiveBytes >> 2] = HEAP32[$vbr_rate >> 2] >> 6;
 } else label = 15; else label = 15;
 if ((label | 0) == 15) {
  HEAP32[$vbr_rate >> 2] = 0;
  HEAP32[$tmp >> 2] = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0;
  if ((HEAP32[$tell >> 2] | 0) > 1) HEAP32[$tmp >> 2] = (HEAP32[$tmp >> 2] | 0) + (HEAP32[$tell >> 2] | 0);
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0) != -1) {
   if ((HEAP32[$nbCompressedBytes$addr >> 2] | 0) < ((((HEAP32[$tmp >> 2] | 0) + (HEAP32[HEAP32[$mode >> 2] >> 2] << 2) | 0) / (HEAP32[HEAP32[$mode >> 2] >> 2] << 3 | 0) | 0) - (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] | 0) != 0 ^ 1 ^ 1) & 1) | 0)) $cond92 = HEAP32[$nbCompressedBytes$addr >> 2] | 0; else $cond92 = (((HEAP32[$tmp >> 2] | 0) + (HEAP32[HEAP32[$mode >> 2] >> 2] << 2) | 0) / (HEAP32[HEAP32[$mode >> 2] >> 2] << 3 | 0) | 0) - (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] | 0) != 0 ^ 1 ^ 1) & 1) | 0;
   do if (2 > ($cond92 | 0)) $cond130 = 2; else if ((HEAP32[$nbCompressedBytes$addr >> 2] | 0) < ((((HEAP32[$tmp >> 2] | 0) + (HEAP32[HEAP32[$mode >> 2] >> 2] << 2) | 0) / (HEAP32[HEAP32[$mode >> 2] >> 2] << 3 | 0) | 0) - (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] | 0) != 0 ^ 1 ^ 1) & 1) | 0)) {
    $cond130 = HEAP32[$nbCompressedBytes$addr >> 2] | 0;
    break;
   } else {
    $cond130 = (((HEAP32[$tmp >> 2] | 0) + (HEAP32[HEAP32[$mode >> 2] >> 2] << 2) | 0) / (HEAP32[HEAP32[$mode >> 2] >> 2] << 3 | 0) | 0) - (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] | 0) != 0 ^ 1 ^ 1) & 1) | 0;
    break;
   } while (0);
   HEAP32[$nbCompressedBytes$addr >> 2] = $cond130;
  }
  HEAP32[$effectiveBytes >> 2] = (HEAP32[$nbCompressedBytes$addr >> 2] | 0) - (HEAP32[$nbFilledBytes >> 2] | 0);
 }
 HEAP32[$equiv_rate >> 2] = ((HEAP32[$nbCompressedBytes$addr >> 2] << 3) * 50 >> 3 - (HEAP32[$LM >> 2] | 0)) - (Math_imul(((HEAP32[$C >> 2] | 0) * 40 | 0) + 20 | 0, (400 >> HEAP32[$LM >> 2]) - 50 | 0) | 0);
 if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0) != -1) {
  if ((HEAP32[$equiv_rate >> 2] | 0) < ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0) - (Math_imul(((HEAP32[$C >> 2] | 0) * 40 | 0) + 20 | 0, (400 >> HEAP32[$LM >> 2]) - 50 | 0) | 0) | 0)) $cond167 = HEAP32[$equiv_rate >> 2] | 0; else $cond167 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0) - (Math_imul(((HEAP32[$C >> 2] | 0) * 40 | 0) + 20 | 0, (400 >> HEAP32[$LM >> 2]) - 50 | 0) | 0) | 0;
  HEAP32[$equiv_rate >> 2] = $cond167;
 }
 if (!(HEAP32[$enc$addr >> 2] | 0)) {
  _ec_enc_init($_enc, HEAP32[$compressed$addr >> 2] | 0, HEAP32[$nbCompressedBytes$addr >> 2] | 0);
  HEAP32[$enc$addr >> 2] = $_enc;
 }
 if ((HEAP32[$vbr_rate >> 2] | 0) > 0) if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] | 0) {
  HEAP32[$vbr_bound >> 2] = HEAP32[$vbr_rate >> 2];
  if ((((HEAP32[$tell >> 2] | 0) == 1 ? 2 : 0) | 0) > ((HEAP32[$vbr_rate >> 2] | 0) + (HEAP32[$vbr_bound >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 208 >> 2] | 0) >> 6 | 0)) $cond196 = (HEAP32[$tell >> 2] | 0) == 1 ? 2 : 0; else $cond196 = (HEAP32[$vbr_rate >> 2] | 0) + (HEAP32[$vbr_bound >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 208 >> 2] | 0) >> 6;
  do if (($cond196 | 0) < (HEAP32[$nbAvailableBytes >> 2] | 0)) if ((((HEAP32[$tell >> 2] | 0) == 1 ? 2 : 0) | 0) > ((HEAP32[$vbr_rate >> 2] | 0) + (HEAP32[$vbr_bound >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 208 >> 2] | 0) >> 6 | 0)) {
   $cond222 = (HEAP32[$tell >> 2] | 0) == 1 ? 2 : 0;
   break;
  } else {
   $cond222 = (HEAP32[$vbr_rate >> 2] | 0) + (HEAP32[$vbr_bound >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 208 >> 2] | 0) >> 6;
   break;
  } else $cond222 = HEAP32[$nbAvailableBytes >> 2] | 0; while (0);
  HEAP32[$max_allowed >> 2] = $cond222;
  if ((HEAP32[$max_allowed >> 2] | 0) < (HEAP32[$nbAvailableBytes >> 2] | 0)) {
   HEAP32[$nbCompressedBytes$addr >> 2] = (HEAP32[$nbFilledBytes >> 2] | 0) + (HEAP32[$max_allowed >> 2] | 0);
   HEAP32[$nbAvailableBytes >> 2] = HEAP32[$max_allowed >> 2];
   _ec_enc_shrink(HEAP32[$enc$addr >> 2] | 0, HEAP32[$nbCompressedBytes$addr >> 2] | 0);
  }
 }
 HEAP32[$total_bits >> 2] = HEAP32[$nbCompressedBytes$addr >> 2] << 3;
 HEAP32[$effEnd >> 2] = HEAP32[$end >> 2];
 if ((HEAP32[$effEnd >> 2] | 0) > (HEAP32[(HEAP32[$mode >> 2] | 0) + 12 >> 2] | 0)) HEAP32[$effEnd >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 12 >> 2];
 $mul237 = Math_imul(HEAP32[$CC >> 2] | 0, (HEAP32[$N >> 2] | 0) + (HEAP32[$overlap >> 2] | 0) | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($mul237 << 2) | 0) + 15 & -16) | 0;
 $178 = +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 224 >> 2];
 $mul239 = Math_imul(HEAP32[$C >> 2] | 0, (HEAP32[$N >> 2] | 0) - (HEAP32[$overlap >> 2] | 0) | 0) | 0;
 if ($178 > +_celt_maxabs16_55(HEAP32[$pcm$addr >> 2] | 0, ($mul239 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] | 0) | 0)) $cond254 = +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 224 >> 2]; else {
  $mul249 = Math_imul(HEAP32[$C >> 2] | 0, (HEAP32[$N >> 2] | 0) - (HEAP32[$overlap >> 2] | 0) | 0) | 0;
  $cond254 = +_celt_maxabs16_55(HEAP32[$pcm$addr >> 2] | 0, ($mul249 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] | 0) | 0);
 }
 HEAPF32[$sample_max >> 2] = $cond254;
 $mul256 = Math_imul(HEAP32[$C >> 2] | 0, (HEAP32[$N >> 2] | 0) - (HEAP32[$overlap >> 2] | 0) | 0) | 0;
 $mul260 = Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$overlap >> 2] | 0) | 0;
 $call263 = +_celt_maxabs16_55((HEAP32[$pcm$addr >> 2] | 0) + ((($mul256 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] | 0) | 0) << 2) | 0, ($mul260 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] | 0) | 0);
 HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 224 >> 2] = $call263;
 if (+HEAPF32[$sample_max >> 2] > +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 224 >> 2]) $cond272 = +HEAPF32[$sample_max >> 2]; else $cond272 = +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 224 >> 2];
 HEAPF32[$sample_max >> 2] = $cond272;
 HEAP32[$silence >> 2] = +HEAPF32[$sample_max >> 2] <= 1.0 / +(1 << HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0) & 1;
 if ((HEAP32[$tell >> 2] | 0) == 1) _ec_enc_bit_logp(HEAP32[$enc$addr >> 2] | 0, HEAP32[$silence >> 2] | 0, 15); else HEAP32[$silence >> 2] = 0;
 if (HEAP32[$silence >> 2] | 0) {
  if ((HEAP32[$vbr_rate >> 2] | 0) > 0) {
   $cond295 = (HEAP32[$nbCompressedBytes$addr >> 2] | 0) < ((HEAP32[$nbFilledBytes >> 2] | 0) + 2 | 0) ? HEAP32[$nbCompressedBytes$addr >> 2] | 0 : (HEAP32[$nbFilledBytes >> 2] | 0) + 2 | 0;
   HEAP32[$nbCompressedBytes$addr >> 2] = $cond295;
   HEAP32[$effectiveBytes >> 2] = $cond295;
   HEAP32[$total_bits >> 2] = HEAP32[$nbCompressedBytes$addr >> 2] << 3;
   HEAP32[$nbAvailableBytes >> 2] = 2;
   _ec_enc_shrink(HEAP32[$enc$addr >> 2] | 0, HEAP32[$nbCompressedBytes$addr >> 2] | 0);
  }
  HEAP32[$tell >> 2] = HEAP32[$nbCompressedBytes$addr >> 2] << 3;
  $226 = HEAP32[$tell >> 2] | 0;
  $sub300 = $226 - (_ec_tell_54(HEAP32[$enc$addr >> 2] | 0) | 0) | 0;
  $nbits_total = (HEAP32[$enc$addr >> 2] | 0) + 20 | 0;
  HEAP32[$nbits_total >> 2] = (HEAP32[$nbits_total >> 2] | 0) + $sub300;
 }
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$need_clip >> 2] = 0;
  HEAP32[$need_clip >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0 ? +HEAPF32[$sample_max >> 2] > 65536.0 : 0) & 1;
  $add$ptr309 = $vla + ((Math_imul(HEAP32[$c >> 2] | 0, (HEAP32[$N >> 2] | 0) + (HEAP32[$overlap >> 2] | 0) | 0) | 0) << 2) | 0;
  _celt_preemphasis((HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2) | 0, $add$ptr309 + (HEAP32[$overlap >> 2] << 2) | 0, HEAP32[$N >> 2] | 0, HEAP32[$CC >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] | 0, (HEAP32[$mode >> 2] | 0) + 16 | 0, (HEAP32[$st$addr >> 2] | 0) + 192 + (HEAP32[$c >> 2] << 2) | 0, HEAP32[$need_clip >> 2] | 0);
  $inc315 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc315;
 } while (($inc315 | 0) < (HEAP32[$CC >> 2] | 0));
 if ((HEAP32[$nbAvailableBytes >> 2] | 0) > 3 ? (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) != 0 : 0) if ((HEAP32[$hybrid >> 2] | 0) != 0 | (HEAP32[$silence >> 2] | 0) != 0) $261 = 0; else label = 66; else if ((HEAP32[$hybrid >> 2] | 0 ? 1 : (HEAP32[$nbAvailableBytes >> 2] | 0) <= ((HEAP32[$C >> 2] | 0) * 12 | 0)) | (HEAP32[$silence >> 2] | 0) != 0) $261 = 0; else label = 66;
 if ((label | 0) == 66) if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 20 >> 2] | 0) $261 = 0; else $261 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0) >= 5;
 HEAP32[$enabled >> 2] = $261 & 1;
 HEAP32[$prefilter_tapset >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 100 >> 2];
 HEAP32[$pf_on >> 2] = _run_prefilter(HEAP32[$st$addr >> 2] | 0, $vla, HEAP32[$prefilter_mem >> 2] | 0, HEAP32[$CC >> 2] | 0, HEAP32[$N >> 2] | 0, HEAP32[$prefilter_tapset >> 2] | 0, $pitch_index, $gain1, $qg, HEAP32[$enabled >> 2] | 0, HEAP32[$nbAvailableBytes >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 120 | 0) | 0;
 if (+HEAPF32[$gain1 >> 2] > .4000000059604645) label = 70; else if (+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] > .4000000059604645) label = 70;
 do if ((label | 0) == 70) {
  if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] | 0) if (!(+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 120 + 4 >> 2] > .3)) break;
  if (!(+(HEAP32[$pitch_index >> 2] | 0) > +(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] | 0) * 1.26)) if (!(+(HEAP32[$pitch_index >> 2] | 0) < +(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] | 0) * .79)) break;
  HEAP32[$pitch_change >> 2] = 1;
 } while (0);
 if (!(HEAP32[$pf_on >> 2] | 0)) {
  if (!(HEAP32[$hybrid >> 2] | 0)) if (((HEAP32[$tell >> 2] | 0) + 16 | 0) <= (HEAP32[$total_bits >> 2] | 0)) _ec_enc_bit_logp(HEAP32[$enc$addr >> 2] | 0, 0, 1);
 } else {
  _ec_enc_bit_logp(HEAP32[$enc$addr >> 2] | 0, 1, 1);
  HEAP32[$pitch_index >> 2] = (HEAP32[$pitch_index >> 2] | 0) + 1;
  HEAP32[$octave >> 2] = 32 - (Math_clz32(HEAP32[$pitch_index >> 2] | 0) | 0) - 5;
  _ec_enc_uint(HEAP32[$enc$addr >> 2] | 0, HEAP32[$octave >> 2] | 0, 6);
  _ec_enc_bits(HEAP32[$enc$addr >> 2] | 0, (HEAP32[$pitch_index >> 2] | 0) - (16 << HEAP32[$octave >> 2]) | 0, 4 + (HEAP32[$octave >> 2] | 0) | 0);
  HEAP32[$pitch_index >> 2] = (HEAP32[$pitch_index >> 2] | 0) - 1;
  _ec_enc_bits(HEAP32[$enc$addr >> 2] | 0, HEAP32[$qg >> 2] | 0, 3);
  _ec_enc_icdf(HEAP32[$enc$addr >> 2] | 0, HEAP32[$prefilter_tapset >> 2] | 0, 30342, 2);
 }
 HEAP32[$isTransient >> 2] = 0;
 HEAP32[$shortBlocks >> 2] = 0;
 if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0) >= 1) if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0)) {
  if ((HEAP32[$hybrid >> 2] | 0) != 0 & (HEAP32[$effectiveBytes >> 2] | 0) < 15) $313 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 184 >> 2] | 0) != 2; else $313 = 0;
  HEAP32[$allow_weak_transients >> 2] = $313 & 1;
  HEAP32[$isTransient >> 2] = _transient_analysis($vla, (HEAP32[$N >> 2] | 0) + (HEAP32[$overlap >> 2] | 0) | 0, HEAP32[$CC >> 2] | 0, $tf_estimate, $tf_chan, HEAP32[$allow_weak_transients >> 2] | 0, $weak_transient) | 0;
 }
 if ((HEAP32[$LM >> 2] | 0) > 0) {
  $add408 = (_ec_tell_54(HEAP32[$enc$addr >> 2] | 0) | 0) + 3 | 0;
  if (($add408 | 0) <= (HEAP32[$total_bits >> 2] | 0)) {
   if (HEAP32[$isTransient >> 2] | 0) HEAP32[$shortBlocks >> 2] = HEAP32[$M >> 2];
  } else label = 89;
 } else label = 89;
 if ((label | 0) == 89) {
  HEAP32[$isTransient >> 2] = 0;
  HEAP32[$transient_got_disabled >> 2] = 1;
 }
 $vla418$alloca_mul = (Math_imul(HEAP32[$CC >> 2] | 0, HEAP32[$N >> 2] | 0) | 0) << 2;
 $vla418 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla418$alloca_mul | 0) + 15 & -16) | 0;
 $vla420$alloca_mul = (Math_imul(HEAP32[$nbEBands >> 2] | 0, HEAP32[$CC >> 2] | 0) | 0) << 2;
 $vla420 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla420$alloca_mul | 0) + 15 & -16) | 0;
 $vla422$alloca_mul = (Math_imul(HEAP32[$nbEBands >> 2] | 0, HEAP32[$CC >> 2] | 0) | 0) << 2;
 $vla422 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla422$alloca_mul | 0) + 15 & -16) | 0;
 if (HEAP32[$shortBlocks >> 2] | 0) $332 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0) >= 8; else $332 = 0;
 HEAP32[$secondMdct >> 2] = $332 & 1;
 $vla431$alloca_mul = (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2;
 $vla431 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla431$alloca_mul | 0) + 15 & -16) | 0;
 L131 : do if (HEAP32[$secondMdct >> 2] | 0) {
  _compute_mdcts(HEAP32[$mode >> 2] | 0, 0, $vla, $vla418, HEAP32[$C >> 2] | 0, HEAP32[$CC >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
  _compute_band_energies(HEAP32[$mode >> 2] | 0, $vla418, $vla420, HEAP32[$effEnd >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
  _amp2Log2(HEAP32[$mode >> 2] | 0, HEAP32[$effEnd >> 2] | 0, HEAP32[$end >> 2] | 0, $vla420, $vla431, HEAP32[$C >> 2] | 0);
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0)) break L131;
   $arrayidx = $vla431 + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[$arrayidx >> 2] = +HEAPF32[$arrayidx >> 2] + +(HEAP32[$LM >> 2] | 0) * .5;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 _compute_mdcts(HEAP32[$mode >> 2] | 0, HEAP32[$shortBlocks >> 2] | 0, $vla, $vla418, HEAP32[$C >> 2] | 0, HEAP32[$CC >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
 if ((HEAP32[$CC >> 2] | 0) == 2 & (HEAP32[$C >> 2] | 0) == 1) HEAP32[$tf_chan >> 2] = 0;
 _compute_band_energies(HEAP32[$mode >> 2] | 0, $vla418, $vla420, HEAP32[$effEnd >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
 L140 : do if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) {
  HEAP32[$i >> 2] = 2;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break L140;
   if (+HEAPF32[$vla420 + (HEAP32[$i >> 2] << 2) >> 2] < +HEAPF32[$vla420 >> 2] * 9.999999747378752e-05) $cond476 = +HEAPF32[$vla420 + (HEAP32[$i >> 2] << 2) >> 2]; else $cond476 = +HEAPF32[$vla420 >> 2] * 9.999999747378752e-05;
   HEAPF32[$vla420 + (HEAP32[$i >> 2] << 2) >> 2] = $cond476;
   if (+HEAPF32[$vla420 + (HEAP32[$i >> 2] << 2) >> 2] > 1.0000000036274937e-15) $cond485 = +HEAPF32[$vla420 + (HEAP32[$i >> 2] << 2) >> 2]; else $cond485 = 1.0000000036274937e-15;
   HEAPF32[$vla420 + (HEAP32[$i >> 2] << 2) >> 2] = $cond485;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 _amp2Log2(HEAP32[$mode >> 2] | 0, HEAP32[$effEnd >> 2] | 0, HEAP32[$end >> 2] | 0, $vla420, $vla422, HEAP32[$C >> 2] | 0);
 $vla492$alloca_mul = (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2;
 $vla492 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla492$alloca_mul | 0) + 15 & -16) | 0;
 _memset($vla492 | 0, 0, HEAP32[$end >> 2] << 2 | 0) | 0;
 do if (!(HEAP32[$hybrid >> 2] | 0)) {
  if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] | 0)) break;
  if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) break;
  HEAPF32[$mask_avg >> 2] = 0.0;
  HEAPF32[$diff >> 2] = 0.0;
  HEAP32[$count >> 2] = 0;
  if (2 > (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0)) $cond507 = 2; else $cond507 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0;
  HEAP32[$mask_end >> 2] = $cond507;
  HEAP32[$c >> 2] = 0;
  while (1) {
   if ((HEAP32[$c >> 2] | 0) >= (HEAP32[$C >> 2] | 0)) break;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$mask_end >> 2] | 0)) break;
    $mul517 = Math_imul(HEAP32[$nbEBands >> 2] | 0, HEAP32[$c >> 2] | 0) | 0;
    if (+HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] | 0) + ($mul517 + (HEAP32[$i >> 2] | 0) << 2) >> 2] < .25) {
     $mul524 = Math_imul(HEAP32[$nbEBands >> 2] | 0, HEAP32[$c >> 2] | 0) | 0;
     $cond529 = +HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] | 0) + ($mul524 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
    } else $cond529 = .25;
    do if ($cond529 > -2.0) {
     $mul534 = Math_imul(HEAP32[$nbEBands >> 2] | 0, HEAP32[$c >> 2] | 0) | 0;
     if (!(+HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] | 0) + ($mul534 + (HEAP32[$i >> 2] | 0) << 2) >> 2] < .25)) {
      $cond549 = .25;
      break;
     }
     $mul541 = Math_imul(HEAP32[$nbEBands >> 2] | 0, HEAP32[$c >> 2] | 0) | 0;
     $cond549 = +HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] | 0) + ($mul541 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
    } else $cond549 = -2.0; while (0);
    HEAPF32[$mask >> 2] = $cond549;
    if (+HEAPF32[$mask >> 2] > 0.0) HEAPF32[$mask >> 2] = +HEAPF32[$mask >> 2] * .5;
    HEAPF32[$mask_avg >> 2] = +HEAPF32[$mask_avg >> 2] + +HEAPF32[$mask >> 2] * +((HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0);
    HEAP32[$count >> 2] = (HEAP32[$count >> 2] | 0) + ((HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0));
    HEAPF32[$diff >> 2] = +HEAPF32[$diff >> 2] + +HEAPF32[$mask >> 2] * +(1 + (HEAP32[$i >> 2] << 1) - (HEAP32[$mask_end >> 2] | 0) | 0);
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP32[$c >> 2] = (HEAP32[$c >> 2] | 0) + 1;
  }
  HEAPF32[$mask_avg >> 2] = +HEAPF32[$mask_avg >> 2] / +(HEAP32[$count >> 2] | 0);
  HEAPF32[$mask_avg >> 2] = +HEAPF32[$mask_avg >> 2] + .20000000298023224;
  $mul588 = Math_imul(HEAP32[$C >> 2] | 0, (HEAP32[$mask_end >> 2] | 0) - 1 | 0) | 0;
  $mul590 = Math_imul($mul588, (HEAP32[$mask_end >> 2] | 0) + 1 | 0) | 0;
  HEAPF32[$diff >> 2] = +HEAPF32[$diff >> 2] * 6.0 / +(Math_imul($mul590, HEAP32[$mask_end >> 2] | 0) | 0);
  HEAPF32[$diff >> 2] = +HEAPF32[$diff >> 2] * .5;
  if ((+HEAPF32[$diff >> 2] < .03099999949336052 ? +HEAPF32[$diff >> 2] : .03099999949336052) > -.03099999949336052) $cond612 = +HEAPF32[$diff >> 2] < .03099999949336052 ? +HEAPF32[$diff >> 2] : .03099999949336052; else $cond612 = -.03099999949336052;
  HEAPF32[$diff >> 2] = $cond612;
  HEAP32[$midband >> 2] = 0;
  while (1) {
   if ((HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$midband >> 2] | 0) + 1 << 1) >> 1] | 0) >= ((HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$mask_end >> 2] << 1) >> 1] | 0) / 2 | 0 | 0)) break;
   HEAP32[$midband >> 2] = (HEAP32[$midband >> 2] | 0) + 1;
  }
  HEAP32[$count_dynalloc >> 2] = 0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$mask_end >> 2] | 0)) break;
   HEAPF32[$lin >> 2] = +HEAPF32[$mask_avg >> 2] + +HEAPF32[$diff >> 2] * +((HEAP32[$i >> 2] | 0) - (HEAP32[$midband >> 2] | 0) | 0);
   $492 = +HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   if ((HEAP32[$C >> 2] | 0) == 2) {
    if ($492 > +HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] | 0) + ((HEAP32[$nbEBands >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2]) $add649$sink = HEAP32[$i >> 2] | 0; else $add649$sink = (HEAP32[$nbEBands >> 2] | 0) + (HEAP32[$i >> 2] | 0) | 0;
    HEAPF32[$unmask >> 2] = +HEAPF32[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] | 0) + ($add649$sink << 2) >> 2];
   } else HEAPF32[$unmask >> 2] = $492;
   HEAPF32[$unmask >> 2] = +HEAPF32[$unmask >> 2] < 0.0 ? +HEAPF32[$unmask >> 2] : 0.0;
   HEAPF32[$unmask >> 2] = +HEAPF32[$unmask >> 2] - +HEAPF32[$lin >> 2];
   if (+HEAPF32[$unmask >> 2] > .25) {
    HEAPF32[$vla492 + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$unmask >> 2] - .25;
    HEAP32[$count_dynalloc >> 2] = (HEAP32[$count_dynalloc >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  L200 : do if ((HEAP32[$count_dynalloc >> 2] | 0) >= 3) {
   HEAPF32[$mask_avg >> 2] = +HEAPF32[$mask_avg >> 2] + .25;
   if (+HEAPF32[$mask_avg >> 2] > 0.0) {
    HEAPF32[$mask_avg >> 2] = 0.0;
    HEAPF32[$diff >> 2] = 0.0;
    _memset($vla492 | 0, 0, HEAP32[$mask_end >> 2] << 2 | 0) | 0;
    break;
   }
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$mask_end >> 2] | 0)) break L200;
    if (0.0 > +HEAPF32[$vla492 + (HEAP32[$i >> 2] << 2) >> 2] - .25) $cond696 = 0.0; else $cond696 = +HEAPF32[$vla492 + (HEAP32[$i >> 2] << 2) >> 2] - .25;
    HEAPF32[$vla492 + (HEAP32[$i >> 2] << 2) >> 2] = $cond696;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  } while (0);
  HEAPF32[$mask_avg >> 2] = +HEAPF32[$mask_avg >> 2] + .20000000298023224;
  HEAPF32[$surround_trim >> 2] = +HEAPF32[$diff >> 2] * 64.0;
  HEAPF32[$surround_masking >> 2] = +HEAPF32[$mask_avg >> 2];
 } while (0);
 if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0)) {
  HEAPF32[$follow >> 2] = -10.0;
  HEAPF32[$frame_avg >> 2] = 0.0;
  if (HEAP32[$shortBlocks >> 2] | 0) $cond715 = +(HEAP32[$LM >> 2] | 0) * .5; else $cond715 = 0.0;
  HEAPF32[$offset >> 2] = $cond715;
  HEAP32[$i >> 2] = HEAP32[$start >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
   if (+HEAPF32[$follow >> 2] - 1.0 > +HEAPF32[$vla422 + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[$offset >> 2]) $cond731 = +HEAPF32[$follow >> 2] - 1.0; else $cond731 = +HEAPF32[$vla422 + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[$offset >> 2];
   HEAPF32[$follow >> 2] = $cond731;
   if ((HEAP32[$C >> 2] | 0) == 2) {
    if (+HEAPF32[$follow >> 2] > +HEAPF32[$vla422 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$nbEBands >> 2] | 0) << 2) >> 2] - +HEAPF32[$offset >> 2]) $cond746 = +HEAPF32[$follow >> 2]; else $cond746 = +HEAPF32[$vla422 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$nbEBands >> 2] | 0) << 2) >> 2] - +HEAPF32[$offset >> 2];
    HEAPF32[$follow >> 2] = $cond746;
   }
   HEAPF32[$frame_avg >> 2] = +HEAPF32[$frame_avg >> 2] + +HEAPF32[$follow >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[$frame_avg >> 2] = +HEAPF32[$frame_avg >> 2] / +((HEAP32[$end >> 2] | 0) - (HEAP32[$start >> 2] | 0) | 0);
  HEAPF32[$temporal_vbr >> 2] = +HEAPF32[$frame_avg >> 2] - +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 240 >> 2];
  if (3.0 < (-1.5 > +HEAPF32[$temporal_vbr >> 2] ? -1.5 : +HEAPF32[$temporal_vbr >> 2])) $cond773 = 3.0; else $cond773 = -1.5 > +HEAPF32[$temporal_vbr >> 2] ? -1.5 : +HEAPF32[$temporal_vbr >> 2];
  HEAPF32[$temporal_vbr >> 2] = $cond773;
  $spec_avg775 = (HEAP32[$st$addr >> 2] | 0) + 240 | 0;
  HEAPF32[$spec_avg775 >> 2] = +HEAPF32[$spec_avg775 >> 2] + +HEAPF32[$temporal_vbr >> 2] * .019999999552965164;
 }
 if (!(HEAP32[$secondMdct >> 2] | 0)) {
  $mul781 = (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2;
  _memcpy($vla431 | 0, $vla422 | 0, $mul781 + 0 | 0) | 0;
 }
 do if ((HEAP32[$LM >> 2] | 0) > 0) {
  $add789 = (_ec_tell_54(HEAP32[$enc$addr >> 2] | 0) | 0) + 3 | 0;
  if (HEAP32[$isTransient >> 2] | 0 ? 1 : ($add789 | 0) > (HEAP32[$total_bits >> 2] | 0)) break;
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0) < 5) break;
  if (HEAP32[$hybrid >> 2] | 0 ? 1 : (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) != 0) break;
  if (!(_patch_transient_decision($vla422, HEAP32[$oldBandE >> 2] | 0, HEAP32[$nbEBands >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, HEAP32[$C >> 2] | 0) | 0)) break;
  HEAP32[$isTransient >> 2] = 1;
  HEAP32[$shortBlocks >> 2] = HEAP32[$M >> 2];
  _compute_mdcts(HEAP32[$mode >> 2] | 0, HEAP32[$shortBlocks >> 2] | 0, $vla, $vla418, HEAP32[$C >> 2] | 0, HEAP32[$CC >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
  _compute_band_energies(HEAP32[$mode >> 2] | 0, $vla418, $vla420, HEAP32[$effEnd >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
  _amp2Log2(HEAP32[$mode >> 2] | 0, HEAP32[$effEnd >> 2] | 0, HEAP32[$end >> 2] | 0, $vla420, $vla422, HEAP32[$C >> 2] | 0);
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0)) break;
   $arrayidx817 = $vla431 + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[$arrayidx817 >> 2] = +HEAPF32[$arrayidx817 >> 2] + +(HEAP32[$LM >> 2] | 0) * .5;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[$tf_estimate >> 2] = .20000000298023224;
 } while (0);
 do if ((HEAP32[$LM >> 2] | 0) > 0) {
  $add828 = (_ec_tell_54(HEAP32[$enc$addr >> 2] | 0) | 0) + 3 | 0;
  if (($add828 | 0) > (HEAP32[$total_bits >> 2] | 0)) break;
  _ec_enc_bit_logp(HEAP32[$enc$addr >> 2] | 0, HEAP32[$isTransient >> 2] | 0, 3);
 } while (0);
 $vla834$alloca_mul = (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$N >> 2] | 0) | 0) << 2;
 $vla834 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla834$alloca_mul | 0) + 15 & -16) | 0;
 _normalise_bands(HEAP32[$mode >> 2] | 0, $vla418, $vla834, $vla420, HEAP32[$effEnd >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$M >> 2] | 0);
 do if (HEAP32[$hybrid >> 2] | 0 ? 1 : (HEAP32[$effectiveBytes >> 2] | 0) < ((HEAP32[$C >> 2] | 0) * 15 | 0)) $632 = 0; else {
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0) < 2) {
   $632 = 0;
   break;
  }
  $632 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) != 0 ^ 1;
 } while (0);
 HEAP32[$enable_tf_analysis >> 2] = $632 & 1;
 $vla851 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla852 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla853 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAPF32[$maxDepth >> 2] = +_dynalloc_analysis($vla422, $vla431, HEAP32[$nbEBands >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, HEAP32[$C >> 2] | 0, $vla851, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[(HEAP32[$mode >> 2] | 0) + 56 >> 2] | 0, HEAP32[$isTransient >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] | 0, HEAP32[$eBands >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[$effectiveBytes >> 2] | 0, $tot_boost, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0, $vla492, (HEAP32[$st$addr >> 2] | 0) + 120 | 0, $vla852, $vla853);
 $vla860 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 L259 : do if (HEAP32[$enable_tf_analysis >> 2] | 0) {
  if (80 > ((20480 / (HEAP32[$effectiveBytes >> 2] | 0) | 0) + 2 | 0)) $cond872 = 80; else $cond872 = (20480 / (HEAP32[$effectiveBytes >> 2] | 0) | 0) + 2 | 0;
  HEAP32[$lambda >> 2] = $cond872;
  HEAP32[$tf_select >> 2] = _tf_analysis(HEAP32[$mode >> 2] | 0, HEAP32[$effEnd >> 2] | 0, HEAP32[$isTransient >> 2] | 0, $vla860, HEAP32[$lambda >> 2] | 0, $vla834, HEAP32[$N >> 2] | 0, HEAP32[$LM >> 2] | 0, +HEAPF32[$tf_estimate >> 2], HEAP32[$tf_chan >> 2] | 0, $vla852) | 0;
  HEAP32[$i >> 2] = HEAP32[$effEnd >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break L259;
   HEAP32[$vla860 + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$vla860 + ((HEAP32[$effEnd >> 2] | 0) - 1 << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } else {
  if ((HEAP32[$hybrid >> 2] | 0) != 0 & (HEAP32[$weak_transient >> 2] | 0) != 0) {
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
    HEAP32[$vla860 + (HEAP32[$i >> 2] << 2) >> 2] = 1;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP32[$tf_select >> 2] = 0;
   break;
  }
  do if ((HEAP32[$hybrid >> 2] | 0) != 0 & (HEAP32[$effectiveBytes >> 2] | 0) < 15) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 184 >> 2] | 0) == 2) break;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
    HEAP32[$vla860 + (HEAP32[$i >> 2] << 2) >> 2] = 0;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP32[$tf_select >> 2] = HEAP32[$isTransient >> 2];
   break L259;
  } while (0);
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
   HEAP32[$vla860 + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$isTransient >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$tf_select >> 2] = 0;
 } while (0);
 $vla929$alloca_mul = (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2;
 $vla929 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla929$alloca_mul | 0) + 15 & -16) | 0;
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = HEAP32[$start >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
   $702 = +HEAPF32[$vla422 + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) >> 2];
   if (+Math_abs(+($702 - +HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) >> 2])) < 2.0) {
    $mul951 = +HEAPF32[(HEAP32[$energyError >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) >> 2] * .25;
    $arrayidx954 = $vla422 + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) | 0;
    HEAPF32[$arrayidx954 >> 2] = +HEAPF32[$arrayidx954 >> 2] - $mul951;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc961 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc961;
 } while (($inc961 | 0) < (HEAP32[$C >> 2] | 0));
 _quant_coarse_energy(HEAP32[$mode >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, HEAP32[$effEnd >> 2] | 0, $vla422, HEAP32[$oldBandE >> 2] | 0, HEAP32[$total_bits >> 2] | 0, $vla929, HEAP32[$enc$addr >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[$nbAvailableBytes >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 84 | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0) >= 4 & 1, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0);
 _tf_encode(HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, HEAP32[$isTransient >> 2] | 0, $vla860, HEAP32[$LM >> 2] | 0, HEAP32[$tf_select >> 2] | 0, HEAP32[$enc$addr >> 2] | 0);
 $add970 = (_ec_tell_54(HEAP32[$enc$addr >> 2] | 0) | 0) + 4 | 0;
 if (($add970 | 0) <= (HEAP32[$total_bits >> 2] | 0)) {
  L300 : do if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) {
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 100 >> 2] = 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] = 2;
  } else {
   if (HEAP32[$hybrid >> 2] | 0) if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0)) {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] = 0;
    break;
   } else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] = HEAP32[$isTransient >> 2] | 0 ? 2 : 3;
    break;
   }
   do if (!(HEAP32[$shortBlocks >> 2] | 0)) {
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0) < 3) break;
    if ((HEAP32[$nbAvailableBytes >> 2] | 0) < ((HEAP32[$C >> 2] | 0) * 10 | 0)) break;
    if (HEAP32[$pf_on >> 2] | 0) $773 = (HEAP32[$shortBlocks >> 2] | 0) != 0 ^ 1; else $773 = 0;
    $call1023 = _spreading_decision(HEAP32[$mode >> 2] | 0, $vla834, (HEAP32[$st$addr >> 2] | 0) + 88 | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 96 | 0, (HEAP32[$st$addr >> 2] | 0) + 100 | 0, $773 & 1, HEAP32[$effEnd >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$M >> 2] | 0, $vla853) | 0;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] = $call1023;
    break L300;
   } while (0);
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0) == 0 ? 0 : 2;
  } while (0);
  _ec_enc_icdf(HEAP32[$enc$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] | 0, 30345, 5);
 }
 if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) {
  if (8 < ((HEAP32[$effectiveBytes >> 2] | 0) / 3 | 0 | 0)) $cond1040 = 8; else $cond1040 = (HEAP32[$effectiveBytes >> 2] | 0) / 3 | 0;
  HEAP32[$vla851 >> 2] = $cond1040;
 }
 $vla1043 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 _init_caps(HEAP32[$mode >> 2] | 0, $vla1043, HEAP32[$LM >> 2] | 0, HEAP32[$C >> 2] | 0);
 HEAP32[$dynalloc_logp >> 2] = 6;
 HEAP32[$total_bits >> 2] = HEAP32[$total_bits >> 2] << 3;
 HEAP32[$total_boost >> 2] = 0;
 HEAP32[$tell >> 2] = _ec_tell_frac(HEAP32[$enc$addr >> 2] | 0) | 0;
 HEAP32[$i >> 2] = HEAP32[$start >> 2];
 while (1) {
  $794 = HEAP32[$C >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
  $mul1056 = Math_imul($794, (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) | 0;
  HEAP32[$width >> 2] = $mul1056 << HEAP32[$LM >> 2];
  $805 = HEAP32[$width >> 2] | 0;
  if ((HEAP32[$width >> 2] << 3 | 0) < ((48 > (HEAP32[$width >> 2] | 0) ? 48 : HEAP32[$width >> 2] | 0) | 0)) $cond1077 = $805 << 3; else $cond1077 = 48 > ($805 | 0) ? 48 : HEAP32[$width >> 2] | 0;
  HEAP32[$quanta >> 2] = $cond1077;
  HEAP32[$dynalloc_loop_logp >> 2] = HEAP32[$dynalloc_logp >> 2];
  HEAP32[$boost >> 2] = 0;
  HEAP32[$j >> 2] = 0;
  while (1) {
   if (((HEAP32[$tell >> 2] | 0) + (HEAP32[$dynalloc_loop_logp >> 2] << 3) | 0) >= ((HEAP32[$total_bits >> 2] | 0) - (HEAP32[$total_boost >> 2] | 0) | 0)) break;
   if ((HEAP32[$boost >> 2] | 0) >= (HEAP32[$vla1043 + (HEAP32[$i >> 2] << 2) >> 2] | 0)) break;
   HEAP32[$flag >> 2] = (HEAP32[$j >> 2] | 0) < (HEAP32[$vla851 + (HEAP32[$i >> 2] << 2) >> 2] | 0) & 1;
   _ec_enc_bit_logp(HEAP32[$enc$addr >> 2] | 0, HEAP32[$flag >> 2] | 0, HEAP32[$dynalloc_loop_logp >> 2] | 0);
   HEAP32[$tell >> 2] = _ec_tell_frac(HEAP32[$enc$addr >> 2] | 0) | 0;
   if (!(HEAP32[$flag >> 2] | 0)) break;
   HEAP32[$boost >> 2] = (HEAP32[$boost >> 2] | 0) + (HEAP32[$quanta >> 2] | 0);
   HEAP32[$total_boost >> 2] = (HEAP32[$total_boost >> 2] | 0) + (HEAP32[$quanta >> 2] | 0);
   HEAP32[$dynalloc_loop_logp >> 2] = 1;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  if (HEAP32[$j >> 2] | 0) HEAP32[$dynalloc_logp >> 2] = 2 > ((HEAP32[$dynalloc_logp >> 2] | 0) - 1 | 0) ? 2 : (HEAP32[$dynalloc_logp >> 2] | 0) - 1 | 0;
  HEAP32[$vla851 + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$boost >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if (($794 | 0) == 2) {
  if (HEAP32[$LM >> 2] | 0) HEAP32[$dual_stereo >> 2] = _stereo_analysis(HEAP32[$mode >> 2] | 0, $vla834, HEAP32[$LM >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
  $call1128 = _hysteresis_decision(+((HEAP32[$equiv_rate >> 2] | 0) / 1e3 | 0 | 0), 2780, 2864, 21, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] | 0) | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] = $call1128;
  if ((HEAP32[$start >> 2] | 0) > (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] | 0)) $cond1137 = HEAP32[$start >> 2] | 0; else $cond1137 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] | 0;
  do if ((HEAP32[$end >> 2] | 0) < ($cond1137 | 0)) $cond1151 = HEAP32[$end >> 2] | 0; else if ((HEAP32[$start >> 2] | 0) > (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] | 0)) {
   $cond1151 = HEAP32[$start >> 2] | 0;
   break;
  } else {
   $cond1151 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] | 0;
   break;
  } while (0);
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] = $cond1151;
 }
 HEAP32[$alloc_trim >> 2] = 5;
 if (((HEAP32[$tell >> 2] | 0) + 48 | 0) <= ((HEAP32[$total_bits >> 2] | 0) - (HEAP32[$total_boost >> 2] | 0) | 0)) {
  do if ((HEAP32[$start >> 2] | 0) > 0) label = 259; else {
   if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) {
    label = 259;
    break;
   }
   HEAP32[$alloc_trim >> 2] = _alloc_trim_analysis(HEAP32[$mode >> 2] | 0, $vla834, $vla422, HEAP32[$end >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$N >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 120 | 0, (HEAP32[$st$addr >> 2] | 0) + 228 | 0, +HEAPF32[$tf_estimate >> 2], HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] | 0, +HEAPF32[$surround_trim >> 2], HEAP32[$equiv_rate >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0) | 0;
  } while (0);
  if ((label | 0) == 259) {
   HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 228 >> 2] = 0.0;
   HEAP32[$alloc_trim >> 2] = 5;
  }
  _ec_enc_icdf(HEAP32[$enc$addr >> 2] | 0, HEAP32[$alloc_trim >> 2] | 0, 30349, 7);
  HEAP32[$tell >> 2] = _ec_tell_frac(HEAP32[$enc$addr >> 2] | 0) | 0;
 }
 if ((HEAP32[$vbr_rate >> 2] | 0) > 0) {
  HEAP32[$lm_diff >> 2] = (HEAP32[(HEAP32[$mode >> 2] | 0) + 36 >> 2] | 0) - (HEAP32[$LM >> 2] | 0);
  if ((HEAP32[$nbCompressedBytes$addr >> 2] | 0) < (1275 >> 3 - (HEAP32[$LM >> 2] | 0) | 0)) $cond1188 = HEAP32[$nbCompressedBytes$addr >> 2] | 0; else $cond1188 = 1275 >> 3 - (HEAP32[$LM >> 2] | 0);
  HEAP32[$nbCompressedBytes$addr >> 2] = $cond1188;
  $890 = HEAP32[$vbr_rate >> 2] | 0;
  $891 = HEAP32[$C >> 2] | 0;
  if (HEAP32[$hybrid >> 2] | 0) {
   if (0 > ($890 - (($891 * 9 | 0) + 4 << 3) | 0)) $cond1209 = 0; else $cond1209 = (HEAP32[$vbr_rate >> 2] | 0) - (((HEAP32[$C >> 2] | 0) * 9 | 0) + 4 << 3) | 0;
   HEAP32[$base_target >> 2] = $cond1209;
  } else HEAP32[$base_target >> 2] = $890 - (($891 * 40 | 0) + 20 << 3);
  if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] | 0) HEAP32[$base_target >> 2] = (HEAP32[$base_target >> 2] | 0) + (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 216 >> 2] >> HEAP32[$lm_diff >> 2]);
  do if (HEAP32[$hybrid >> 2] | 0) {
   HEAP32[$target >> 2] = HEAP32[$base_target >> 2];
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 184 + 4 >> 2] | 0) < 100) HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) + (96 >> 3 - (HEAP32[$LM >> 2] | 0));
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 184 + 4 >> 2] | 0) > 100) HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) - (144 >> 3 - (HEAP32[$LM >> 2] | 0));
   HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) + ~~((+HEAPF32[$tf_estimate >> 2] - .25) * 400.0);
   if (!(+HEAPF32[$tf_estimate >> 2] > .699999988079071)) break;
   HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) > 400 ? HEAP32[$target >> 2] | 0 : 400;
  } else HEAP32[$target >> 2] = _compute_vbr(HEAP32[$mode >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 120 | 0, HEAP32[$base_target >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[$equiv_rate >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] | 0, +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 228 >> 2], HEAP32[$tot_boost >> 2] | 0, +HEAPF32[$tf_estimate >> 2], HEAP32[$pitch_change >> 2] | 0, +HEAPF32[$maxDepth >> 2], HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0, (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] | 0) != 0 & 1, +HEAPF32[$surround_masking >> 2], +HEAPF32[$temporal_vbr >> 2]) | 0; while (0);
  HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) + (HEAP32[$tell >> 2] | 0);
  HEAP32[$min_allowed >> 2] = ((HEAP32[$tell >> 2] | 0) + (HEAP32[$total_boost >> 2] | 0) + 64 - 1 >> 6) + 2;
  if (HEAP32[$hybrid >> 2] | 0) {
   if ((HEAP32[$min_allowed >> 2] | 0) > ((HEAP32[$tell0_frac >> 2] | 0) + 296 + (HEAP32[$total_boost >> 2] | 0) + 64 - 1 >> 6 | 0)) $cond1286 = HEAP32[$min_allowed >> 2] | 0; else $cond1286 = (HEAP32[$tell0_frac >> 2] | 0) + 296 + (HEAP32[$total_boost >> 2] | 0) + 64 - 1 >> 6;
   HEAP32[$min_allowed >> 2] = $cond1286;
  }
  HEAP32[$nbAvailableBytes >> 2] = (HEAP32[$target >> 2] | 0) + 32 >> 6;
  HEAP32[$nbAvailableBytes >> 2] = (HEAP32[$min_allowed >> 2] | 0) > (HEAP32[$nbAvailableBytes >> 2] | 0) ? HEAP32[$min_allowed >> 2] | 0 : HEAP32[$nbAvailableBytes >> 2] | 0;
  HEAP32[$nbAvailableBytes >> 2] = (HEAP32[$nbCompressedBytes$addr >> 2] | 0) < (HEAP32[$nbAvailableBytes >> 2] | 0) ? HEAP32[$nbCompressedBytes$addr >> 2] | 0 : HEAP32[$nbAvailableBytes >> 2] | 0;
  HEAP32[$delta >> 2] = (HEAP32[$target >> 2] | 0) - (HEAP32[$vbr_rate >> 2] | 0);
  HEAP32[$target >> 2] = HEAP32[$nbAvailableBytes >> 2] << 6;
  if (HEAP32[$silence >> 2] | 0) {
   HEAP32[$nbAvailableBytes >> 2] = 2;
   HEAP32[$target >> 2] = 128;
   HEAP32[$delta >> 2] = 0;
  }
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 220 >> 2] | 0) < 970) {
   $vbr_count1310 = (HEAP32[$st$addr >> 2] | 0) + 220 | 0;
   HEAP32[$vbr_count1310 >> 2] = (HEAP32[$vbr_count1310 >> 2] | 0) + 1;
   HEAPF32[$alpha >> 2] = 1.0 / +((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 220 >> 2] | 0) + 20 | 0);
  } else HEAPF32[$alpha >> 2] = 1.0000000474974513e-03;
  if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] | 0) {
   $vbr_reservoir1322 = (HEAP32[$st$addr >> 2] | 0) + 208 | 0;
   HEAP32[$vbr_reservoir1322 >> 2] = (HEAP32[$vbr_reservoir1322 >> 2] | 0) + ((HEAP32[$target >> 2] | 0) - (HEAP32[$vbr_rate >> 2] | 0));
  }
  if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] | 0) {
   $mul1329 = Math_imul(HEAP32[$delta >> 2] | 0, 1 << HEAP32[$lm_diff >> 2]) | 0;
   $vbr_drift1336 = (HEAP32[$st$addr >> 2] | 0) + 212 | 0;
   HEAP32[$vbr_drift1336 >> 2] = (HEAP32[$vbr_drift1336 >> 2] | 0) + ~~(+HEAPF32[$alpha >> 2] * +($mul1329 - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 216 >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 212 >> 2] | 0) | 0));
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 216 >> 2] = 0 - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 212 >> 2] | 0);
  }
  do if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] | 0) {
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 208 >> 2] | 0) >= 0) break;
   HEAP32[$adjust >> 2] = (0 - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 208 >> 2] | 0) | 0) / 64 | 0;
   HEAP32[$nbAvailableBytes >> 2] = (HEAP32[$nbAvailableBytes >> 2] | 0) + (HEAP32[$silence >> 2] | 0 ? 0 : HEAP32[$adjust >> 2] | 0);
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 208 >> 2] = 0;
  } while (0);
  HEAP32[$nbCompressedBytes$addr >> 2] = (HEAP32[$nbCompressedBytes$addr >> 2] | 0) < (HEAP32[$nbAvailableBytes >> 2] | 0) ? HEAP32[$nbCompressedBytes$addr >> 2] | 0 : HEAP32[$nbAvailableBytes >> 2] | 0;
  _ec_enc_shrink(HEAP32[$enc$addr >> 2] | 0, HEAP32[$nbCompressedBytes$addr >> 2] | 0);
 }
 $vla1367 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla1368 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla1369 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 $shl1371 = HEAP32[$nbCompressedBytes$addr >> 2] << 3 << 3;
 HEAP32[$bits >> 2] = $shl1371 - (_ec_tell_frac(HEAP32[$enc$addr >> 2] | 0) | 0) - 1;
 if ((HEAP32[$isTransient >> 2] | 0) != 0 & (HEAP32[$LM >> 2] | 0) >= 2) $1014 = (HEAP32[$bits >> 2] | 0) >= ((HEAP32[$LM >> 2] | 0) + 2 << 3 | 0); else $1014 = 0;
 HEAP32[$anti_collapse_rsv >> 2] = $1014 ? 8 : 0;
 HEAP32[$bits >> 2] = (HEAP32[$bits >> 2] | 0) - (HEAP32[$anti_collapse_rsv >> 2] | 0);
 HEAP32[$signalBandwidth >> 2] = (HEAP32[$end >> 2] | 0) - 1;
 if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] | 0) {
  do if ((HEAP32[$equiv_rate >> 2] | 0) < ((HEAP32[$C >> 2] | 0) * 32e3 | 0)) HEAP32[$min_bandwidth >> 2] = 13; else {
   if ((HEAP32[$equiv_rate >> 2] | 0) < ((HEAP32[$C >> 2] | 0) * 48e3 | 0)) {
    HEAP32[$min_bandwidth >> 2] = 16;
    break;
   }
   if ((HEAP32[$equiv_rate >> 2] | 0) < ((HEAP32[$C >> 2] | 0) * 6e4 | 0)) {
    HEAP32[$min_bandwidth >> 2] = 18;
    break;
   }
   if ((HEAP32[$equiv_rate >> 2] | 0) < ((HEAP32[$C >> 2] | 0) * 8e4 | 0)) {
    HEAP32[$min_bandwidth >> 2] = 19;
    break;
   } else {
    HEAP32[$min_bandwidth >> 2] = 20;
    break;
   }
  } while (0);
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 + 32 >> 2] | 0) > (HEAP32[$min_bandwidth >> 2] | 0)) $cond1425 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 + 32 >> 2] | 0; else $cond1425 = HEAP32[$min_bandwidth >> 2] | 0;
  HEAP32[$signalBandwidth >> 2] = $cond1425;
 }
 if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) HEAP32[$signalBandwidth >> 2] = 1;
 HEAP32[$codedBands >> 2] = _compute_allocation(HEAP32[$mode >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, $vla851, $vla1043, HEAP32[$alloc_trim >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 232 | 0, $dual_stereo, HEAP32[$bits >> 2] | 0, $balance, $vla1368, $vla1367, $vla1369, HEAP32[$C >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[$enc$addr >> 2] | 0, 1, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0, HEAP32[$signalBandwidth >> 2] | 0) | 0;
 if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0) {
  if (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0) - 1 | 0) > (HEAP32[$codedBands >> 2] | 0)) $cond1448 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0) - 1 | 0; else $cond1448 = HEAP32[$codedBands >> 2] | 0;
  $1059 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0;
  do if (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0) + 1 | 0) < ($cond1448 | 0)) $cond1466 = $1059 + 1 | 0; else if (($1059 - 1 | 0) > (HEAP32[$codedBands >> 2] | 0)) {
   $cond1466 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 92 >> 2] | 0) - 1 | 0;
   break;
  } else {
   $cond1466 = HEAP32[$codedBands >> 2] | 0;
   break;
  } while (0);
  $$sink24 = $cond1466;
  $$sink25 = HEAP32[$st$addr >> 2] | 0;
 } else {
  $$sink24 = HEAP32[$codedBands >> 2] | 0;
  $$sink25 = HEAP32[$st$addr >> 2] | 0;
 }
 HEAP32[$$sink25 + 92 >> 2] = $$sink24;
 _quant_fine_energy(HEAP32[$mode >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, HEAP32[$oldBandE >> 2] | 0, $vla929, $vla1367, HEAP32[$enc$addr >> 2] | 0, HEAP32[$C >> 2] | 0);
 $vla1472$alloca_mul = Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
 $vla1472 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla1472$alloca_mul | 0) + 15 & -16) | 0;
 _quant_all_bands(1, HEAP32[$mode >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, $vla834, (HEAP32[$C >> 2] | 0) == 2 ? $vla834 + (HEAP32[$N >> 2] << 2) | 0 : 0, $vla1472, $vla420, $vla1368, HEAP32[$shortBlocks >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] | 0, HEAP32[$dual_stereo >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 232 >> 2] | 0, $vla860, (HEAP32[$nbCompressedBytes$addr >> 2] << 6) - (HEAP32[$anti_collapse_rsv >> 2] | 0) | 0, HEAP32[$balance >> 2] | 0, HEAP32[$enc$addr >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[$codedBands >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 76 | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2] | 0);
 if ((HEAP32[$anti_collapse_rsv >> 2] | 0) > 0) {
  HEAP32[$anti_collapse_on >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 116 >> 2] | 0) < 2 & 1;
  _ec_enc_bits(HEAP32[$enc$addr >> 2] | 0, HEAP32[$anti_collapse_on >> 2] | 0, 1);
 }
 $1104 = HEAP32[$mode >> 2] | 0;
 $1105 = HEAP32[$start >> 2] | 0;
 $1106 = HEAP32[$end >> 2] | 0;
 $1107 = HEAP32[$oldBandE >> 2] | 0;
 $mul1492 = HEAP32[$nbCompressedBytes$addr >> 2] << 3;
 $sub1494 = $mul1492 - (_ec_tell_54(HEAP32[$enc$addr >> 2] | 0) | 0) | 0;
 _quant_energy_finalise($1104, $1105, $1106, $1107, $vla929, $vla1367, $vla1369, $sub1494, HEAP32[$enc$addr >> 2] | 0, HEAP32[$C >> 2] | 0);
 _memset(HEAP32[$energyError >> 2] | 0, 0, (Math_imul(HEAP32[$nbEBands >> 2] | 0, HEAP32[$CC >> 2] | 0) | 0) << 2 | 0) | 0;
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = HEAP32[$start >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
   if (.5 < +HEAPF32[$vla929 + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) >> 2]) $cond1513 = .5; else $cond1513 = +HEAPF32[$vla929 + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) >> 2];
   do if (-.5 > $cond1513) $cond1531 = -.5; else {
    if (.5 < +HEAPF32[$vla929 + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) >> 2]) {
     $cond1531 = .5;
     break;
    }
    $cond1531 = +HEAPF32[$vla929 + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) >> 2];
   } while (0);
   HEAPF32[(HEAP32[$energyError >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) >> 2] = $cond1531;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc1539 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc1539;
 } while (($inc1539 | 0) < (HEAP32[$C >> 2] | 0));
 L478 : do if (HEAP32[$silence >> 2] | 0) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0)) break L478;
   HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = -28.0;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] = HEAP32[$pitch_index >> 2];
 HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] = +HEAPF32[$gain1 >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] = HEAP32[$prefilter_tapset >> 2];
 if ((HEAP32[$CC >> 2] | 0) == 2 & (HEAP32[$C >> 2] | 0) == 1) _memcpy((HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$nbEBands >> 2] << 2) | 0, HEAP32[$oldBandE >> 2] | 0, (HEAP32[$nbEBands >> 2] << 2) + 0 | 0) | 0;
 L487 : do if (HEAP32[$isTransient >> 2] | 0) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$CC >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0)) break L487;
   if (+HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] < +HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $arrayidx1605$sink = (HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0; else $arrayidx1605$sink = (HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$arrayidx1605$sink >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } else {
  $mul1577 = (Math_imul(HEAP32[$CC >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2;
  _memcpy(HEAP32[$oldLogE2 >> 2] | 0, HEAP32[$oldLogE >> 2] | 0, $mul1577 + 0 | 0) | 0;
  $mul1585 = (Math_imul(HEAP32[$CC >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2;
  _memcpy(HEAP32[$oldLogE >> 2] | 0, HEAP32[$oldBandE >> 2] | 0, $mul1585 + 0 | 0) | 0;
 } while (0);
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$start >> 2] | 0)) break;
   $mul1618 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ($mul1618 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = 0.0;
   $mul1621 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldLogE2 >> 2] | 0) + ($mul1621 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = -28.0;
   $mul1624 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + ($mul1624 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = -28.0;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = HEAP32[$end >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nbEBands >> 2] | 0)) break;
   $mul1634 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ($mul1634 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = 0.0;
   $mul1637 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldLogE2 >> 2] | 0) + ($mul1637 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = -28.0;
   $mul1640 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + ($mul1640 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = -28.0;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc1647 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc1647;
 } while (($inc1647 | 0) < (HEAP32[$CC >> 2] | 0));
 $consec_transient1655 = (HEAP32[$st$addr >> 2] | 0) + 116 | 0;
 if ((HEAP32[$isTransient >> 2] | 0) != 0 | (HEAP32[$transient_got_disabled >> 2] | 0) != 0) $$sink30 = (HEAP32[$consec_transient1655 >> 2] | 0) + 1 | 0; else $$sink30 = 0;
 HEAP32[$consec_transient1655 >> 2] = $$sink30;
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2] = HEAP32[(HEAP32[$enc$addr >> 2] | 0) + 28 >> 2];
 _ec_enc_done(HEAP32[$enc$addr >> 2] | 0);
 if (_ec_get_error(HEAP32[$enc$addr >> 2] | 0) | 0) {
  HEAP32[$retval >> 2] = -3;
  HEAP32[$cleanup$dest$slot >> 2] = 1;
 } else {
  HEAP32[$retval >> 2] = HEAP32[$nbCompressedBytes$addr >> 2];
  HEAP32[$cleanup$dest$slot >> 2] = 1;
 }
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 $1237 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $1237 | 0;
}

function _malloc($bytes) {
 $bytes = $bytes | 0;
 var $$pre$phi$i$iZ2D = 0, $$pre$phi$i180Z2D = 0, $$pre$phi$i45$iZ2D = 0, $$pre$phi$iZ2D = 0, $$pre$phiZ2D = 0, $$v$0$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $102 = 0, $103 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $112 = 0, $116 = 0, $117 = 0, $119 = 0, $121 = 0, $122 = 0, $123 = 0, $126 = 0, $128 = 0, $13 = 0, $130 = 0, $133 = 0, $134 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $145 = 0, $146 = 0, $147 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $164 = 0, $165 = 0, $166 = 0, $168 = 0, $171 = 0, $173 = 0, $174 = 0, $176 = 0, $179 = 0, $18 = 0, $180 = 0, $182 = 0, $184 = 0, $185 = 0, $186 = 0, $188 = 0, $19 = 0, $191 = 0, $193 = 0, $194 = 0, $196 = 0, $197 = 0, $2 = 0, $22 = 0, $23 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $41 = 0, $42 = 0, $43 = 0, $46 = 0, $47 = 0, $48 = 0, $50 = 0, $51 = 0, $53 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $74 = 0, $75 = 0, $76 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $83 = 0, $86 = 0, $88 = 0, $89 = 0, $9 = 0, $91 = 0, $92 = 0, $94 = 0, $95 = 0, $98 = 0, $99 = 0, $F$0$i$i = 0, $F104$0 = 0, $F197$0$i = 0, $F224$0$i$i = 0, $F290$0$i = 0, $I252$0$i$i = 0, $I316$0$i = 0, $I57$0$i$i = 0, $K105$0$i$i = 0, $K305$0$i$i = 0, $K373$0$i = 0, $R$1$i = 0, $R$1$i$i = 0, $R$1$i169 = 0, $R$3$i = 0, $R$3$i$i = 0, $R$3$i172 = 0, $RP$1$i = 0, $RP$1$i$i = 0, $RP$1$i168 = 0, $T$0$i = 0, $T$0$i$i = 0, $T$0$i46$i = 0, $add$i$i = 0, $add$i183 = 0, $add$ptr$i = 0, $add$ptr$i$i$i = 0, $add$ptr$i162 = 0, $add$ptr14$i$i = 0, $add$ptr16$i$i = 0, $add$ptr166 = 0, $add$ptr17$i$i = 0, $add$ptr193 = 0, $add$ptr2$i$i = 0, $add$ptr227$i = 0, $add$ptr262$i = 0, $add$ptr4$i$i = 0, $add$ptr4$i$i$i = 0, $add$ptr4$i25$i = 0, $add$ptr4$i54$i = 0, $add$ptr7$i$i = 0, $add$ptr81$i$i = 0, $add$ptr95 = 0, $add144 = 0, $add150$i = 0, $add17$i = 0, $add17$i186 = 0, $add177$i = 0, $add215$i = 0, $add26$i$i = 0, $add268$i = 0, $add278$i$i = 0, $add346$i = 0, $add54$i = 0, $add64 = 0, $add8 = 0, $add83$i$i = 0, $add9$i = 0, $and$i145 = 0, $and104$i = 0, $and11$add51$i = 0, $and11$i = 0, $and12$i = 0, $and13$i = 0, $and145 = 0, $and17$i = 0, $and194$i = 0, $and264$i$i = 0, $and268$i$i = 0, $and273$i$i = 0, $and3$i = 0, $and331$i = 0, $and336$i = 0, $and341$i = 0, $and37$i$i = 0, $and41 = 0, $and46 = 0, $and49 = 0, $and53 = 0, $and57 = 0, $and6$i = 0, $and61 = 0, $and64$i = 0, $and69$i$i = 0, $and73$i = 0, $and73$i$i = 0, $and74 = 0, $and77$i = 0, $and78$i$i = 0, $and8$i = 0, $and80$i = 0, $and81$i = 0, $and85$i = 0, $and89$i = 0, $and9$i = 0, $arrayidx = 0, $arrayidx$i$i = 0, $arrayidx$i36$i = 0, $arrayidx103 = 0, $arrayidx103$i$i = 0, $arrayidx107$i$i = 0, $arrayidx123$i$i = 0, $arrayidx126$i$i = 0, $arrayidx151$i = 0, $arrayidx155$i = 0, $arrayidx161$i = 0, $arrayidx165$i170 = 0, $arrayidx184$i = 0, $arrayidx196$i = 0, $arrayidx223$i$i = 0, $arrayidx287$i$i = 0, $arrayidx289$i = 0, $arrayidx325$i$i = 0, $arrayidx355$i = 0, $arrayidx394$i = 0, $arrayidx61$i = 0, $arrayidx65$i = 0, $arrayidx66 = 0, $arrayidx71$i = 0, $arrayidx75$i = 0, $arrayidx91$i$i = 0, $arrayidx94$i = 0, $arrayidx96$i$i = 0, $bk = 0, $bk136$i = 0, $bk47$i = 0, $bk78 = 0, $bk82$i$i = 0, $br$2$ph$i = 0, $call131$i = 0, $call132$i = 0, $call37$i = 0, $call68$i = 0, $call83$i = 0, $child$i$i = 0, $child166$i$i = 0, $child289$i$i = 0, $child357$i = 0, $cmp102$i = 0, $cmp141$i = 0, $cmp32$i = 0, $cmp49$i = 0, $cond = 0, $cond$i$i$i = 0, $cond$i17$i = 0, $cond$i53$i = 0, $cond13$i$i = 0, $fd139$i = 0, $fd148$i$i = 0, $fd344$i$i = 0, $fd416$i = 0, $fd50$i = 0, $fd59$i$i = 0, $fd68$pre$phi$i$iZ2D = 0, $fd69 = 0, $fd85$i$i = 0, $fd9 = 0, $head$i$i = 0, $head179 = 0, $head182$i = 0, $head208$i$i = 0, $head25 = 0, $head274$i = 0, $idx$0$i = 0, $magic$i$i = 0, $nb$0 = 0, $neg$i185 = 0, $oldfirst$0$i$i = 0, $qsize$0$i$i = 0, $retval$0 = 0, $rsize$0$i = 0, $rsize$0$lcssa$i = 0, $rsize$08$i = 0, $rsize$1$i = 0, $rsize$3$i = 0, $rsize$4$lcssa$i = 0, $rsize$410$i = 0, $rst$0$i = 0, $rst$1$i = 0, $shl$i146 = 0, $shl105 = 0, $shl198$i = 0, $shl22 = 0, $shl226$i$i = 0, $shl265$i$i = 0, $shl270$i$i = 0, $shl291$i = 0, $shl294$i$i = 0, $shl333$i = 0, $shl338$i = 0, $shl362$i = 0, $shl37 = 0, $shl39$i$i = 0, $shl60$i = 0, $shl70$i$i = 0, $shl75$i$i = 0, $shl9$i = 0, $shl90 = 0, $shl95$i$i = 0, $shr = 0, $shr$i$i = 0, $shr$i141 = 0, $shr$i33$i = 0, $shr101 = 0, $shr11$i = 0, $shr15$i = 0, $shr194$i = 0, $shr214$i$i = 0, $shr253$i$i = 0, $shr283$i = 0, $shr3 = 0, $shr318$i = 0, $shr4$i = 0, $shr47 = 0, $shr51 = 0, $shr55 = 0, $shr58$i$i = 0, $shr59 = 0, $shr7$i = 0, $shr75$i = 0, $shr79$i = 0, $shr83$i = 0, $shr87$i = 0, $size$i$i = 0, $size188$i = 0, $size245$i = 0, $sizebits$0$i = 0, $sp$0$i$i = 0, $sp$0$i$i$i = 0, $sp$0108$i = 0, $sp$1107$i = 0, $ssize$2$ph$i = 0, $sub$i140 = 0, $sub$i184 = 0, $sub$ptr$sub$i = 0, $sub$ptr$sub$i$i = 0, $sub101$i = 0, $sub101$rsize$4$i = 0, $sub112$i = 0, $sub16$i$i = 0, $sub160 = 0, $sub172$i = 0, $sub18$i$i = 0, $sub190 = 0, $sub2$i = 0, $sub22$i = 0, $sub260$i = 0, $sub31$i = 0, $sub31$rsize$0$i = 0, $sub33$i = 0, $sub41$i = 0, $sub44 = 0, $sub5$i$i = 0, $sub5$i$i$i = 0, $sub5$i55$i = 0, $sub70$i = 0, $sub91 = 0, $t$0$i = 0, $t$2$i = 0, $t$4$ph$i = 0, $t$4$v$4$i = 0, $t$49$i = 0, $tbase$796$i = 0, $tsize$2657583$i = 0, $tsize$4$i = 0, $tsize$795$i = 0, $v$0$i = 0, $v$0$lcssa$i = 0, $v$09$i = 0, $v$1$i = 0, $v$3$i = 0, $v$4$lcssa$i = 0, $v$4$ph$i = 0, $v$411$i = 0, label = 0, sp = 0, $182$looptemp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $magic$i$i = sp;
 do if ($bytes >>> 0 < 245) {
  $cond = $bytes >>> 0 < 11 ? 16 : $bytes + 11 & -8;
  $shr = $cond >>> 3;
  $0 = HEAP32[8875] | 0;
  $shr3 = $0 >>> $shr;
  if ($shr3 & 3 | 0) {
   $add8 = ($shr3 & 1 ^ 1) + $shr | 0;
   $arrayidx = 35540 + ($add8 << 1 << 2) | 0;
   $1 = $arrayidx + 8 | 0;
   $2 = HEAP32[$1 >> 2] | 0;
   $fd9 = $2 + 8 | 0;
   $3 = HEAP32[$fd9 >> 2] | 0;
   do if (($3 | 0) == ($arrayidx | 0)) HEAP32[8875] = $0 & ~(1 << $add8); else {
    if ((HEAP32[8879] | 0) >>> 0 > $3 >>> 0) _abort();
    $bk = $3 + 12 | 0;
    if ((HEAP32[$bk >> 2] | 0) == ($2 | 0)) {
     HEAP32[$bk >> 2] = $arrayidx;
     HEAP32[$1 >> 2] = $3;
     break;
    } else _abort();
   } while (0);
   $shl22 = $add8 << 3;
   HEAP32[$2 + 4 >> 2] = $shl22 | 3;
   $head25 = $2 + $shl22 + 4 | 0;
   HEAP32[$head25 >> 2] = HEAP32[$head25 >> 2] | 1;
   $retval$0 = $fd9;
   STACKTOP = sp;
   return $retval$0 | 0;
  }
  $7 = HEAP32[8877] | 0;
  if ($cond >>> 0 > $7 >>> 0) {
   if ($shr3 | 0) {
    $shl37 = 2 << $shr;
    $and41 = $shr3 << $shr & ($shl37 | 0 - $shl37);
    $sub44 = ($and41 & 0 - $and41) + -1 | 0;
    $and46 = $sub44 >>> 12 & 16;
    $shr47 = $sub44 >>> $and46;
    $and49 = $shr47 >>> 5 & 8;
    $shr51 = $shr47 >>> $and49;
    $and53 = $shr51 >>> 2 & 4;
    $shr55 = $shr51 >>> $and53;
    $and57 = $shr55 >>> 1 & 2;
    $shr59 = $shr55 >>> $and57;
    $and61 = $shr59 >>> 1 & 1;
    $add64 = ($and49 | $and46 | $and53 | $and57 | $and61) + ($shr59 >>> $and61) | 0;
    $arrayidx66 = 35540 + ($add64 << 1 << 2) | 0;
    $8 = $arrayidx66 + 8 | 0;
    $9 = HEAP32[$8 >> 2] | 0;
    $fd69 = $9 + 8 | 0;
    $10 = HEAP32[$fd69 >> 2] | 0;
    do if (($10 | 0) == ($arrayidx66 | 0)) {
     $and74 = $0 & ~(1 << $add64);
     HEAP32[8875] = $and74;
     $14 = $and74;
    } else {
     if ((HEAP32[8879] | 0) >>> 0 > $10 >>> 0) _abort();
     $bk78 = $10 + 12 | 0;
     if ((HEAP32[$bk78 >> 2] | 0) == ($9 | 0)) {
      HEAP32[$bk78 >> 2] = $arrayidx66;
      HEAP32[$8 >> 2] = $10;
      $14 = $0;
      break;
     } else _abort();
    } while (0);
    $shl90 = $add64 << 3;
    $sub91 = $shl90 - $cond | 0;
    HEAP32[$9 + 4 >> 2] = $cond | 3;
    $add$ptr95 = $9 + $cond | 0;
    HEAP32[$add$ptr95 + 4 >> 2] = $sub91 | 1;
    HEAP32[$9 + $shl90 >> 2] = $sub91;
    if ($7 | 0) {
     $13 = HEAP32[8880] | 0;
     $shr101 = $7 >>> 3;
     $arrayidx103 = 35540 + ($shr101 << 1 << 2) | 0;
     $shl105 = 1 << $shr101;
     if (!($14 & $shl105)) {
      HEAP32[8875] = $14 | $shl105;
      $$pre$phiZ2D = $arrayidx103 + 8 | 0;
      $F104$0 = $arrayidx103;
     } else {
      $15 = $arrayidx103 + 8 | 0;
      $16 = HEAP32[$15 >> 2] | 0;
      if ((HEAP32[8879] | 0) >>> 0 > $16 >>> 0) _abort(); else {
       $$pre$phiZ2D = $15;
       $F104$0 = $16;
      }
     }
     HEAP32[$$pre$phiZ2D >> 2] = $13;
     HEAP32[$F104$0 + 12 >> 2] = $13;
     HEAP32[$13 + 8 >> 2] = $F104$0;
     HEAP32[$13 + 12 >> 2] = $arrayidx103;
    }
    HEAP32[8877] = $sub91;
    HEAP32[8880] = $add$ptr95;
    $retval$0 = $fd69;
    STACKTOP = sp;
    return $retval$0 | 0;
   }
   $18 = HEAP32[8876] | 0;
   if (!$18) $nb$0 = $cond; else {
    $sub2$i = ($18 & 0 - $18) + -1 | 0;
    $and3$i = $sub2$i >>> 12 & 16;
    $shr4$i = $sub2$i >>> $and3$i;
    $and6$i = $shr4$i >>> 5 & 8;
    $shr7$i = $shr4$i >>> $and6$i;
    $and9$i = $shr7$i >>> 2 & 4;
    $shr11$i = $shr7$i >>> $and9$i;
    $and13$i = $shr11$i >>> 1 & 2;
    $shr15$i = $shr11$i >>> $and13$i;
    $and17$i = $shr15$i >>> 1 & 1;
    $19 = HEAP32[35804 + (($and6$i | $and3$i | $and9$i | $and13$i | $and17$i) + ($shr15$i >>> $and17$i) << 2) >> 2] | 0;
    $sub22$i = (HEAP32[$19 + 4 >> 2] & -8) - $cond | 0;
    $22 = HEAP32[$19 + 16 + (((HEAP32[$19 + 16 >> 2] | 0) == 0 & 1) << 2) >> 2] | 0;
    if (!$22) {
     $rsize$0$lcssa$i = $sub22$i;
     $v$0$lcssa$i = $19;
    } else {
     $23 = $22;
     $rsize$08$i = $sub22$i;
     $v$09$i = $19;
     while (1) {
      $sub31$i = (HEAP32[$23 + 4 >> 2] & -8) - $cond | 0;
      $cmp32$i = $sub31$i >>> 0 < $rsize$08$i >>> 0;
      $sub31$rsize$0$i = $cmp32$i ? $sub31$i : $rsize$08$i;
      $$v$0$i = $cmp32$i ? $23 : $v$09$i;
      $23 = HEAP32[$23 + 16 + (((HEAP32[$23 + 16 >> 2] | 0) == 0 & 1) << 2) >> 2] | 0;
      if (!$23) {
       $rsize$0$lcssa$i = $sub31$rsize$0$i;
       $v$0$lcssa$i = $$v$0$i;
       break;
      } else {
       $rsize$08$i = $sub31$rsize$0$i;
       $v$09$i = $$v$0$i;
      }
     }
    }
    $27 = HEAP32[8879] | 0;
    if ($27 >>> 0 > $v$0$lcssa$i >>> 0) _abort();
    $add$ptr$i = $v$0$lcssa$i + $cond | 0;
    if ($add$ptr$i >>> 0 <= $v$0$lcssa$i >>> 0) _abort();
    $28 = HEAP32[$v$0$lcssa$i + 24 >> 2] | 0;
    $29 = HEAP32[$v$0$lcssa$i + 12 >> 2] | 0;
    do if (($29 | 0) == ($v$0$lcssa$i | 0)) {
     $arrayidx61$i = $v$0$lcssa$i + 20 | 0;
     $33 = HEAP32[$arrayidx61$i >> 2] | 0;
     if (!$33) {
      $arrayidx65$i = $v$0$lcssa$i + 16 | 0;
      $34 = HEAP32[$arrayidx65$i >> 2] | 0;
      if (!$34) {
       $R$3$i = 0;
       break;
      } else {
       $R$1$i = $34;
       $RP$1$i = $arrayidx65$i;
      }
     } else {
      $R$1$i = $33;
      $RP$1$i = $arrayidx61$i;
     }
     while (1) {
      $arrayidx71$i = $R$1$i + 20 | 0;
      $35 = HEAP32[$arrayidx71$i >> 2] | 0;
      if ($35 | 0) {
       $R$1$i = $35;
       $RP$1$i = $arrayidx71$i;
       continue;
      }
      $arrayidx75$i = $R$1$i + 16 | 0;
      $36 = HEAP32[$arrayidx75$i >> 2] | 0;
      if (!$36) break; else {
       $R$1$i = $36;
       $RP$1$i = $arrayidx75$i;
      }
     }
     if ($27 >>> 0 > $RP$1$i >>> 0) _abort(); else {
      HEAP32[$RP$1$i >> 2] = 0;
      $R$3$i = $R$1$i;
      break;
     }
    } else {
     $30 = HEAP32[$v$0$lcssa$i + 8 >> 2] | 0;
     if ($27 >>> 0 > $30 >>> 0) _abort();
     $bk47$i = $30 + 12 | 0;
     if ((HEAP32[$bk47$i >> 2] | 0) != ($v$0$lcssa$i | 0)) _abort();
     $fd50$i = $29 + 8 | 0;
     if ((HEAP32[$fd50$i >> 2] | 0) == ($v$0$lcssa$i | 0)) {
      HEAP32[$bk47$i >> 2] = $29;
      HEAP32[$fd50$i >> 2] = $30;
      $R$3$i = $29;
      break;
     } else _abort();
    } while (0);
    L73 : do if ($28 | 0) {
     $37 = HEAP32[$v$0$lcssa$i + 28 >> 2] | 0;
     $arrayidx94$i = 35804 + ($37 << 2) | 0;
     do if (($v$0$lcssa$i | 0) == (HEAP32[$arrayidx94$i >> 2] | 0)) {
      HEAP32[$arrayidx94$i >> 2] = $R$3$i;
      if (!$R$3$i) {
       HEAP32[8876] = $18 & ~(1 << $37);
       break L73;
      }
     } else if ((HEAP32[8879] | 0) >>> 0 > $28 >>> 0) _abort(); else {
      HEAP32[$28 + 16 + (((HEAP32[$28 + 16 >> 2] | 0) != ($v$0$lcssa$i | 0) & 1) << 2) >> 2] = $R$3$i;
      if (!$R$3$i) break L73; else break;
     } while (0);
     $41 = HEAP32[8879] | 0;
     if ($41 >>> 0 > $R$3$i >>> 0) _abort();
     HEAP32[$R$3$i + 24 >> 2] = $28;
     $42 = HEAP32[$v$0$lcssa$i + 16 >> 2] | 0;
     do if ($42 | 0) if ($41 >>> 0 > $42 >>> 0) _abort(); else {
      HEAP32[$R$3$i + 16 >> 2] = $42;
      HEAP32[$42 + 24 >> 2] = $R$3$i;
      break;
     } while (0);
     $43 = HEAP32[$v$0$lcssa$i + 20 >> 2] | 0;
     if ($43 | 0) if ((HEAP32[8879] | 0) >>> 0 > $43 >>> 0) _abort(); else {
      HEAP32[$R$3$i + 20 >> 2] = $43;
      HEAP32[$43 + 24 >> 2] = $R$3$i;
      break;
     }
    } while (0);
    if ($rsize$0$lcssa$i >>> 0 < 16) {
     $add177$i = $rsize$0$lcssa$i + $cond | 0;
     HEAP32[$v$0$lcssa$i + 4 >> 2] = $add177$i | 3;
     $head182$i = $v$0$lcssa$i + $add177$i + 4 | 0;
     HEAP32[$head182$i >> 2] = HEAP32[$head182$i >> 2] | 1;
    } else {
     HEAP32[$v$0$lcssa$i + 4 >> 2] = $cond | 3;
     HEAP32[$add$ptr$i + 4 >> 2] = $rsize$0$lcssa$i | 1;
     HEAP32[$add$ptr$i + $rsize$0$lcssa$i >> 2] = $rsize$0$lcssa$i;
     if ($7 | 0) {
      $46 = HEAP32[8880] | 0;
      $shr194$i = $7 >>> 3;
      $arrayidx196$i = 35540 + ($shr194$i << 1 << 2) | 0;
      $shl198$i = 1 << $shr194$i;
      if (!($0 & $shl198$i)) {
       HEAP32[8875] = $0 | $shl198$i;
       $$pre$phi$iZ2D = $arrayidx196$i + 8 | 0;
       $F197$0$i = $arrayidx196$i;
      } else {
       $47 = $arrayidx196$i + 8 | 0;
       $48 = HEAP32[$47 >> 2] | 0;
       if ((HEAP32[8879] | 0) >>> 0 > $48 >>> 0) _abort(); else {
        $$pre$phi$iZ2D = $47;
        $F197$0$i = $48;
       }
      }
      HEAP32[$$pre$phi$iZ2D >> 2] = $46;
      HEAP32[$F197$0$i + 12 >> 2] = $46;
      HEAP32[$46 + 8 >> 2] = $F197$0$i;
      HEAP32[$46 + 12 >> 2] = $arrayidx196$i;
     }
     HEAP32[8877] = $rsize$0$lcssa$i;
     HEAP32[8880] = $add$ptr$i;
    }
    $retval$0 = $v$0$lcssa$i + 8 | 0;
    STACKTOP = sp;
    return $retval$0 | 0;
   }
  } else $nb$0 = $cond;
 } else if ($bytes >>> 0 > 4294967231) $nb$0 = -1; else {
  $add144 = $bytes + 11 | 0;
  $and145 = $add144 & -8;
  $50 = HEAP32[8876] | 0;
  if (!$50) $nb$0 = $and145; else {
   $sub$i140 = 0 - $and145 | 0;
   $shr$i141 = $add144 >>> 8;
   if (!$shr$i141) $idx$0$i = 0; else if ($and145 >>> 0 > 16777215) $idx$0$i = 31; else {
    $and$i145 = ($shr$i141 + 1048320 | 0) >>> 16 & 8;
    $shl$i146 = $shr$i141 << $and$i145;
    $and8$i = ($shl$i146 + 520192 | 0) >>> 16 & 4;
    $shl9$i = $shl$i146 << $and8$i;
    $and12$i = ($shl9$i + 245760 | 0) >>> 16 & 2;
    $add17$i = 14 - ($and8$i | $and$i145 | $and12$i) + ($shl9$i << $and12$i >>> 15) | 0;
    $idx$0$i = $and145 >>> ($add17$i + 7 | 0) & 1 | $add17$i << 1;
   }
   $51 = HEAP32[35804 + ($idx$0$i << 2) >> 2] | 0;
   L117 : do if (!$51) {
    $rsize$3$i = $sub$i140;
    $t$2$i = 0;
    $v$3$i = 0;
    label = 81;
   } else {
    $rsize$0$i = $sub$i140;
    $rst$0$i = 0;
    $sizebits$0$i = $and145 << (($idx$0$i | 0) == 31 ? 0 : 25 - ($idx$0$i >>> 1) | 0);
    $t$0$i = $51;
    $v$0$i = 0;
    while (1) {
     $sub33$i = (HEAP32[$t$0$i + 4 >> 2] & -8) - $and145 | 0;
     if ($sub33$i >>> 0 < $rsize$0$i >>> 0) if (!$sub33$i) {
      $rsize$410$i = 0;
      $t$49$i = $t$0$i;
      $v$411$i = $t$0$i;
      label = 85;
      break L117;
     } else {
      $rsize$1$i = $sub33$i;
      $v$1$i = $t$0$i;
     } else {
      $rsize$1$i = $rsize$0$i;
      $v$1$i = $v$0$i;
     }
     $53 = HEAP32[$t$0$i + 20 >> 2] | 0;
     $t$0$i = HEAP32[$t$0$i + 16 + ($sizebits$0$i >>> 31 << 2) >> 2] | 0;
     $rst$1$i = ($53 | 0) == 0 | ($53 | 0) == ($t$0$i | 0) ? $rst$0$i : $53;
     $cmp49$i = ($t$0$i | 0) == 0;
     if ($cmp49$i) {
      $rsize$3$i = $rsize$1$i;
      $t$2$i = $rst$1$i;
      $v$3$i = $v$1$i;
      label = 81;
      break;
     } else {
      $rsize$0$i = $rsize$1$i;
      $rst$0$i = $rst$1$i;
      $sizebits$0$i = $sizebits$0$i << (($cmp49$i ^ 1) & 1);
      $v$0$i = $v$1$i;
     }
    }
   } while (0);
   if ((label | 0) == 81) {
    if (($t$2$i | 0) == 0 & ($v$3$i | 0) == 0) {
     $shl60$i = 2 << $idx$0$i;
     $and64$i = $50 & ($shl60$i | 0 - $shl60$i);
     if (!$and64$i) {
      $nb$0 = $and145;
      break;
     }
     $sub70$i = ($and64$i & 0 - $and64$i) + -1 | 0;
     $and73$i = $sub70$i >>> 12 & 16;
     $shr75$i = $sub70$i >>> $and73$i;
     $and77$i = $shr75$i >>> 5 & 8;
     $shr79$i = $shr75$i >>> $and77$i;
     $and81$i = $shr79$i >>> 2 & 4;
     $shr83$i = $shr79$i >>> $and81$i;
     $and85$i = $shr83$i >>> 1 & 2;
     $shr87$i = $shr83$i >>> $and85$i;
     $and89$i = $shr87$i >>> 1 & 1;
     $t$4$ph$i = HEAP32[35804 + (($and77$i | $and73$i | $and81$i | $and85$i | $and89$i) + ($shr87$i >>> $and89$i) << 2) >> 2] | 0;
     $v$4$ph$i = 0;
    } else {
     $t$4$ph$i = $t$2$i;
     $v$4$ph$i = $v$3$i;
    }
    if (!$t$4$ph$i) {
     $rsize$4$lcssa$i = $rsize$3$i;
     $v$4$lcssa$i = $v$4$ph$i;
    } else {
     $rsize$410$i = $rsize$3$i;
     $t$49$i = $t$4$ph$i;
     $v$411$i = $v$4$ph$i;
     label = 85;
    }
   }
   if ((label | 0) == 85) while (1) {
    label = 0;
    $sub101$i = (HEAP32[$t$49$i + 4 >> 2] & -8) - $and145 | 0;
    $cmp102$i = $sub101$i >>> 0 < $rsize$410$i >>> 0;
    $sub101$rsize$4$i = $cmp102$i ? $sub101$i : $rsize$410$i;
    $t$4$v$4$i = $cmp102$i ? $t$49$i : $v$411$i;
    $t$49$i = HEAP32[$t$49$i + 16 + (((HEAP32[$t$49$i + 16 >> 2] | 0) == 0 & 1) << 2) >> 2] | 0;
    if (!$t$49$i) {
     $rsize$4$lcssa$i = $sub101$rsize$4$i;
     $v$4$lcssa$i = $t$4$v$4$i;
     break;
    } else {
     $rsize$410$i = $sub101$rsize$4$i;
     $v$411$i = $t$4$v$4$i;
     label = 85;
    }
   }
   if (!$v$4$lcssa$i) $nb$0 = $and145; else if ($rsize$4$lcssa$i >>> 0 < ((HEAP32[8877] | 0) - $and145 | 0) >>> 0) {
    $60 = HEAP32[8879] | 0;
    if ($60 >>> 0 > $v$4$lcssa$i >>> 0) _abort();
    $add$ptr$i162 = $v$4$lcssa$i + $and145 | 0;
    if ($add$ptr$i162 >>> 0 <= $v$4$lcssa$i >>> 0) _abort();
    $61 = HEAP32[$v$4$lcssa$i + 24 >> 2] | 0;
    $62 = HEAP32[$v$4$lcssa$i + 12 >> 2] | 0;
    do if (($62 | 0) == ($v$4$lcssa$i | 0)) {
     $arrayidx151$i = $v$4$lcssa$i + 20 | 0;
     $66 = HEAP32[$arrayidx151$i >> 2] | 0;
     if (!$66) {
      $arrayidx155$i = $v$4$lcssa$i + 16 | 0;
      $67 = HEAP32[$arrayidx155$i >> 2] | 0;
      if (!$67) {
       $R$3$i172 = 0;
       break;
      } else {
       $R$1$i169 = $67;
       $RP$1$i168 = $arrayidx155$i;
      }
     } else {
      $R$1$i169 = $66;
      $RP$1$i168 = $arrayidx151$i;
     }
     while (1) {
      $arrayidx161$i = $R$1$i169 + 20 | 0;
      $68 = HEAP32[$arrayidx161$i >> 2] | 0;
      if ($68 | 0) {
       $R$1$i169 = $68;
       $RP$1$i168 = $arrayidx161$i;
       continue;
      }
      $arrayidx165$i170 = $R$1$i169 + 16 | 0;
      $69 = HEAP32[$arrayidx165$i170 >> 2] | 0;
      if (!$69) break; else {
       $R$1$i169 = $69;
       $RP$1$i168 = $arrayidx165$i170;
      }
     }
     if ($60 >>> 0 > $RP$1$i168 >>> 0) _abort(); else {
      HEAP32[$RP$1$i168 >> 2] = 0;
      $R$3$i172 = $R$1$i169;
      break;
     }
    } else {
     $63 = HEAP32[$v$4$lcssa$i + 8 >> 2] | 0;
     if ($60 >>> 0 > $63 >>> 0) _abort();
     $bk136$i = $63 + 12 | 0;
     if ((HEAP32[$bk136$i >> 2] | 0) != ($v$4$lcssa$i | 0)) _abort();
     $fd139$i = $62 + 8 | 0;
     if ((HEAP32[$fd139$i >> 2] | 0) == ($v$4$lcssa$i | 0)) {
      HEAP32[$bk136$i >> 2] = $62;
      HEAP32[$fd139$i >> 2] = $63;
      $R$3$i172 = $62;
      break;
     } else _abort();
    } while (0);
    L164 : do if (!$61) $83 = $50; else {
     $70 = HEAP32[$v$4$lcssa$i + 28 >> 2] | 0;
     $arrayidx184$i = 35804 + ($70 << 2) | 0;
     do if (($v$4$lcssa$i | 0) == (HEAP32[$arrayidx184$i >> 2] | 0)) {
      HEAP32[$arrayidx184$i >> 2] = $R$3$i172;
      if (!$R$3$i172) {
       $and194$i = $50 & ~(1 << $70);
       HEAP32[8876] = $and194$i;
       $83 = $and194$i;
       break L164;
      }
     } else if ((HEAP32[8879] | 0) >>> 0 > $61 >>> 0) _abort(); else {
      HEAP32[$61 + 16 + (((HEAP32[$61 + 16 >> 2] | 0) != ($v$4$lcssa$i | 0) & 1) << 2) >> 2] = $R$3$i172;
      if (!$R$3$i172) {
       $83 = $50;
       break L164;
      } else break;
     } while (0);
     $74 = HEAP32[8879] | 0;
     if ($74 >>> 0 > $R$3$i172 >>> 0) _abort();
     HEAP32[$R$3$i172 + 24 >> 2] = $61;
     $75 = HEAP32[$v$4$lcssa$i + 16 >> 2] | 0;
     do if ($75 | 0) if ($74 >>> 0 > $75 >>> 0) _abort(); else {
      HEAP32[$R$3$i172 + 16 >> 2] = $75;
      HEAP32[$75 + 24 >> 2] = $R$3$i172;
      break;
     } while (0);
     $76 = HEAP32[$v$4$lcssa$i + 20 >> 2] | 0;
     if (!$76) $83 = $50; else if ((HEAP32[8879] | 0) >>> 0 > $76 >>> 0) _abort(); else {
      HEAP32[$R$3$i172 + 20 >> 2] = $76;
      HEAP32[$76 + 24 >> 2] = $R$3$i172;
      $83 = $50;
      break;
     }
    } while (0);
    do if ($rsize$4$lcssa$i >>> 0 < 16) {
     $add268$i = $rsize$4$lcssa$i + $and145 | 0;
     HEAP32[$v$4$lcssa$i + 4 >> 2] = $add268$i | 3;
     $head274$i = $v$4$lcssa$i + $add268$i + 4 | 0;
     HEAP32[$head274$i >> 2] = HEAP32[$head274$i >> 2] | 1;
    } else {
     HEAP32[$v$4$lcssa$i + 4 >> 2] = $and145 | 3;
     HEAP32[$add$ptr$i162 + 4 >> 2] = $rsize$4$lcssa$i | 1;
     HEAP32[$add$ptr$i162 + $rsize$4$lcssa$i >> 2] = $rsize$4$lcssa$i;
     $shr283$i = $rsize$4$lcssa$i >>> 3;
     if ($rsize$4$lcssa$i >>> 0 < 256) {
      $arrayidx289$i = 35540 + ($shr283$i << 1 << 2) | 0;
      $79 = HEAP32[8875] | 0;
      $shl291$i = 1 << $shr283$i;
      if (!($79 & $shl291$i)) {
       HEAP32[8875] = $79 | $shl291$i;
       $$pre$phi$i180Z2D = $arrayidx289$i + 8 | 0;
       $F290$0$i = $arrayidx289$i;
      } else {
       $80 = $arrayidx289$i + 8 | 0;
       $81 = HEAP32[$80 >> 2] | 0;
       if ((HEAP32[8879] | 0) >>> 0 > $81 >>> 0) _abort(); else {
        $$pre$phi$i180Z2D = $80;
        $F290$0$i = $81;
       }
      }
      HEAP32[$$pre$phi$i180Z2D >> 2] = $add$ptr$i162;
      HEAP32[$F290$0$i + 12 >> 2] = $add$ptr$i162;
      HEAP32[$add$ptr$i162 + 8 >> 2] = $F290$0$i;
      HEAP32[$add$ptr$i162 + 12 >> 2] = $arrayidx289$i;
      break;
     }
     $shr318$i = $rsize$4$lcssa$i >>> 8;
     if (!$shr318$i) $I316$0$i = 0; else if ($rsize$4$lcssa$i >>> 0 > 16777215) $I316$0$i = 31; else {
      $and331$i = ($shr318$i + 1048320 | 0) >>> 16 & 8;
      $shl333$i = $shr318$i << $and331$i;
      $and336$i = ($shl333$i + 520192 | 0) >>> 16 & 4;
      $shl338$i = $shl333$i << $and336$i;
      $and341$i = ($shl338$i + 245760 | 0) >>> 16 & 2;
      $add346$i = 14 - ($and336$i | $and331$i | $and341$i) + ($shl338$i << $and341$i >>> 15) | 0;
      $I316$0$i = $rsize$4$lcssa$i >>> ($add346$i + 7 | 0) & 1 | $add346$i << 1;
     }
     $arrayidx355$i = 35804 + ($I316$0$i << 2) | 0;
     HEAP32[$add$ptr$i162 + 28 >> 2] = $I316$0$i;
     $child357$i = $add$ptr$i162 + 16 | 0;
     HEAP32[$child357$i + 4 >> 2] = 0;
     HEAP32[$child357$i >> 2] = 0;
     $shl362$i = 1 << $I316$0$i;
     if (!($83 & $shl362$i)) {
      HEAP32[8876] = $83 | $shl362$i;
      HEAP32[$arrayidx355$i >> 2] = $add$ptr$i162;
      HEAP32[$add$ptr$i162 + 24 >> 2] = $arrayidx355$i;
      HEAP32[$add$ptr$i162 + 12 >> 2] = $add$ptr$i162;
      HEAP32[$add$ptr$i162 + 8 >> 2] = $add$ptr$i162;
      break;
     }
     $K373$0$i = $rsize$4$lcssa$i << (($I316$0$i | 0) == 31 ? 0 : 25 - ($I316$0$i >>> 1) | 0);
     $T$0$i = HEAP32[$arrayidx355$i >> 2] | 0;
     while (1) {
      if ((HEAP32[$T$0$i + 4 >> 2] & -8 | 0) == ($rsize$4$lcssa$i | 0)) {
       label = 139;
       break;
      }
      $arrayidx394$i = $T$0$i + 16 + ($K373$0$i >>> 31 << 2) | 0;
      $86 = HEAP32[$arrayidx394$i >> 2] | 0;
      if (!$86) {
       label = 136;
       break;
      } else {
       $K373$0$i = $K373$0$i << 1;
       $T$0$i = $86;
      }
     }
     if ((label | 0) == 136) if ((HEAP32[8879] | 0) >>> 0 > $arrayidx394$i >>> 0) _abort(); else {
      HEAP32[$arrayidx394$i >> 2] = $add$ptr$i162;
      HEAP32[$add$ptr$i162 + 24 >> 2] = $T$0$i;
      HEAP32[$add$ptr$i162 + 12 >> 2] = $add$ptr$i162;
      HEAP32[$add$ptr$i162 + 8 >> 2] = $add$ptr$i162;
      break;
     } else if ((label | 0) == 139) {
      $fd416$i = $T$0$i + 8 | 0;
      $88 = HEAP32[$fd416$i >> 2] | 0;
      $89 = HEAP32[8879] | 0;
      if ($89 >>> 0 <= $88 >>> 0 & $89 >>> 0 <= $T$0$i >>> 0) {
       HEAP32[$88 + 12 >> 2] = $add$ptr$i162;
       HEAP32[$fd416$i >> 2] = $add$ptr$i162;
       HEAP32[$add$ptr$i162 + 8 >> 2] = $88;
       HEAP32[$add$ptr$i162 + 12 >> 2] = $T$0$i;
       HEAP32[$add$ptr$i162 + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } while (0);
    $retval$0 = $v$4$lcssa$i + 8 | 0;
    STACKTOP = sp;
    return $retval$0 | 0;
   } else $nb$0 = $and145;
  }
 } while (0);
 $91 = HEAP32[8877] | 0;
 if ($91 >>> 0 >= $nb$0 >>> 0) {
  $sub160 = $91 - $nb$0 | 0;
  $92 = HEAP32[8880] | 0;
  if ($sub160 >>> 0 > 15) {
   $add$ptr166 = $92 + $nb$0 | 0;
   HEAP32[8880] = $add$ptr166;
   HEAP32[8877] = $sub160;
   HEAP32[$add$ptr166 + 4 >> 2] = $sub160 | 1;
   HEAP32[$92 + $91 >> 2] = $sub160;
   HEAP32[$92 + 4 >> 2] = $nb$0 | 3;
  } else {
   HEAP32[8877] = 0;
   HEAP32[8880] = 0;
   HEAP32[$92 + 4 >> 2] = $91 | 3;
   $head179 = $92 + $91 + 4 | 0;
   HEAP32[$head179 >> 2] = HEAP32[$head179 >> 2] | 1;
  }
  $retval$0 = $92 + 8 | 0;
  STACKTOP = sp;
  return $retval$0 | 0;
 }
 $94 = HEAP32[8878] | 0;
 if ($94 >>> 0 > $nb$0 >>> 0) {
  $sub190 = $94 - $nb$0 | 0;
  HEAP32[8878] = $sub190;
  $95 = HEAP32[8881] | 0;
  $add$ptr193 = $95 + $nb$0 | 0;
  HEAP32[8881] = $add$ptr193;
  HEAP32[$add$ptr193 + 4 >> 2] = $sub190 | 1;
  HEAP32[$95 + 4 >> 2] = $nb$0 | 3;
  $retval$0 = $95 + 8 | 0;
  STACKTOP = sp;
  return $retval$0 | 0;
 }
 if (!(HEAP32[8993] | 0)) {
  HEAP32[8995] = 4096;
  HEAP32[8994] = 4096;
  HEAP32[8996] = -1;
  HEAP32[8997] = -1;
  HEAP32[8998] = 0;
  HEAP32[8986] = 0;
  HEAP32[8993] = $magic$i$i & -16 ^ 1431655768;
  $98 = 4096;
 } else $98 = HEAP32[8995] | 0;
 $add$i183 = $nb$0 + 48 | 0;
 $sub$i184 = $nb$0 + 47 | 0;
 $add9$i = $98 + $sub$i184 | 0;
 $neg$i185 = 0 - $98 | 0;
 $and11$i = $add9$i & $neg$i185;
 if ($and11$i >>> 0 <= $nb$0 >>> 0) {
  $retval$0 = 0;
  STACKTOP = sp;
  return $retval$0 | 0;
 }
 $99 = HEAP32[8985] | 0;
 if ($99 | 0) {
  $100 = HEAP32[8983] | 0;
  $add17$i186 = $100 + $and11$i | 0;
  if ($add17$i186 >>> 0 <= $100 >>> 0 | $add17$i186 >>> 0 > $99 >>> 0) {
   $retval$0 = 0;
   STACKTOP = sp;
   return $retval$0 | 0;
  }
 }
 L244 : do if (!(HEAP32[8986] & 4)) {
  $102 = HEAP32[8881] | 0;
  L246 : do if (!$102) label = 163; else {
   $sp$0$i$i = 35948;
   while (1) {
    $103 = HEAP32[$sp$0$i$i >> 2] | 0;
    if ($103 >>> 0 <= $102 >>> 0) {
     $size$i$i = $sp$0$i$i + 4 | 0;
     if (($103 + (HEAP32[$size$i$i >> 2] | 0) | 0) >>> 0 > $102 >>> 0) break;
    }
    $105 = HEAP32[$sp$0$i$i + 8 >> 2] | 0;
    if (!$105) {
     label = 163;
     break L246;
    } else $sp$0$i$i = $105;
   }
   $and80$i = $add9$i - $94 & $neg$i185;
   if ($and80$i >>> 0 < 2147483647) {
    $call83$i = _sbrk($and80$i | 0) | 0;
    if (($call83$i | 0) == ((HEAP32[$sp$0$i$i >> 2] | 0) + (HEAP32[$size$i$i >> 2] | 0) | 0)) if (($call83$i | 0) == (-1 | 0)) $tsize$2657583$i = $and80$i; else {
     $tbase$796$i = $call83$i;
     $tsize$795$i = $and80$i;
     label = 180;
     break L244;
    } else {
     $br$2$ph$i = $call83$i;
     $ssize$2$ph$i = $and80$i;
     label = 171;
    }
   } else $tsize$2657583$i = 0;
  } while (0);
  do if ((label | 0) == 163) {
   $call37$i = _sbrk(0) | 0;
   if (($call37$i | 0) == (-1 | 0)) $tsize$2657583$i = 0; else {
    $106 = $call37$i;
    $107 = HEAP32[8994] | 0;
    $sub41$i = $107 + -1 | 0;
    $and11$add51$i = (($sub41$i & $106 | 0) == 0 ? 0 : ($sub41$i + $106 & 0 - $107) - $106 | 0) + $and11$i | 0;
    $108 = HEAP32[8983] | 0;
    $add54$i = $and11$add51$i + $108 | 0;
    if ($and11$add51$i >>> 0 > $nb$0 >>> 0 & $and11$add51$i >>> 0 < 2147483647) {
     $109 = HEAP32[8985] | 0;
     if ($109 | 0) if ($add54$i >>> 0 <= $108 >>> 0 | $add54$i >>> 0 > $109 >>> 0) {
      $tsize$2657583$i = 0;
      break;
     }
     $call68$i = _sbrk($and11$add51$i | 0) | 0;
     if (($call68$i | 0) == ($call37$i | 0)) {
      $tbase$796$i = $call37$i;
      $tsize$795$i = $and11$add51$i;
      label = 180;
      break L244;
     } else {
      $br$2$ph$i = $call68$i;
      $ssize$2$ph$i = $and11$add51$i;
      label = 171;
     }
    } else $tsize$2657583$i = 0;
   }
  } while (0);
  do if ((label | 0) == 171) {
   $sub112$i = 0 - $ssize$2$ph$i | 0;
   if (!($add$i183 >>> 0 > $ssize$2$ph$i >>> 0 & ($ssize$2$ph$i >>> 0 < 2147483647 & ($br$2$ph$i | 0) != (-1 | 0)))) if (($br$2$ph$i | 0) == (-1 | 0)) {
    $tsize$2657583$i = 0;
    break;
   } else {
    $tbase$796$i = $br$2$ph$i;
    $tsize$795$i = $ssize$2$ph$i;
    label = 180;
    break L244;
   }
   $112 = HEAP32[8995] | 0;
   $and104$i = $sub$i184 - $ssize$2$ph$i + $112 & 0 - $112;
   if ($and104$i >>> 0 >= 2147483647) {
    $tbase$796$i = $br$2$ph$i;
    $tsize$795$i = $ssize$2$ph$i;
    label = 180;
    break L244;
   }
   if ((_sbrk($and104$i | 0) | 0) == (-1 | 0)) {
    _sbrk($sub112$i | 0) | 0;
    $tsize$2657583$i = 0;
    break;
   } else {
    $tbase$796$i = $br$2$ph$i;
    $tsize$795$i = $and104$i + $ssize$2$ph$i | 0;
    label = 180;
    break L244;
   }
  } while (0);
  HEAP32[8986] = HEAP32[8986] | 4;
  $tsize$4$i = $tsize$2657583$i;
  label = 178;
 } else {
  $tsize$4$i = 0;
  label = 178;
 } while (0);
 if ((label | 0) == 178) if ($and11$i >>> 0 < 2147483647) {
  $call131$i = _sbrk($and11$i | 0) | 0;
  $call132$i = _sbrk(0) | 0;
  $sub$ptr$sub$i = $call132$i - $call131$i | 0;
  $cmp141$i = $sub$ptr$sub$i >>> 0 > ($nb$0 + 40 | 0) >>> 0;
  if (!(($call131$i | 0) == (-1 | 0) | $cmp141$i ^ 1 | $call131$i >>> 0 < $call132$i >>> 0 & (($call131$i | 0) != (-1 | 0) & ($call132$i | 0) != (-1 | 0)) ^ 1)) {
   $tbase$796$i = $call131$i;
   $tsize$795$i = $cmp141$i ? $sub$ptr$sub$i : $tsize$4$i;
   label = 180;
  }
 }
 if ((label | 0) == 180) {
  $add150$i = (HEAP32[8983] | 0) + $tsize$795$i | 0;
  HEAP32[8983] = $add150$i;
  if ($add150$i >>> 0 > (HEAP32[8984] | 0) >>> 0) HEAP32[8984] = $add150$i;
  $116 = HEAP32[8881] | 0;
  do if (!$116) {
   $117 = HEAP32[8879] | 0;
   if (($117 | 0) == 0 | $tbase$796$i >>> 0 < $117 >>> 0) HEAP32[8879] = $tbase$796$i;
   HEAP32[8987] = $tbase$796$i;
   HEAP32[8988] = $tsize$795$i;
   HEAP32[8990] = 0;
   HEAP32[8884] = HEAP32[8993];
   HEAP32[8883] = -1;
   HEAP32[8888] = 35540;
   HEAP32[8887] = 35540;
   HEAP32[8890] = 35548;
   HEAP32[8889] = 35548;
   HEAP32[8892] = 35556;
   HEAP32[8891] = 35556;
   HEAP32[8894] = 35564;
   HEAP32[8893] = 35564;
   HEAP32[8896] = 35572;
   HEAP32[8895] = 35572;
   HEAP32[8898] = 35580;
   HEAP32[8897] = 35580;
   HEAP32[8900] = 35588;
   HEAP32[8899] = 35588;
   HEAP32[8902] = 35596;
   HEAP32[8901] = 35596;
   HEAP32[8904] = 35604;
   HEAP32[8903] = 35604;
   HEAP32[8906] = 35612;
   HEAP32[8905] = 35612;
   HEAP32[8908] = 35620;
   HEAP32[8907] = 35620;
   HEAP32[8910] = 35628;
   HEAP32[8909] = 35628;
   HEAP32[8912] = 35636;
   HEAP32[8911] = 35636;
   HEAP32[8914] = 35644;
   HEAP32[8913] = 35644;
   HEAP32[8916] = 35652;
   HEAP32[8915] = 35652;
   HEAP32[8918] = 35660;
   HEAP32[8917] = 35660;
   HEAP32[8920] = 35668;
   HEAP32[8919] = 35668;
   HEAP32[8922] = 35676;
   HEAP32[8921] = 35676;
   HEAP32[8924] = 35684;
   HEAP32[8923] = 35684;
   HEAP32[8926] = 35692;
   HEAP32[8925] = 35692;
   HEAP32[8928] = 35700;
   HEAP32[8927] = 35700;
   HEAP32[8930] = 35708;
   HEAP32[8929] = 35708;
   HEAP32[8932] = 35716;
   HEAP32[8931] = 35716;
   HEAP32[8934] = 35724;
   HEAP32[8933] = 35724;
   HEAP32[8936] = 35732;
   HEAP32[8935] = 35732;
   HEAP32[8938] = 35740;
   HEAP32[8937] = 35740;
   HEAP32[8940] = 35748;
   HEAP32[8939] = 35748;
   HEAP32[8942] = 35756;
   HEAP32[8941] = 35756;
   HEAP32[8944] = 35764;
   HEAP32[8943] = 35764;
   HEAP32[8946] = 35772;
   HEAP32[8945] = 35772;
   HEAP32[8948] = 35780;
   HEAP32[8947] = 35780;
   HEAP32[8950] = 35788;
   HEAP32[8949] = 35788;
   $sub172$i = $tsize$795$i + -40 | 0;
   $119 = $tbase$796$i + 8 | 0;
   $cond$i17$i = ($119 & 7 | 0) == 0 ? 0 : 0 - $119 & 7;
   $add$ptr4$i$i = $tbase$796$i + $cond$i17$i | 0;
   $sub5$i$i = $sub172$i - $cond$i17$i | 0;
   HEAP32[8881] = $add$ptr4$i$i;
   HEAP32[8878] = $sub5$i$i;
   HEAP32[$add$ptr4$i$i + 4 >> 2] = $sub5$i$i | 1;
   HEAP32[$tbase$796$i + $sub172$i + 4 >> 2] = 40;
   HEAP32[8882] = HEAP32[8997];
  } else {
   $sp$0108$i = 35948;
   while (1) {
    $121 = HEAP32[$sp$0108$i >> 2] | 0;
    $size188$i = $sp$0108$i + 4 | 0;
    $122 = HEAP32[$size188$i >> 2] | 0;
    if (($tbase$796$i | 0) == ($121 + $122 | 0)) {
     label = 188;
     break;
    }
    $123 = HEAP32[$sp$0108$i + 8 >> 2] | 0;
    if (!$123) break; else $sp$0108$i = $123;
   }
   if ((label | 0) == 188) if (!(HEAP32[$sp$0108$i + 12 >> 2] & 8)) if ($tbase$796$i >>> 0 > $116 >>> 0 & $121 >>> 0 <= $116 >>> 0) {
    HEAP32[$size188$i >> 2] = $122 + $tsize$795$i;
    $add215$i = (HEAP32[8878] | 0) + $tsize$795$i | 0;
    $126 = $116 + 8 | 0;
    $cond$i53$i = ($126 & 7 | 0) == 0 ? 0 : 0 - $126 & 7;
    $add$ptr4$i54$i = $116 + $cond$i53$i | 0;
    $sub5$i55$i = $add215$i - $cond$i53$i | 0;
    HEAP32[8881] = $add$ptr4$i54$i;
    HEAP32[8878] = $sub5$i55$i;
    HEAP32[$add$ptr4$i54$i + 4 >> 2] = $sub5$i55$i | 1;
    HEAP32[$116 + $add215$i + 4 >> 2] = 40;
    HEAP32[8882] = HEAP32[8997];
    break;
   }
   $128 = HEAP32[8879] | 0;
   if ($tbase$796$i >>> 0 < $128 >>> 0) {
    HEAP32[8879] = $tbase$796$i;
    $141 = $tbase$796$i;
   } else $141 = $128;
   $add$ptr227$i = $tbase$796$i + $tsize$795$i | 0;
   $sp$1107$i = 35948;
   while (1) {
    if ((HEAP32[$sp$1107$i >> 2] | 0) == ($add$ptr227$i | 0)) {
     label = 196;
     break;
    }
    $130 = HEAP32[$sp$1107$i + 8 >> 2] | 0;
    if (!$130) {
     $sp$0$i$i$i = 35948;
     break;
    } else $sp$1107$i = $130;
   }
   if ((label | 0) == 196) if (!(HEAP32[$sp$1107$i + 12 >> 2] & 8)) {
    HEAP32[$sp$1107$i >> 2] = $tbase$796$i;
    $size245$i = $sp$1107$i + 4 | 0;
    HEAP32[$size245$i >> 2] = (HEAP32[$size245$i >> 2] | 0) + $tsize$795$i;
    $133 = $tbase$796$i + 8 | 0;
    $add$ptr4$i25$i = $tbase$796$i + (($133 & 7 | 0) == 0 ? 0 : 0 - $133 & 7) | 0;
    $134 = $add$ptr227$i + 8 | 0;
    $add$ptr16$i$i = $add$ptr227$i + (($134 & 7 | 0) == 0 ? 0 : 0 - $134 & 7) | 0;
    $add$ptr17$i$i = $add$ptr4$i25$i + $nb$0 | 0;
    $sub18$i$i = $add$ptr16$i$i - $add$ptr4$i25$i - $nb$0 | 0;
    HEAP32[$add$ptr4$i25$i + 4 >> 2] = $nb$0 | 3;
    do if (($116 | 0) == ($add$ptr16$i$i | 0)) {
     $add$i$i = (HEAP32[8878] | 0) + $sub18$i$i | 0;
     HEAP32[8878] = $add$i$i;
     HEAP32[8881] = $add$ptr17$i$i;
     HEAP32[$add$ptr17$i$i + 4 >> 2] = $add$i$i | 1;
    } else {
     if ((HEAP32[8880] | 0) == ($add$ptr16$i$i | 0)) {
      $add26$i$i = (HEAP32[8877] | 0) + $sub18$i$i | 0;
      HEAP32[8877] = $add26$i$i;
      HEAP32[8880] = $add$ptr17$i$i;
      HEAP32[$add$ptr17$i$i + 4 >> 2] = $add26$i$i | 1;
      HEAP32[$add$ptr17$i$i + $add26$i$i >> 2] = $add26$i$i;
      break;
     }
     $138 = HEAP32[$add$ptr16$i$i + 4 >> 2] | 0;
     if (($138 & 3 | 0) == 1) {
      $and37$i$i = $138 & -8;
      $shr$i33$i = $138 >>> 3;
      L311 : do if ($138 >>> 0 < 256) {
       $139 = HEAP32[$add$ptr16$i$i + 8 >> 2] | 0;
       $140 = HEAP32[$add$ptr16$i$i + 12 >> 2] | 0;
       $arrayidx$i36$i = 35540 + ($shr$i33$i << 1 << 2) | 0;
       do if (($139 | 0) != ($arrayidx$i36$i | 0)) {
        if ($141 >>> 0 > $139 >>> 0) _abort();
        if ((HEAP32[$139 + 12 >> 2] | 0) == ($add$ptr16$i$i | 0)) break;
        _abort();
       } while (0);
       if (($140 | 0) == ($139 | 0)) {
        HEAP32[8875] = HEAP32[8875] & ~(1 << $shr$i33$i);
        break;
       }
       do if (($140 | 0) == ($arrayidx$i36$i | 0)) $fd68$pre$phi$i$iZ2D = $140 + 8 | 0; else {
        if ($141 >>> 0 > $140 >>> 0) _abort();
        $fd59$i$i = $140 + 8 | 0;
        if ((HEAP32[$fd59$i$i >> 2] | 0) == ($add$ptr16$i$i | 0)) {
         $fd68$pre$phi$i$iZ2D = $fd59$i$i;
         break;
        }
        _abort();
       } while (0);
       HEAP32[$139 + 12 >> 2] = $140;
       HEAP32[$fd68$pre$phi$i$iZ2D >> 2] = $139;
      } else {
       $145 = HEAP32[$add$ptr16$i$i + 24 >> 2] | 0;
       $146 = HEAP32[$add$ptr16$i$i + 12 >> 2] | 0;
       do if (($146 | 0) == ($add$ptr16$i$i | 0)) {
        $child$i$i = $add$ptr16$i$i + 16 | 0;
        $arrayidx96$i$i = $child$i$i + 4 | 0;
        $150 = HEAP32[$arrayidx96$i$i >> 2] | 0;
        if (!$150) {
         $151 = HEAP32[$child$i$i >> 2] | 0;
         if (!$151) {
          $R$3$i$i = 0;
          break;
         } else {
          $R$1$i$i = $151;
          $RP$1$i$i = $child$i$i;
         }
        } else {
         $R$1$i$i = $150;
         $RP$1$i$i = $arrayidx96$i$i;
        }
        while (1) {
         $arrayidx103$i$i = $R$1$i$i + 20 | 0;
         $152 = HEAP32[$arrayidx103$i$i >> 2] | 0;
         if ($152 | 0) {
          $R$1$i$i = $152;
          $RP$1$i$i = $arrayidx103$i$i;
          continue;
         }
         $arrayidx107$i$i = $R$1$i$i + 16 | 0;
         $153 = HEAP32[$arrayidx107$i$i >> 2] | 0;
         if (!$153) break; else {
          $R$1$i$i = $153;
          $RP$1$i$i = $arrayidx107$i$i;
         }
        }
        if ($141 >>> 0 > $RP$1$i$i >>> 0) _abort(); else {
         HEAP32[$RP$1$i$i >> 2] = 0;
         $R$3$i$i = $R$1$i$i;
         break;
        }
       } else {
        $147 = HEAP32[$add$ptr16$i$i + 8 >> 2] | 0;
        if ($141 >>> 0 > $147 >>> 0) _abort();
        $bk82$i$i = $147 + 12 | 0;
        if ((HEAP32[$bk82$i$i >> 2] | 0) != ($add$ptr16$i$i | 0)) _abort();
        $fd85$i$i = $146 + 8 | 0;
        if ((HEAP32[$fd85$i$i >> 2] | 0) == ($add$ptr16$i$i | 0)) {
         HEAP32[$bk82$i$i >> 2] = $146;
         HEAP32[$fd85$i$i >> 2] = $147;
         $R$3$i$i = $146;
         break;
        } else _abort();
       } while (0);
       if (!$145) break;
       $154 = HEAP32[$add$ptr16$i$i + 28 >> 2] | 0;
       $arrayidx123$i$i = 35804 + ($154 << 2) | 0;
       do if ((HEAP32[$arrayidx123$i$i >> 2] | 0) == ($add$ptr16$i$i | 0)) {
        HEAP32[$arrayidx123$i$i >> 2] = $R$3$i$i;
        if ($R$3$i$i | 0) break;
        HEAP32[8876] = HEAP32[8876] & ~(1 << $154);
        break L311;
       } else if ((HEAP32[8879] | 0) >>> 0 > $145 >>> 0) _abort(); else {
        HEAP32[$145 + 16 + (((HEAP32[$145 + 16 >> 2] | 0) != ($add$ptr16$i$i | 0) & 1) << 2) >> 2] = $R$3$i$i;
        if (!$R$3$i$i) break L311; else break;
       } while (0);
       $159 = HEAP32[8879] | 0;
       if ($159 >>> 0 > $R$3$i$i >>> 0) _abort();
       HEAP32[$R$3$i$i + 24 >> 2] = $145;
       $child166$i$i = $add$ptr16$i$i + 16 | 0;
       $160 = HEAP32[$child166$i$i >> 2] | 0;
       do if ($160 | 0) if ($159 >>> 0 > $160 >>> 0) _abort(); else {
        HEAP32[$R$3$i$i + 16 >> 2] = $160;
        HEAP32[$160 + 24 >> 2] = $R$3$i$i;
        break;
       } while (0);
       $161 = HEAP32[$child166$i$i + 4 >> 2] | 0;
       if (!$161) break;
       if ((HEAP32[8879] | 0) >>> 0 > $161 >>> 0) _abort(); else {
        HEAP32[$R$3$i$i + 20 >> 2] = $161;
        HEAP32[$161 + 24 >> 2] = $R$3$i$i;
        break;
       }
      } while (0);
      $oldfirst$0$i$i = $add$ptr16$i$i + $and37$i$i | 0;
      $qsize$0$i$i = $and37$i$i + $sub18$i$i | 0;
     } else {
      $oldfirst$0$i$i = $add$ptr16$i$i;
      $qsize$0$i$i = $sub18$i$i;
     }
     $head208$i$i = $oldfirst$0$i$i + 4 | 0;
     HEAP32[$head208$i$i >> 2] = HEAP32[$head208$i$i >> 2] & -2;
     HEAP32[$add$ptr17$i$i + 4 >> 2] = $qsize$0$i$i | 1;
     HEAP32[$add$ptr17$i$i + $qsize$0$i$i >> 2] = $qsize$0$i$i;
     $shr214$i$i = $qsize$0$i$i >>> 3;
     if ($qsize$0$i$i >>> 0 < 256) {
      $arrayidx223$i$i = 35540 + ($shr214$i$i << 1 << 2) | 0;
      $164 = HEAP32[8875] | 0;
      $shl226$i$i = 1 << $shr214$i$i;
      do if (!($164 & $shl226$i$i)) {
       HEAP32[8875] = $164 | $shl226$i$i;
       $$pre$phi$i45$iZ2D = $arrayidx223$i$i + 8 | 0;
       $F224$0$i$i = $arrayidx223$i$i;
      } else {
       $165 = $arrayidx223$i$i + 8 | 0;
       $166 = HEAP32[$165 >> 2] | 0;
       if ((HEAP32[8879] | 0) >>> 0 <= $166 >>> 0) {
        $$pre$phi$i45$iZ2D = $165;
        $F224$0$i$i = $166;
        break;
       }
       _abort();
      } while (0);
      HEAP32[$$pre$phi$i45$iZ2D >> 2] = $add$ptr17$i$i;
      HEAP32[$F224$0$i$i + 12 >> 2] = $add$ptr17$i$i;
      HEAP32[$add$ptr17$i$i + 8 >> 2] = $F224$0$i$i;
      HEAP32[$add$ptr17$i$i + 12 >> 2] = $arrayidx223$i$i;
      break;
     }
     $shr253$i$i = $qsize$0$i$i >>> 8;
     do if (!$shr253$i$i) $I252$0$i$i = 0; else {
      if ($qsize$0$i$i >>> 0 > 16777215) {
       $I252$0$i$i = 31;
       break;
      }
      $and264$i$i = ($shr253$i$i + 1048320 | 0) >>> 16 & 8;
      $shl265$i$i = $shr253$i$i << $and264$i$i;
      $and268$i$i = ($shl265$i$i + 520192 | 0) >>> 16 & 4;
      $shl270$i$i = $shl265$i$i << $and268$i$i;
      $and273$i$i = ($shl270$i$i + 245760 | 0) >>> 16 & 2;
      $add278$i$i = 14 - ($and268$i$i | $and264$i$i | $and273$i$i) + ($shl270$i$i << $and273$i$i >>> 15) | 0;
      $I252$0$i$i = $qsize$0$i$i >>> ($add278$i$i + 7 | 0) & 1 | $add278$i$i << 1;
     } while (0);
     $arrayidx287$i$i = 35804 + ($I252$0$i$i << 2) | 0;
     HEAP32[$add$ptr17$i$i + 28 >> 2] = $I252$0$i$i;
     $child289$i$i = $add$ptr17$i$i + 16 | 0;
     HEAP32[$child289$i$i + 4 >> 2] = 0;
     HEAP32[$child289$i$i >> 2] = 0;
     $168 = HEAP32[8876] | 0;
     $shl294$i$i = 1 << $I252$0$i$i;
     if (!($168 & $shl294$i$i)) {
      HEAP32[8876] = $168 | $shl294$i$i;
      HEAP32[$arrayidx287$i$i >> 2] = $add$ptr17$i$i;
      HEAP32[$add$ptr17$i$i + 24 >> 2] = $arrayidx287$i$i;
      HEAP32[$add$ptr17$i$i + 12 >> 2] = $add$ptr17$i$i;
      HEAP32[$add$ptr17$i$i + 8 >> 2] = $add$ptr17$i$i;
      break;
     }
     $K305$0$i$i = $qsize$0$i$i << (($I252$0$i$i | 0) == 31 ? 0 : 25 - ($I252$0$i$i >>> 1) | 0);
     $T$0$i46$i = HEAP32[$arrayidx287$i$i >> 2] | 0;
     while (1) {
      if ((HEAP32[$T$0$i46$i + 4 >> 2] & -8 | 0) == ($qsize$0$i$i | 0)) {
       label = 263;
       break;
      }
      $arrayidx325$i$i = $T$0$i46$i + 16 + ($K305$0$i$i >>> 31 << 2) | 0;
      $171 = HEAP32[$arrayidx325$i$i >> 2] | 0;
      if (!$171) {
       label = 260;
       break;
      } else {
       $K305$0$i$i = $K305$0$i$i << 1;
       $T$0$i46$i = $171;
      }
     }
     if ((label | 0) == 260) if ((HEAP32[8879] | 0) >>> 0 > $arrayidx325$i$i >>> 0) _abort(); else {
      HEAP32[$arrayidx325$i$i >> 2] = $add$ptr17$i$i;
      HEAP32[$add$ptr17$i$i + 24 >> 2] = $T$0$i46$i;
      HEAP32[$add$ptr17$i$i + 12 >> 2] = $add$ptr17$i$i;
      HEAP32[$add$ptr17$i$i + 8 >> 2] = $add$ptr17$i$i;
      break;
     } else if ((label | 0) == 263) {
      $fd344$i$i = $T$0$i46$i + 8 | 0;
      $173 = HEAP32[$fd344$i$i >> 2] | 0;
      $174 = HEAP32[8879] | 0;
      if ($174 >>> 0 <= $173 >>> 0 & $174 >>> 0 <= $T$0$i46$i >>> 0) {
       HEAP32[$173 + 12 >> 2] = $add$ptr17$i$i;
       HEAP32[$fd344$i$i >> 2] = $add$ptr17$i$i;
       HEAP32[$add$ptr17$i$i + 8 >> 2] = $173;
       HEAP32[$add$ptr17$i$i + 12 >> 2] = $T$0$i46$i;
       HEAP32[$add$ptr17$i$i + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } while (0);
    $retval$0 = $add$ptr4$i25$i + 8 | 0;
    STACKTOP = sp;
    return $retval$0 | 0;
   } else $sp$0$i$i$i = 35948;
   while (1) {
    $176 = HEAP32[$sp$0$i$i$i >> 2] | 0;
    if ($176 >>> 0 <= $116 >>> 0) {
     $add$ptr$i$i$i = $176 + (HEAP32[$sp$0$i$i$i + 4 >> 2] | 0) | 0;
     if ($add$ptr$i$i$i >>> 0 > $116 >>> 0) break;
    }
    $sp$0$i$i$i = HEAP32[$sp$0$i$i$i + 8 >> 2] | 0;
   }
   $add$ptr2$i$i = $add$ptr$i$i$i + -47 | 0;
   $179 = $add$ptr2$i$i + 8 | 0;
   $add$ptr7$i$i = $add$ptr2$i$i + (($179 & 7 | 0) == 0 ? 0 : 0 - $179 & 7) | 0;
   $add$ptr81$i$i = $116 + 16 | 0;
   $cond13$i$i = $add$ptr7$i$i >>> 0 < $add$ptr81$i$i >>> 0 ? $116 : $add$ptr7$i$i;
   $add$ptr14$i$i = $cond13$i$i + 8 | 0;
   $sub16$i$i = $tsize$795$i + -40 | 0;
   $180 = $tbase$796$i + 8 | 0;
   $cond$i$i$i = ($180 & 7 | 0) == 0 ? 0 : 0 - $180 & 7;
   $add$ptr4$i$i$i = $tbase$796$i + $cond$i$i$i | 0;
   $sub5$i$i$i = $sub16$i$i - $cond$i$i$i | 0;
   HEAP32[8881] = $add$ptr4$i$i$i;
   HEAP32[8878] = $sub5$i$i$i;
   HEAP32[$add$ptr4$i$i$i + 4 >> 2] = $sub5$i$i$i | 1;
   HEAP32[$tbase$796$i + $sub16$i$i + 4 >> 2] = 40;
   HEAP32[8882] = HEAP32[8997];
   $head$i$i = $cond13$i$i + 4 | 0;
   HEAP32[$head$i$i >> 2] = 27;
   HEAP32[$add$ptr14$i$i >> 2] = HEAP32[8987];
   HEAP32[$add$ptr14$i$i + 4 >> 2] = HEAP32[8988];
   HEAP32[$add$ptr14$i$i + 8 >> 2] = HEAP32[8989];
   HEAP32[$add$ptr14$i$i + 12 >> 2] = HEAP32[8990];
   HEAP32[8987] = $tbase$796$i;
   HEAP32[8988] = $tsize$795$i;
   HEAP32[8990] = 0;
   HEAP32[8989] = $add$ptr14$i$i;
   $182 = $cond13$i$i + 24 | 0;
   do {
    $182$looptemp = $182;
    $182 = $182 + 4 | 0;
    HEAP32[$182 >> 2] = 7;
   } while (($182$looptemp + 8 | 0) >>> 0 < $add$ptr$i$i$i >>> 0);
   if (($cond13$i$i | 0) != ($116 | 0)) {
    $sub$ptr$sub$i$i = $cond13$i$i - $116 | 0;
    HEAP32[$head$i$i >> 2] = HEAP32[$head$i$i >> 2] & -2;
    HEAP32[$116 + 4 >> 2] = $sub$ptr$sub$i$i | 1;
    HEAP32[$cond13$i$i >> 2] = $sub$ptr$sub$i$i;
    $shr$i$i = $sub$ptr$sub$i$i >>> 3;
    if ($sub$ptr$sub$i$i >>> 0 < 256) {
     $arrayidx$i$i = 35540 + ($shr$i$i << 1 << 2) | 0;
     $184 = HEAP32[8875] | 0;
     $shl39$i$i = 1 << $shr$i$i;
     if (!($184 & $shl39$i$i)) {
      HEAP32[8875] = $184 | $shl39$i$i;
      $$pre$phi$i$iZ2D = $arrayidx$i$i + 8 | 0;
      $F$0$i$i = $arrayidx$i$i;
     } else {
      $185 = $arrayidx$i$i + 8 | 0;
      $186 = HEAP32[$185 >> 2] | 0;
      if ((HEAP32[8879] | 0) >>> 0 > $186 >>> 0) _abort(); else {
       $$pre$phi$i$iZ2D = $185;
       $F$0$i$i = $186;
      }
     }
     HEAP32[$$pre$phi$i$iZ2D >> 2] = $116;
     HEAP32[$F$0$i$i + 12 >> 2] = $116;
     HEAP32[$116 + 8 >> 2] = $F$0$i$i;
     HEAP32[$116 + 12 >> 2] = $arrayidx$i$i;
     break;
    }
    $shr58$i$i = $sub$ptr$sub$i$i >>> 8;
    if (!$shr58$i$i) $I57$0$i$i = 0; else if ($sub$ptr$sub$i$i >>> 0 > 16777215) $I57$0$i$i = 31; else {
     $and69$i$i = ($shr58$i$i + 1048320 | 0) >>> 16 & 8;
     $shl70$i$i = $shr58$i$i << $and69$i$i;
     $and73$i$i = ($shl70$i$i + 520192 | 0) >>> 16 & 4;
     $shl75$i$i = $shl70$i$i << $and73$i$i;
     $and78$i$i = ($shl75$i$i + 245760 | 0) >>> 16 & 2;
     $add83$i$i = 14 - ($and73$i$i | $and69$i$i | $and78$i$i) + ($shl75$i$i << $and78$i$i >>> 15) | 0;
     $I57$0$i$i = $sub$ptr$sub$i$i >>> ($add83$i$i + 7 | 0) & 1 | $add83$i$i << 1;
    }
    $arrayidx91$i$i = 35804 + ($I57$0$i$i << 2) | 0;
    HEAP32[$116 + 28 >> 2] = $I57$0$i$i;
    HEAP32[$116 + 20 >> 2] = 0;
    HEAP32[$add$ptr81$i$i >> 2] = 0;
    $188 = HEAP32[8876] | 0;
    $shl95$i$i = 1 << $I57$0$i$i;
    if (!($188 & $shl95$i$i)) {
     HEAP32[8876] = $188 | $shl95$i$i;
     HEAP32[$arrayidx91$i$i >> 2] = $116;
     HEAP32[$116 + 24 >> 2] = $arrayidx91$i$i;
     HEAP32[$116 + 12 >> 2] = $116;
     HEAP32[$116 + 8 >> 2] = $116;
     break;
    }
    $K105$0$i$i = $sub$ptr$sub$i$i << (($I57$0$i$i | 0) == 31 ? 0 : 25 - ($I57$0$i$i >>> 1) | 0);
    $T$0$i$i = HEAP32[$arrayidx91$i$i >> 2] | 0;
    while (1) {
     if ((HEAP32[$T$0$i$i + 4 >> 2] & -8 | 0) == ($sub$ptr$sub$i$i | 0)) {
      label = 289;
      break;
     }
     $arrayidx126$i$i = $T$0$i$i + 16 + ($K105$0$i$i >>> 31 << 2) | 0;
     $191 = HEAP32[$arrayidx126$i$i >> 2] | 0;
     if (!$191) {
      label = 286;
      break;
     } else {
      $K105$0$i$i = $K105$0$i$i << 1;
      $T$0$i$i = $191;
     }
    }
    if ((label | 0) == 286) if ((HEAP32[8879] | 0) >>> 0 > $arrayidx126$i$i >>> 0) _abort(); else {
     HEAP32[$arrayidx126$i$i >> 2] = $116;
     HEAP32[$116 + 24 >> 2] = $T$0$i$i;
     HEAP32[$116 + 12 >> 2] = $116;
     HEAP32[$116 + 8 >> 2] = $116;
     break;
    } else if ((label | 0) == 289) {
     $fd148$i$i = $T$0$i$i + 8 | 0;
     $193 = HEAP32[$fd148$i$i >> 2] | 0;
     $194 = HEAP32[8879] | 0;
     if ($194 >>> 0 <= $193 >>> 0 & $194 >>> 0 <= $T$0$i$i >>> 0) {
      HEAP32[$193 + 12 >> 2] = $116;
      HEAP32[$fd148$i$i >> 2] = $116;
      HEAP32[$116 + 8 >> 2] = $193;
      HEAP32[$116 + 12 >> 2] = $T$0$i$i;
      HEAP32[$116 + 24 >> 2] = 0;
      break;
     } else _abort();
    }
   }
  } while (0);
  $196 = HEAP32[8878] | 0;
  if ($196 >>> 0 > $nb$0 >>> 0) {
   $sub260$i = $196 - $nb$0 | 0;
   HEAP32[8878] = $sub260$i;
   $197 = HEAP32[8881] | 0;
   $add$ptr262$i = $197 + $nb$0 | 0;
   HEAP32[8881] = $add$ptr262$i;
   HEAP32[$add$ptr262$i + 4 >> 2] = $sub260$i | 1;
   HEAP32[$197 + 4 >> 2] = $nb$0 | 3;
   $retval$0 = $197 + 8 | 0;
   STACKTOP = sp;
   return $retval$0 | 0;
  }
 }
 HEAP32[(___errno_location() | 0) >> 2] = 12;
 $retval$0 = 0;
 STACKTOP = sp;
 return $retval$0 | 0;
}

function _tonality_analysis($tonal, $celt_mode, $x, $len, $offset, $c1, $c2, $C, $lsb_depth, $downmix) {
 $tonal = $tonal | 0;
 $celt_mode = $celt_mode | 0;
 $x = $x | 0;
 $len = $len | 0;
 $offset = $offset | 0;
 $c1 = $c1 | 0;
 $c2 = $c2 | 0;
 $C = $C | 0;
 $lsb_depth = $lsb_depth | 0;
 $downmix = $downmix | 0;
 var $$sink = 0.0, $$sink1 = 0, $161 = 0.0, $169 = 0.0, $205 = 0, $207 = 0, $211 = 0, $329 = 0.0, $350 = 0, $361 = 0.0, $362 = 0, $370 = 0, $389 = 0, $477 = 0, $487 = 0, $503 = 0, $513 = 0, $60 = 0, $612 = 0.0, $918 = 0.0, $920 = 0.0, $923 = 0.0, $A = 0, $BFCC = 0, $C$addr = 0, $E = 0, $E360 = 0, $E868 = 0, $E988 = 0, $Em = 0, $Em987 = 0, $L1 = 0, $L2 = 0, $N = 0, $N2 = 0, $X1i = 0, $X1r = 0, $X1r304 = 0, $X2i = 0, $X2r = 0, $X2r305 = 0, $above_max_pitch = 0, $add271$sink$sink = 0, $alpha = 0, $alphaE = 0, $alphaE2 = 0, $angle159 = 0, $angle2 = 0, $arrayidx211 = 0, $arrayidx482 = 0, $arrayidx486 = 0, $arrayidx544$sink = 0, $avg_mod = 0, $b = 0, $band_end = 0, $band_log2 = 0, $band_start = 0, $band_tonality = 0, $bandwidth = 0, $bandwidth_mask = 0, $below_max_pitch = 0, $binE = 0, $binE368 = 0, $binE876 = 0, $boost = 0, $c1$addr = 0, $c2$addr = 0, $call = 0.0, $call141 = 0.0, $celt_mode$addr = 0, $cond = 0, $cond1008 = 0.0, $cond1020 = 0.0, $cond1087 = 0.0, $cond1168 = 0.0, $cond1183 = 0, $cond14 = 0, $cond1407 = 0.0, $cond1439 = 0.0, $cond26 = 0, $cond286 = 0.0, $cond404 = 0.0, $cond514 = 0.0, $cond542 = 0.0, $cond542$sink = 0.0, $cond594 = 0.0, $cond612 = 0.0, $cond63 = 0, $cond639 = 0.0, $cond680 = 0.0, $cond697 = 0.0, $cond727 = 0.0, $cond742 = 0.0, $cond761 = 0.0, $cond775 = 0.0, $cond792 = 0, $cond933 = 0.0, $cond945 = 0.0, $conv1350 = 0.0, $conv201 = 0.0, $conv210 = 0.0, $conv431 = 0.0, $conv436 = 0.0, $conv568 = 0.0, $d2A = 0, $d2_angle161 = 0, $d2_angle2 = 0, $dA = 0, $d_angle160 = 0, $d_angle2 = 0, $dist = 0, $div1148 = 0.0, $div28 = 0.0, $downmix$addr = 0, $features = 0, $frame_loudness = 0, $frame_noisiness = 0, $frame_probs = 0, $frame_stationarity = 0, $frame_tonality = 0, $hp_ener = 0, $hp_ener_accum = 0, $i = 0, $in = 0, $info = 0, $info75 = 0, $is_masked = 0, $j = 0, $k = 0, $kfft = 0, $layer_out = 0, $leak_slope = 0, $leak_slope706 = 0, $leakage_from = 0, $leakage_to = 0, $len$addr = 0, $logE = 0, $lowECount = 0, $lowECount1096 = 0, $lsb_depth$addr = 0, $maxE = 0, $max_frame_tonality = 0, $mem_fill71 = 0, $midE = 0, $mindist = 0, $mod1 = 0, $mod2 = 0, $mul442 = 0.0, $nE = 0, $noise_floor = 0, $noise_ratio = 0, $noisiness = 0, $offset$addr = 0, $out = 0, $relativeE = 0, $remaining = 0, $slope = 0, $spec_variability = 0, $stationarity = 0, $sum = 0, $sum1124 = 0, $tE = 0, $tmp = 0, $tonal$addr = 0, $tonality = 0, $tonality2 = 0, $tt = 0, $w = 0, $write_pos = 0, $write_pos81 = 0, $x$addr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 11648 | 0;
 $tonal$addr = sp + 11636 | 0;
 $celt_mode$addr = sp + 11632 | 0;
 $x$addr = sp + 11628 | 0;
 $len$addr = sp + 11624 | 0;
 $offset$addr = sp + 11620 | 0;
 $c1$addr = sp + 11616 | 0;
 $c2$addr = sp + 11612 | 0;
 $C$addr = sp + 11608 | 0;
 $lsb_depth$addr = sp + 11604 | 0;
 $downmix$addr = sp + 11600 | 0;
 $i = sp + 11596 | 0;
 $b = sp + 11592 | 0;
 $kfft = sp + 11588 | 0;
 $N = sp + 11584 | 0;
 $N2 = sp + 11580 | 0;
 $A = sp + 11576 | 0;
 $dA = sp + 11572 | 0;
 $d2A = sp + 11568 | 0;
 $band_tonality = sp + 11496 | 0;
 $logE = sp + 11424 | 0;
 $BFCC = sp + 11392 | 0;
 $features = sp + 11292 | 0;
 $frame_tonality = sp + 11288 | 0;
 $max_frame_tonality = sp + 11284 | 0;
 $frame_noisiness = sp + 11280 | 0;
 $slope = sp + 11272 | 0;
 $frame_stationarity = sp + 11268 | 0;
 $relativeE = sp + 11264 | 0;
 $frame_probs = sp + 11256 | 0;
 $alpha = sp + 11252 | 0;
 $alphaE = sp + 11248 | 0;
 $alphaE2 = sp + 11244 | 0;
 $frame_loudness = sp + 11240 | 0;
 $bandwidth_mask = sp + 11236 | 0;
 $is_masked = sp + 11160 | 0;
 $bandwidth = sp + 11156 | 0;
 $maxE = sp + 11152 | 0;
 $noise_floor = sp + 11148 | 0;
 $remaining = sp + 11144 | 0;
 $info = sp + 11140 | 0;
 $hp_ener = sp + 11136 | 0;
 $tonality2 = sp + 10176 | 0;
 $midE = sp + 10144 | 0;
 $spec_variability = sp + 10140 | 0;
 $band_log2 = sp + 10064 | 0;
 $leakage_from = sp + 9988 | 0;
 $leakage_to = sp + 9912 | 0;
 $layer_out = sp + 9784 | 0;
 $below_max_pitch = sp + 9780 | 0;
 $above_max_pitch = sp + 9776 | 0;
 $in = sp + 5936 | 0;
 $out = sp + 2096 | 0;
 $tonality = sp + 1136 | 0;
 $noisiness = sp + 176 | 0;
 $w = sp + 172 | 0;
 $X1r = sp + 168 | 0;
 $X2r = sp + 164 | 0;
 $X1i = sp + 160 | 0;
 $X2i = sp + 156 | 0;
 $angle159 = sp + 152 | 0;
 $d_angle160 = sp + 148 | 0;
 $d2_angle161 = sp + 144 | 0;
 $angle2 = sp + 140 | 0;
 $d_angle2 = sp + 136 | 0;
 $d2_angle2 = sp + 132 | 0;
 $mod1 = sp + 128 | 0;
 $mod2 = sp + 124 | 0;
 $avg_mod = sp + 120 | 0;
 $tt = sp + 116 | 0;
 $E = sp + 112 | 0;
 $X1r304 = sp + 108 | 0;
 $X2r305 = sp + 104 | 0;
 $binE = sp + 100 | 0;
 $E360 = sp + 96 | 0;
 $tE = sp + 92 | 0;
 $nE = sp + 88 | 0;
 $L1 = sp + 84 | 0;
 $L2 = sp + 80 | 0;
 $stationarity = sp + 76 | 0;
 $binE368 = sp + 72 | 0;
 $leak_slope = sp + 68 | 0;
 $leak_slope706 = sp + 64 | 0;
 $boost = sp + 60 | 0;
 $j = sp + 56 | 0;
 $mindist = sp + 52 | 0;
 $k = sp + 48 | 0;
 $dist = sp + 44 | 0;
 $tmp = sp + 40 | 0;
 $E868 = sp + 36 | 0;
 $Em = sp + 32 | 0;
 $band_start = sp + 28 | 0;
 $band_end = sp + 24 | 0;
 $binE876 = sp + 20 | 0;
 $noise_ratio = sp + 16 | 0;
 $Em987 = sp + 12 | 0;
 $E988 = sp + 8 | 0;
 $sum = sp + 4 | 0;
 $sum1124 = sp;
 HEAP32[$tonal$addr >> 2] = $tonal;
 HEAP32[$celt_mode$addr >> 2] = $celt_mode;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$offset$addr >> 2] = $offset;
 HEAP32[$c1$addr >> 2] = $c1;
 HEAP32[$c2$addr >> 2] = $c2;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$lsb_depth$addr >> 2] = $lsb_depth;
 HEAP32[$downmix$addr >> 2] = $downmix;
 HEAP32[$N >> 2] = 480;
 HEAP32[$N2 >> 2] = 240;
 HEAP32[$A >> 2] = (HEAP32[$tonal$addr >> 2] | 0) + 12;
 HEAP32[$dA >> 2] = (HEAP32[$tonal$addr >> 2] | 0) + 972;
 HEAP32[$d2A >> 2] = (HEAP32[$tonal$addr >> 2] | 0) + 1932;
 HEAPF32[sp + 11276 >> 2] = 97.40908813476562;
 HEAPF32[$slope >> 2] = 0.0;
 HEAP32[$bandwidth >> 2] = 0;
 HEAPF32[$maxE >> 2] = 0.0;
 HEAPF32[$spec_variability >> 2] = 0.0;
 if (10 < (1 + (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) | 0)) $cond = 10; else $cond = 1 + (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) | 0;
 HEAPF32[$alpha >> 2] = 1.0 / +($cond | 0);
 if (25 < (1 + (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) | 0)) $cond14 = 25; else $cond14 = 1 + (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) | 0;
 HEAPF32[$alphaE >> 2] = 1.0 / +($cond14 | 0);
 if (100 < (1 + (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) | 0)) $cond26 = 100; else $cond26 = 1 + (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) | 0;
 $div28 = 1.0 / +($cond26 | 0);
 HEAPF32[$alphaE2 >> 2] = $div28;
 HEAPF32[$alphaE2 >> 2] = (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) <= 1 ? 1.0 : $div28;
 if ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 8 >> 2] | 0) == 48e3) {
  HEAP32[$len$addr >> 2] = (HEAP32[$len$addr >> 2] | 0) / 2 | 0;
  HEAP32[$offset$addr >> 2] = (HEAP32[$offset$addr >> 2] | 0) / 2 | 0;
 } else if ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 8 >> 2] | 0) == 16e3) {
  HEAP32[$len$addr >> 2] = ((HEAP32[$len$addr >> 2] | 0) * 3 | 0) / 2 | 0;
  HEAP32[$offset$addr >> 2] = ((HEAP32[$offset$addr >> 2] | 0) * 3 | 0) / 2 | 0;
 }
 HEAP32[$kfft >> 2] = HEAP32[(HEAP32[$celt_mode$addr >> 2] | 0) + 64 + 8 >> 2];
 if (!(HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0)) HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5772 >> 2] = 240;
 if ((HEAP32[$len$addr >> 2] | 0) < (720 - (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5772 >> 2] | 0) | 0)) $cond63 = HEAP32[$len$addr >> 2] | 0; else $cond63 = 720 - (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5772 >> 2] | 0) | 0;
 $call = +_downmix_and_resample(HEAP32[$downmix$addr >> 2] | 0, HEAP32[$x$addr >> 2] | 0, (HEAP32[$tonal$addr >> 2] | 0) + 2892 + (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5772 >> 2] << 2) | 0, (HEAP32[$tonal$addr >> 2] | 0) + 7588 | 0, $cond63, HEAP32[$offset$addr >> 2] | 0, HEAP32[$c1$addr >> 2] | 0, HEAP32[$c2$addr >> 2] | 0, HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 8 >> 2] | 0);
 $hp_ener_accum = (HEAP32[$tonal$addr >> 2] | 0) + 7456 | 0;
 HEAPF32[$hp_ener_accum >> 2] = +HEAPF32[$hp_ener_accum >> 2] + $call;
 if (((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5772 >> 2] | 0) + (HEAP32[$len$addr >> 2] | 0) | 0) < 720) {
  $mem_fill71 = (HEAP32[$tonal$addr >> 2] | 0) + 5772 | 0;
  HEAP32[$mem_fill71 >> 2] = (HEAP32[$mem_fill71 >> 2] | 0) + (HEAP32[$len$addr >> 2] | 0);
  STACKTOP = sp;
  return;
 }
 HEAPF32[$hp_ener >> 2] = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7456 >> 2];
 $info75 = (HEAP32[$tonal$addr >> 2] | 0) + 7600 | 0;
 $write_pos = (HEAP32[$tonal$addr >> 2] | 0) + 7444 | 0;
 $60 = HEAP32[$write_pos >> 2] | 0;
 HEAP32[$write_pos >> 2] = $60 + 1;
 HEAP32[$info >> 2] = $info75 + ($60 << 6);
 if ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7444 >> 2] | 0) >= 100) {
  $write_pos81 = (HEAP32[$tonal$addr >> 2] | 0) + 7444 | 0;
  HEAP32[$write_pos81 >> 2] = (HEAP32[$write_pos81 >> 2] | 0) - 100;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N2 >> 2] | 0)) break;
  HEAPF32[$w >> 2] = +HEAPF32[332 + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$in + (HEAP32[$i >> 2] << 3) >> 2] = +HEAPF32[$w >> 2] * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 2892 + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$in + (HEAP32[$i >> 2] << 3) + 4 >> 2] = +HEAPF32[$w >> 2] * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 2892 + ((HEAP32[$N2 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
  HEAPF32[$in + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 3) >> 2] = +HEAPF32[$w >> 2] * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 2892 + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2];
  HEAPF32[$in + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 3) + 4 >> 2] = +HEAPF32[$w >> 2] * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 2892 + ((HEAP32[$N >> 2] | 0) + (HEAP32[$N2 >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _memmove((HEAP32[$tonal$addr >> 2] | 0) + 2892 | 0, (HEAP32[$tonal$addr >> 2] | 0) + 2892 + 2880 + -960 | 0, 960 | 0) | 0;
 HEAP32[$remaining >> 2] = (HEAP32[$len$addr >> 2] | 0) - (720 - (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5772 >> 2] | 0));
 $call141 = +_downmix_and_resample(HEAP32[$downmix$addr >> 2] | 0, HEAP32[$x$addr >> 2] | 0, (HEAP32[$tonal$addr >> 2] | 0) + 2892 + 960 | 0, (HEAP32[$tonal$addr >> 2] | 0) + 7588 | 0, HEAP32[$remaining >> 2] | 0, (HEAP32[$offset$addr >> 2] | 0) + 720 - (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5772 >> 2] | 0) | 0, HEAP32[$c1$addr >> 2] | 0, HEAP32[$c2$addr >> 2] | 0, HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 8 >> 2] | 0);
 HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7456 >> 2] = $call141;
 HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5772 >> 2] = 240 + (HEAP32[$remaining >> 2] | 0);
 _opus_fft_c(HEAP32[$kfft >> 2] | 0, $in, $out);
 if (+HEAPF32[$out >> 2] != +HEAPF32[$out >> 2]) {
  HEAP32[HEAP32[$info >> 2] >> 2] = 0;
  STACKTOP = sp;
  return;
 }
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N2 >> 2] | 0)) break;
  HEAPF32[$X1r >> 2] = +HEAPF32[$out + (HEAP32[$i >> 2] << 3) >> 2] + +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) >> 2];
  HEAPF32[$X1i >> 2] = +HEAPF32[$out + (HEAP32[$i >> 2] << 3) + 4 >> 2] - +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) + 4 >> 2];
  HEAPF32[$X2r >> 2] = +HEAPF32[$out + (HEAP32[$i >> 2] << 3) + 4 >> 2] + +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) + 4 >> 2];
  HEAPF32[$X2i >> 2] = +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) >> 2] - +HEAPF32[$out + (HEAP32[$i >> 2] << 3) >> 2];
  HEAPF32[$angle159 >> 2] = +_fast_atan2f(+HEAPF32[$X1i >> 2], +HEAPF32[$X1r >> 2]) * .15915493667125702;
  HEAPF32[$d_angle160 >> 2] = +HEAPF32[$angle159 >> 2] - +HEAPF32[(HEAP32[$A >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$d2_angle161 >> 2] = +HEAPF32[$d_angle160 >> 2] - +HEAPF32[(HEAP32[$dA >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$angle2 >> 2] = +_fast_atan2f(+HEAPF32[$X2i >> 2], +HEAPF32[$X2r >> 2]) * .15915493667125702;
  HEAPF32[$d_angle2 >> 2] = +HEAPF32[$angle2 >> 2] - +HEAPF32[$angle159 >> 2];
  HEAPF32[$d2_angle2 >> 2] = +HEAPF32[$d_angle2 >> 2] - +HEAPF32[$d_angle160 >> 2];
  $161 = +HEAPF32[$d2_angle161 >> 2];
  HEAPF32[$mod1 >> 2] = $161 - +(_lrintf(+HEAPF32[$d2_angle161 >> 2]) | 0);
  $conv201 = +Math_abs(+(+HEAPF32[$mod1 >> 2]));
  HEAPF32[$noisiness + (HEAP32[$i >> 2] << 2) >> 2] = $conv201;
  HEAPF32[$mod1 >> 2] = +HEAPF32[$mod1 >> 2] * +HEAPF32[$mod1 >> 2];
  HEAPF32[$mod1 >> 2] = +HEAPF32[$mod1 >> 2] * +HEAPF32[$mod1 >> 2];
  $169 = +HEAPF32[$d2_angle2 >> 2];
  HEAPF32[$mod2 >> 2] = $169 - +(_lrintf(+HEAPF32[$d2_angle2 >> 2]) | 0);
  $conv210 = +Math_abs(+(+HEAPF32[$mod2 >> 2]));
  $arrayidx211 = $noisiness + (HEAP32[$i >> 2] << 2) | 0;
  HEAPF32[$arrayidx211 >> 2] = +HEAPF32[$arrayidx211 >> 2] + $conv210;
  HEAPF32[$mod2 >> 2] = +HEAPF32[$mod2 >> 2] * +HEAPF32[$mod2 >> 2];
  HEAPF32[$mod2 >> 2] = +HEAPF32[$mod2 >> 2] * +HEAPF32[$mod2 >> 2];
  HEAPF32[$avg_mod >> 2] = (+HEAPF32[(HEAP32[$d2A >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[$mod1 >> 2] + +HEAPF32[$mod2 >> 2] * 2.0) * .25;
  HEAPF32[$tonality + (HEAP32[$i >> 2] << 2) >> 2] = 1.0 / (+HEAPF32[$avg_mod >> 2] * 62341.81640625 + 1.0) - .014999999664723873;
  HEAPF32[$tonality2 + (HEAP32[$i >> 2] << 2) >> 2] = 1.0 / (+HEAPF32[$mod2 >> 2] * 62341.81640625 + 1.0) - .014999999664723873;
  HEAPF32[(HEAP32[$A >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$angle2 >> 2];
  HEAPF32[(HEAP32[$dA >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$d_angle2 >> 2];
  HEAPF32[(HEAP32[$d2A >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$mod2 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 2;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$N2 >> 2] | 0) - 1 | 0)) break;
  $205 = HEAP32[$i >> 2] | 0;
  $207 = HEAP32[$i >> 2] | 0;
  if (+HEAPF32[$tonality2 + (HEAP32[$i >> 2] << 2) >> 2] < +HEAPF32[$tonality2 + ((+HEAPF32[$tonality2 + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] > +HEAPF32[$tonality2 + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] ? $205 - 1 | 0 : $205 + 1 | 0) << 2) >> 2]) $add271$sink$sink = $207; else {
   $211 = HEAP32[$i >> 2] | 0;
   $add271$sink$sink = +HEAPF32[$tonality2 + ($207 - 1 << 2) >> 2] > +HEAPF32[$tonality2 + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] ? $211 - 1 | 0 : $211 + 1 | 0;
  }
  HEAPF32[$tt >> 2] = +HEAPF32[$tonality2 + ($add271$sink$sink << 2) >> 2];
  if (+HEAPF32[$tonality + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[$tt >> 2] - .10000000149011612) $cond286 = +HEAPF32[$tonality + (HEAP32[$i >> 2] << 2) >> 2]; else $cond286 = +HEAPF32[$tt >> 2] - .10000000149011612;
  HEAPF32[$tonality + (HEAP32[$i >> 2] << 2) >> 2] = .8999999761581421 * $cond286;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[$frame_tonality >> 2] = 0.0;
 HEAPF32[$max_frame_tonality >> 2] = 0.0;
 HEAPF32[(HEAP32[$info >> 2] | 0) + 16 >> 2] = 0.0;
 HEAPF32[$frame_noisiness >> 2] = 0.0;
 HEAPF32[$frame_stationarity >> 2] = 0.0;
 L52 : do if (!(HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0)) {
  HEAP32[$b >> 2] = 0;
  while (1) {
   if ((HEAP32[$b >> 2] | 0) >= 18) break L52;
   HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2] = 1.0e10;
   HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) >> 2] = -1.0e10;
   HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
  }
 } while (0);
 HEAPF32[$relativeE >> 2] = 0.0;
 HEAPF32[$frame_loudness >> 2] = 0.0;
 HEAPF32[$E >> 2] = 0.0;
 HEAPF32[$X1r304 >> 2] = +HEAPF32[$out >> 2] * 2.0;
 HEAPF32[$X2r305 >> 2] = +HEAPF32[$out + 4 >> 2] * 2.0;
 HEAPF32[$E >> 2] = +HEAPF32[$X1r304 >> 2] * +HEAPF32[$X1r304 >> 2] + +HEAPF32[$X2r305 >> 2] * +HEAPF32[$X2r305 >> 2];
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 4) break;
  HEAPF32[$binE >> 2] = +HEAPF32[$out + (HEAP32[$i >> 2] << 3) >> 2] * +HEAPF32[$out + (HEAP32[$i >> 2] << 3) >> 2] + +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) >> 2] * +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) >> 2] + +HEAPF32[$out + (HEAP32[$i >> 2] << 3) + 4 >> 2] * +HEAPF32[$out + (HEAP32[$i >> 2] << 3) + 4 >> 2] + +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) + 4 >> 2] * +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) + 4 >> 2];
  HEAPF32[$E >> 2] = +HEAPF32[$E >> 2] + +HEAPF32[$binE >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[$E >> 2] = +HEAPF32[$E >> 2];
 HEAPF32[$band_log2 >> 2] = +Math_log(+(+HEAPF32[$E >> 2] + 1.000000013351432e-10)) * .7213475108146667;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 18) break;
  HEAPF32[$E360 >> 2] = 0.0;
  HEAPF32[$tE >> 2] = 0.0;
  HEAPF32[$nE >> 2] = 0.0;
  HEAP32[$i >> 2] = HEAP32[1292 + (HEAP32[$b >> 2] << 2) >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[1292 + ((HEAP32[$b >> 2] | 0) + 1 << 2) >> 2] | 0)) break;
   HEAPF32[$binE368 >> 2] = +HEAPF32[$out + (HEAP32[$i >> 2] << 3) >> 2] * +HEAPF32[$out + (HEAP32[$i >> 2] << 3) >> 2] + +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) >> 2] * +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) >> 2] + +HEAPF32[$out + (HEAP32[$i >> 2] << 3) + 4 >> 2] * +HEAPF32[$out + (HEAP32[$i >> 2] << 3) + 4 >> 2] + +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) + 4 >> 2] * +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) + 4 >> 2];
   HEAPF32[$binE368 >> 2] = +HEAPF32[$binE368 >> 2];
   HEAPF32[$E360 >> 2] = +HEAPF32[$E360 >> 2] + +HEAPF32[$binE368 >> 2];
   if (0.0 > +HEAPF32[$tonality + (HEAP32[$i >> 2] << 2) >> 2]) $cond404 = 0.0; else $cond404 = +HEAPF32[$tonality + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$tE >> 2] = +HEAPF32[$tE >> 2] + +HEAPF32[$binE368 >> 2] * $cond404;
   HEAPF32[$nE >> 2] = +HEAPF32[$nE >> 2] + +HEAPF32[$binE368 >> 2] * 2.0 * (.5 - +HEAPF32[$noisiness + (HEAP32[$i >> 2] << 2) >> 2]);
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  if (!(+HEAPF32[$E360 >> 2] < 1.0e9)) {
   label = 52;
   break;
  }
  if (+HEAPF32[$E360 >> 2] != +HEAPF32[$E360 >> 2]) {
   label = 52;
   break;
  }
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 5856 + ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7432 >> 2] | 0) * 72 | 0) + (HEAP32[$b >> 2] << 2) >> 2] = +HEAPF32[$E360 >> 2];
  HEAPF32[$frame_noisiness >> 2] = +HEAPF32[$frame_noisiness >> 2] + +HEAPF32[$nE >> 2] / (+HEAPF32[$E360 >> 2] + 1.0000000036274937e-15);
  $conv431 = +Math_sqrt(+(+HEAPF32[$E360 >> 2] + 1.000000013351432e-10));
  HEAPF32[$frame_loudness >> 2] = +HEAPF32[$frame_loudness >> 2] + $conv431;
  $conv436 = +Math_log(+(+HEAPF32[$E360 >> 2] + 1.000000013351432e-10));
  HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2] = $conv436;
  $mul442 = +Math_log(+(+HEAPF32[$E360 >> 2] + 1.000000013351432e-10)) * .7213475108146667;
  HEAPF32[$band_log2 + ((HEAP32[$b >> 2] | 0) + 1 << 2) >> 2] = $mul442;
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 6432 + ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7432 >> 2] | 0) * 72 | 0) + (HEAP32[$b >> 2] << 2) >> 2] = +HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2];
  if (!(HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0)) {
   $329 = +HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2];
   HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2] = $329;
   HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) >> 2] = $329;
  }
  do if (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) >> 2] > +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2] + 7.5) {
   $350 = HEAP32[$tonal$addr >> 2] | 0;
   if (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) >> 2] - +HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2] > +HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2] - +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2]) {
    $arrayidx482 = $350 + 7080 + (HEAP32[$b >> 2] << 2) | 0;
    HEAPF32[$arrayidx482 >> 2] = +HEAPF32[$arrayidx482 >> 2] - .009999999776482582;
    break;
   } else {
    $arrayidx486 = $350 + 7008 + (HEAP32[$b >> 2] << 2) | 0;
    HEAPF32[$arrayidx486 >> 2] = +HEAPF32[$arrayidx486 >> 2] + .009999999776482582;
    break;
   }
  } while (0);
  $361 = +HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2];
  $362 = HEAP32[$tonal$addr >> 2] | 0;
  if (+HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2] > +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) >> 2]) {
   HEAPF32[$362 + 7080 + (HEAP32[$b >> 2] << 2) >> 2] = $361;
   $370 = HEAP32[$tonal$addr >> 2] | 0;
   if (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) >> 2] - 15.0 > +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2]) $cond514 = +HEAPF32[$370 + 7080 + (HEAP32[$b >> 2] << 2) >> 2] - 15.0; else $cond514 = +HEAPF32[$370 + 7008 + (HEAP32[$b >> 2] << 2) >> 2];
   $arrayidx544$sink = (HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) | 0;
   $cond542$sink = $cond514;
   label = 69;
  } else if ($361 < +HEAPF32[$362 + 7008 + (HEAP32[$b >> 2] << 2) >> 2]) {
   HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2] = +HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2];
   $389 = HEAP32[$tonal$addr >> 2] | 0;
   if (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2] + 15.0 < +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) >> 2]) $cond542 = +HEAPF32[$389 + 7008 + (HEAP32[$b >> 2] << 2) >> 2] + 15.0; else $cond542 = +HEAPF32[$389 + 7080 + (HEAP32[$b >> 2] << 2) >> 2];
   $arrayidx544$sink = (HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) | 0;
   $cond542$sink = $cond542;
   label = 69;
  }
  if ((label | 0) == 69) {
   label = 0;
   HEAPF32[$arrayidx544$sink >> 2] = $cond542$sink;
  }
  HEAPF32[$relativeE >> 2] = +HEAPF32[$relativeE >> 2] + (+HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2] - +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2]) / (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) >> 2] - +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2] + 1.0000000036274937e-15);
  HEAPF32[$L2 >> 2] = 0.0;
  HEAPF32[$L1 >> 2] = 0.0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 8) break;
   $conv568 = +Math_sqrt(+(+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 5856 + ((HEAP32[$i >> 2] | 0) * 72 | 0) + (HEAP32[$b >> 2] << 2) >> 2]));
   HEAPF32[$L1 >> 2] = +HEAPF32[$L1 >> 2] + $conv568;
   HEAPF32[$L2 >> 2] = +HEAPF32[$L2 >> 2] + +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 5856 + ((HEAP32[$i >> 2] | 0) * 72 | 0) + (HEAP32[$b >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  if (.9900000095367432 < +HEAPF32[$L1 >> 2] / +Math_sqrt(+(+HEAPF32[$L2 >> 2] * 8.0 + 1.0e-15))) $cond594 = .9900000095367432; else $cond594 = +HEAPF32[$L1 >> 2] / +Math_sqrt(+(+HEAPF32[$L2 >> 2] * 8.0 + 1.0e-15));
  HEAPF32[$stationarity >> 2] = $cond594;
  HEAPF32[$stationarity >> 2] = +HEAPF32[$stationarity >> 2] * +HEAPF32[$stationarity >> 2];
  HEAPF32[$stationarity >> 2] = +HEAPF32[$stationarity >> 2] * +HEAPF32[$stationarity >> 2];
  HEAPF32[$frame_stationarity >> 2] = +HEAPF32[$frame_stationarity >> 2] + +HEAPF32[$stationarity >> 2];
  if (+HEAPF32[$tE >> 2] / (+HEAPF32[$E360 >> 2] + 1.0000000036274937e-15) > +HEAPF32[$stationarity >> 2] * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 5776 + (HEAP32[$b >> 2] << 2) >> 2]) $cond612 = +HEAPF32[$tE >> 2] / (+HEAPF32[$E360 >> 2] + 1.0000000036274937e-15); else $cond612 = +HEAPF32[$stationarity >> 2] * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 5776 + (HEAP32[$b >> 2] << 2) >> 2];
  HEAPF32[$band_tonality + (HEAP32[$b >> 2] << 2) >> 2] = $cond612;
  HEAPF32[$frame_tonality >> 2] = +HEAPF32[$frame_tonality >> 2] + +HEAPF32[$band_tonality + (HEAP32[$b >> 2] << 2) >> 2];
  if ((HEAP32[$b >> 2] | 0) >= 9) HEAPF32[$frame_tonality >> 2] = +HEAPF32[$frame_tonality >> 2] - +HEAPF32[$band_tonality + ((HEAP32[$b >> 2] | 0) - 18 + 9 << 2) >> 2];
  if (+HEAPF32[$max_frame_tonality >> 2] > (+((HEAP32[$b >> 2] | 0) - 18 | 0) * .029999999329447746 + 1.0) * +HEAPF32[$frame_tonality >> 2]) $cond639 = +HEAPF32[$max_frame_tonality >> 2]; else $cond639 = (+((HEAP32[$b >> 2] | 0) - 18 | 0) * .029999999329447746 + 1.0) * +HEAPF32[$frame_tonality >> 2];
  HEAPF32[$max_frame_tonality >> 2] = $cond639;
  HEAPF32[$slope >> 2] = +HEAPF32[$slope >> 2] + +HEAPF32[$band_tonality + (HEAP32[$b >> 2] << 2) >> 2] * +((HEAP32[$b >> 2] | 0) - 8 | 0);
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 5776 + (HEAP32[$b >> 2] << 2) >> 2] = +HEAPF32[$band_tonality + (HEAP32[$b >> 2] << 2) >> 2];
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 if ((label | 0) == 52) {
  HEAP32[HEAP32[$info >> 2] >> 2] = 0;
  STACKTOP = sp;
  return;
 }
 HEAPF32[$leakage_from >> 2] = +HEAPF32[$band_log2 >> 2];
 HEAPF32[$leakage_to >> 2] = +HEAPF32[$band_log2 >> 2] - 2.5;
 HEAP32[$b >> 2] = 1;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 19) break;
  HEAPF32[$leak_slope >> 2] = +((HEAP32[1292 + (HEAP32[$b >> 2] << 2) >> 2] | 0) - (HEAP32[1292 + ((HEAP32[$b >> 2] | 0) - 1 << 2) >> 2] | 0) | 0) * 2.0 / 4.0;
  $477 = HEAP32[$b >> 2] | 0;
  if (+HEAPF32[$leakage_from + ((HEAP32[$b >> 2] | 0) - 1 << 2) >> 2] + +HEAPF32[$leak_slope >> 2] < +HEAPF32[$band_log2 + (HEAP32[$b >> 2] << 2) >> 2]) $cond680 = +HEAPF32[$leakage_from + ($477 - 1 << 2) >> 2] + +HEAPF32[$leak_slope >> 2]; else $cond680 = +HEAPF32[$band_log2 + ($477 << 2) >> 2];
  HEAPF32[$leakage_from + (HEAP32[$b >> 2] << 2) >> 2] = $cond680;
  $487 = HEAP32[$b >> 2] | 0;
  if (+HEAPF32[$leakage_to + ((HEAP32[$b >> 2] | 0) - 1 << 2) >> 2] - +HEAPF32[$leak_slope >> 2] > +HEAPF32[$band_log2 + (HEAP32[$b >> 2] << 2) >> 2] - 2.5) $cond697 = +HEAPF32[$leakage_to + ($487 - 1 << 2) >> 2] - +HEAPF32[$leak_slope >> 2]; else $cond697 = +HEAPF32[$band_log2 + ($487 << 2) >> 2] - 2.5;
  HEAPF32[$leakage_to + (HEAP32[$b >> 2] << 2) >> 2] = $cond697;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 HEAP32[$b >> 2] = 16;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) < 0) break;
  HEAPF32[$leak_slope706 >> 2] = +((HEAP32[1292 + ((HEAP32[$b >> 2] | 0) + 1 << 2) >> 2] | 0) - (HEAP32[1292 + (HEAP32[$b >> 2] << 2) >> 2] | 0) | 0) * 2.0 / 4.0;
  $503 = HEAP32[$b >> 2] | 0;
  if (+HEAPF32[$leakage_from + ((HEAP32[$b >> 2] | 0) + 1 << 2) >> 2] + +HEAPF32[$leak_slope706 >> 2] < +HEAPF32[$leakage_from + (HEAP32[$b >> 2] << 2) >> 2]) $cond727 = +HEAPF32[$leakage_from + ($503 + 1 << 2) >> 2] + +HEAPF32[$leak_slope706 >> 2]; else $cond727 = +HEAPF32[$leakage_from + ($503 << 2) >> 2];
  HEAPF32[$leakage_from + (HEAP32[$b >> 2] << 2) >> 2] = $cond727;
  $513 = HEAP32[$b >> 2] | 0;
  if (+HEAPF32[$leakage_to + ((HEAP32[$b >> 2] | 0) + 1 << 2) >> 2] - +HEAPF32[$leak_slope706 >> 2] > +HEAPF32[$leakage_to + (HEAP32[$b >> 2] << 2) >> 2]) $cond742 = +HEAPF32[$leakage_to + ($513 + 1 << 2) >> 2] - +HEAPF32[$leak_slope706 >> 2]; else $cond742 = +HEAPF32[$leakage_to + ($513 << 2) >> 2];
  HEAPF32[$leakage_to + (HEAP32[$b >> 2] << 2) >> 2] = $cond742;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + -1;
 }
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 19) break;
  if (0.0 > +HEAPF32[$leakage_to + (HEAP32[$b >> 2] << 2) >> 2] - +HEAPF32[$band_log2 + (HEAP32[$b >> 2] << 2) >> 2]) $cond761 = 0.0; else $cond761 = +HEAPF32[$leakage_to + (HEAP32[$b >> 2] << 2) >> 2] - +HEAPF32[$band_log2 + (HEAP32[$b >> 2] << 2) >> 2];
  if (0.0 > +HEAPF32[$band_log2 + (HEAP32[$b >> 2] << 2) >> 2] - (+HEAPF32[$leakage_from + (HEAP32[$b >> 2] << 2) >> 2] + 2.5)) $cond775 = 0.0; else $cond775 = +HEAPF32[$band_log2 + (HEAP32[$b >> 2] << 2) >> 2] - (+HEAPF32[$leakage_from + (HEAP32[$b >> 2] << 2) >> 2] + 2.5);
  HEAPF32[$boost >> 2] = $cond761 + $cond775;
  if (255 < (~~+Math_floor(+(+HEAPF32[$boost >> 2] * 64.0 + .5)) | 0)) $cond792 = 255; else $cond792 = ~~+Math_floor(+(+HEAPF32[$boost >> 2] * 64.0 + .5));
  HEAP8[(HEAP32[$info >> 2] | 0) + 44 + (HEAP32[$b >> 2] | 0) >> 0] = $cond792;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 19) break;
  HEAP8[(HEAP32[$info >> 2] | 0) + 44 + (HEAP32[$b >> 2] | 0) >> 0] = 0;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 8) break;
  HEAPF32[$mindist >> 2] = 999999986991104.0;
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= 8) break;
   HEAPF32[$dist >> 2] = 0.0;
   HEAP32[$k >> 2] = 0;
   while (1) {
    if ((HEAP32[$k >> 2] | 0) >= 18) break;
    HEAPF32[$tmp >> 2] = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 6432 + ((HEAP32[$i >> 2] | 0) * 72 | 0) + (HEAP32[$k >> 2] << 2) >> 2] - +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 6432 + ((HEAP32[$j >> 2] | 0) * 72 | 0) + (HEAP32[$k >> 2] << 2) >> 2];
    HEAPF32[$dist >> 2] = +HEAPF32[$dist >> 2] + +HEAPF32[$tmp >> 2] * +HEAPF32[$tmp >> 2];
    HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   }
   if ((HEAP32[$j >> 2] | 0) != (HEAP32[$i >> 2] | 0)) HEAPF32[$mindist >> 2] = +HEAPF32[$mindist >> 2] < +HEAPF32[$dist >> 2] ? +HEAPF32[$mindist >> 2] : +HEAPF32[$dist >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAPF32[$spec_variability >> 2] = +HEAPF32[$spec_variability >> 2] + +HEAPF32[$mindist >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[$spec_variability >> 2] = +Math_sqrt(+(+HEAPF32[$spec_variability >> 2] / 8.0 / 18.0));
 HEAPF32[$bandwidth_mask >> 2] = 0.0;
 HEAP32[$bandwidth >> 2] = 0;
 HEAPF32[$maxE >> 2] = 0.0;
 HEAPF32[$noise_floor >> 2] = 5.699999746866524e-04 / +(1 << (0 > ((HEAP32[$lsb_depth$addr >> 2] | 0) - 8 | 0) ? 0 : (HEAP32[$lsb_depth$addr >> 2] | 0) - 8 | 0) | 0);
 HEAPF32[$noise_floor >> 2] = +HEAPF32[$noise_floor >> 2] * +HEAPF32[$noise_floor >> 2];
 HEAPF32[$below_max_pitch >> 2] = 0.0;
 HEAPF32[$above_max_pitch >> 2] = 0.0;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 18) break;
  HEAPF32[$E868 >> 2] = 0.0;
  HEAP32[$band_start >> 2] = HEAP32[1292 + (HEAP32[$b >> 2] << 2) >> 2];
  HEAP32[$band_end >> 2] = HEAP32[1292 + ((HEAP32[$b >> 2] | 0) + 1 << 2) >> 2];
  HEAP32[$i >> 2] = HEAP32[$band_start >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$band_end >> 2] | 0)) break;
   HEAPF32[$binE876 >> 2] = +HEAPF32[$out + (HEAP32[$i >> 2] << 3) >> 2] * +HEAPF32[$out + (HEAP32[$i >> 2] << 3) >> 2] + +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) >> 2] * +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) >> 2] + +HEAPF32[$out + (HEAP32[$i >> 2] << 3) + 4 >> 2] * +HEAPF32[$out + (HEAP32[$i >> 2] << 3) + 4 >> 2] + +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) + 4 >> 2] * +HEAPF32[$out + ((HEAP32[$N >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 3) + 4 >> 2];
   HEAPF32[$E868 >> 2] = +HEAPF32[$E868 >> 2] + +HEAPF32[$binE876 >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[$E868 >> 2] = +HEAPF32[$E868 >> 2];
  HEAPF32[$maxE >> 2] = +HEAPF32[$maxE >> 2] > +HEAPF32[$E868 >> 2] ? +HEAPF32[$maxE >> 2] : +HEAPF32[$E868 >> 2];
  $612 = +HEAPF32[$E868 >> 2];
  if ((HEAP32[$band_start >> 2] | 0) < 64) HEAPF32[$below_max_pitch >> 2] = +HEAPF32[$below_max_pitch >> 2] + $612; else HEAPF32[$above_max_pitch >> 2] = +HEAPF32[$above_max_pitch >> 2] + $612;
  if ((1.0 - +HEAPF32[$alphaE2 >> 2]) * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2] > +HEAPF32[$E868 >> 2]) $cond933 = (1.0 - +HEAPF32[$alphaE2 >> 2]) * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2]; else $cond933 = +HEAPF32[$E868 >> 2];
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2] = $cond933;
  if (+HEAPF32[$E868 >> 2] > +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2]) $cond945 = +HEAPF32[$E868 >> 2]; else $cond945 = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2];
  HEAPF32[$Em >> 2] = $cond945;
  do if (+HEAPF32[$E868 >> 2] * 1.0e9 > +HEAPF32[$maxE >> 2]) {
   if (!(+HEAPF32[$Em >> 2] > +HEAPF32[$noise_floor >> 2] * 3.0 * +((HEAP32[$band_end >> 2] | 0) - (HEAP32[$band_start >> 2] | 0) | 0))) if (!(+HEAPF32[$E868 >> 2] > +HEAPF32[$noise_floor >> 2] * +((HEAP32[$band_end >> 2] | 0) - (HEAP32[$band_start >> 2] | 0) | 0))) break;
   HEAP32[$bandwidth >> 2] = (HEAP32[$b >> 2] | 0) + 1;
  } while (0);
  HEAP32[$is_masked + (HEAP32[$b >> 2] << 2) >> 2] = +HEAPF32[$E868 >> 2] < ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5852 >> 2] | 0) >= ((HEAP32[$b >> 2] | 0) + 1 | 0) ? .009999999776482582 : .05000000074505806) * +HEAPF32[$bandwidth_mask >> 2] & 1;
  HEAPF32[$bandwidth_mask >> 2] = +HEAPF32[$bandwidth_mask >> 2] * .05000000074505806 > +HEAPF32[$E868 >> 2] ? +HEAPF32[$bandwidth_mask >> 2] * .05000000074505806 : +HEAPF32[$E868 >> 2];
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 if ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 8 >> 2] | 0) == 48e3) {
  HEAPF32[$E988 >> 2] = +HEAPF32[$hp_ener >> 2] * 2.7777778450399637e-04;
  HEAPF32[$noise_ratio >> 2] = (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5852 >> 2] | 0) == 20 ? 10.0 : 30.0;
  HEAPF32[$above_max_pitch >> 2] = +HEAPF32[$above_max_pitch >> 2] + +HEAPF32[$E988 >> 2];
  if ((1.0 - +HEAPF32[$alphaE2 >> 2]) * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2] > +HEAPF32[$E988 >> 2]) $cond1008 = (1.0 - +HEAPF32[$alphaE2 >> 2]) * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2]; else $cond1008 = +HEAPF32[$E988 >> 2];
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2] = $cond1008;
  if (+HEAPF32[$E988 >> 2] > +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2]) $cond1020 = +HEAPF32[$E988 >> 2]; else $cond1020 = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7152 + (HEAP32[$b >> 2] << 2) >> 2];
  HEAPF32[$Em987 >> 2] = $cond1020;
  if (+HEAPF32[$Em987 >> 2] > +HEAPF32[$noise_ratio >> 2] * 3.0 * +HEAPF32[$noise_floor >> 2] * 160.0) label = 152; else if (+HEAPF32[$E988 >> 2] > +HEAPF32[$noise_ratio >> 2] * +HEAPF32[$noise_floor >> 2] * 160.0) label = 152;
  if ((label | 0) == 152) HEAP32[$bandwidth >> 2] = 20;
  HEAP32[$is_masked + (HEAP32[$b >> 2] << 2) >> 2] = +HEAPF32[$E988 >> 2] < ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5852 >> 2] | 0) == 20 ? .009999999776482582 : .05000000074505806) * +HEAPF32[$bandwidth_mask >> 2] & 1;
 }
 if (+HEAPF32[$above_max_pitch >> 2] > +HEAPF32[$below_max_pitch >> 2]) {
  $$sink = +HEAPF32[$below_max_pitch >> 2] / +HEAPF32[$above_max_pitch >> 2];
  $$sink1 = HEAP32[$info >> 2] | 0;
 } else {
  $$sink = 1.0;
  $$sink1 = HEAP32[$info >> 2] | 0;
 }
 HEAPF32[$$sink1 + 40 >> 2] = $$sink;
 if ((HEAP32[$bandwidth >> 2] | 0) == 20) if (HEAP32[$is_masked + 72 >> 2] | 0) HEAP32[$bandwidth >> 2] = (HEAP32[$bandwidth >> 2] | 0) - 2; else label = 160; else label = 160;
 if ((label | 0) == 160) if ((HEAP32[$bandwidth >> 2] | 0) > 0 & (HEAP32[$bandwidth >> 2] | 0) <= 18) if (HEAP32[$is_masked + ((HEAP32[$bandwidth >> 2] | 0) - 1 << 2) >> 2] | 0) HEAP32[$bandwidth >> 2] = (HEAP32[$bandwidth >> 2] | 0) + -1;
 if ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) <= 2) HEAP32[$bandwidth >> 2] = 20;
 HEAPF32[$frame_loudness >> 2] = +_log10(+HEAPF32[$frame_loudness >> 2]) * 20.0;
 if (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7424 >> 2] - .003000000026077032 > +HEAPF32[$frame_loudness >> 2]) $cond1087 = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7424 >> 2] - .003000000026077032; else $cond1087 = +HEAPF32[$frame_loudness >> 2];
 HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7424 >> 2] = $cond1087;
 $lowECount = (HEAP32[$tonal$addr >> 2] | 0) + 7428 | 0;
 HEAPF32[$lowECount >> 2] = +HEAPF32[$lowECount >> 2] * (1.0 - +HEAPF32[$alphaE >> 2]);
 if (+HEAPF32[$frame_loudness >> 2] < +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7424 >> 2] - 30.0) {
  $lowECount1096 = (HEAP32[$tonal$addr >> 2] | 0) + 7428 | 0;
  HEAPF32[$lowECount1096 >> 2] = +HEAPF32[$lowECount1096 >> 2] + +HEAPF32[$alphaE >> 2];
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 8) break;
  HEAPF32[$sum >> 2] = 0.0;
  HEAP32[$b >> 2] = 0;
  while (1) {
   if ((HEAP32[$b >> 2] | 0) >= 16) break;
   HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +HEAPF32[1368 + ((HEAP32[$i >> 2] << 4) + (HEAP32[$b >> 2] | 0) << 2) >> 2] * +HEAPF32[$logE + (HEAP32[$b >> 2] << 2) >> 2];
   HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
  }
  HEAPF32[$BFCC + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$sum >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 8) break;
  HEAPF32[$sum1124 >> 2] = 0.0;
  HEAP32[$b >> 2] = 0;
  while (1) {
   if ((HEAP32[$b >> 2] | 0) >= 16) break;
   HEAPF32[$sum1124 >> 2] = +HEAPF32[$sum1124 >> 2] + +HEAPF32[1368 + ((HEAP32[$i >> 2] << 4) + (HEAP32[$b >> 2] | 0) << 2) >> 2] * .5 * (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7080 + (HEAP32[$b >> 2] << 2) >> 2] + +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7008 + (HEAP32[$b >> 2] << 2) >> 2]);
   HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
  }
  HEAPF32[$midE + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$sum1124 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[$frame_stationarity >> 2] = +HEAPF32[$frame_stationarity >> 2] / 18.0;
 $div1148 = +HEAPF32[$relativeE >> 2] / 18.0;
 HEAPF32[$relativeE >> 2] = $div1148;
 HEAPF32[$relativeE >> 2] = (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) < 10 ? .5 : $div1148;
 HEAPF32[$frame_noisiness >> 2] = +HEAPF32[$frame_noisiness >> 2] / 18.0;
 HEAPF32[(HEAP32[$info >> 2] | 0) + 16 >> 2] = +HEAPF32[$frame_noisiness >> 2] + (1.0 - +HEAPF32[$frame_noisiness >> 2]) * +HEAPF32[$relativeE >> 2];
 HEAPF32[$frame_tonality >> 2] = +HEAPF32[$max_frame_tonality >> 2] / 9.0;
 if (+HEAPF32[$frame_tonality >> 2] > +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 5848 >> 2] * .800000011920929) $cond1168 = +HEAPF32[$frame_tonality >> 2]; else $cond1168 = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 5848 >> 2] * .800000011920929;
 HEAPF32[$frame_tonality >> 2] = $cond1168;
 HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 5848 >> 2] = +HEAPF32[$frame_tonality >> 2];
 HEAPF32[$slope >> 2] = +HEAPF32[$slope >> 2] / 64.0;
 HEAPF32[(HEAP32[$info >> 2] | 0) + 8 >> 2] = +HEAPF32[$slope >> 2];
 HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7432 >> 2] = ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7432 >> 2] | 0) + 1 | 0) % 8 | 0;
 if (((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) + 1 | 0) < 1e4) $cond1183 = (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) + 1 | 0; else $cond1183 = 1e4;
 HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] = $cond1183;
 HEAPF32[(HEAP32[$info >> 2] | 0) + 4 >> 2] = +HEAPF32[$frame_tonality >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 4) break;
  HEAPF32[$features + (HEAP32[$i >> 2] << 2) >> 2] = (+HEAPF32[$BFCC + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 24 << 2) >> 2]) * -.12298999726772308 + (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 16 << 2) >> 2]) * .49195000529289246 + +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 8 << 2) >> 2] * .6969299912452698 - +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7356 + (HEAP32[$i >> 2] << 2) >> 2] * 1.4349000453948975;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 4) break;
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7356 + (HEAP32[$i >> 2] << 2) >> 2] = (1.0 - +HEAPF32[$alpha >> 2]) * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7356 + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[$alpha >> 2] * +HEAPF32[$BFCC + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 4) break;
  HEAPF32[$features + (4 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = (+HEAPF32[$BFCC + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 24 << 2) >> 2]) * .6324599981307983 + (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 16 << 2) >> 2]) * .31622999906539917;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 3) break;
  HEAPF32[$features + (8 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = (+HEAPF32[$BFCC + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 24 << 2) >> 2]) * .5345199704170227 - (+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 16 << 2) >> 2]) * .26725998520851135 - +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 8 << 2) >> 2] * .5345199704170227;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L278 : do if ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) > 5) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 9) break L278;
   HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7388 + (HEAP32[$i >> 2] << 2) >> 2] = (1.0 - +HEAPF32[$alpha >> 2]) * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7388 + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[$alpha >> 2] * +HEAPF32[$features + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[$features + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 4) break;
  HEAPF32[$features + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$BFCC + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[$midE + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 8) break;
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 24 << 2) >> 2] = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 16 << 2) >> 2];
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 16 << 2) >> 2] = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 8 << 2) >> 2];
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + ((HEAP32[$i >> 2] | 0) + 8 << 2) >> 2] = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7228 + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$BFCC + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 9) break;
  $conv1350 = +Math_sqrt(+(+HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7388 + (HEAP32[$i >> 2] << 2) >> 2]));
  HEAPF32[$features + (11 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = $conv1350 - +HEAPF32[1880 + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[$features + 72 >> 2] = +HEAPF32[$spec_variability >> 2] - .7799999713897705;
 HEAPF32[$features + 80 >> 2] = +HEAPF32[(HEAP32[$info >> 2] | 0) + 4 >> 2] - .15472300350666046;
 HEAPF32[$features + 84 >> 2] = +HEAPF32[(HEAP32[$info >> 2] | 0) + 16 >> 2] - .7246429920196533;
 HEAPF32[$features + 88 >> 2] = +HEAPF32[$frame_stationarity >> 2] - .7437170147895813;
 HEAPF32[$features + 92 >> 2] = +HEAPF32[(HEAP32[$info >> 2] | 0) + 8 >> 2] + .06921599805355072;
 HEAPF32[$features + 96 >> 2] = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7428 >> 2] - .06792999804019928;
 _compute_dense(2720, $layer_out, $features);
 _compute_gru(2740, (HEAP32[$tonal$addr >> 2] | 0) + 7460 | 0, $layer_out);
 _compute_dense(2760, $frame_probs, (HEAP32[$tonal$addr >> 2] | 0) + 7460 | 0);
 HEAPF32[(HEAP32[$info >> 2] | 0) + 36 >> 2] = +HEAPF32[$frame_probs + 4 >> 2];
 $918 = +HEAPF32[$frame_probs >> 2];
 if (+HEAPF32[$frame_probs >> 2] * 10.0 < +HEAPF32[$frame_probs >> 2] * .6899999976158142 * (2.0 - +HEAPF32[$frame_probs >> 2]) + .11999999731779099) $cond1407 = 10.0 * $918; else $cond1407 = .6899999976158142 * $918 * (2.0 - +HEAPF32[$frame_probs >> 2]) + .11999999731779099;
 $920 = +HEAPF32[$frame_probs >> 2];
 do if (1.0 - (1.0 - +HEAPF32[$frame_probs >> 2]) * 10.0 > $cond1407) $cond1439 = 1.0 - (1.0 - $920) * 10.0; else {
  $923 = +HEAPF32[$frame_probs >> 2];
  if (10.0 * $920 < +HEAPF32[$frame_probs >> 2] * .6899999976158142 * (2.0 - +HEAPF32[$frame_probs >> 2]) + .11999999731779099) {
   $cond1439 = 10.0 * $923;
   break;
  } else {
   $cond1439 = .6899999976158142 * $923 * (2.0 - +HEAPF32[$frame_probs >> 2]) + .11999999731779099;
   break;
  }
 } while (0);
 HEAPF32[(HEAP32[$info >> 2] | 0) + 20 >> 2] = $cond1439;
 HEAP32[(HEAP32[$info >> 2] | 0) + 32 >> 2] = HEAP32[$bandwidth >> 2];
 HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 5852 >> 2] = HEAP32[$bandwidth >> 2];
 HEAPF32[(HEAP32[$info >> 2] | 0) + 12 >> 2] = +HEAPF32[$frame_noisiness >> 2];
 HEAP32[HEAP32[$info >> 2] >> 2] = 1;
 STACKTOP = sp;
 return;
}

function _silk_Encode($encState, $encControl, $samplesIn, $nSamplesIn, $psRangeEnc, $nBytesOut, $prefillFlag) {
 $encState = $encState | 0;
 $encControl = $encControl | 0;
 $samplesIn = $samplesIn | 0;
 $nSamplesIn = $nSamplesIn | 0;
 $psRangeEnc = $psRangeEnc | 0;
 $nBytesOut = $nBytesOut | 0;
 $prefillFlag = $prefillFlag | 0;
 var $$sink$sink = 0, $$sink3$sink = 0, $$sink9 = 0, $125 = 0, $31 = 0, $393 = 0, $40 = 0, $408 = 0, $430 = 0, $482 = 0, $53 = 0, $603 = 0, $637 = 0, $LBRR_flags633 = 0, $LBRR_symbol = 0, $MStargetRates_bps = 0, $TargetRate_bps = 0, $allowBandwidthSwitch1118 = 0, $arrayidx1030 = 0, $arrayidx48 = 0, $arrayidx880 = 0, $bitsBalance = 0, $call = 0, $call128 = 0, $call22 = 0, $call245 = 0, $call302 = 0, $call347 = 0, $call374 = 0, $call447 = 0, $call638 = 0, $call679 = 0, $channelRate_bps = 0, $cmp1025 = 0, $cmp545 = 0, $cond1099 = 0, $cond1168 = 0, $cond125 = 0, $cond277 = 0, $cond726 = 0, $condCoding = 0, $condCoding944 = 0, $conv660 = 0, $curr_block = 0, $div1082 = 0, $encControl$addr = 0, $encState$addr = 0, $flags = 0, $force_fs_kHz = 0, $i = 0, $iCDF = 0, $id = 0, $inputBufIx250 = 0, $inputBufIx452 = 0, $maxBits = 0, $mul100 = 0, $mul172 = 0, $mul194 = 0, $mul457 = 0, $n = 0, $nBits = 0, $nBitsExceeded1077 = 0, $nBitsExceeded1083 = 0, $nBlocksOf10ms = 0, $nBytesOut$addr = 0, $nFramesEncoded986 = 0, $nSamplesFromInput = 0, $nSamplesFromInputMax = 0, $nSamplesIn$addr = 0, $nSamplesToBuffer = 0, $nSamplesToBufferMax = 0, $prefillFlag$addr = 0, $prev_NLSFq_Q15 = 0, $psEnc = 0, $psRangeEnc$addr = 0, $ret = 0, $retval = 0, $sLP = 0, $sMid870 = 0, $sShape = 0, $samplesIn$addr = 0, $saved_stack = 0, $speech_act_thr_for_switch_Q8 = 0, $sum = 0, $timeSinceSwitchAllowed_ms1123 = 0, $tmp_complexity = 0, $tmp_payloadSize_ms = 0, $tot_blocks = 0, $transition = 0, $useCBR = 0, $vla = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 $retval = sp + 156 | 0;
 $encState$addr = sp + 152 | 0;
 $encControl$addr = sp + 148 | 0;
 $samplesIn$addr = sp + 144 | 0;
 $nSamplesIn$addr = sp + 140 | 0;
 $psRangeEnc$addr = sp + 136 | 0;
 $nBytesOut$addr = sp + 132 | 0;
 $prefillFlag$addr = sp + 128 | 0;
 $n = sp + 124 | 0;
 $i = sp + 120 | 0;
 $nBits = sp + 116 | 0;
 $flags = sp + 112 | 0;
 $tmp_payloadSize_ms = sp + 108 | 0;
 $tmp_complexity = sp + 104 | 0;
 $ret = sp + 100 | 0;
 $nSamplesToBuffer = sp + 96 | 0;
 $nSamplesToBufferMax = sp + 92 | 0;
 $nBlocksOf10ms = sp + 88 | 0;
 $nSamplesFromInput = sp + 84 | 0;
 $nSamplesFromInputMax = sp + 80 | 0;
 $speech_act_thr_for_switch_Q8 = sp + 76 | 0;
 $TargetRate_bps = sp + 72 | 0;
 $MStargetRates_bps = sp + 64 | 0;
 $channelRate_bps = sp + 56 | 0;
 $LBRR_symbol = sp + 52 | 0;
 $sum = sp + 48 | 0;
 $psEnc = sp + 44 | 0;
 $transition = sp + 40 | 0;
 $curr_block = sp + 36 | 0;
 $tot_blocks = sp + 32 | 0;
 $force_fs_kHz = sp + 28 | 0;
 $saved_stack = sp + 24 | 0;
 $id = sp + 20 | 0;
 $iCDF = sp + 160 | 0;
 $condCoding = sp + 16 | 0;
 $bitsBalance = sp + 12 | 0;
 $maxBits = sp + 8 | 0;
 $useCBR = sp + 4 | 0;
 $condCoding944 = sp;
 HEAP32[$encState$addr >> 2] = $encState;
 HEAP32[$encControl$addr >> 2] = $encControl;
 HEAP32[$samplesIn$addr >> 2] = $samplesIn;
 HEAP32[$nSamplesIn$addr >> 2] = $nSamplesIn;
 HEAP32[$psRangeEnc$addr >> 2] = $psRangeEnc;
 HEAP32[$nBytesOut$addr >> 2] = $nBytesOut;
 HEAP32[$prefillFlag$addr >> 2] = $prefillFlag;
 HEAP32[$tmp_payloadSize_ms >> 2] = 0;
 HEAP32[$tmp_complexity >> 2] = 0;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$nSamplesFromInput >> 2] = 0;
 HEAP32[$psEnc >> 2] = HEAP32[$encState$addr >> 2];
 if (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 68 >> 2] | 0) {
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4660 >> 2] = 1;
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 4660 >> 2] = 1;
 }
 HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 5744 >> 2] = 0;
 HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] = 0;
 $call = _check_control_input(HEAP32[$encControl$addr >> 2] | 0) | 0;
 HEAP32[$ret >> 2] = $call;
 if ($call | 0) {
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $637 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $637 | 0;
 }
 HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 88 >> 2] = 0;
 if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) > (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20188 >> 2] | 0)) {
  $call22 = _silk_init_encoder((HEAP32[$psEnc >> 2] | 0) + 10060 | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5088 >> 2] | 0) | 0;
  HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call22;
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20120 >> 2] = 0;
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20120 + 8 >> 2] = 0;
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20120 + 12 >> 2] = 0;
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20120 + 12 + 4 >> 2] = 1;
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20120 + 12 + 8 >> 2] = 0;
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20120 + 12 + 12 >> 2] = 1;
  HEAP16[(HEAP32[$psEnc >> 2] | 0) + 20120 + 30 >> 1] = 0;
  HEAP16[(HEAP32[$psEnc >> 2] | 0) + 20120 + 28 >> 1] = 16384;
  if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20184 >> 2] | 0) == 2) {
   _memcpy((HEAP32[$psEnc >> 2] | 0) + 10060 + 5772 | 0, (HEAP32[$psEnc >> 2] | 0) + 5772 | 0, 300) | 0;
   $arrayidx48 = (HEAP32[$psEnc >> 2] | 0) + 10060 | 0;
   $31 = HEAP32[$psEnc >> 2] | 0;
   HEAP32[$arrayidx48 >> 2] = HEAP32[$31 >> 2];
   HEAP32[$arrayidx48 + 4 >> 2] = HEAP32[$31 + 4 >> 2];
  }
 }
 if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) != (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4608 >> 2] | 0)) $40 = 1; else $40 = (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20188 >> 2] | 0) != (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0);
 HEAP32[$transition >> 2] = $40 & 1;
 HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20184 >> 2] = HEAP32[HEAP32[$encControl$addr >> 2] >> 2];
 HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20188 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2];
 HEAP32[$nBlocksOf10ms >> 2] = ((HEAP32[$nSamplesIn$addr >> 2] | 0) * 100 | 0) / (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
 HEAP32[$tot_blocks >> 2] = (HEAP32[$nBlocksOf10ms >> 2] | 0) > 1 ? HEAP32[$nBlocksOf10ms >> 2] >> 1 : 1;
 HEAP32[$curr_block >> 2] = 0;
 $53 = HEAP32[$nBlocksOf10ms >> 2] | 0;
 L15 : do if (HEAP32[$prefillFlag$addr >> 2] | 0) {
  if (($53 | 0) != 1) {
   HEAP32[$retval >> 2] = -101;
   $637 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $637 | 0;
  }
  HEAP32[$n >> 2] = 0;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
   HEAP32[$ret >> 2] = _silk_init_encoder((HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 5088 >> 2] | 0) | 0;
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
  HEAP32[$tmp_payloadSize_ms >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2];
  HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] = 10;
  HEAP32[$tmp_complexity >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 36 >> 2];
  HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 36 >> 2] = 0;
  HEAP32[$n >> 2] = 0;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0)) break L15;
   HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4664 >> 2] = 0;
   HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4676 >> 2] = 1;
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
 } else {
  $mul100 = Math_imul($53, HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
  if ((HEAP32[$nSamplesIn$addr >> 2] | 0) < 0 ? 1 : ($mul100 | 0) != ((HEAP32[$nSamplesIn$addr >> 2] | 0) * 100 | 0)) {
   HEAP32[$retval >> 2] = -101;
   $637 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $637 | 0;
  }
  if (((HEAP32[$nSamplesIn$addr >> 2] | 0) * 1e3 | 0) > (Math_imul(HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0, HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) | 0)) {
   HEAP32[$retval >> 2] = -101;
   $637 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $637 | 0;
  }
 } while (0);
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
  if ((HEAP32[$n >> 2] | 0) == 1) $cond125 = HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4572 >> 2] | 0; else $cond125 = 0;
  HEAP32[$force_fs_kHz >> 2] = $cond125;
  $call128 = _silk_control_encoder((HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) | 0, HEAP32[$encControl$addr >> 2] | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20200 >> 2] | 0, HEAP32[$n >> 2] | 0, HEAP32[$force_fs_kHz >> 2] | 0) | 0;
  HEAP32[$ret >> 2] = $call128;
  if ($call128 | 0) {
   label = 28;
   break;
  }
  L43 : do if (HEAP32[$transition >> 2] | 0 ? 1 : (HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4660 >> 2] | 0) != 0) {
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5740 >> 2] | 0)) break L43;
    HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4720 + (HEAP32[$i >> 2] << 2) >> 2] = 0;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  } while (0);
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 6076 >> 2] = HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 6072 >> 2];
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 if ((label | 0) == 28) {
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $637 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $637 | 0;
 }
 HEAP32[$nSamplesToBufferMax >> 2] = Math_imul((HEAP32[$nBlocksOf10ms >> 2] | 0) * 10 | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4572 >> 2] | 0) | 0;
 $mul172 = Math_imul(HEAP32[$nSamplesToBufferMax >> 2] | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4552 >> 2] | 0) | 0;
 HEAP32[$nSamplesFromInputMax >> 2] = ($mul172 | 0) / ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4572 >> 2] | 0) * 1e3 | 0) | 0;
 $125 = HEAP32[$nSamplesFromInputMax >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($125 << 1) | 0) + 15 & -16) | 0;
 while (1) {
  HEAP32[$nSamplesToBuffer >> 2] = (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4580 >> 2] | 0) - (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5736 >> 2] | 0);
  HEAP32[$nSamplesToBuffer >> 2] = (HEAP32[$nSamplesToBuffer >> 2] | 0) < (HEAP32[$nSamplesToBufferMax >> 2] | 0) ? HEAP32[$nSamplesToBuffer >> 2] | 0 : HEAP32[$nSamplesToBufferMax >> 2] | 0;
  $mul194 = Math_imul(HEAP32[$nSamplesToBuffer >> 2] | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4552 >> 2] | 0) | 0;
  HEAP32[$nSamplesFromInput >> 2] = ($mul194 | 0) / ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4572 >> 2] | 0) * 1e3 | 0) | 0;
  if ((HEAP32[HEAP32[$encControl$addr >> 2] >> 2] | 0) == 2) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) == 2) {
   HEAP32[$id >> 2] = HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2];
   HEAP32[$n >> 2] = 0;
   while (1) {
    if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$nSamplesFromInput >> 2] | 0)) break;
    HEAP16[$vla + (HEAP32[$n >> 2] << 1) >> 1] = HEAP16[(HEAP32[$samplesIn$addr >> 2] | 0) + (HEAP32[$n >> 2] << 1 << 1) >> 1] | 0;
    HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
   }
   if ((HEAP32[$id >> 2] | 0) == 0 ? (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20192 >> 2] | 0) == 1 : 0) _memcpy((HEAP32[$psEnc >> 2] | 0) + 10060 + 5772 | 0, (HEAP32[$psEnc >> 2] | 0) + 5772 | 0, 300) | 0;
   $call245 = _silk_resampler((HEAP32[$psEnc >> 2] | 0) + 5772 | 0, (HEAP32[$psEnc >> 2] | 0) + 5092 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5736 >> 2] | 0) + 2 << 1) | 0, $vla, HEAP32[$nSamplesFromInput >> 2] | 0) | 0;
   HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call245;
   $inputBufIx250 = (HEAP32[$psEnc >> 2] | 0) + 5736 | 0;
   HEAP32[$inputBufIx250 >> 2] = (HEAP32[$inputBufIx250 >> 2] | 0) + (HEAP32[$nSamplesToBuffer >> 2] | 0);
   HEAP32[$nSamplesToBuffer >> 2] = (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 4580 >> 2] | 0) - (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 5736 >> 2] | 0);
   if ((HEAP32[$nSamplesToBuffer >> 2] | 0) < (Math_imul((HEAP32[$nBlocksOf10ms >> 2] | 0) * 10 | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 4572 >> 2] | 0) | 0)) $cond277 = HEAP32[$nSamplesToBuffer >> 2] | 0; else $cond277 = Math_imul((HEAP32[$nBlocksOf10ms >> 2] | 0) * 10 | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 4572 >> 2] | 0) | 0;
   HEAP32[$nSamplesToBuffer >> 2] = $cond277;
   HEAP32[$n >> 2] = 0;
   while (1) {
    if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$nSamplesFromInput >> 2] | 0)) break;
    HEAP16[$vla + (HEAP32[$n >> 2] << 1) >> 1] = HEAP16[(HEAP32[$samplesIn$addr >> 2] | 0) + ((HEAP32[$n >> 2] << 1) + 1 << 1) >> 1] | 0;
    HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
   }
   $call302 = _silk_resampler((HEAP32[$psEnc >> 2] | 0) + 10060 + 5772 | 0, (HEAP32[$psEnc >> 2] | 0) + 10060 + 5092 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 5736 >> 2] | 0) + 2 << 1) | 0, $vla, HEAP32[$nSamplesFromInput >> 2] | 0) | 0;
   HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call302;
   $$sink$sink = HEAP32[$psEnc >> 2] | 0;
   $$sink3$sink = HEAP32[$nSamplesToBuffer >> 2] | 0;
   $$sink9 = 1;
  } else label = 49; else label = 49;
  do if ((label | 0) == 49) {
   label = 0;
   if ((HEAP32[HEAP32[$encControl$addr >> 2] >> 2] | 0) == 2) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) == 1) {
    HEAP32[$n >> 2] = 0;
    while (1) {
     if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$nSamplesFromInput >> 2] | 0)) break;
     HEAP32[$sum >> 2] = (HEAP16[(HEAP32[$samplesIn$addr >> 2] | 0) + (HEAP32[$n >> 2] << 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$samplesIn$addr >> 2] | 0) + ((HEAP32[$n >> 2] << 1) + 1 << 1) >> 1] | 0);
     HEAP16[$vla + (HEAP32[$n >> 2] << 1) >> 1] = (HEAP32[$sum >> 2] >> 1) + (HEAP32[$sum >> 2] & 1);
     HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
    }
    $call347 = _silk_resampler((HEAP32[$psEnc >> 2] | 0) + 5772 | 0, (HEAP32[$psEnc >> 2] | 0) + 5092 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5736 >> 2] | 0) + 2 << 1) | 0, $vla, HEAP32[$nSamplesFromInput >> 2] | 0) | 0;
    HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call347;
    L82 : do if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20192 >> 2] | 0) == 2) if (!(HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0)) {
     $call374 = _silk_resampler((HEAP32[$psEnc >> 2] | 0) + 10060 + 5772 | 0, (HEAP32[$psEnc >> 2] | 0) + 10060 + 5092 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 5736 >> 2] | 0) + 2 << 1) | 0, $vla, HEAP32[$nSamplesFromInput >> 2] | 0) | 0;
     HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call374;
     HEAP32[$n >> 2] = 0;
     while (1) {
      if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4580 >> 2] | 0)) break L82;
      HEAP16[(HEAP32[$psEnc >> 2] | 0) + 5092 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5736 >> 2] | 0) + (HEAP32[$n >> 2] | 0) + 2 << 1) >> 1] = (HEAP16[(HEAP32[$psEnc >> 2] | 0) + 5092 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5736 >> 2] | 0) + (HEAP32[$n >> 2] | 0) + 2 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$psEnc >> 2] | 0) + 10060 + 5092 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 5736 >> 2] | 0) + (HEAP32[$n >> 2] | 0) + 2 << 1) >> 1] | 0) >> 1;
      HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
     }
    } while (0);
    $$sink$sink = HEAP32[$psEnc >> 2] | 0;
    $$sink3$sink = HEAP32[$nSamplesToBuffer >> 2] | 0;
    $$sink9 = 0;
    break;
   }
   _memcpy($vla | 0, HEAP32[$samplesIn$addr >> 2] | 0, HEAP32[$nSamplesFromInput >> 2] << 1 | 0) | 0;
   $call447 = _silk_resampler((HEAP32[$psEnc >> 2] | 0) + 5772 | 0, (HEAP32[$psEnc >> 2] | 0) + 5092 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5736 >> 2] | 0) + 2 << 1) | 0, $vla, HEAP32[$nSamplesFromInput >> 2] | 0) | 0;
   HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call447;
   $$sink$sink = HEAP32[$psEnc >> 2] | 0;
   $$sink3$sink = HEAP32[$nSamplesToBuffer >> 2] | 0;
   $$sink9 = 0;
  } while (0);
  $inputBufIx452 = $$sink$sink + ($$sink9 * 10060 | 0) + 5736 | 0;
  HEAP32[$inputBufIx452 >> 2] = (HEAP32[$inputBufIx452 >> 2] | 0) + $$sink3$sink;
  $mul457 = Math_imul(HEAP32[$nSamplesFromInput >> 2] | 0, HEAP32[HEAP32[$encControl$addr >> 2] >> 2] | 0) | 0;
  HEAP32[$samplesIn$addr >> 2] = (HEAP32[$samplesIn$addr >> 2] | 0) + ($mul457 << 1);
  HEAP32[$nSamplesIn$addr >> 2] = (HEAP32[$nSamplesIn$addr >> 2] | 0) - (HEAP32[$nSamplesFromInput >> 2] | 0);
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20200 >> 2] = 0;
  if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5736 >> 2] | 0) < (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4580 >> 2] | 0)) break;
  if (!(HEAP32[$prefillFlag$addr >> 2] | 0 ? 1 : (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) != 0)) {
   HEAP8[$iCDF >> 0] = 0;
   HEAP8[$iCDF + 1 >> 0] = 0;
   HEAP8[$iCDF >> 0] = 256 - (256 >> (Math_imul((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5740 >> 2] | 0) + 1 | 0, HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) | 0));
   _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, 0, $iCDF, 8);
   HEAP32[$n >> 2] = 0;
   while (1) {
    if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
    HEAP32[$LBRR_symbol >> 2] = 0;
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 5740 >> 2] | 0)) break;
     HEAP32[$LBRR_symbol >> 2] = HEAP32[$LBRR_symbol >> 2] | HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4720 + (HEAP32[$i >> 2] << 2) >> 2] << HEAP32[$i >> 2];
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
    HEAP8[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4719 >> 0] = (HEAP32[$LBRR_symbol >> 2] | 0) > 0 ? 1 : 0;
    if (HEAP32[$LBRR_symbol >> 2] | 0) if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 5740 >> 2] | 0) > 1) _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, (HEAP32[$LBRR_symbol >> 2] | 0) - 1 | 0, HEAP32[15200 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 5740 >> 2] | 0) - 2 << 2) >> 2] | 0, 8);
    HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = 0;
   while (1) {
    $cmp545 = (HEAP32[$i >> 2] | 0) < (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5740 >> 2] | 0);
    HEAP32[$n >> 2] = 0;
    if (!$cmp545) break;
    while (1) {
     if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
     if (HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4720 + (HEAP32[$i >> 2] << 2) >> 2] | 0) {
      if ((HEAP32[$n >> 2] | 0) == 0 ? (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) == 2 : 0) {
       _silk_stereo_encode_pred(HEAP32[$psRangeEnc$addr >> 2] | 0, (HEAP32[$psEnc >> 2] | 0) + 20120 + 34 + ((HEAP32[$i >> 2] | 0) * 6 | 0) | 0);
       if (!(HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 4720 + (HEAP32[$i >> 2] << 2) >> 2] | 0)) _silk_stereo_encode_mid_only(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psEnc >> 2] | 0) + 20120 + 52 + (HEAP32[$i >> 2] | 0) >> 0] | 0);
      }
      if ((HEAP32[$i >> 2] | 0) > 0) if (HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4720 + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] | 0) HEAP32[$condCoding >> 2] = 2; else label = 82; else label = 82;
      if ((label | 0) == 82) {
       label = 0;
       HEAP32[$condCoding >> 2] = 0;
      }
      _silk_encode_indices((HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) | 0, HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$i >> 2] | 0, 1, HEAP32[$condCoding >> 2] | 0);
      _silk_encode_pulses(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 6096 + ((HEAP32[$i >> 2] | 0) * 36 | 0) + 29 >> 0] | 0, HEAP8[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 6096 + ((HEAP32[$i >> 2] | 0) * 36 | 0) + 30 >> 0] | 0, (HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 6204 + ((HEAP32[$i >> 2] | 0) * 320 | 0) | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4580 >> 2] | 0);
     }
     HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
    }
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   while (1) {
    if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
    $LBRR_flags633 = (HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4720 | 0;
    HEAP32[$LBRR_flags633 >> 2] = 0;
    HEAP32[$LBRR_flags633 + 4 >> 2] = 0;
    HEAP32[$LBRR_flags633 + 8 >> 2] = 0;
    HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
   }
   $call638 = _ec_tell_157(HEAP32[$psRangeEnc$addr >> 2] | 0) | 0;
   HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20176 >> 2] = $call638;
  }
  _silk_HP_variable_cutoff(HEAP32[$psEnc >> 2] | 0);
  HEAP32[$nBits >> 2] = (Math_imul(HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 28 >> 2] | 0, HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) | 0) / 1e3 | 0;
  if (!(HEAP32[$prefillFlag$addr >> 2] | 0)) HEAP32[$nBits >> 2] = (HEAP32[$nBits >> 2] | 0) - (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20176 >> 2] | 0);
  HEAP32[$nBits >> 2] = (HEAP32[$nBits >> 2] | 0) / (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5740 >> 2] | 0) | 0;
  $conv660 = (HEAP32[$nBits >> 2] & 65535) << 16 >> 16;
  if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) == 10) HEAP32[$TargetRate_bps >> 2] = $conv660 * 100; else HEAP32[$TargetRate_bps >> 2] = $conv660 * 50;
  HEAP32[$TargetRate_bps >> 2] = (HEAP32[$TargetRate_bps >> 2] | 0) - (((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20180 >> 2] | 0) * 1e3 | 0) / 500 | 0);
  if (!(HEAP32[$prefillFlag$addr >> 2] | 0)) if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) > 0) {
   $call679 = _ec_tell_157(HEAP32[$psRangeEnc$addr >> 2] | 0) | 0;
   HEAP32[$bitsBalance >> 2] = $call679 - (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20176 >> 2] | 0) - (Math_imul(HEAP32[$nBits >> 2] | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) | 0);
   HEAP32[$TargetRate_bps >> 2] = (HEAP32[$TargetRate_bps >> 2] | 0) - (((HEAP32[$bitsBalance >> 2] | 0) * 1e3 | 0) / 500 | 0);
  }
  $393 = HEAP32[$TargetRate_bps >> 2] | 0;
  do if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 28 >> 2] | 0) > 5e3) if (($393 | 0) > (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 28 >> 2] | 0)) {
   $cond726 = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 28 >> 2] | 0;
   break;
  } else {
   $cond726 = (HEAP32[$TargetRate_bps >> 2] | 0) < 5e3 ? 5e3 : HEAP32[$TargetRate_bps >> 2] | 0;
   break;
  } else if (($393 | 0) > 5e3) $cond726 = 5e3; else if ((HEAP32[$TargetRate_bps >> 2] | 0) < (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 28 >> 2] | 0)) {
   $cond726 = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 28 >> 2] | 0;
   break;
  } else {
   $cond726 = HEAP32[$TargetRate_bps >> 2] | 0;
   break;
  } while (0);
  HEAP32[$TargetRate_bps >> 2] = $cond726;
  $408 = HEAP32[$psEnc >> 2] | 0;
  if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) == 2) {
   _silk_stereo_LR_to_MS($408 + 20120 | 0, (HEAP32[$psEnc >> 2] | 0) + 5092 + 4 | 0, (HEAP32[$psEnc >> 2] | 0) + 10060 + 5092 + 4 | 0, (HEAP32[$psEnc >> 2] | 0) + 20120 + 34 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) * 6 | 0) | 0, (HEAP32[$psEnc >> 2] | 0) + 20120 + 52 + (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) | 0, $MStargetRates_bps, HEAP32[$TargetRate_bps >> 2] | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4528 >> 2] | 0, HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4572 >> 2] | 0, HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4580 >> 2] | 0);
   $430 = HEAP32[$psEnc >> 2] | 0;
   if (!(HEAP8[(HEAP32[$psEnc >> 2] | 0) + 20120 + 52 + (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) >> 0] | 0)) {
    if ((HEAP32[$430 + 20204 >> 2] | 0) == 1) {
     $sShape = (HEAP32[$psEnc >> 2] | 0) + 10060 + 7164 | 0;
     HEAP32[$sShape >> 2] = 0;
     HEAP32[$sShape + 4 >> 2] = 0;
     HEAP32[$sShape + 8 >> 2] = 0;
     _memset((HEAP32[$psEnc >> 2] | 0) + 10060 + 144 | 0, 0, 4352) | 0;
     $prev_NLSFq_Q15 = (HEAP32[$psEnc >> 2] | 0) + 10060 + 4496 | 0;
     HEAP32[$prev_NLSFq_Q15 >> 2] = 0;
     HEAP32[$prev_NLSFq_Q15 + 4 >> 2] = 0;
     HEAP32[$prev_NLSFq_Q15 + 8 >> 2] = 0;
     HEAP32[$prev_NLSFq_Q15 + 12 >> 2] = 0;
     HEAP32[$prev_NLSFq_Q15 + 16 >> 2] = 0;
     HEAP32[$prev_NLSFq_Q15 + 20 >> 2] = 0;
     HEAP32[$prev_NLSFq_Q15 + 24 >> 2] = 0;
     HEAP32[$prev_NLSFq_Q15 + 28 >> 2] = 0;
     $sLP = (HEAP32[$psEnc >> 2] | 0) + 10060 + 16 | 0;
     HEAP32[$sLP >> 2] = 0;
     HEAP32[$sLP + 4 >> 2] = 0;
     HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 4540 >> 2] = 100;
     HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 144 + 4328 >> 2] = 100;
     HEAP8[(HEAP32[$psEnc >> 2] | 0) + 10060 + 7164 >> 0] = 10;
     HEAP8[(HEAP32[$psEnc >> 2] | 0) + 10060 + 4537 >> 0] = 0;
     HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 144 + 4344 >> 2] = 65536;
     HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 4660 >> 2] = 1;
    }
    _silk_encode_do_VAD_FLP((HEAP32[$psEnc >> 2] | 0) + 10060 | 0);
   } else HEAP8[$430 + 10060 + 4716 + (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) >> 0] = 0;
   if (!(HEAP32[$prefillFlag$addr >> 2] | 0)) {
    _silk_stereo_encode_pred(HEAP32[$psRangeEnc$addr >> 2] | 0, (HEAP32[$psEnc >> 2] | 0) + 20120 + 34 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) * 6 | 0) | 0);
    if (!(HEAP8[(HEAP32[$psEnc >> 2] | 0) + 10060 + 4716 + (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) >> 0] | 0)) _silk_stereo_encode_mid_only(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psEnc >> 2] | 0) + 20120 + 52 + (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) >> 0] | 0);
   }
  } else {
   HEAP32[$408 + 5092 >> 2] = HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20120 + 4 >> 2];
   $sMid870 = (HEAP32[$psEnc >> 2] | 0) + 20120 + 4 | 0;
   $arrayidx880 = (HEAP32[$psEnc >> 2] | 0) + 5092 + (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4580 >> 2] << 1) | 0;
   HEAP16[$sMid870 >> 1] = HEAP16[$arrayidx880 >> 1] | 0;
   HEAP16[$sMid870 + 2 >> 1] = HEAP16[$arrayidx880 + 2 >> 1] | 0;
  }
  _silk_encode_do_VAD_FLP(HEAP32[$psEnc >> 2] | 0);
  HEAP32[$n >> 2] = 0;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
   HEAP32[$maxBits >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 56 >> 2];
   do if ((HEAP32[$tot_blocks >> 2] | 0) == 2 & (HEAP32[$curr_block >> 2] | 0) == 0) HEAP32[$maxBits >> 2] = ((HEAP32[$maxBits >> 2] | 0) * 3 | 0) / 5 | 0; else if ((HEAP32[$tot_blocks >> 2] | 0) == 3) {
    if (!(HEAP32[$curr_block >> 2] | 0)) {
     HEAP32[$maxBits >> 2] = (HEAP32[$maxBits >> 2] << 1 | 0) / 5 | 0;
     break;
    }
    if ((HEAP32[$curr_block >> 2] | 0) != 1) break;
    HEAP32[$maxBits >> 2] = ((HEAP32[$maxBits >> 2] | 0) * 3 | 0) / 4 | 0;
   } while (0);
   if (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 52 >> 2] | 0) $482 = (HEAP32[$curr_block >> 2] | 0) == ((HEAP32[$tot_blocks >> 2] | 0) - 1 | 0); else $482 = 0;
   HEAP32[$useCBR >> 2] = $482 & 1;
   do if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) == 1) HEAP32[$channelRate_bps >> 2] = HEAP32[$TargetRate_bps >> 2]; else {
    HEAP32[$channelRate_bps >> 2] = HEAP32[$MStargetRates_bps + (HEAP32[$n >> 2] << 2) >> 2];
    if (HEAP32[$n >> 2] | 0) break;
    if ((HEAP32[$MStargetRates_bps + 4 >> 2] | 0) <= 0) break;
    HEAP32[$useCBR >> 2] = 0;
    HEAP32[$maxBits >> 2] = (HEAP32[$maxBits >> 2] | 0) - ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 56 >> 2] | 0) / (HEAP32[$tot_blocks >> 2] << 1 | 0) | 0);
   } while (0);
   if ((HEAP32[$channelRate_bps >> 2] | 0) > 0) {
    _silk_control_SNR((HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) | 0, HEAP32[$channelRate_bps >> 2] | 0) | 0;
    L188 : do if (((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) - (HEAP32[$n >> 2] | 0) | 0) <= 0) HEAP32[$condCoding944 >> 2] = 0; else {
     do if ((HEAP32[$n >> 2] | 0) > 0) {
      if (!(HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20204 >> 2] | 0)) break;
      HEAP32[$condCoding944 >> 2] = 1;
      break L188;
     } while (0);
     HEAP32[$condCoding944 >> 2] = 2;
    } while (0);
    HEAP32[$ret >> 2] = _silk_encode_frame_FLP((HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) | 0, HEAP32[$nBytesOut$addr >> 2] | 0, HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$condCoding944 >> 2] | 0, HEAP32[$maxBits >> 2] | 0, HEAP32[$useCBR >> 2] | 0) | 0;
   }
   HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4664 >> 2] = 0;
   HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 5736 >> 2] = 0;
   $nFramesEncoded986 = (HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 5744 | 0;
   HEAP32[$nFramesEncoded986 >> 2] = (HEAP32[$nFramesEncoded986 >> 2] | 0) + 1;
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
  HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20204 >> 2] = HEAP8[(HEAP32[$psEnc >> 2] | 0) + 20120 + 52 + ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) - 1) >> 0];
  do if ((HEAP32[HEAP32[$nBytesOut$addr >> 2] >> 2] | 0) > 0) if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5744 >> 2] | 0) == (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5740 >> 2] | 0)) {
   HEAP32[$flags >> 2] = 0;
   HEAP32[$n >> 2] = 0;
   while (1) {
    if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
    HEAP32[$i >> 2] = 0;
    while (1) {
     $cmp1025 = (HEAP32[$i >> 2] | 0) < (HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 5740 >> 2] | 0);
     HEAP32[$flags >> 2] = HEAP32[$flags >> 2] << 1;
     $arrayidx1030 = (HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) | 0;
     if (!$cmp1025) break;
     HEAP32[$flags >> 2] = HEAP32[$flags >> 2] | HEAP8[$arrayidx1030 + 4716 + (HEAP32[$i >> 2] | 0) >> 0];
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
    HEAP32[$flags >> 2] = HEAP32[$flags >> 2] | HEAP8[$arrayidx1030 + 4719 >> 0];
    HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
   }
   if (!(HEAP32[$prefillFlag$addr >> 2] | 0)) _ec_enc_patch_initial_bits(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$flags >> 2] | 0, Math_imul((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 5740 >> 2] | 0) + 1 | 0, HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) | 0);
   do if (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 6076 >> 2] | 0) {
    if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) != 1) if (!(HEAP32[(HEAP32[$psEnc >> 2] | 0) + 10060 + 6076 >> 2] | 0)) break;
    HEAP32[HEAP32[$nBytesOut$addr >> 2] >> 2] = 0;
   } while (0);
   $nBitsExceeded1077 = (HEAP32[$psEnc >> 2] | 0) + 20180 | 0;
   HEAP32[$nBitsExceeded1077 >> 2] = (HEAP32[$nBitsExceeded1077 >> 2] | 0) + (HEAP32[HEAP32[$nBytesOut$addr >> 2] >> 2] << 3);
   $div1082 = (Math_imul(HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 28 >> 2] | 0, HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) | 0) / 1e3 | 0;
   $nBitsExceeded1083 = (HEAP32[$psEnc >> 2] | 0) + 20180 | 0;
   HEAP32[$nBitsExceeded1083 >> 2] = (HEAP32[$nBitsExceeded1083 >> 2] | 0) - $div1082;
   do if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20180 >> 2] | 0) > 1e4) $cond1099 = 1e4; else {
    if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20180 >> 2] | 0) < 0) {
     $cond1099 = 0;
     break;
    }
    $cond1099 = HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20180 >> 2] | 0;
   } while (0);
   HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20180 >> 2] = $cond1099;
   HEAP32[$speech_act_thr_for_switch_Q8 >> 2] = 13 + (0 + (((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20196 >> 2] & 65535) << 16 >> 16) * 3188 >> 16));
   $allowBandwidthSwitch1118 = (HEAP32[$psEnc >> 2] | 0) + 20200 | 0;
   if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4528 >> 2] | 0) < (HEAP32[$speech_act_thr_for_switch_Q8 >> 2] | 0)) {
    HEAP32[$allowBandwidthSwitch1118 >> 2] = 1;
    HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20196 >> 2] = 0;
    break;
   } else {
    HEAP32[$allowBandwidthSwitch1118 >> 2] = 0;
    $timeSinceSwitchAllowed_ms1123 = (HEAP32[$psEnc >> 2] | 0) + 20196 | 0;
    HEAP32[$timeSinceSwitchAllowed_ms1123 >> 2] = (HEAP32[$timeSinceSwitchAllowed_ms1123 >> 2] | 0) + (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0);
    break;
   }
  } while (0);
  if (!(HEAP32[$nSamplesIn$addr >> 2] | 0)) break;
  HEAP32[$curr_block >> 2] = (HEAP32[$curr_block >> 2] | 0) + 1;
 }
 HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20192 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2];
 HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 76 >> 2] = HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20200 >> 2];
 if ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4572 >> 2] | 0) == 16) $603 = (HEAP32[(HEAP32[$psEnc >> 2] | 0) + 16 + 12 >> 2] | 0) == 0; else $603 = 0;
 HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 80 >> 2] = $603 & 1;
 HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 72 >> 2] = ((HEAP32[(HEAP32[$psEnc >> 2] | 0) + 4572 >> 2] & 65535) << 16 >> 16) * 1e3;
 if (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 60 >> 2] | 0) $cond1168 = 0; else $cond1168 = HEAP16[(HEAP32[$psEnc >> 2] | 0) + 20120 + 28 >> 1] | 0;
 HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 84 >> 2] = $cond1168;
 L234 : do if (HEAP32[$prefillFlag$addr >> 2] | 0) {
  HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] = HEAP32[$tmp_payloadSize_ms >> 2];
  HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 36 >> 2] = HEAP32[$tmp_complexity >> 2];
  HEAP32[$n >> 2] = 0;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0)) break L234;
   HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4664 >> 2] = 0;
   HEAP32[(HEAP32[$psEnc >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 10060 | 0) + 4676 >> 2] = 0;
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 92 >> 2] = HEAP8[(HEAP32[$psEnc >> 2] | 0) + 4732 + 29 >> 0];
 HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 96 >> 2] = HEAP16[22956 + (HEAP8[(HEAP32[$psEnc >> 2] | 0) + 4732 + 29 >> 0] >> 1 << 2) + (HEAP8[(HEAP32[$psEnc >> 2] | 0) + 4732 + 30 >> 0] << 1) >> 1];
 HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 $637 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $637 | 0;
}

function _silk_noise_shape_quantizer_del_dec($NSQ, $psDelDec, $signalType, $x_Q10, $pulses, $xq, $sLTP_Q15, $delayedGain_Q10, $a_Q12, $b_Q14, $AR_shp_Q13, $lag, $HarmShapeFIRPacked_Q14, $Tilt_Q14, $LF_shp_Q14, $Gain_Q16, $Lambda_Q10, $offset_Q10, $length, $subfr, $shapingLPCOrder, $predictLPCOrder, $warping_Q16, $nStatesDelayedDecision, $smpl_buf_idx, $decisionDelay, $arch) {
 $NSQ = $NSQ | 0;
 $psDelDec = $psDelDec | 0;
 $signalType = $signalType | 0;
 $x_Q10 = $x_Q10 | 0;
 $pulses = $pulses | 0;
 $xq = $xq | 0;
 $sLTP_Q15 = $sLTP_Q15 | 0;
 $delayedGain_Q10 = $delayedGain_Q10 | 0;
 $a_Q12 = $a_Q12 | 0;
 $b_Q14 = $b_Q14 | 0;
 $AR_shp_Q13 = $AR_shp_Q13 | 0;
 $lag = $lag | 0;
 $HarmShapeFIRPacked_Q14 = $HarmShapeFIRPacked_Q14 | 0;
 $Tilt_Q14 = $Tilt_Q14 | 0;
 $LF_shp_Q14 = $LF_shp_Q14 | 0;
 $Gain_Q16 = $Gain_Q16 | 0;
 $Lambda_Q10 = $Lambda_Q10 | 0;
 $offset_Q10 = $offset_Q10 | 0;
 $length = $length | 0;
 $subfr = $subfr | 0;
 $shapingLPCOrder = $shapingLPCOrder | 0;
 $predictLPCOrder = $predictLPCOrder | 0;
 $warping_Q16 = $warping_Q16 | 0;
 $nStatesDelayedDecision = $nStatesDelayedDecision | 0;
 $smpl_buf_idx = $smpl_buf_idx | 0;
 $decisionDelay = $decisionDelay | 0;
 $arch = $arch | 0;
 var $$sink = 0, $$sink1 = 0, $0 = 0, $240 = 0, $241 = 0, $242 = 0, $245 = 0, $287 = 0, $366 = 0, $AR_shp_Q13$addr = 0, $Gain_Q10 = 0, $Gain_Q16$addr = 0, $HarmShapeFIRPacked_Q14$addr = 0, $LF_shp_Q14$addr = 0, $LPC_exc_Q14 = 0, $LPC_pred_Q14 = 0, $LTP_pred_Q14 = 0, $Lambda_Q10$addr = 0, $NSQ$addr = 0, $RDmax_Q10 = 0, $RDmax_ind = 0, $RDmin_Q10 = 0, $RDmin_ind = 0, $Tilt_Q14$addr = 0, $Winner_ind = 0, $Winner_rand_state = 0, $a_Q12$addr = 0, $add109 = 0, $add287 = 0, $add645 = 0, $add676 = 0, $add707 = 0, $add90 = 0, $arrayidx612 = 0, $arrayidx615 = 0, $b_Q14$addr = 0, $cond316 = 0, $cond722 = 0, $decisionDelay$addr = 0, $delayedGain_Q10$addr = 0, $exc_Q14 = 0, $i = 0, $j = 0, $k = 0, $lag$addr = 0, $last_smple_idx = 0, $length$addr = 0, $mul = 0, $mul118 = 0, $mul136 = 0, $mul153 = 0, $mul175 = 0, $mul19 = 0, $mul194 = 0, $mul213 = 0, $mul231 = 0, $mul247 = 0, $mul260 = 0, $mul274 = 0, $mul32 = 0, $mul45 = 0, $mul58 = 0, $mul636 = 0, $mul667 = 0, $mul698 = 0, $mul76 = 0, $nStatesDelayedDecision$addr = 0, $n_AR_Q14 = 0, $n_LF_Q14 = 0, $n_LTP_Q14 = 0, $offset_Q10$addr = 0, $pred_lag_ptr = 0, $predictLPCOrder$addr = 0, $psDD = 0, $psDelDec$addr = 0, $psLPC_Q14 = 0, $psSS = 0, $pulses$addr = 0, $q1_Q0 = 0, $q1_Q10 = 0, $q2_Q10 = 0, $r_Q10 = 0, $rd1_Q10 = 0, $rd2_Q10 = 0, $rdo_offset = 0, $rr_Q10 = 0, $sLF_AR_shp_Q14 = 0, $sLTP_Q15$addr = 0, $sLTP_buf_idx739 = 0, $sLTP_shp_buf_idx737 = 0, $saved_stack = 0, $shapingLPCOrder$addr = 0, $shp_lag_ptr = 0, $signalType$addr = 0, $smpl_buf_idx$addr = 0, $subfr$addr = 0, $tmp1 = 0, $tmp2 = 0, $vla = 0, $warping_Q16$addr = 0, $x_Q10$addr = 0, $xq$addr = 0, $xq_Q14 = 0, dest = 0, label = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 $NSQ$addr = sp + 248 | 0;
 $psDelDec$addr = sp + 244 | 0;
 $signalType$addr = sp + 240 | 0;
 $x_Q10$addr = sp + 236 | 0;
 $pulses$addr = sp + 232 | 0;
 $xq$addr = sp + 228 | 0;
 $sLTP_Q15$addr = sp + 224 | 0;
 $delayedGain_Q10$addr = sp + 220 | 0;
 $a_Q12$addr = sp + 216 | 0;
 $b_Q14$addr = sp + 212 | 0;
 $AR_shp_Q13$addr = sp + 208 | 0;
 $lag$addr = sp + 204 | 0;
 $HarmShapeFIRPacked_Q14$addr = sp + 200 | 0;
 $Tilt_Q14$addr = sp + 196 | 0;
 $LF_shp_Q14$addr = sp + 192 | 0;
 $Gain_Q16$addr = sp + 188 | 0;
 $Lambda_Q10$addr = sp + 184 | 0;
 $offset_Q10$addr = sp + 180 | 0;
 $length$addr = sp + 176 | 0;
 $subfr$addr = sp + 172 | 0;
 $shapingLPCOrder$addr = sp + 168 | 0;
 $predictLPCOrder$addr = sp + 164 | 0;
 $warping_Q16$addr = sp + 160 | 0;
 $nStatesDelayedDecision$addr = sp + 156 | 0;
 $smpl_buf_idx$addr = sp + 152 | 0;
 $decisionDelay$addr = sp + 148 | 0;
 $i = sp + 140 | 0;
 $j = sp + 136 | 0;
 $k = sp + 132 | 0;
 $Winner_ind = sp + 128 | 0;
 $RDmin_ind = sp + 124 | 0;
 $RDmax_ind = sp + 120 | 0;
 $last_smple_idx = sp + 116 | 0;
 $Winner_rand_state = sp + 112 | 0;
 $LTP_pred_Q14 = sp + 108 | 0;
 $LPC_pred_Q14 = sp + 104 | 0;
 $n_AR_Q14 = sp + 100 | 0;
 $n_LTP_Q14 = sp + 96 | 0;
 $n_LF_Q14 = sp + 92 | 0;
 $r_Q10 = sp + 88 | 0;
 $rr_Q10 = sp + 84 | 0;
 $rd1_Q10 = sp + 80 | 0;
 $rd2_Q10 = sp + 76 | 0;
 $RDmin_Q10 = sp + 72 | 0;
 $RDmax_Q10 = sp + 68 | 0;
 $q1_Q0 = sp + 64 | 0;
 $q1_Q10 = sp + 60 | 0;
 $q2_Q10 = sp + 56 | 0;
 $exc_Q14 = sp + 52 | 0;
 $LPC_exc_Q14 = sp + 48 | 0;
 $xq_Q14 = sp + 44 | 0;
 $Gain_Q10 = sp + 40 | 0;
 $tmp1 = sp + 36 | 0;
 $tmp2 = sp + 32 | 0;
 $sLF_AR_shp_Q14 = sp + 28 | 0;
 $pred_lag_ptr = sp + 24 | 0;
 $shp_lag_ptr = sp + 20 | 0;
 $psLPC_Q14 = sp + 16 | 0;
 $psDD = sp + 12 | 0;
 $psSS = sp + 8 | 0;
 $saved_stack = sp + 4 | 0;
 $rdo_offset = sp;
 HEAP32[$NSQ$addr >> 2] = $NSQ;
 HEAP32[$psDelDec$addr >> 2] = $psDelDec;
 HEAP32[$signalType$addr >> 2] = $signalType;
 HEAP32[$x_Q10$addr >> 2] = $x_Q10;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$xq$addr >> 2] = $xq;
 HEAP32[$sLTP_Q15$addr >> 2] = $sLTP_Q15;
 HEAP32[$delayedGain_Q10$addr >> 2] = $delayedGain_Q10;
 HEAP32[$a_Q12$addr >> 2] = $a_Q12;
 HEAP32[$b_Q14$addr >> 2] = $b_Q14;
 HEAP32[$AR_shp_Q13$addr >> 2] = $AR_shp_Q13;
 HEAP32[$lag$addr >> 2] = $lag;
 HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] = $HarmShapeFIRPacked_Q14;
 HEAP32[$Tilt_Q14$addr >> 2] = $Tilt_Q14;
 HEAP32[$LF_shp_Q14$addr >> 2] = $LF_shp_Q14;
 HEAP32[$Gain_Q16$addr >> 2] = $Gain_Q16;
 HEAP32[$Lambda_Q10$addr >> 2] = $Lambda_Q10;
 HEAP32[$offset_Q10$addr >> 2] = $offset_Q10;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$subfr$addr >> 2] = $subfr;
 HEAP32[$shapingLPCOrder$addr >> 2] = $shapingLPCOrder;
 HEAP32[$predictLPCOrder$addr >> 2] = $predictLPCOrder;
 HEAP32[$warping_Q16$addr >> 2] = $warping_Q16;
 HEAP32[$nStatesDelayedDecision$addr >> 2] = $nStatesDelayedDecision;
 HEAP32[$smpl_buf_idx$addr >> 2] = $smpl_buf_idx;
 HEAP32[$decisionDelay$addr >> 2] = $decisionDelay;
 HEAP32[sp + 144 >> 2] = $arch;
 $0 = HEAP32[$nStatesDelayedDecision$addr >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($0 * 56 | 0) | 0) + 15 & -16) | 0;
 HEAP32[$shp_lag_ptr >> 2] = (HEAP32[$NSQ$addr >> 2] | 0) + 1280 + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0) - (HEAP32[$lag$addr >> 2] | 0) + 1 << 2);
 HEAP32[$pred_lag_ptr >> 2] = (HEAP32[$sLTP_Q15$addr >> 2] | 0) + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0) - (HEAP32[$lag$addr >> 2] | 0) + 2 << 2);
 HEAP32[$Gain_Q10 >> 2] = HEAP32[$Gain_Q16$addr >> 2] >> 6;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  if ((HEAP32[$signalType$addr >> 2] | 0) == 2) {
   HEAP32[$LTP_pred_Q14 >> 2] = 2;
   $mul = Math_imul(HEAP32[HEAP32[$pred_lag_ptr >> 2] >> 2] >> 16, HEAP16[HEAP32[$b_Q14$addr >> 2] >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q14 >> 2] = (HEAP32[$LTP_pred_Q14 >> 2] | 0) + ($mul + ((Math_imul(HEAP32[HEAP32[$pred_lag_ptr >> 2] >> 2] & 65535, HEAP16[HEAP32[$b_Q14$addr >> 2] >> 1] | 0) | 0) >> 16));
   $mul19 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -4 >> 2] >> 16, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 2 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q14 >> 2] = (HEAP32[$LTP_pred_Q14 >> 2] | 0) + ($mul19 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -4 >> 2] & 65535, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
   $mul32 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -8 >> 2] >> 16, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 4 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q14 >> 2] = (HEAP32[$LTP_pred_Q14 >> 2] | 0) + ($mul32 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -8 >> 2] & 65535, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
   $mul45 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -12 >> 2] >> 16, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 6 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q14 >> 2] = (HEAP32[$LTP_pred_Q14 >> 2] | 0) + ($mul45 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -12 >> 2] & 65535, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
   $mul58 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -16 >> 2] >> 16, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 8 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q14 >> 2] = (HEAP32[$LTP_pred_Q14 >> 2] | 0) + ($mul58 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -16 >> 2] & 65535, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
   HEAP32[$LTP_pred_Q14 >> 2] = HEAP32[$LTP_pred_Q14 >> 2] << 1;
   HEAP32[$pred_lag_ptr >> 2] = (HEAP32[$pred_lag_ptr >> 2] | 0) + 4;
  } else HEAP32[$LTP_pred_Q14 >> 2] = 0;
  if ((HEAP32[$lag$addr >> 2] | 0) > 0) {
   $mul76 = Math_imul((HEAP32[HEAP32[$shp_lag_ptr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$shp_lag_ptr >> 2] | 0) + -8 >> 2] | 0) >> 16, (HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$n_LTP_Q14 >> 2] = $mul76 + ((Math_imul((HEAP32[HEAP32[$shp_lag_ptr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$shp_lag_ptr >> 2] | 0) + -8 >> 2] | 0) & 65535, (HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16);
   $add90 = (HEAP32[$n_LTP_Q14 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$shp_lag_ptr >> 2] | 0) + -4 >> 2] >> 16, HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] >> 16) | 0) | 0;
   HEAP32[$n_LTP_Q14 >> 2] = $add90 + ((Math_imul(HEAP32[(HEAP32[$shp_lag_ptr >> 2] | 0) + -4 >> 2] & 65535, HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] >> 16) | 0) >> 16);
   HEAP32[$n_LTP_Q14 >> 2] = (HEAP32[$LTP_pred_Q14 >> 2] | 0) - (HEAP32[$n_LTP_Q14 >> 2] << 2);
   HEAP32[$shp_lag_ptr >> 2] = (HEAP32[$shp_lag_ptr >> 2] | 0) + 4;
  } else HEAP32[$n_LTP_Q14 >> 2] = 0;
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nStatesDelayedDecision$addr >> 2] | 0)) break;
   HEAP32[$psDD >> 2] = (HEAP32[$psDelDec$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 1300 | 0);
   HEAP32[$psSS >> 2] = $vla + ((HEAP32[$k >> 2] | 0) * 56 | 0);
   $add109 = 907633515 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2] | 0, 196314165) | 0) | 0;
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2] = $add109;
   HEAP32[$psLPC_Q14 >> 2] = (HEAP32[$psDD >> 2] | 0) + (15 + (HEAP32[$i >> 2] | 0) << 2);
   HEAP32[$LPC_pred_Q14 >> 2] = _silk_noise_shape_quantizer_short_prediction_c_424(HEAP32[$psLPC_Q14 >> 2] | 0, HEAP32[$a_Q12$addr >> 2] | 0, HEAP32[$predictLPCOrder$addr >> 2] | 0) | 0;
   HEAP32[$LPC_pred_Q14 >> 2] = HEAP32[$LPC_pred_Q14 >> 2] << 4;
   $mul118 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 >> 2] >> 16, (HEAP32[$warping_Q16$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$tmp2 >> 2] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1284 >> 2] | 0) + ($mul118 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 >> 2] & 65535, (HEAP32[$warping_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16));
   $mul136 = Math_imul((HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + 4 >> 2] | 0) - (HEAP32[$tmp2 >> 2] | 0) >> 16, (HEAP32[$warping_Q16$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$tmp1 >> 2] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 >> 2] | 0) + ($mul136 + ((Math_imul((HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + 4 >> 2] | 0) - (HEAP32[$tmp2 >> 2] | 0) & 65535, (HEAP32[$warping_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16));
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 >> 2] = HEAP32[$tmp2 >> 2];
   HEAP32[$n_AR_Q14 >> 2] = HEAP32[$shapingLPCOrder$addr >> 2] >> 1;
   $mul153 = Math_imul(HEAP32[$tmp2 >> 2] >> 16, HEAP16[HEAP32[$AR_shp_Q13$addr >> 2] >> 1] | 0) | 0;
   HEAP32[$n_AR_Q14 >> 2] = (HEAP32[$n_AR_Q14 >> 2] | 0) + ($mul153 + ((Math_imul(HEAP32[$tmp2 >> 2] & 65535, HEAP16[HEAP32[$AR_shp_Q13$addr >> 2] >> 1] | 0) | 0) >> 16));
   HEAP32[$j >> 2] = 2;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$shapingLPCOrder$addr >> 2] | 0)) break;
    $mul175 = Math_imul((HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + ((HEAP32[$j >> 2] | 0) + 0 << 2) >> 2] | 0) - (HEAP32[$tmp1 >> 2] | 0) >> 16, (HEAP32[$warping_Q16$addr >> 2] & 65535) << 16 >> 16) | 0;
    HEAP32[$tmp2 >> 2] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + ((HEAP32[$j >> 2] | 0) - 1 << 2) >> 2] | 0) + ($mul175 + ((Math_imul((HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + ((HEAP32[$j >> 2] | 0) + 0 << 2) >> 2] | 0) - (HEAP32[$tmp1 >> 2] | 0) & 65535, (HEAP32[$warping_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16));
    HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + ((HEAP32[$j >> 2] | 0) - 1 << 2) >> 2] = HEAP32[$tmp1 >> 2];
    $mul194 = Math_imul(HEAP32[$tmp1 >> 2] >> 16, HEAP16[(HEAP32[$AR_shp_Q13$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) - 1 << 1) >> 1] | 0) | 0;
    HEAP32[$n_AR_Q14 >> 2] = (HEAP32[$n_AR_Q14 >> 2] | 0) + ($mul194 + ((Math_imul(HEAP32[$tmp1 >> 2] & 65535, HEAP16[(HEAP32[$AR_shp_Q13$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) >> 16));
    $mul213 = Math_imul((HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] | 0) - (HEAP32[$tmp2 >> 2] | 0) >> 16, (HEAP32[$warping_Q16$addr >> 2] & 65535) << 16 >> 16) | 0;
    HEAP32[$tmp1 >> 2] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + ((HEAP32[$j >> 2] | 0) + 0 << 2) >> 2] | 0) + ($mul213 + ((Math_imul((HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] | 0) - (HEAP32[$tmp2 >> 2] | 0) & 65535, (HEAP32[$warping_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16));
    HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + ((HEAP32[$j >> 2] | 0) + 0 << 2) >> 2] = HEAP32[$tmp2 >> 2];
    $mul231 = Math_imul(HEAP32[$tmp2 >> 2] >> 16, HEAP16[(HEAP32[$AR_shp_Q13$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0;
    HEAP32[$n_AR_Q14 >> 2] = (HEAP32[$n_AR_Q14 >> 2] | 0) + ($mul231 + ((Math_imul(HEAP32[$tmp2 >> 2] & 65535, HEAP16[(HEAP32[$AR_shp_Q13$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0) >> 16));
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 2;
   }
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + ((HEAP32[$shapingLPCOrder$addr >> 2] | 0) - 1 << 2) >> 2] = HEAP32[$tmp1 >> 2];
   $mul247 = Math_imul(HEAP32[$tmp1 >> 2] >> 16, HEAP16[(HEAP32[$AR_shp_Q13$addr >> 2] | 0) + ((HEAP32[$shapingLPCOrder$addr >> 2] | 0) - 1 << 1) >> 1] | 0) | 0;
   HEAP32[$n_AR_Q14 >> 2] = (HEAP32[$n_AR_Q14 >> 2] | 0) + ($mul247 + ((Math_imul(HEAP32[$tmp1 >> 2] & 65535, HEAP16[(HEAP32[$AR_shp_Q13$addr >> 2] | 0) + ((HEAP32[$shapingLPCOrder$addr >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) >> 16));
   HEAP32[$n_AR_Q14 >> 2] = HEAP32[$n_AR_Q14 >> 2] << 1;
   $mul260 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] >> 16, (HEAP32[$Tilt_Q14$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$n_AR_Q14 >> 2] = (HEAP32[$n_AR_Q14 >> 2] | 0) + ($mul260 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] & 65535, (HEAP32[$Tilt_Q14$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16));
   HEAP32[$n_AR_Q14 >> 2] = HEAP32[$n_AR_Q14 >> 2] << 2;
   $mul274 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] << 2) >> 2] >> 16, (HEAP32[$LF_shp_Q14$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$n_LF_Q14 >> 2] = $mul274 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] << 2) >> 2] & 65535, (HEAP32[$LF_shp_Q14$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16);
   $add287 = (HEAP32[$n_LF_Q14 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] >> 16, HEAP32[$LF_shp_Q14$addr >> 2] >> 16) | 0) | 0;
   HEAP32[$n_LF_Q14 >> 2] = $add287 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] & 65535, HEAP32[$LF_shp_Q14$addr >> 2] >> 16) | 0) >> 16);
   HEAP32[$n_LF_Q14 >> 2] = HEAP32[$n_LF_Q14 >> 2] << 2;
   HEAP32[$tmp1 >> 2] = (HEAP32[$n_AR_Q14 >> 2] | 0) + (HEAP32[$n_LF_Q14 >> 2] | 0);
   HEAP32[$tmp2 >> 2] = (HEAP32[$n_LTP_Q14 >> 2] | 0) + (HEAP32[$LPC_pred_Q14 >> 2] | 0);
   HEAP32[$tmp1 >> 2] = (HEAP32[$tmp2 >> 2] | 0) - (HEAP32[$tmp1 >> 2] | 0);
   HEAP32[$tmp1 >> 2] = (HEAP32[$tmp1 >> 2] >> 3) + 1 >> 1;
   HEAP32[$r_Q10 >> 2] = (HEAP32[(HEAP32[$x_Q10$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) - (HEAP32[$tmp1 >> 2] | 0);
   if ((HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2] | 0) < 0) HEAP32[$r_Q10 >> 2] = 0 - (HEAP32[$r_Q10 >> 2] | 0);
   if ((HEAP32[$r_Q10 >> 2] | 0) > 30720) $cond316 = 30720; else $cond316 = (HEAP32[$r_Q10 >> 2] | 0) < -31744 ? -31744 : HEAP32[$r_Q10 >> 2] | 0;
   HEAP32[$r_Q10 >> 2] = $cond316;
   HEAP32[$q1_Q10 >> 2] = (HEAP32[$r_Q10 >> 2] | 0) - (HEAP32[$offset_Q10$addr >> 2] | 0);
   HEAP32[$q1_Q0 >> 2] = HEAP32[$q1_Q10 >> 2] >> 10;
   do if ((HEAP32[$Lambda_Q10$addr >> 2] | 0) > 2048) {
    HEAP32[$rdo_offset >> 2] = ((HEAP32[$Lambda_Q10$addr >> 2] | 0) / 2 | 0) - 512;
    $240 = HEAP32[$q1_Q10 >> 2] | 0;
    $241 = HEAP32[$rdo_offset >> 2] | 0;
    if ((HEAP32[$q1_Q10 >> 2] | 0) > (HEAP32[$rdo_offset >> 2] | 0)) {
     HEAP32[$q1_Q0 >> 2] = $240 - $241 >> 10;
     break;
    }
    $242 = HEAP32[$q1_Q10 >> 2] | 0;
    if (($240 | 0) < (0 - $241 | 0)) {
     HEAP32[$q1_Q0 >> 2] = $242 + (HEAP32[$rdo_offset >> 2] | 0) >> 10;
     break;
    }
    if (($242 | 0) < 0) {
     HEAP32[$q1_Q0 >> 2] = -1;
     break;
    } else {
     HEAP32[$q1_Q0 >> 2] = 0;
     break;
    }
   } while (0);
   $245 = HEAP32[$q1_Q0 >> 2] | 0;
   do if ((HEAP32[$q1_Q0 >> 2] | 0) > 0) {
    HEAP32[$q1_Q10 >> 2] = ($245 << 10) - 80;
    HEAP32[$q1_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + (HEAP32[$offset_Q10$addr >> 2] | 0);
    HEAP32[$q2_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + 1024;
    HEAP32[$rd1_Q10 >> 2] = Math_imul((HEAP32[$q1_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
    HEAP32[$rd2_Q10 >> 2] = Math_imul((HEAP32[$q2_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
   } else {
    if (!$245) {
     HEAP32[$q1_Q10 >> 2] = HEAP32[$offset_Q10$addr >> 2];
     HEAP32[$q2_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + 944;
     HEAP32[$rd1_Q10 >> 2] = Math_imul((HEAP32[$q1_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
     HEAP32[$rd2_Q10 >> 2] = Math_imul((HEAP32[$q2_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
     break;
    }
    if ((HEAP32[$q1_Q0 >> 2] | 0) == -1) {
     HEAP32[$q2_Q10 >> 2] = HEAP32[$offset_Q10$addr >> 2];
     HEAP32[$q1_Q10 >> 2] = (HEAP32[$q2_Q10 >> 2] | 0) - 944;
     HEAP32[$rd1_Q10 >> 2] = Math_imul((0 - (HEAP32[$q1_Q10 >> 2] | 0) & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
     HEAP32[$rd2_Q10 >> 2] = Math_imul((HEAP32[$q2_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
     break;
    } else {
     HEAP32[$q1_Q10 >> 2] = (HEAP32[$q1_Q0 >> 2] << 10) + 80;
     HEAP32[$q1_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + (HEAP32[$offset_Q10$addr >> 2] | 0);
     HEAP32[$q2_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + 1024;
     HEAP32[$rd1_Q10 >> 2] = Math_imul((0 - (HEAP32[$q1_Q10 >> 2] | 0) & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
     HEAP32[$rd2_Q10 >> 2] = Math_imul((0 - (HEAP32[$q2_Q10 >> 2] | 0) & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
     break;
    }
   } while (0);
   HEAP32[$rr_Q10 >> 2] = (HEAP32[$r_Q10 >> 2] | 0) - (HEAP32[$q1_Q10 >> 2] | 0);
   HEAP32[$rd1_Q10 >> 2] = (HEAP32[$rd1_Q10 >> 2] | 0) + (Math_imul((HEAP32[$rr_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$rr_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 10;
   HEAP32[$rr_Q10 >> 2] = (HEAP32[$r_Q10 >> 2] | 0) - (HEAP32[$q2_Q10 >> 2] | 0);
   HEAP32[$rd2_Q10 >> 2] = (HEAP32[$rd2_Q10 >> 2] | 0) + (Math_imul((HEAP32[$rr_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$rr_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 10;
   $287 = HEAP32[(HEAP32[$psDD >> 2] | 0) + 1296 >> 2] | 0;
   if ((HEAP32[$rd1_Q10 >> 2] | 0) < (HEAP32[$rd2_Q10 >> 2] | 0)) {
    HEAP32[(HEAP32[$psSS >> 2] | 0) + 4 >> 2] = $287 + (HEAP32[$rd1_Q10 >> 2] | 0);
    HEAP32[(HEAP32[$psSS >> 2] | 0) + 28 + 4 >> 2] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1296 >> 2] | 0) + (HEAP32[$rd2_Q10 >> 2] | 0);
    HEAP32[HEAP32[$psSS >> 2] >> 2] = HEAP32[$q1_Q10 >> 2];
    $$sink = HEAP32[$q2_Q10 >> 2] | 0;
    $$sink1 = HEAP32[$psSS >> 2] | 0;
   } else {
    HEAP32[(HEAP32[$psSS >> 2] | 0) + 4 >> 2] = $287 + (HEAP32[$rd2_Q10 >> 2] | 0);
    HEAP32[(HEAP32[$psSS >> 2] | 0) + 28 + 4 >> 2] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1296 >> 2] | 0) + (HEAP32[$rd1_Q10 >> 2] | 0);
    HEAP32[HEAP32[$psSS >> 2] >> 2] = HEAP32[$q2_Q10 >> 2];
    $$sink = HEAP32[$q1_Q10 >> 2] | 0;
    $$sink1 = HEAP32[$psSS >> 2] | 0;
   }
   HEAP32[$$sink1 + 28 >> 2] = $$sink;
   HEAP32[$exc_Q14 >> 2] = HEAP32[HEAP32[$psSS >> 2] >> 2] << 4;
   if ((HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2] | 0) < 0) HEAP32[$exc_Q14 >> 2] = 0 - (HEAP32[$exc_Q14 >> 2] | 0);
   HEAP32[$LPC_exc_Q14 >> 2] = (HEAP32[$exc_Q14 >> 2] | 0) + (HEAP32[$LTP_pred_Q14 >> 2] | 0);
   HEAP32[$xq_Q14 >> 2] = (HEAP32[$LPC_exc_Q14 >> 2] | 0) + (HEAP32[$LPC_pred_Q14 >> 2] | 0);
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 16 >> 2] = (HEAP32[$xq_Q14 >> 2] | 0) - (HEAP32[(HEAP32[$x_Q10$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] << 4);
   HEAP32[$sLF_AR_shp_Q14 >> 2] = (HEAP32[(HEAP32[$psSS >> 2] | 0) + 16 >> 2] | 0) - (HEAP32[$n_AR_Q14 >> 2] | 0);
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 20 >> 2] = (HEAP32[$sLF_AR_shp_Q14 >> 2] | 0) - (HEAP32[$n_LF_Q14 >> 2] | 0);
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 12 >> 2] = HEAP32[$sLF_AR_shp_Q14 >> 2];
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 24 >> 2] = HEAP32[$LPC_exc_Q14 >> 2];
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 8 >> 2] = HEAP32[$xq_Q14 >> 2];
   HEAP32[$exc_Q14 >> 2] = HEAP32[(HEAP32[$psSS >> 2] | 0) + 28 >> 2] << 4;
   if ((HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2] | 0) < 0) HEAP32[$exc_Q14 >> 2] = 0 - (HEAP32[$exc_Q14 >> 2] | 0);
   HEAP32[$LPC_exc_Q14 >> 2] = (HEAP32[$exc_Q14 >> 2] | 0) + (HEAP32[$LTP_pred_Q14 >> 2] | 0);
   HEAP32[$xq_Q14 >> 2] = (HEAP32[$LPC_exc_Q14 >> 2] | 0) + (HEAP32[$LPC_pred_Q14 >> 2] | 0);
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 28 + 16 >> 2] = (HEAP32[$xq_Q14 >> 2] | 0) - (HEAP32[(HEAP32[$x_Q10$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] << 4);
   HEAP32[$sLF_AR_shp_Q14 >> 2] = (HEAP32[(HEAP32[$psSS >> 2] | 0) + 28 + 16 >> 2] | 0) - (HEAP32[$n_AR_Q14 >> 2] | 0);
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 28 + 20 >> 2] = (HEAP32[$sLF_AR_shp_Q14 >> 2] | 0) - (HEAP32[$n_LF_Q14 >> 2] | 0);
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 28 + 12 >> 2] = HEAP32[$sLF_AR_shp_Q14 >> 2];
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 28 + 24 >> 2] = HEAP32[$LPC_exc_Q14 >> 2];
   HEAP32[(HEAP32[$psSS >> 2] | 0) + 28 + 8 >> 2] = HEAP32[$xq_Q14 >> 2];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] = ((HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] | 0) - 1 | 0) % 40 | 0;
  if ((HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] | 0) < 0) {
   $366 = HEAP32[$smpl_buf_idx$addr >> 2] | 0;
   HEAP32[$366 >> 2] = (HEAP32[$366 >> 2] | 0) + 40;
  }
  HEAP32[$last_smple_idx >> 2] = ((HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] | 0) + (HEAP32[$decisionDelay$addr >> 2] | 0) | 0) % 40 | 0;
  HEAP32[$RDmin_Q10 >> 2] = HEAP32[$vla + 4 >> 2];
  HEAP32[$Winner_ind >> 2] = 0;
  HEAP32[$k >> 2] = 1;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nStatesDelayedDecision$addr >> 2] | 0)) break;
   if ((HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 4 >> 2] | 0) < (HEAP32[$RDmin_Q10 >> 2] | 0)) {
    HEAP32[$RDmin_Q10 >> 2] = HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 4 >> 2];
    HEAP32[$Winner_ind >> 2] = HEAP32[$k >> 2];
   }
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP32[$Winner_rand_state >> 2] = HEAP32[(HEAP32[$psDelDec$addr >> 2] | 0) + ((HEAP32[$Winner_ind >> 2] | 0) * 1300 | 0) + 384 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2];
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nStatesDelayedDecision$addr >> 2] | 0)) break;
   if ((HEAP32[(HEAP32[$psDelDec$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 1300 | 0) + 384 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0) != (HEAP32[$Winner_rand_state >> 2] | 0)) {
    HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 4 >> 2] = (HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 4 >> 2] | 0) + 134217727;
    HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 28 + 4 >> 2] = (HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 28 + 4 >> 2] | 0) + 134217727;
   }
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP32[$RDmax_Q10 >> 2] = HEAP32[$vla + 4 >> 2];
  HEAP32[$RDmin_Q10 >> 2] = HEAP32[$vla + 28 + 4 >> 2];
  HEAP32[$RDmax_ind >> 2] = 0;
  HEAP32[$RDmin_ind >> 2] = 0;
  HEAP32[$k >> 2] = 1;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nStatesDelayedDecision$addr >> 2] | 0)) break;
   if ((HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 4 >> 2] | 0) > (HEAP32[$RDmax_Q10 >> 2] | 0)) {
    HEAP32[$RDmax_Q10 >> 2] = HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 4 >> 2];
    HEAP32[$RDmax_ind >> 2] = HEAP32[$k >> 2];
   }
   if ((HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 28 + 4 >> 2] | 0) < (HEAP32[$RDmin_Q10 >> 2] | 0)) {
    HEAP32[$RDmin_Q10 >> 2] = HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 56 | 0) + 28 + 4 >> 2];
    HEAP32[$RDmin_ind >> 2] = HEAP32[$k >> 2];
   }
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  if ((HEAP32[$RDmin_Q10 >> 2] | 0) < (HEAP32[$RDmax_Q10 >> 2] | 0)) {
   _memcpy((HEAP32[$psDelDec$addr >> 2] | 0) + ((HEAP32[$RDmax_ind >> 2] | 0) * 1300 | 0) + (HEAP32[$i >> 2] << 2) | 0, (HEAP32[$psDelDec$addr >> 2] | 0) + ((HEAP32[$RDmin_ind >> 2] | 0) * 1300 | 0) + (HEAP32[$i >> 2] << 2) | 0, 1300 - (HEAP32[$i >> 2] << 2) | 0) | 0;
   $arrayidx612 = $vla + ((HEAP32[$RDmax_ind >> 2] | 0) * 56 | 0) | 0;
   $arrayidx615 = $vla + ((HEAP32[$RDmin_ind >> 2] | 0) * 56 | 0) + 28 | 0;
   HEAP32[$arrayidx612 >> 2] = HEAP32[$arrayidx615 >> 2];
   HEAP32[$arrayidx612 + 4 >> 2] = HEAP32[$arrayidx615 + 4 >> 2];
   HEAP32[$arrayidx612 + 8 >> 2] = HEAP32[$arrayidx615 + 8 >> 2];
   HEAP32[$arrayidx612 + 12 >> 2] = HEAP32[$arrayidx615 + 12 >> 2];
   HEAP32[$arrayidx612 + 16 >> 2] = HEAP32[$arrayidx615 + 16 >> 2];
   HEAP32[$arrayidx612 + 20 >> 2] = HEAP32[$arrayidx615 + 20 >> 2];
   HEAP32[$arrayidx612 + 24 >> 2] = HEAP32[$arrayidx615 + 24 >> 2];
  }
  HEAP32[$psDD >> 2] = (HEAP32[$psDelDec$addr >> 2] | 0) + ((HEAP32[$Winner_ind >> 2] | 0) * 1300 | 0);
  if ((HEAP32[$subfr$addr >> 2] | 0) > 0) label = 64; else if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$decisionDelay$addr >> 2] | 0)) label = 64;
  if ((label | 0) == 64) {
   label = 0;
   HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$decisionDelay$addr >> 2] | 0)) >> 0] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 544 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 9) + 1 >> 1;
   $mul636 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 16, (HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
   $add645 = $mul636 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535, (HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   if ((($add645 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0, (HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond722 = 32767; else {
    $mul667 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 16, (HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
    $add676 = $mul667 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535, (HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    if ((($add676 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0, (HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond722 = -32768; else {
     $mul698 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 16, (HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
     $add707 = $mul698 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535, (HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
     $cond722 = ($add707 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0, (HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
    }
   }
   HEAP16[(HEAP32[$xq$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$decisionDelay$addr >> 2] | 0) << 1) >> 1] = $cond722;
   HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0) - (HEAP32[$decisionDelay$addr >> 2] | 0) << 2) >> 2] = HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2];
   HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0) - (HEAP32[$decisionDelay$addr >> 2] | 0) << 2) >> 2] = HEAP32[(HEAP32[$psDD >> 2] | 0) + 864 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2];
  }
  $sLTP_shp_buf_idx737 = (HEAP32[$NSQ$addr >> 2] | 0) + 4336 | 0;
  HEAP32[$sLTP_shp_buf_idx737 >> 2] = (HEAP32[$sLTP_shp_buf_idx737 >> 2] | 0) + 1;
  $sLTP_buf_idx739 = (HEAP32[$NSQ$addr >> 2] | 0) + 4332 | 0;
  HEAP32[$sLTP_buf_idx739 >> 2] = (HEAP32[$sLTP_buf_idx739 >> 2] | 0) + 1;
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nStatesDelayedDecision$addr >> 2] | 0)) break;
   HEAP32[$psDD >> 2] = (HEAP32[$psDelDec$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 1300 | 0);
   HEAP32[$psSS >> 2] = $vla + ((HEAP32[$k >> 2] | 0) * 56 | 0);
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] = HEAP32[(HEAP32[$psSS >> 2] | 0) + 12 >> 2];
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1284 >> 2] = HEAP32[(HEAP32[$psSS >> 2] | 0) + 16 >> 2];
   HEAP32[(HEAP32[$psDD >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = HEAP32[(HEAP32[$psSS >> 2] | 0) + 8 >> 2];
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] << 2) >> 2] = HEAP32[(HEAP32[$psSS >> 2] | 0) + 8 >> 2];
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 544 + (HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] << 2) >> 2] = HEAP32[HEAP32[$psSS >> 2] >> 2];
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 864 + (HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] << 2) >> 2] = HEAP32[(HEAP32[$psSS >> 2] | 0) + 24 >> 2] << 1;
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] << 2) >> 2] = HEAP32[(HEAP32[$psSS >> 2] | 0) + 20 >> 2];
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2] | 0) + ((HEAP32[HEAP32[$psSS >> 2] >> 2] >> 9) + 1 >> 1);
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 384 + (HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] << 2) >> 2] = HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2];
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1296 >> 2] = HEAP32[(HEAP32[$psSS >> 2] | 0) + 4 >> 2];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP32[(HEAP32[$delayedGain_Q10$addr >> 2] | 0) + (HEAP32[HEAP32[$smpl_buf_idx$addr >> 2] >> 2] << 2) >> 2] = HEAP32[$Gain_Q10 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nStatesDelayedDecision$addr >> 2] | 0)) break;
  HEAP32[$psDD >> 2] = (HEAP32[$psDelDec$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 1300 | 0);
  dest = HEAP32[$psDD >> 2] | 0;
  src = (HEAP32[$psDD >> 2] | 0) + (HEAP32[$length$addr >> 2] << 2) | 0;
  stop = dest + 64 | 0;
  do {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  } while ((dest | 0) < (stop | 0));
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _opus_encoder_ctl($st, $request, $varargs) {
 $st = $st | 0;
 $request = $request | 0;
 $varargs = $varargs | 0;
 var $$old = 0, $10 = 0, $100 = 0, $108 = 0, $116 = 0, $117 = 0, $128 = 0, $129 = 0, $138 = 0, $146 = 0, $147 = 0, $158 = 0, $159 = 0, $170 = 0, $171 = 0, $182 = 0, $183 = 0, $189 = 0, $196 = 0, $197 = 0, $208 = 0, $209 = 0, $220 = 0, $221 = 0, $232 = 0, $233 = 0, $239 = 0, $246 = 0, $247 = 0, $258 = 0, $259 = 0, $272 = 0, $273 = 0, $284 = 0, $285 = 0, $29 = 0, $296 = 0, $297 = 0, $30 = 0, $308 = 0, $309 = 0, $320 = 0, $321 = 0, $332 = 0, $333 = 0, $345 = 0, $346 = 0, $357 = 0, $358 = 0, $368 = 0, $375 = 0, $376 = 0, $387 = 0, $388 = 0, $399 = 0, $400 = 0, $41 = 0, $411 = 0, $412 = 0, $42 = 0, $423 = 0, $424 = 0, $438 = 0, $445 = 0, $446 = 0, $457 = 0, $458 = 0, $469 = 0, $470 = 0, $481 = 0, $482 = 0, $486 = 0, $493 = 0, $494 = 0, $497 = 0, $527 = 0, $528 = 0, $540 = 0, $541 = 0, $545 = 0, $552 = 0, $553 = 0, $557 = 0, $566 = 0, $567 = 0, $570 = 0, $575 = 0, $60 = 0, $61 = 0, $73 = 0, $74 = 0, $87 = 0, $88 = 0, $9 = 0, $99 = 0, $ap = 0, $call = 0, $celt_enc = 0, $dummy = 0, $request$addr = 0, $ret = 0, $retval = 0, $shl = 0, $silk_enc = 0, $st$addr = 0, $start = 0, $value = 0, $value11 = 0, $value125 = 0, $value132 = 0, $value141 = 0, $value149 = 0, $value161 = 0, $value170 = 0, $value182 = 0, $value19 = 0, $value191 = 0, $value206 = 0, $value215 = 0, $value227 = 0, $value235 = 0, $value246 = 0, $value254 = 0, $value265 = 0, $value273 = 0, $value287 = 0, $value295 = 0, $value307 = 0, $value315 = 0, $value322 = 0, $value333 = 0, $value341 = 0, $value379 = 0, $value387 = 0, $value399 = 0, $value40 = 0, $value408 = 0, $value422 = 0, $value446 = 0, $value460 = 0, $value467 = 0, $value47 = 0, $value477 = 0, $value59 = 0, $value67 = 0, $value90 = 0, $value98 = 0, $vararg_buffer = 0, $vararg_buffer105 = 0, $vararg_buffer153 = 0, $vararg_buffer168 = 0, $vararg_buffer174 = 0, $vararg_buffer177 = 0, $vararg_buffer185 = 0, $vararg_buffer191 = 0, $vararg_buffer197 = 0, $varet = 0, $varet100 = 0, $varet127 = 0, $varet13 = 0, $varet134 = 0, $varet143 = 0, $varet151 = 0, $varet163 = 0, $varet172 = 0, $varet184 = 0, $varet193 = 0, $varet208 = 0, $varet21 = 0, $varet217 = 0, $varet229 = 0, $varet237 = 0, $varet248 = 0, $varet256 = 0, $varet267 = 0, $varet275 = 0, $varet289 = 0, $varet297 = 0, $varet309 = 0, $varet317 = 0, $varet324 = 0, $varet335 = 0, $varet343 = 0, $varet381 = 0, $varet389 = 0, $varet401 = 0, $varet410 = 0, $varet42 = 0, $varet424 = 0, $varet448 = 0, $varet462 = 0, $varet469 = 0, $varet479 = 0, $varet49 = 0, $varet61 = 0, $varet69 = 0, $varet92 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 544 | 0;
 $vararg_buffer197 = sp + 64 | 0;
 $vararg_buffer191 = sp + 56 | 0;
 $vararg_buffer185 = sp + 48 | 0;
 $vararg_buffer177 = sp + 40 | 0;
 $vararg_buffer174 = sp + 32 | 0;
 $vararg_buffer168 = sp + 24 | 0;
 $vararg_buffer153 = sp + 16 | 0;
 $vararg_buffer105 = sp + 8 | 0;
 $vararg_buffer = sp;
 $retval = sp + 536 | 0;
 $st$addr = sp + 532 | 0;
 $request$addr = sp + 528 | 0;
 $ret = sp + 524 | 0;
 $celt_enc = sp + 520 | 0;
 $ap = sp + 504 | 0;
 $value = sp + 500 | 0;
 $varet = sp + 496 | 0;
 $value11 = sp + 492 | 0;
 $varet13 = sp + 488 | 0;
 $value19 = sp + 484 | 0;
 $varet21 = sp + 480 | 0;
 $value40 = sp + 476 | 0;
 $varet42 = sp + 472 | 0;
 $value47 = sp + 468 | 0;
 $varet49 = sp + 464 | 0;
 $value59 = sp + 460 | 0;
 $varet61 = sp + 456 | 0;
 $value67 = sp + 452 | 0;
 $varet69 = sp + 448 | 0;
 $value90 = sp + 444 | 0;
 $varet92 = sp + 440 | 0;
 $value98 = sp + 436 | 0;
 $varet100 = sp + 432 | 0;
 $value125 = sp + 428 | 0;
 $varet127 = sp + 424 | 0;
 $value132 = sp + 420 | 0;
 $varet134 = sp + 416 | 0;
 $value141 = sp + 412 | 0;
 $varet143 = sp + 408 | 0;
 $value149 = sp + 404 | 0;
 $varet151 = sp + 400 | 0;
 $value161 = sp + 396 | 0;
 $varet163 = sp + 392 | 0;
 $value170 = sp + 388 | 0;
 $varet172 = sp + 384 | 0;
 $value182 = sp + 380 | 0;
 $varet184 = sp + 376 | 0;
 $value191 = sp + 372 | 0;
 $varet193 = sp + 368 | 0;
 $value206 = sp + 364 | 0;
 $varet208 = sp + 360 | 0;
 $value215 = sp + 356 | 0;
 $varet217 = sp + 352 | 0;
 $value227 = sp + 348 | 0;
 $varet229 = sp + 344 | 0;
 $value235 = sp + 340 | 0;
 $varet237 = sp + 336 | 0;
 $value246 = sp + 332 | 0;
 $varet248 = sp + 328 | 0;
 $value254 = sp + 324 | 0;
 $varet256 = sp + 320 | 0;
 $value265 = sp + 316 | 0;
 $varet267 = sp + 312 | 0;
 $value273 = sp + 308 | 0;
 $varet275 = sp + 304 | 0;
 $value287 = sp + 300 | 0;
 $varet289 = sp + 296 | 0;
 $value295 = sp + 292 | 0;
 $varet297 = sp + 288 | 0;
 $value307 = sp + 284 | 0;
 $varet309 = sp + 280 | 0;
 $value315 = sp + 276 | 0;
 $varet317 = sp + 272 | 0;
 $value322 = sp + 268 | 0;
 $varet324 = sp + 264 | 0;
 $value333 = sp + 260 | 0;
 $varet335 = sp + 256 | 0;
 $value341 = sp + 252 | 0;
 $varet343 = sp + 248 | 0;
 $value379 = sp + 244 | 0;
 $varet381 = sp + 240 | 0;
 $value387 = sp + 236 | 0;
 $varet389 = sp + 232 | 0;
 $value399 = sp + 228 | 0;
 $varet401 = sp + 224 | 0;
 $value408 = sp + 220 | 0;
 $varet410 = sp + 216 | 0;
 $value422 = sp + 212 | 0;
 $varet424 = sp + 208 | 0;
 $silk_enc = sp + 204 | 0;
 $dummy = sp + 104 | 0;
 $start = sp + 100 | 0;
 $value446 = sp + 96 | 0;
 $varet448 = sp + 92 | 0;
 $value460 = sp + 88 | 0;
 $varet462 = sp + 84 | 0;
 $value467 = sp + 80 | 0;
 $varet469 = sp + 76 | 0;
 $value477 = sp + 72 | 0;
 $varet479 = sp + 68 | 0;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$request$addr >> 2] = $request;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$ap >> 2] = $varargs;
 HEAP32[$celt_enc >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0);
 L1 : do switch (HEAP32[$request$addr >> 2] | 0) {
 case 4e3:
  {
   $9 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $10 = HEAP32[$9 >> 2] | 0;
   HEAP32[$ap >> 2] = $9 + 4;
   HEAP32[$varet >> 2] = $10;
   HEAP32[$value >> 2] = HEAP32[$varet >> 2];
   do if (!((HEAP32[$value >> 2] | 0) != 2048 & (HEAP32[$value >> 2] | 0) != 2049 & (HEAP32[$value >> 2] | 0) != 2051)) {
    if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14248 >> 2] | 0)) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] | 0) != (HEAP32[$value >> 2] | 0)) break;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] = HEAP32[$value >> 2];
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 188 + 4 >> 2] = HEAP32[$value >> 2];
    label = 99;
    break L1;
   } while (0);
   HEAP32[$ret >> 2] = -1;
   label = 99;
   break;
  }
 case 4001:
  {
   $29 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $30 = HEAP32[$29 >> 2] | 0;
   HEAP32[$ap >> 2] = $29 + 4;
   HEAP32[$varet13 >> 2] = $30;
   HEAP32[$value11 >> 2] = HEAP32[$varet13 >> 2];
   if (HEAP32[$value11 >> 2] | 0) {
    HEAP32[HEAP32[$value11 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4002:
  {
   $41 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $42 = HEAP32[$41 >> 2] | 0;
   HEAP32[$ap >> 2] = $41 + 4;
   HEAP32[$varet21 >> 2] = $42;
   HEAP32[$value19 >> 2] = HEAP32[$varet21 >> 2];
   do if ((HEAP32[$value19 >> 2] | 0) != -1e3 & (HEAP32[$value19 >> 2] | 0) != -1) {
    if ((HEAP32[$value19 >> 2] | 0) <= 0) {
     label = 100;
     break L1;
    }
    if ((HEAP32[$value19 >> 2] | 0) <= 500) {
     HEAP32[$value19 >> 2] = 500;
     break;
    }
    if ((HEAP32[$value19 >> 2] | 0) > ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) * 3e5 | 0)) HEAP32[$value19 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) * 3e5;
   } while (0);
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 164 >> 2] = HEAP32[$value19 >> 2];
   label = 99;
   break;
  }
 case 4003:
  {
   $60 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $61 = HEAP32[$60 >> 2] | 0;
   HEAP32[$ap >> 2] = $60 + 4;
   HEAP32[$varet42 >> 2] = $61;
   HEAP32[$value40 >> 2] = HEAP32[$varet42 >> 2];
   if (HEAP32[$value40 >> 2] | 0) {
    $call = _user_bitrate_to_bitrate(HEAP32[$st$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14232 >> 2] | 0, 1276) | 0;
    HEAP32[HEAP32[$value40 >> 2] >> 2] = $call;
    label = 99;
   } else label = 100;
   break;
  }
 case 4022:
  {
   $73 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $74 = HEAP32[$73 >> 2] | 0;
   HEAP32[$ap >> 2] = $73 + 4;
   HEAP32[$varet49 >> 2] = $74;
   HEAP32[$value47 >> 2] = HEAP32[$varet49 >> 2];
   $$old = HEAP32[$value47 >> 2] | 0;
   if ((HEAP32[$value47 >> 2] | 0) < 1) {
    if (($$old | 0) != -1e3) {
     label = 100;
     break L1;
    }
   } else if ((HEAP32[$value47 >> 2] | 0) != -1e3 ? ($$old | 0) > (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) : 0) {
    label = 100;
    break L1;
   }
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] = HEAP32[$value47 >> 2];
   label = 99;
   break;
  }
 case 4023:
  {
   $87 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $88 = HEAP32[$87 >> 2] | 0;
   HEAP32[$ap >> 2] = $87 + 4;
   HEAP32[$varet61 >> 2] = $88;
   HEAP32[$value59 >> 2] = HEAP32[$varet61 >> 2];
   if (HEAP32[$value59 >> 2] | 0) {
    HEAP32[HEAP32[$value59 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4004:
  {
   $99 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $100 = HEAP32[$99 >> 2] | 0;
   HEAP32[$ap >> 2] = $99 + 4;
   HEAP32[$varet69 >> 2] = $100;
   HEAP32[$value67 >> 2] = HEAP32[$varet69 >> 2];
   if ((HEAP32[$value67 >> 2] | 0) < 1101 | (HEAP32[$value67 >> 2] | 0) > 1105) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 132 >> 2] = HEAP32[$value67 >> 2];
    $108 = HEAP32[$st$addr >> 2] | 0;
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 132 >> 2] | 0) == 1101) {
     HEAP32[$108 + 8 + 12 >> 2] = 8e3;
     label = 99;
     break L1;
    } else {
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 12 >> 2] = (HEAP32[$108 + 132 >> 2] | 0) == 1102 ? 12e3 : 16e3;
     label = 99;
     break L1;
    }
   }
   break;
  }
 case 4005:
  {
   $116 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $117 = HEAP32[$116 >> 2] | 0;
   HEAP32[$ap >> 2] = $116 + 4;
   HEAP32[$varet92 >> 2] = $117;
   HEAP32[$value90 >> 2] = HEAP32[$varet92 >> 2];
   if (HEAP32[$value90 >> 2] | 0) {
    HEAP32[HEAP32[$value90 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 132 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4008:
  {
   $128 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $129 = HEAP32[$128 >> 2] | 0;
   HEAP32[$ap >> 2] = $128 + 4;
   HEAP32[$varet100 >> 2] = $129;
   HEAP32[$value98 >> 2] = HEAP32[$varet100 >> 2];
   if (((HEAP32[$value98 >> 2] | 0) < 1101 | (HEAP32[$value98 >> 2] | 0) > 1105) & (HEAP32[$value98 >> 2] | 0) != -1e3) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 128 >> 2] = HEAP32[$value98 >> 2];
    $138 = HEAP32[$st$addr >> 2] | 0;
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 128 >> 2] | 0) == 1101) {
     HEAP32[$138 + 8 + 12 >> 2] = 8e3;
     label = 99;
     break L1;
    } else {
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 12 >> 2] = (HEAP32[$138 + 128 >> 2] | 0) == 1102 ? 12e3 : 16e3;
     label = 99;
     break L1;
    }
   }
   break;
  }
 case 4009:
  {
   $146 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $147 = HEAP32[$146 >> 2] | 0;
   HEAP32[$ap >> 2] = $146 + 4;
   HEAP32[$varet127 >> 2] = $147;
   HEAP32[$value125 >> 2] = HEAP32[$varet127 >> 2];
   if (HEAP32[$value125 >> 2] | 0) {
    HEAP32[HEAP32[$value125 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4016:
  {
   $158 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $159 = HEAP32[$158 >> 2] | 0;
   HEAP32[$ap >> 2] = $158 + 4;
   HEAP32[$varet134 >> 2] = $159;
   HEAP32[$value132 >> 2] = HEAP32[$varet134 >> 2];
   if ((HEAP32[$value132 >> 2] | 0) < 0 | (HEAP32[$value132 >> 2] | 0) > 1) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 184 >> 2] = HEAP32[$value132 >> 2];
    label = 99;
   }
   break;
  }
 case 4017:
  {
   $170 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $171 = HEAP32[$170 >> 2] | 0;
   HEAP32[$ap >> 2] = $170 + 4;
   HEAP32[$varet143 >> 2] = $171;
   HEAP32[$value141 >> 2] = HEAP32[$varet143 >> 2];
   if (HEAP32[$value141 >> 2] | 0) {
    HEAP32[HEAP32[$value141 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 184 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4010:
  {
   $182 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $183 = HEAP32[$182 >> 2] | 0;
   HEAP32[$ap >> 2] = $182 + 4;
   HEAP32[$varet151 >> 2] = $183;
   HEAP32[$value149 >> 2] = HEAP32[$varet151 >> 2];
   if ((HEAP32[$value149 >> 2] | 0) < 0 | (HEAP32[$value149 >> 2] | 0) > 10) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 36 >> 2] = HEAP32[$value149 >> 2];
    $189 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer >> 2] = HEAP32[$value149 >> 2];
    _opus_custom_encoder_ctl($189, 4010, $vararg_buffer) | 0;
    label = 99;
   }
   break;
  }
 case 4011:
  {
   $196 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $197 = HEAP32[$196 >> 2] | 0;
   HEAP32[$ap >> 2] = $196 + 4;
   HEAP32[$varet163 >> 2] = $197;
   HEAP32[$value161 >> 2] = HEAP32[$varet163 >> 2];
   if (HEAP32[$value161 >> 2] | 0) {
    HEAP32[HEAP32[$value161 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 36 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4012:
  {
   $208 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $209 = HEAP32[$208 >> 2] | 0;
   HEAP32[$ap >> 2] = $208 + 4;
   HEAP32[$varet172 >> 2] = $209;
   HEAP32[$value170 >> 2] = HEAP32[$varet172 >> 2];
   if ((HEAP32[$value170 >> 2] | 0) < 0 | (HEAP32[$value170 >> 2] | 0) > 1) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 40 >> 2] = HEAP32[$value170 >> 2];
    label = 99;
   }
   break;
  }
 case 4013:
  {
   $220 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $221 = HEAP32[$220 >> 2] | 0;
   HEAP32[$ap >> 2] = $220 + 4;
   HEAP32[$varet184 >> 2] = $221;
   HEAP32[$value182 >> 2] = HEAP32[$varet184 >> 2];
   if (HEAP32[$value182 >> 2] | 0) {
    HEAP32[HEAP32[$value182 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 40 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4014:
  {
   $232 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $233 = HEAP32[$232 >> 2] | 0;
   HEAP32[$ap >> 2] = $232 + 4;
   HEAP32[$varet193 >> 2] = $233;
   HEAP32[$value191 >> 2] = HEAP32[$varet193 >> 2];
   if ((HEAP32[$value191 >> 2] | 0) < 0 | (HEAP32[$value191 >> 2] | 0) > 100) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 32 >> 2] = HEAP32[$value191 >> 2];
    $239 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer105 >> 2] = HEAP32[$value191 >> 2];
    _opus_custom_encoder_ctl($239, 4014, $vararg_buffer105) | 0;
    label = 99;
   }
   break;
  }
 case 4015:
  {
   $246 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $247 = HEAP32[$246 >> 2] | 0;
   HEAP32[$ap >> 2] = $246 + 4;
   HEAP32[$varet208 >> 2] = $247;
   HEAP32[$value206 >> 2] = HEAP32[$varet208 >> 2];
   if (HEAP32[$value206 >> 2] | 0) {
    HEAP32[HEAP32[$value206 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 32 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4006:
  {
   $258 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $259 = HEAP32[$258 >> 2] | 0;
   HEAP32[$ap >> 2] = $258 + 4;
   HEAP32[$varet217 >> 2] = $259;
   HEAP32[$value215 >> 2] = HEAP32[$varet217 >> 2];
   if ((HEAP32[$value215 >> 2] | 0) < 0 | (HEAP32[$value215 >> 2] | 0) > 1) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] = HEAP32[$value215 >> 2];
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 52 >> 2] = 1 - (HEAP32[$value215 >> 2] | 0);
    label = 99;
   }
   break;
  }
 case 4007:
  {
   $272 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $273 = HEAP32[$272 >> 2] | 0;
   HEAP32[$ap >> 2] = $272 + 4;
   HEAP32[$varet229 >> 2] = $273;
   HEAP32[$value227 >> 2] = HEAP32[$varet229 >> 2];
   if (HEAP32[$value227 >> 2] | 0) {
    HEAP32[HEAP32[$value227 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 11018:
  {
   $284 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $285 = HEAP32[$284 >> 2] | 0;
   HEAP32[$ap >> 2] = $284 + 4;
   HEAP32[$varet237 >> 2] = $285;
   HEAP32[$value235 >> 2] = HEAP32[$varet237 >> 2];
   if ((HEAP32[$value235 >> 2] | 0) < -1 | (HEAP32[$value235 >> 2] | 0) > 100) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 140 >> 2] = HEAP32[$value235 >> 2];
    label = 99;
   }
   break;
  }
 case 11019:
  {
   $296 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $297 = HEAP32[$296 >> 2] | 0;
   HEAP32[$ap >> 2] = $296 + 4;
   HEAP32[$varet248 >> 2] = $297;
   HEAP32[$value246 >> 2] = HEAP32[$varet248 >> 2];
   if (HEAP32[$value246 >> 2] | 0) {
    HEAP32[HEAP32[$value246 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 140 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4020:
  {
   $308 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $309 = HEAP32[$308 >> 2] | 0;
   HEAP32[$ap >> 2] = $308 + 4;
   HEAP32[$varet256 >> 2] = $309;
   HEAP32[$value254 >> 2] = HEAP32[$varet256 >> 2];
   if ((HEAP32[$value254 >> 2] | 0) < 0 | (HEAP32[$value254 >> 2] | 0) > 1) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 152 >> 2] = HEAP32[$value254 >> 2];
    label = 99;
   }
   break;
  }
 case 4021:
  {
   $320 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $321 = HEAP32[$320 >> 2] | 0;
   HEAP32[$ap >> 2] = $320 + 4;
   HEAP32[$varet267 >> 2] = $321;
   HEAP32[$value265 >> 2] = HEAP32[$varet267 >> 2];
   if (HEAP32[$value265 >> 2] | 0) {
    HEAP32[HEAP32[$value265 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 152 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4024:
  {
   $332 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $333 = HEAP32[$332 >> 2] | 0;
   HEAP32[$ap >> 2] = $332 + 4;
   HEAP32[$varet275 >> 2] = $333;
   HEAP32[$value273 >> 2] = HEAP32[$varet275 >> 2];
   if ((HEAP32[$value273 >> 2] | 0) != -1e3 & (HEAP32[$value273 >> 2] | 0) != 3001 & (HEAP32[$value273 >> 2] | 0) != 3002) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 124 >> 2] = HEAP32[$value273 >> 2];
    label = 99;
   }
   break;
  }
 case 4025:
  {
   $345 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $346 = HEAP32[$345 >> 2] | 0;
   HEAP32[$ap >> 2] = $345 + 4;
   HEAP32[$varet289 >> 2] = $346;
   HEAP32[$value287 >> 2] = HEAP32[$varet289 >> 2];
   if (HEAP32[$value287 >> 2] | 0) {
    HEAP32[HEAP32[$value287 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 124 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4027:
  {
   $357 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $358 = HEAP32[$357 >> 2] | 0;
   HEAP32[$ap >> 2] = $357 + 4;
   HEAP32[$varet297 >> 2] = $358;
   HEAP32[$value295 >> 2] = HEAP32[$varet297 >> 2];
   if (HEAP32[$value295 >> 2] | 0) {
    HEAP32[HEAP32[$value295 >> 2] >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 400 | 0;
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] | 0) != 2051) {
     $368 = HEAP32[$value295 >> 2] | 0;
     HEAP32[$368 >> 2] = (HEAP32[$368 >> 2] | 0) + (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 116 >> 2] | 0);
     label = 99;
    } else label = 99;
   } else label = 100;
   break;
  }
 case 4029:
  {
   $375 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $376 = HEAP32[$375 >> 2] | 0;
   HEAP32[$ap >> 2] = $375 + 4;
   HEAP32[$varet309 >> 2] = $376;
   HEAP32[$value307 >> 2] = HEAP32[$varet309 >> 2];
   if (HEAP32[$value307 >> 2] | 0) {
    HEAP32[HEAP32[$value307 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4031:
  {
   $387 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $388 = HEAP32[$387 >> 2] | 0;
   HEAP32[$ap >> 2] = $387 + 4;
   HEAP32[$varet317 >> 2] = $388;
   HEAP32[$value315 >> 2] = HEAP32[$varet317 >> 2];
   if (HEAP32[$value315 >> 2] | 0) {
    HEAP32[HEAP32[$value315 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18132 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4036:
  {
   $399 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $400 = HEAP32[$399 >> 2] | 0;
   HEAP32[$ap >> 2] = $399 + 4;
   HEAP32[$varet324 >> 2] = $400;
   HEAP32[$value322 >> 2] = HEAP32[$varet324 >> 2];
   if ((HEAP32[$value322 >> 2] | 0) < 8 | (HEAP32[$value322 >> 2] | 0) > 24) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 168 >> 2] = HEAP32[$value322 >> 2];
    label = 99;
   }
   break;
  }
 case 4037:
  {
   $411 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $412 = HEAP32[$411 >> 2] | 0;
   HEAP32[$ap >> 2] = $411 + 4;
   HEAP32[$varet335 >> 2] = $412;
   HEAP32[$value333 >> 2] = HEAP32[$varet335 >> 2];
   if (HEAP32[$value333 >> 2] | 0) {
    HEAP32[HEAP32[$value333 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 168 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4040:
  {
   $423 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $424 = HEAP32[$423 >> 2] | 0;
   HEAP32[$ap >> 2] = $423 + 4;
   HEAP32[$varet343 >> 2] = $424;
   HEAP32[$value341 >> 2] = HEAP32[$varet343 >> 2];
   if ((HEAP32[$value341 >> 2] | 0) != 5e3 & (HEAP32[$value341 >> 2] | 0) != 5001 & (HEAP32[$value341 >> 2] | 0) != 5002 & (HEAP32[$value341 >> 2] | 0) != 5003 & (HEAP32[$value341 >> 2] | 0) != 5004 & (HEAP32[$value341 >> 2] | 0) != 5005 & (HEAP32[$value341 >> 2] | 0) != 5006 & (HEAP32[$value341 >> 2] | 0) != 5007 & (HEAP32[$value341 >> 2] | 0) != 5008 & (HEAP32[$value341 >> 2] | 0) != 5009) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 156 >> 2] = HEAP32[$value341 >> 2];
    $438 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer153 >> 2] = HEAP32[$value341 >> 2];
    _opus_custom_encoder_ctl($438, 4040, $vararg_buffer153) | 0;
    label = 99;
   }
   break;
  }
 case 4041:
  {
   $445 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $446 = HEAP32[$445 >> 2] | 0;
   HEAP32[$ap >> 2] = $445 + 4;
   HEAP32[$varet381 >> 2] = $446;
   HEAP32[$value379 >> 2] = HEAP32[$varet381 >> 2];
   if (HEAP32[$value379 >> 2] | 0) {
    HEAP32[HEAP32[$value379 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 156 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4042:
  {
   $457 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $458 = HEAP32[$457 >> 2] | 0;
   HEAP32[$ap >> 2] = $457 + 4;
   HEAP32[$varet389 >> 2] = $458;
   HEAP32[$value387 >> 2] = HEAP32[$varet389 >> 2];
   if ((HEAP32[$value387 >> 2] | 0) > 1 | (HEAP32[$value387 >> 2] | 0) < 0) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 68 >> 2] = HEAP32[$value387 >> 2];
    label = 99;
   }
   break;
  }
 case 4043:
  {
   $469 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $470 = HEAP32[$469 >> 2] | 0;
   HEAP32[$ap >> 2] = $469 + 4;
   HEAP32[$varet401 >> 2] = $470;
   HEAP32[$value399 >> 2] = HEAP32[$varet401 >> 2];
   if (HEAP32[$value399 >> 2] | 0) {
    HEAP32[HEAP32[$value399 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 68 >> 2];
    label = 99;
   } else label = 100;
   break;
  }
 case 4046:
  {
   $481 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $482 = HEAP32[$481 >> 2] | 0;
   HEAP32[$ap >> 2] = $481 + 4;
   HEAP32[$varet410 >> 2] = $482;
   HEAP32[$value408 >> 2] = HEAP32[$varet410 >> 2];
   if ((HEAP32[$value408 >> 2] | 0) < 0 | (HEAP32[$value408 >> 2] | 0) > 1) label = 100; else {
    $486 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer168 >> 2] = HEAP32[$value408 >> 2];
    _opus_custom_encoder_ctl($486, 4046, $vararg_buffer168) | 0;
    label = 99;
   }
   break;
  }
 case 4047:
  {
   $493 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $494 = HEAP32[$493 >> 2] | 0;
   HEAP32[$ap >> 2] = $493 + 4;
   HEAP32[$varet424 >> 2] = $494;
   HEAP32[$value422 >> 2] = HEAP32[$varet424 >> 2];
   if (HEAP32[$value422 >> 2] | 0) {
    $497 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer174 >> 2] = (HEAP32[$value422 >> 2] | 0) + ((((HEAP32[$value422 >> 2] | 0) - (HEAP32[$value422 >> 2] | 0) | 0) / 4 | 0) << 2);
    _opus_custom_encoder_ctl($497, 4047, $vararg_buffer174) | 0;
    label = 99;
   } else label = 100;
   break;
  }
 case 4028:
  {
   HEAP32[$silk_enc >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0);
   _tonality_analysis_reset((HEAP32[$st$addr >> 2] | 0) + 188 | 0);
   HEAP32[$start >> 2] = (HEAP32[$st$addr >> 2] | 0) + 14188;
   _memset(HEAP32[$start >> 2] | 0, 0, 18136 - ((HEAP32[$start >> 2] | 0) - (HEAP32[$st$addr >> 2] | 0)) | 0) | 0;
   _opus_custom_encoder_ctl(HEAP32[$celt_enc >> 2] | 0, 4028, $vararg_buffer177) | 0;
   _silk_InitEncoder(HEAP32[$silk_enc >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] | 0, $dummy) | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2];
   HEAP16[(HEAP32[$st$addr >> 2] | 0) + 14192 >> 1] = 16384;
   HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14200 >> 2] = 1.0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14248 >> 2] = 1;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = 1001;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = 1105;
   $shl = (_silk_lin2log(60) | 0) << 8;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14196 >> 2] = $shl;
   label = 99;
   break;
  }
 case 11002:
  {
   $527 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $528 = HEAP32[$527 >> 2] | 0;
   HEAP32[$ap >> 2] = $527 + 4;
   HEAP32[$varet448 >> 2] = $528;
   HEAP32[$value446 >> 2] = HEAP32[$varet448 >> 2];
   if (((HEAP32[$value446 >> 2] | 0) < 1e3 | (HEAP32[$value446 >> 2] | 0) > 1002) & (HEAP32[$value446 >> 2] | 0) != -1e3) label = 100; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 136 >> 2] = HEAP32[$value446 >> 2];
    label = 99;
   }
   break;
  }
 case 10024:
  {
   $540 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $541 = HEAP32[$540 >> 2] | 0;
   HEAP32[$ap >> 2] = $540 + 4;
   HEAP32[$varet462 >> 2] = $541;
   HEAP32[$value460 >> 2] = HEAP32[$varet462 >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 176 >> 2] = HEAP32[$value460 >> 2];
   $545 = HEAP32[$celt_enc >> 2] | 0;
   HEAP32[$vararg_buffer185 >> 2] = HEAP32[$value460 >> 2];
   HEAP32[$ret >> 2] = _opus_custom_encoder_ctl($545, 10024, $vararg_buffer185) | 0;
   label = 99;
   break;
  }
 case 10026:
  {
   $552 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $553 = HEAP32[$552 >> 2] | 0;
   HEAP32[$ap >> 2] = $552 + 4;
   HEAP32[$varet469 >> 2] = $553;
   HEAP32[$value467 >> 2] = HEAP32[$varet469 >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14252 >> 2] = HEAP32[$value467 >> 2];
   $557 = HEAP32[$celt_enc >> 2] | 0;
   HEAP32[$vararg_buffer191 >> 2] = (HEAP32[$value467 >> 2] | 0) + ((((HEAP32[$value467 >> 2] | 0) - (HEAP32[$value467 >> 2] | 0) | 0) / 4 | 0) << 2);
   HEAP32[$ret >> 2] = _opus_custom_encoder_ctl($557, 10026, $vararg_buffer191) | 0;
   label = 99;
   break;
  }
 case 10015:
  {
   $566 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $567 = HEAP32[$566 >> 2] | 0;
   HEAP32[$ap >> 2] = $566 + 4;
   HEAP32[$varet479 >> 2] = $567;
   HEAP32[$value477 >> 2] = HEAP32[$varet479 >> 2];
   if (HEAP32[$value477 >> 2] | 0) {
    $570 = HEAP32[$celt_enc >> 2] | 0;
    HEAP32[$vararg_buffer197 >> 2] = (HEAP32[$value477 >> 2] | 0) + ((((HEAP32[$value477 >> 2] | 0) - (HEAP32[$value477 >> 2] | 0) | 0) / 4 | 0) << 2);
    HEAP32[$ret >> 2] = _opus_custom_encoder_ctl($570, 10015, $vararg_buffer197) | 0;
    label = 99;
   } else label = 100;
   break;
  }
 default:
  {
   HEAP32[$ret >> 2] = -5;
   label = 99;
  }
 } while (0);
 if ((label | 0) == 99) {
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $575 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $575 | 0;
 } else if ((label | 0) == 100) {
  HEAP32[$retval >> 2] = -1;
  $575 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $575 | 0;
 }
 return 0;
}

function _quant_all_bands($encode, $m, $start, $end, $X_, $Y_, $collapse_masks, $bandE, $pulses, $shortBlocks, $spread, $dual_stereo, $intensity, $tf_res, $total_bits, $balance, $ec, $LM, $codedBands, $seed, $complexity, $arch, $disable_inv) {
 $encode = $encode | 0;
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $X_ = $X_ | 0;
 $Y_ = $Y_ | 0;
 $collapse_masks = $collapse_masks | 0;
 $bandE = $bandE | 0;
 $pulses = $pulses | 0;
 $shortBlocks = $shortBlocks | 0;
 $spread = $spread | 0;
 $dual_stereo = $dual_stereo | 0;
 $intensity = $intensity | 0;
 $tf_res = $tf_res | 0;
 $total_bits = $total_bits | 0;
 $balance = $balance | 0;
 $ec = $ec | 0;
 $LM = $LM | 0;
 $codedBands = $codedBands | 0;
 $seed = $seed | 0;
 $complexity = $complexity | 0;
 $arch = $arch | 0;
 $disable_inv = $disable_inv | 0;
 var $202 = 0, $203 = 0, $326 = 0.0, $331 = 0.0, $400 = 0.0, $405 = 0.0, $7 = 0, $B = 0, $C = 0, $LM$addr = 0, $M = 0, $N = 0, $X = 0, $X_$addr = 0, $Y = 0, $Y_$addr = 0, $add$ptr = 0, $add$ptr324 = 0, $add$ptr344 = 0, $add$ptr388 = 0, $add$ptr423 = 0, $add$ptr483 = 0, $add$ptr522 = 0, $add$ptr563 = 0, $add$ptr585 = 0, $arch$addr = 0, $b = 0, $balance$addr = 0, $bandE$addr = 0, $bytes_buf = 0, $bytes_save = 0, $cm = 0, $cm2 = 0, $codedBands$addr = 0, $collapse_masks$addr = 0, $complexity$addr = 0, $cond108 = 0, $cond121 = 0, $cond139 = 0, $cond155 = 0, $cond175 = 0, $cond246 = 0, $cond317 = 0, $cond328 = 0, $cond337 = 0, $cond348 = 0, $cond381 = 0, $cond392 = 0, $cond476 = 0, $cond487 = 0, $cond556 = 0, $cond567 = 0, $cond578 = 0, $cond589 = 0, $conv272 = 0, $ctx = 0, $ctx_save = 0, $ctx_save2 = 0, $curr_balance = 0, $dec = 0, $disable_inv$addr = 0, $dist0 = 0, $dist1 = 0, $dual_stereo$addr = 0, $eBands = 0, $ec$addr = 0, $ec_save = 0, $ec_save2 = 0, $effective_lowband = 0, $encode$addr = 0, $end$addr = 0, $fold_end = 0, $fold_i = 0, $fold_start = 0, $i = 0, $inc = 0, $inc279 = 0, $intensity$addr = 0, $j = 0, $last = 0, $lowband_offset = 0, $lowband_scratch = 0, $m$addr = 0, $mul12 = 0, $mul14 = 0, $mul182 = 0, $mul233 = 0, $mul242 = 0, $mul249 = 0, $mul260 = 0, $mul273 = 0, $mul296 = 0, $mul397 = 0.0, $mul493 = 0.0, $mul599 = 0, $mul84 = 0, $nend_bytes = 0, $norm = 0, $norm2 = 0, $norm_offset = 0, $nstart_bytes = 0, $pulses$addr = 0, $remaining_bits = 0, $resynth = 0, $resynth_alloc = 0, $save_bytes = 0, $saved_stack = 0, $seed$addr = 0, $shortBlocks$addr = 0, $spread$addr = 0, $start$addr = 0, $sub284 = 0, $tell = 0, $tf_change = 0, $tf_res$addr = 0, $theta_rdo = 0, $total_bits$addr = 0, $update_lowband = 0, $vla = 0, $vla33 = 0, $vla46 = 0, $vla47 = 0, $vla48 = 0, $vla49 = 0, $vla50 = 0, $w = 0, $x_cm = 0, $y_cm = 0, dest = 0, label = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1808 | 0;
 $encode$addr = sp + 528 | 0;
 $m$addr = sp + 524 | 0;
 $start$addr = sp + 520 | 0;
 $end$addr = sp + 516 | 0;
 $X_$addr = sp + 512 | 0;
 $Y_$addr = sp + 508 | 0;
 $collapse_masks$addr = sp + 504 | 0;
 $bandE$addr = sp + 500 | 0;
 $pulses$addr = sp + 496 | 0;
 $shortBlocks$addr = sp + 492 | 0;
 $spread$addr = sp + 488 | 0;
 $dual_stereo$addr = sp + 484 | 0;
 $intensity$addr = sp + 480 | 0;
 $tf_res$addr = sp + 476 | 0;
 $total_bits$addr = sp + 472 | 0;
 $balance$addr = sp + 468 | 0;
 $ec$addr = sp + 464 | 0;
 $LM$addr = sp + 460 | 0;
 $codedBands$addr = sp + 456 | 0;
 $seed$addr = sp + 452 | 0;
 $complexity$addr = sp + 448 | 0;
 $arch$addr = sp + 444 | 0;
 $disable_inv$addr = sp + 440 | 0;
 $i = sp + 436 | 0;
 $remaining_bits = sp + 432 | 0;
 $eBands = sp + 428 | 0;
 $norm = sp + 424 | 0;
 $norm2 = sp + 420 | 0;
 $resynth_alloc = sp + 416 | 0;
 $lowband_scratch = sp + 412 | 0;
 $B = sp + 408 | 0;
 $M = sp + 404 | 0;
 $lowband_offset = sp + 400 | 0;
 $update_lowband = sp + 396 | 0;
 $C = sp + 392 | 0;
 $norm_offset = sp + 388 | 0;
 $theta_rdo = sp + 384 | 0;
 $resynth = sp + 380 | 0;
 $ctx = sp + 320 | 0;
 $saved_stack = sp + 316 | 0;
 $tell = sp + 312 | 0;
 $b = sp + 308 | 0;
 $N = sp + 304 | 0;
 $curr_balance = sp + 300 | 0;
 $effective_lowband = sp + 296 | 0;
 $X = sp + 292 | 0;
 $Y = sp + 288 | 0;
 $tf_change = sp + 284 | 0;
 $x_cm = sp + 280 | 0;
 $y_cm = sp + 276 | 0;
 $last = sp + 272 | 0;
 $fold_start = sp + 268 | 0;
 $fold_end = sp + 264 | 0;
 $fold_i = sp + 260 | 0;
 $j = sp + 256 | 0;
 $ec_save = sp + 208 | 0;
 $ec_save2 = sp + 160 | 0;
 $ctx_save = sp + 100 | 0;
 $ctx_save2 = sp + 40 | 0;
 $dist0 = sp + 36 | 0;
 $dist1 = sp + 32 | 0;
 $cm = sp + 28 | 0;
 $cm2 = sp + 24 | 0;
 $nstart_bytes = sp + 20 | 0;
 $nend_bytes = sp + 16 | 0;
 $save_bytes = sp + 12 | 0;
 $bytes_buf = sp + 8 | 0;
 $bytes_save = sp + 532 | 0;
 $w = sp;
 HEAP32[$encode$addr >> 2] = $encode;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$X_$addr >> 2] = $X_;
 HEAP32[$Y_$addr >> 2] = $Y_;
 HEAP32[$collapse_masks$addr >> 2] = $collapse_masks;
 HEAP32[$bandE$addr >> 2] = $bandE;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$shortBlocks$addr >> 2] = $shortBlocks;
 HEAP32[$spread$addr >> 2] = $spread;
 HEAP32[$dual_stereo$addr >> 2] = $dual_stereo;
 HEAP32[$intensity$addr >> 2] = $intensity;
 HEAP32[$tf_res$addr >> 2] = $tf_res;
 HEAP32[$total_bits$addr >> 2] = $total_bits;
 HEAP32[$balance$addr >> 2] = $balance;
 HEAP32[$ec$addr >> 2] = $ec;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$codedBands$addr >> 2] = $codedBands;
 HEAP32[$seed$addr >> 2] = $seed;
 HEAP32[$complexity$addr >> 2] = $complexity;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$disable_inv$addr >> 2] = $disable_inv;
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$update_lowband >> 2] = 1;
 HEAP32[$C >> 2] = HEAP32[$Y_$addr >> 2] | 0 ? 2 : 1;
 if ((HEAP32[$encode$addr >> 2] | 0) != 0 & (HEAP32[$Y_$addr >> 2] | 0) != 0 ^ 1 | (HEAP32[$dual_stereo$addr >> 2] | 0) != 0) $7 = 0; else $7 = (HEAP32[$complexity$addr >> 2] | 0) >= 8;
 HEAP32[$theta_rdo >> 2] = $7 & 1;
 HEAP32[$resynth >> 2] = (HEAP32[$encode$addr >> 2] | 0 ? (HEAP32[$theta_rdo >> 2] | 0) != 0 : 1) & 1;
 HEAP32[$M >> 2] = 1 << HEAP32[$LM$addr >> 2];
 HEAP32[$B >> 2] = HEAP32[$shortBlocks$addr >> 2] | 0 ? HEAP32[$M >> 2] | 0 : 1;
 HEAP32[$norm_offset >> 2] = Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0) | 0;
 $mul12 = Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) - 1 << 1) >> 1] | 0) | 0;
 $mul14 = Math_imul(HEAP32[$C >> 2] | 0, $mul12 - (HEAP32[$norm_offset >> 2] | 0) | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($mul14 << 2) | 0) + 15 & -16) | 0;
 HEAP32[$norm >> 2] = $vla;
 $add$ptr = (HEAP32[$norm >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) << 2) | 0;
 HEAP32[$norm2 >> 2] = $add$ptr + (0 - (HEAP32[$norm_offset >> 2] | 0) << 2);
 if ((HEAP32[$encode$addr >> 2] | 0) != 0 & (HEAP32[$resynth >> 2] | 0) != 0) HEAP32[$resynth_alloc >> 2] = Math_imul(HEAP32[$M >> 2] | 0, (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) | 0; else HEAP32[$resynth_alloc >> 2] = 1;
 $vla33 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$resynth_alloc >> 2] << 2) | 0) + 15 & -16) | 0;
 if ((HEAP32[$encode$addr >> 2] | 0) != 0 & (HEAP32[$resynth >> 2] | 0) != 0) HEAP32[$lowband_scratch >> 2] = $vla33; else HEAP32[$lowband_scratch >> 2] = (HEAP32[$X_$addr >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) << 2);
 $vla46 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$resynth_alloc >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla47 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$resynth_alloc >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla48 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$resynth_alloc >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla49 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$resynth_alloc >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla50 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$resynth_alloc >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[$lowband_offset >> 2] = 0;
 HEAP32[$ctx + 36 >> 2] = HEAP32[$bandE$addr >> 2];
 HEAP32[$ctx + 28 >> 2] = HEAP32[$ec$addr >> 2];
 HEAP32[$ctx >> 2] = HEAP32[$encode$addr >> 2];
 HEAP32[$ctx + 16 >> 2] = HEAP32[$intensity$addr >> 2];
 HEAP32[$ctx + 8 >> 2] = HEAP32[$m$addr >> 2];
 HEAP32[$ctx + 40 >> 2] = HEAP32[HEAP32[$seed$addr >> 2] >> 2];
 HEAP32[$ctx + 20 >> 2] = HEAP32[$spread$addr >> 2];
 HEAP32[$ctx + 44 >> 2] = HEAP32[$arch$addr >> 2];
 HEAP32[$ctx + 52 >> 2] = HEAP32[$disable_inv$addr >> 2];
 HEAP32[$ctx + 4 >> 2] = HEAP32[$resynth >> 2];
 HEAP32[$ctx + 48 >> 2] = 0;
 HEAP32[$ctx + 56 >> 2] = (HEAP32[$B >> 2] | 0) > 1 & 1;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP32[$effective_lowband >> 2] = -1;
  HEAP32[$tf_change >> 2] = 0;
  HEAP32[$ctx + 12 >> 2] = HEAP32[$i >> 2];
  HEAP32[$last >> 2] = (HEAP32[$i >> 2] | 0) == ((HEAP32[$end$addr >> 2] | 0) - 1 | 0) & 1;
  HEAP32[$X >> 2] = (HEAP32[$X_$addr >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2);
  if (HEAP32[$Y_$addr >> 2] | 0) HEAP32[$Y >> 2] = (HEAP32[$Y_$addr >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2); else HEAP32[$Y >> 2] = 0;
  $mul84 = Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) | 0;
  HEAP32[$N >> 2] = $mul84 - (Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0);
  HEAP32[$tell >> 2] = _ec_tell_frac(HEAP32[$ec$addr >> 2] | 0) | 0;
  if ((HEAP32[$i >> 2] | 0) != (HEAP32[$start$addr >> 2] | 0)) HEAP32[$balance$addr >> 2] = (HEAP32[$balance$addr >> 2] | 0) - (HEAP32[$tell >> 2] | 0);
  HEAP32[$remaining_bits >> 2] = (HEAP32[$total_bits$addr >> 2] | 0) - (HEAP32[$tell >> 2] | 0) - 1;
  HEAP32[$ctx + 32 >> 2] = HEAP32[$remaining_bits >> 2];
  if ((HEAP32[$i >> 2] | 0) <= ((HEAP32[$codedBands$addr >> 2] | 0) - 1 | 0)) {
   if (3 < ((HEAP32[$codedBands$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) | 0)) $cond108 = 3; else $cond108 = (HEAP32[$codedBands$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) | 0;
   HEAP32[$curr_balance >> 2] = _celt_sudiv(HEAP32[$balance$addr >> 2] | 0, $cond108) | 0;
   if (((HEAP32[$remaining_bits >> 2] | 0) + 1 | 0) < ((HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$curr_balance >> 2] | 0) | 0)) $cond121 = (HEAP32[$remaining_bits >> 2] | 0) + 1 | 0; else $cond121 = (HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$curr_balance >> 2] | 0) | 0;
   do if (16383 < ($cond121 | 0)) $cond139 = 16383; else if (((HEAP32[$remaining_bits >> 2] | 0) + 1 | 0) < ((HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$curr_balance >> 2] | 0) | 0)) {
    $cond139 = (HEAP32[$remaining_bits >> 2] | 0) + 1 | 0;
    break;
   } else {
    $cond139 = (HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$curr_balance >> 2] | 0) | 0;
    break;
   } while (0);
   do if (0 > ($cond139 | 0)) $cond175 = 0; else {
    if (((HEAP32[$remaining_bits >> 2] | 0) + 1 | 0) < ((HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$curr_balance >> 2] | 0) | 0)) $cond155 = (HEAP32[$remaining_bits >> 2] | 0) + 1 | 0; else $cond155 = (HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$curr_balance >> 2] | 0) | 0;
    if (16383 < ($cond155 | 0)) $cond175 = 16383; else if (((HEAP32[$remaining_bits >> 2] | 0) + 1 | 0) < ((HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$curr_balance >> 2] | 0) | 0)) {
     $cond175 = (HEAP32[$remaining_bits >> 2] | 0) + 1 | 0;
     break;
    } else {
     $cond175 = (HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$curr_balance >> 2] | 0) | 0;
     break;
    }
   } while (0);
   HEAP32[$b >> 2] = $cond175;
  } else HEAP32[$b >> 2] = 0;
  do if (HEAP32[$resynth >> 2] | 0) {
   $mul182 = Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
   if (($mul182 - (HEAP32[$N >> 2] | 0) | 0) < (Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0) | 0)) if ((HEAP32[$i >> 2] | 0) != ((HEAP32[$start$addr >> 2] | 0) + 1 | 0)) break;
   if ((HEAP32[$update_lowband >> 2] | 0) != 0 | (HEAP32[$lowband_offset >> 2] | 0) == 0) HEAP32[$lowband_offset >> 2] = HEAP32[$i >> 2];
  } while (0);
  if ((HEAP32[$i >> 2] | 0) == ((HEAP32[$start$addr >> 2] | 0) + 1 | 0)) _special_hybrid_folding(HEAP32[$m$addr >> 2] | 0, HEAP32[$norm >> 2] | 0, HEAP32[$norm2 >> 2] | 0, HEAP32[$start$addr >> 2] | 0, HEAP32[$M >> 2] | 0, HEAP32[$dual_stereo$addr >> 2] | 0);
  HEAP32[$tf_change >> 2] = HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$ctx + 24 >> 2] = HEAP32[$tf_change >> 2];
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 12 >> 2] | 0)) {
   HEAP32[$X >> 2] = HEAP32[$norm >> 2];
   if (HEAP32[$Y_$addr >> 2] | 0) HEAP32[$Y >> 2] = HEAP32[$norm >> 2];
   HEAP32[$lowband_scratch >> 2] = 0;
  }
  if (!((HEAP32[$last >> 2] | 0) == 0 | (HEAP32[$theta_rdo >> 2] | 0) != 0)) HEAP32[$lowband_scratch >> 2] = 0;
  if (HEAP32[$lowband_offset >> 2] | 0) if ((HEAP32[$spread$addr >> 2] | 0) != 3 | (HEAP32[$B >> 2] | 0) > 1 | (HEAP32[$tf_change >> 2] | 0) < 0) {
   $mul233 = Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$lowband_offset >> 2] << 1) >> 1] | 0) | 0;
   if (0 > ($mul233 - (HEAP32[$norm_offset >> 2] | 0) - (HEAP32[$N >> 2] | 0) | 0)) $cond246 = 0; else {
    $mul242 = Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$lowband_offset >> 2] << 1) >> 1] | 0) | 0;
    $cond246 = $mul242 - (HEAP32[$norm_offset >> 2] | 0) - (HEAP32[$N >> 2] | 0) | 0;
   }
   HEAP32[$effective_lowband >> 2] = $cond246;
   HEAP32[$fold_start >> 2] = HEAP32[$lowband_offset >> 2];
   do {
    $202 = HEAP32[$M >> 2] | 0;
    $203 = HEAP32[$eBands >> 2] | 0;
    $dec = (HEAP32[$fold_start >> 2] | 0) + -1 | 0;
    HEAP32[$fold_start >> 2] = $dec;
    $mul249 = Math_imul($202, HEAP16[$203 + ($dec << 1) >> 1] | 0) | 0;
   } while (($mul249 | 0) > ((HEAP32[$effective_lowband >> 2] | 0) + (HEAP32[$norm_offset >> 2] | 0) | 0));
   HEAP32[$fold_end >> 2] = (HEAP32[$lowband_offset >> 2] | 0) - 1;
   do {
    $inc = (HEAP32[$fold_end >> 2] | 0) + 1 | 0;
    HEAP32[$fold_end >> 2] = $inc;
    if (($inc | 0) >= (HEAP32[$i >> 2] | 0)) break;
    $mul260 = Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$fold_end >> 2] << 1) >> 1] | 0) | 0;
   } while (($mul260 | 0) < ((HEAP32[$effective_lowband >> 2] | 0) + (HEAP32[$norm_offset >> 2] | 0) + (HEAP32[$N >> 2] | 0) | 0));
   HEAP32[$y_cm >> 2] = 0;
   HEAP32[$x_cm >> 2] = 0;
   HEAP32[$fold_i >> 2] = HEAP32[$fold_start >> 2];
   do {
    $conv272 = HEAPU8[(HEAP32[$collapse_masks$addr >> 2] | 0) + ((Math_imul(HEAP32[$fold_i >> 2] | 0, HEAP32[$C >> 2] | 0) | 0) + 0) >> 0] | 0;
    HEAP32[$x_cm >> 2] = HEAP32[$x_cm >> 2] | $conv272;
    $mul273 = Math_imul(HEAP32[$fold_i >> 2] | 0, HEAP32[$C >> 2] | 0) | 0;
    HEAP32[$y_cm >> 2] = HEAP32[$y_cm >> 2] | HEAPU8[(HEAP32[$collapse_masks$addr >> 2] | 0) + ($mul273 + (HEAP32[$C >> 2] | 0) - 1) >> 0];
    $inc279 = (HEAP32[$fold_i >> 2] | 0) + 1 | 0;
    HEAP32[$fold_i >> 2] = $inc279;
   } while (($inc279 | 0) < (HEAP32[$fold_end >> 2] | 0));
  } else label = 60; else label = 60;
  if ((label | 0) == 60) {
   label = 0;
   $sub284 = (1 << HEAP32[$B >> 2]) - 1 | 0;
   HEAP32[$y_cm >> 2] = $sub284;
   HEAP32[$x_cm >> 2] = $sub284;
  }
  L87 : do if (HEAP32[$dual_stereo$addr >> 2] | 0) if ((HEAP32[$i >> 2] | 0) == (HEAP32[$intensity$addr >> 2] | 0)) {
   HEAP32[$dual_stereo$addr >> 2] = 0;
   if (HEAP32[$resynth >> 2] | 0) {
    HEAP32[$j >> 2] = 0;
    while (1) {
     $mul296 = Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
     if ((HEAP32[$j >> 2] | 0) >= ($mul296 - (HEAP32[$norm_offset >> 2] | 0) | 0)) break L87;
     HEAPF32[(HEAP32[$norm >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = (+HEAPF32[(HEAP32[$norm >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] + +HEAPF32[(HEAP32[$norm2 >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2]) * .5;
     HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
    }
   }
  } while (0);
  if (HEAP32[$dual_stereo$addr >> 2] | 0) {
   if ((HEAP32[$effective_lowband >> 2] | 0) != -1) $cond317 = (HEAP32[$norm >> 2] | 0) + (HEAP32[$effective_lowband >> 2] << 2) | 0; else $cond317 = 0;
   if (HEAP32[$last >> 2] | 0) $cond328 = 0; else {
    $add$ptr324 = (HEAP32[$norm >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2) | 0;
    $cond328 = $add$ptr324 + (0 - (HEAP32[$norm_offset >> 2] | 0) << 2) | 0;
   }
   HEAP32[$x_cm >> 2] = _quant_band($ctx, HEAP32[$X >> 2] | 0, HEAP32[$N >> 2] | 0, (HEAP32[$b >> 2] | 0) / 2 | 0, HEAP32[$B >> 2] | 0, $cond317, HEAP32[$LM$addr >> 2] | 0, $cond328, 1.0, HEAP32[$lowband_scratch >> 2] | 0, HEAP32[$x_cm >> 2] | 0) | 0;
   if ((HEAP32[$effective_lowband >> 2] | 0) != -1) $cond337 = (HEAP32[$norm2 >> 2] | 0) + (HEAP32[$effective_lowband >> 2] << 2) | 0; else $cond337 = 0;
   if (HEAP32[$last >> 2] | 0) $cond348 = 0; else {
    $add$ptr344 = (HEAP32[$norm2 >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2) | 0;
    $cond348 = $add$ptr344 + (0 - (HEAP32[$norm_offset >> 2] | 0) << 2) | 0;
   }
   HEAP32[$y_cm >> 2] = _quant_band($ctx, HEAP32[$Y >> 2] | 0, HEAP32[$N >> 2] | 0, (HEAP32[$b >> 2] | 0) / 2 | 0, HEAP32[$B >> 2] | 0, $cond337, HEAP32[$LM$addr >> 2] | 0, $cond348, 1.0, HEAP32[$lowband_scratch >> 2] | 0, HEAP32[$y_cm >> 2] | 0) | 0;
  } else {
   L110 : do if (HEAP32[$Y >> 2] | 0) {
    do if (HEAP32[$theta_rdo >> 2] | 0) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$intensity$addr >> 2] | 0)) break;
     _compute_channel_weights(+HEAPF32[(HEAP32[$bandE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2], +HEAPF32[(HEAP32[$bandE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) << 2) >> 2], $w);
     HEAP32[$cm >> 2] = HEAP32[$x_cm >> 2] | HEAP32[$y_cm >> 2];
     dest = $ec_save;
     src = HEAP32[$ec$addr >> 2] | 0;
     stop = dest + 48 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     dest = $ctx_save;
     src = $ctx;
     stop = dest + 60 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     _memcpy($vla46 | 0, HEAP32[$X >> 2] | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     _memcpy($vla47 | 0, HEAP32[$Y >> 2] | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     HEAP32[$ctx + 48 >> 2] = -1;
     if ((HEAP32[$effective_lowband >> 2] | 0) != -1) $cond381 = (HEAP32[$norm >> 2] | 0) + (HEAP32[$effective_lowband >> 2] << 2) | 0; else $cond381 = 0;
     if (HEAP32[$last >> 2] | 0) $cond392 = 0; else {
      $add$ptr388 = (HEAP32[$norm >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2) | 0;
      $cond392 = $add$ptr388 + (0 - (HEAP32[$norm_offset >> 2] | 0) << 2) | 0;
     }
     HEAP32[$x_cm >> 2] = _quant_band_stereo($ctx, HEAP32[$X >> 2] | 0, HEAP32[$Y >> 2] | 0, HEAP32[$N >> 2] | 0, HEAP32[$b >> 2] | 0, HEAP32[$B >> 2] | 0, $cond381, HEAP32[$LM$addr >> 2] | 0, $cond392, HEAP32[$lowband_scratch >> 2] | 0, HEAP32[$cm >> 2] | 0) | 0;
     $326 = +HEAPF32[$w >> 2];
     $mul397 = $326 * +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]($vla46, HEAP32[$X >> 2] | 0, HEAP32[$N >> 2] | 0);
     $331 = +HEAPF32[$w + 4 >> 2];
     HEAPF32[$dist0 >> 2] = $mul397 + $331 * +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]($vla47, HEAP32[$Y >> 2] | 0, HEAP32[$N >> 2] | 0);
     HEAP32[$cm2 >> 2] = HEAP32[$x_cm >> 2];
     dest = $ec_save2;
     src = HEAP32[$ec$addr >> 2] | 0;
     stop = dest + 48 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     dest = $ctx_save2;
     src = $ctx;
     stop = dest + 60 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     _memcpy($vla48 | 0, HEAP32[$X >> 2] | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     _memcpy($vla49 | 0, HEAP32[$Y >> 2] | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     if (!(HEAP32[$last >> 2] | 0)) {
      $add$ptr423 = (HEAP32[$norm >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2) | 0;
      _memcpy($vla50 | 0, $add$ptr423 + (0 - (HEAP32[$norm_offset >> 2] | 0) << 2) | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     }
     HEAP32[$nstart_bytes >> 2] = HEAP32[$ec_save + 24 >> 2];
     HEAP32[$nend_bytes >> 2] = HEAP32[$ec_save + 4 >> 2];
     HEAP32[$bytes_buf >> 2] = (HEAP32[$ec_save >> 2] | 0) + (HEAP32[$nstart_bytes >> 2] | 0);
     HEAP32[$save_bytes >> 2] = (HEAP32[$nend_bytes >> 2] | 0) - (HEAP32[$nstart_bytes >> 2] | 0);
     _memcpy($bytes_save | 0, HEAP32[$bytes_buf >> 2] | 0, (HEAP32[$save_bytes >> 2] | 0) + 0 | 0) | 0;
     dest = HEAP32[$ec$addr >> 2] | 0;
     src = $ec_save;
     stop = dest + 48 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     dest = $ctx;
     src = $ctx_save;
     stop = dest + 60 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     _memcpy(HEAP32[$X >> 2] | 0, $vla46 | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     _memcpy(HEAP32[$Y >> 2] | 0, $vla47 | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     if ((HEAP32[$i >> 2] | 0) == ((HEAP32[$start$addr >> 2] | 0) + 1 | 0)) _special_hybrid_folding(HEAP32[$m$addr >> 2] | 0, HEAP32[$norm >> 2] | 0, HEAP32[$norm2 >> 2] | 0, HEAP32[$start$addr >> 2] | 0, HEAP32[$M >> 2] | 0, HEAP32[$dual_stereo$addr >> 2] | 0);
     HEAP32[$ctx + 48 >> 2] = 1;
     if ((HEAP32[$effective_lowband >> 2] | 0) != -1) $cond476 = (HEAP32[$norm >> 2] | 0) + (HEAP32[$effective_lowband >> 2] << 2) | 0; else $cond476 = 0;
     if (HEAP32[$last >> 2] | 0) $cond487 = 0; else {
      $add$ptr483 = (HEAP32[$norm >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2) | 0;
      $cond487 = $add$ptr483 + (0 - (HEAP32[$norm_offset >> 2] | 0) << 2) | 0;
     }
     HEAP32[$x_cm >> 2] = _quant_band_stereo($ctx, HEAP32[$X >> 2] | 0, HEAP32[$Y >> 2] | 0, HEAP32[$N >> 2] | 0, HEAP32[$b >> 2] | 0, HEAP32[$B >> 2] | 0, $cond476, HEAP32[$LM$addr >> 2] | 0, $cond487, HEAP32[$lowband_scratch >> 2] | 0, HEAP32[$cm >> 2] | 0) | 0;
     $400 = +HEAPF32[$w >> 2];
     $mul493 = $400 * +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]($vla46, HEAP32[$X >> 2] | 0, HEAP32[$N >> 2] | 0);
     $405 = +HEAPF32[$w + 4 >> 2];
     HEAPF32[$dist1 >> 2] = $mul493 + $405 * +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]($vla47, HEAP32[$Y >> 2] | 0, HEAP32[$N >> 2] | 0);
     if (!(+HEAPF32[$dist0 >> 2] >= +HEAPF32[$dist1 >> 2])) break L110;
     HEAP32[$x_cm >> 2] = HEAP32[$cm2 >> 2];
     dest = HEAP32[$ec$addr >> 2] | 0;
     src = $ec_save2;
     stop = dest + 48 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     dest = $ctx;
     src = $ctx_save2;
     stop = dest + 60 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     _memcpy(HEAP32[$X >> 2] | 0, $vla48 | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     _memcpy(HEAP32[$Y >> 2] | 0, $vla49 | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     if (!(HEAP32[$last >> 2] | 0)) {
      $add$ptr522 = (HEAP32[$norm >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2) | 0;
      _memcpy($add$ptr522 + (0 - (HEAP32[$norm_offset >> 2] | 0) << 2) | 0, $vla50 | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
     }
     _memcpy(HEAP32[$bytes_buf >> 2] | 0, $bytes_save | 0, (HEAP32[$save_bytes >> 2] | 0) + 0 | 0) | 0;
     break L110;
    } while (0);
    HEAP32[$ctx + 48 >> 2] = 0;
    if ((HEAP32[$effective_lowband >> 2] | 0) != -1) $cond556 = (HEAP32[$norm >> 2] | 0) + (HEAP32[$effective_lowband >> 2] << 2) | 0; else $cond556 = 0;
    if (HEAP32[$last >> 2] | 0) $cond567 = 0; else {
     $add$ptr563 = (HEAP32[$norm >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2) | 0;
     $cond567 = $add$ptr563 + (0 - (HEAP32[$norm_offset >> 2] | 0) << 2) | 0;
    }
    HEAP32[$x_cm >> 2] = _quant_band_stereo($ctx, HEAP32[$X >> 2] | 0, HEAP32[$Y >> 2] | 0, HEAP32[$N >> 2] | 0, HEAP32[$b >> 2] | 0, HEAP32[$B >> 2] | 0, $cond556, HEAP32[$LM$addr >> 2] | 0, $cond567, HEAP32[$lowband_scratch >> 2] | 0, HEAP32[$x_cm >> 2] | HEAP32[$y_cm >> 2]) | 0;
   } else {
    if ((HEAP32[$effective_lowband >> 2] | 0) != -1) $cond578 = (HEAP32[$norm >> 2] | 0) + (HEAP32[$effective_lowband >> 2] << 2) | 0; else $cond578 = 0;
    if (HEAP32[$last >> 2] | 0) $cond589 = 0; else {
     $add$ptr585 = (HEAP32[$norm >> 2] | 0) + ((Math_imul(HEAP32[$M >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2) | 0;
     $cond589 = $add$ptr585 + (0 - (HEAP32[$norm_offset >> 2] | 0) << 2) | 0;
    }
    HEAP32[$x_cm >> 2] = _quant_band($ctx, HEAP32[$X >> 2] | 0, HEAP32[$N >> 2] | 0, HEAP32[$b >> 2] | 0, HEAP32[$B >> 2] | 0, $cond578, HEAP32[$LM$addr >> 2] | 0, $cond589, 1.0, HEAP32[$lowband_scratch >> 2] | 0, HEAP32[$x_cm >> 2] | HEAP32[$y_cm >> 2]) | 0;
   } while (0);
   HEAP32[$y_cm >> 2] = HEAP32[$x_cm >> 2];
  }
  HEAP8[(HEAP32[$collapse_masks$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C >> 2] | 0) | 0) + 0) >> 0] = HEAP32[$x_cm >> 2];
  $mul599 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C >> 2] | 0) | 0;
  HEAP8[(HEAP32[$collapse_masks$addr >> 2] | 0) + ($mul599 + (HEAP32[$C >> 2] | 0) - 1) >> 0] = HEAP32[$y_cm >> 2];
  HEAP32[$balance$addr >> 2] = (HEAP32[$balance$addr >> 2] | 0) + ((HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$tell >> 2] | 0));
  HEAP32[$update_lowband >> 2] = (HEAP32[$b >> 2] | 0) > (HEAP32[$N >> 2] << 3 | 0) & 1;
  HEAP32[$ctx + 56 >> 2] = 0;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[HEAP32[$seed$addr >> 2] >> 2] = HEAP32[$ctx + 40 >> 2];
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_pitch_analysis_core_FLP($frame, $pitch_out, $lagIndex, $contourIndex, $LTPCorr, $prevLag, $search_thres1, $search_thres2, $Fs_kHz, $complexity, $nb_subfr, $arch) {
 $frame = $frame | 0;
 $pitch_out = $pitch_out | 0;
 $lagIndex = $lagIndex | 0;
 $contourIndex = $contourIndex | 0;
 $LTPCorr = $LTPCorr | 0;
 $prevLag = $prevLag | 0;
 $search_thres1 = +$search_thres1;
 $search_thres2 = +$search_thres2;
 $Fs_kHz = $Fs_kHz | 0;
 $complexity = $complexity | 0;
 $nb_subfr = $nb_subfr | 0;
 $arch = $arch | 0;
 var $$sink = 0.0, $118 = 0, $267 = 0, $276 = 0, $280 = 0, $357 = 0, $369 = 0, $399 = 0, $410 = 0, $434 = 0, $C = 0, $CBimax = 0, $CBimax_new = 0, $CC = 0, $CCmax = 0, $CCmax_b = 0, $CCmax_new = 0, $CCmax_new_b = 0, $Cmax = 0, $Fs_kHz$addr = 0, $LTPCorr$addr = 0, $Lag_CB_ptr = 0, $add81 = 0.0, $arch$addr = 0, $arrayidx115 = 0, $arrayidx133 = 0, $arrayidx203 = 0, $arrayidx243 = 0, $arrayidx303$sink = 0, $arrayidx365 = 0, $arrayidx89 = 0, $basis_ptr = 0, $call = 0.0, $cbk_size = 0, $complexity$addr = 0, $cond470 = 0, $cond595 = 0, $cond60 = 0.0, $cond649 = 0, $contourIndex$addr = 0, $contour_bias = 0, $cross_corr = 0, $cross_corr_st3 = 0, $d = 0, $d_comp = 0, $d_srch = 0, $delta_lag_log2_sqr = 0, $end_lag = 0, $energies_st3 = 0, $energy = 0, $energy_tmp = 0, $filt_state = 0, $frame$addr = 0, $frame_12_FIX = 0, $frame_16_FIX = 0, $frame_4_FIX = 0, $frame_4kHz = 0, $frame_8_FIX = 0, $frame_8kHz = 0, $frame_length = 0, $frame_length_4kHz = 0, $frame_length_8kHz = 0, $i = 0, $j = 0, $k = 0, $lag = 0, $lagIndex$addr = 0, $lag_counter = 0, $lag_log2 = 0, $lag_new = 0, $length_d_comp = 0, $length_d_srch = 0, $max_lag = 0, $max_lag_4kHz = 0, $max_lag_8kHz = 0, $min_lag = 0, $min_lag_4kHz = 0, $min_lag_8kHz = 0, $mul359 = 0, $mul549 = 0, $mul608 = 0, $nb_cbk_search = 0, $nb_subfr$addr = 0, $normalizer = 0, $pitch_out$addr = 0, $prevLag$addr = 0, $prevLag_log2 = 0, $retval = 0, $search_thres1$addr = 0, $search_thres2$addr = 0, $sf_length = 0, $sf_length_4kHz = 0, $sf_length_8kHz = 0, $start_lag = 0, $target_ptr = 0, $threshold = 0, $xcorr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 13936 | 0;
 $retval = sp + 10416 | 0;
 $frame$addr = sp + 10412 | 0;
 $pitch_out$addr = sp + 10408 | 0;
 $lagIndex$addr = sp + 10404 | 0;
 $contourIndex$addr = sp + 10400 | 0;
 $LTPCorr$addr = sp + 10396 | 0;
 $prevLag$addr = sp + 10392 | 0;
 $search_thres1$addr = sp + 10388 | 0;
 $search_thres2$addr = sp + 10384 | 0;
 $Fs_kHz$addr = sp + 10380 | 0;
 $complexity$addr = sp + 10376 | 0;
 $nb_subfr$addr = sp + 10372 | 0;
 $arch$addr = sp + 10368 | 0;
 $i = sp + 10364 | 0;
 $k = sp + 10360 | 0;
 $d = sp + 10356 | 0;
 $j = sp + 10352 | 0;
 $frame_8kHz = sp + 9072 | 0;
 $frame_4kHz = sp + 8432 | 0;
 $frame_8_FIX = sp + 13288 | 0;
 $frame_4_FIX = sp + 12968 | 0;
 $filt_state = sp + 8408 | 0;
 $threshold = sp + 8404 | 0;
 $contour_bias = sp + 8400 | 0;
 $C = sp + 6016 | 0;
 $xcorr = sp + 5756 | 0;
 $CC = sp + 5712 | 0;
 $target_ptr = sp + 5708 | 0;
 $basis_ptr = sp + 5704 | 0;
 $cross_corr = sp + 24 | 0;
 $normalizer = sp + 16 | 0;
 $energy = sp + 8 | 0;
 $energy_tmp = sp;
 $d_srch = sp + 5608 | 0;
 $d_comp = sp + 12664 | 0;
 $length_d_srch = sp + 5600 | 0;
 $length_d_comp = sp + 5596 | 0;
 $Cmax = sp + 5592 | 0;
 $CCmax = sp + 5588 | 0;
 $CCmax_b = sp + 5584 | 0;
 $CCmax_new_b = sp + 5580 | 0;
 $CCmax_new = sp + 5576 | 0;
 $CBimax = sp + 5572 | 0;
 $CBimax_new = sp + 5568 | 0;
 $lag = sp + 5564 | 0;
 $start_lag = sp + 5560 | 0;
 $end_lag = sp + 5556 | 0;
 $lag_new = sp + 5552 | 0;
 $cbk_size = sp + 5548 | 0;
 $lag_log2 = sp + 5544 | 0;
 $prevLag_log2 = sp + 5540 | 0;
 $delta_lag_log2_sqr = sp + 5536 | 0;
 $energies_st3 = sp + 2816 | 0;
 $cross_corr_st3 = sp + 96 | 0;
 $lag_counter = sp + 88 | 0;
 $frame_length = sp + 84 | 0;
 $frame_length_8kHz = sp + 80 | 0;
 $frame_length_4kHz = sp + 76 | 0;
 $sf_length = sp + 72 | 0;
 $sf_length_8kHz = sp + 68 | 0;
 $sf_length_4kHz = sp + 64 | 0;
 $min_lag = sp + 60 | 0;
 $min_lag_8kHz = sp + 56 | 0;
 $min_lag_4kHz = sp + 52 | 0;
 $max_lag = sp + 48 | 0;
 $max_lag_8kHz = sp + 44 | 0;
 $max_lag_4kHz = sp + 40 | 0;
 $nb_cbk_search = sp + 36 | 0;
 $Lag_CB_ptr = sp + 32 | 0;
 $frame_16_FIX = sp + 11384 | 0;
 $frame_12_FIX = sp + 10424 | 0;
 HEAP32[$frame$addr >> 2] = $frame;
 HEAP32[$pitch_out$addr >> 2] = $pitch_out;
 HEAP32[$lagIndex$addr >> 2] = $lagIndex;
 HEAP32[$contourIndex$addr >> 2] = $contourIndex;
 HEAP32[$LTPCorr$addr >> 2] = $LTPCorr;
 HEAP32[$prevLag$addr >> 2] = $prevLag;
 HEAPF32[$search_thres1$addr >> 2] = $search_thres1;
 HEAPF32[$search_thres2$addr >> 2] = $search_thres2;
 HEAP32[$Fs_kHz$addr >> 2] = $Fs_kHz;
 HEAP32[$complexity$addr >> 2] = $complexity;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$frame_length >> 2] = Math_imul(20 + ((HEAP32[$nb_subfr$addr >> 2] | 0) * 5 | 0) | 0, HEAP32[$Fs_kHz$addr >> 2] | 0) | 0;
 HEAP32[$frame_length_4kHz >> 2] = 20 + ((HEAP32[$nb_subfr$addr >> 2] | 0) * 5 | 0) << 2;
 HEAP32[$frame_length_8kHz >> 2] = 20 + ((HEAP32[$nb_subfr$addr >> 2] | 0) * 5 | 0) << 3;
 HEAP32[$sf_length >> 2] = (HEAP32[$Fs_kHz$addr >> 2] | 0) * 5;
 HEAP32[$sf_length_4kHz >> 2] = 20;
 HEAP32[$sf_length_8kHz >> 2] = 40;
 HEAP32[$min_lag >> 2] = HEAP32[$Fs_kHz$addr >> 2] << 1;
 HEAP32[$min_lag_4kHz >> 2] = 8;
 HEAP32[$min_lag_8kHz >> 2] = 16;
 HEAP32[$max_lag >> 2] = ((HEAP32[$Fs_kHz$addr >> 2] | 0) * 18 | 0) - 1;
 HEAP32[$max_lag_4kHz >> 2] = 72;
 HEAP32[$max_lag_8kHz >> 2] = 143;
 do if ((HEAP32[$Fs_kHz$addr >> 2] | 0) == 16) {
  _silk_float2short_array_325($frame_16_FIX, HEAP32[$frame$addr >> 2] | 0, HEAP32[$frame_length >> 2] | 0);
  HEAP32[$filt_state >> 2] = 0;
  HEAP32[$filt_state + 4 >> 2] = 0;
  _silk_resampler_down2($filt_state, $frame_8_FIX, $frame_16_FIX, HEAP32[$frame_length >> 2] | 0);
  _silk_short2float_array_326($frame_8kHz, $frame_8_FIX, HEAP32[$frame_length_8kHz >> 2] | 0);
 } else if ((HEAP32[$Fs_kHz$addr >> 2] | 0) == 12) {
  _silk_float2short_array_325($frame_12_FIX, HEAP32[$frame$addr >> 2] | 0, HEAP32[$frame_length >> 2] | 0);
  HEAP32[$filt_state >> 2] = 0;
  HEAP32[$filt_state + 4 >> 2] = 0;
  HEAP32[$filt_state + 8 >> 2] = 0;
  HEAP32[$filt_state + 12 >> 2] = 0;
  HEAP32[$filt_state + 16 >> 2] = 0;
  HEAP32[$filt_state + 20 >> 2] = 0;
  _silk_resampler_down2_3($filt_state, $frame_8_FIX, $frame_12_FIX, HEAP32[$frame_length >> 2] | 0);
  _silk_short2float_array_326($frame_8kHz, $frame_8_FIX, HEAP32[$frame_length_8kHz >> 2] | 0);
  break;
 } else {
  _silk_float2short_array_325($frame_8_FIX, HEAP32[$frame$addr >> 2] | 0, HEAP32[$frame_length_8kHz >> 2] | 0);
  break;
 } while (0);
 HEAP32[$filt_state >> 2] = 0;
 HEAP32[$filt_state + 4 >> 2] = 0;
 _silk_resampler_down2($filt_state, $frame_4_FIX, $frame_8_FIX, HEAP32[$frame_length_8kHz >> 2] | 0);
 _silk_short2float_array_326($frame_4kHz, $frame_4_FIX, HEAP32[$frame_length_4kHz >> 2] | 0);
 HEAP32[$i >> 2] = (HEAP32[$frame_length_4kHz >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) <= 0) break;
  if (+(~~+HEAPF32[$frame_4kHz + (HEAP32[$i >> 2] << 2) >> 2] | 0) + +HEAPF32[$frame_4kHz + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] > 32767.0) $cond60 = 32767.0; else if (+(~~+HEAPF32[$frame_4kHz + (HEAP32[$i >> 2] << 2) >> 2] | 0) + +HEAPF32[$frame_4kHz + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] < -32768.0) $cond60 = -32768.0; else $cond60 = +(~~+HEAPF32[$frame_4kHz + (HEAP32[$i >> 2] << 2) >> 2] | 0) + +HEAPF32[$frame_4kHz + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2];
  HEAPF32[$frame_4kHz + (HEAP32[$i >> 2] << 2) >> 2] = +(~~$cond60 << 16 >> 16);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 _memset($C | 0, 0, (HEAP32[$nb_subfr$addr >> 2] << 2) * 149 | 0) | 0;
 HEAP32[$target_ptr >> 2] = $frame_4kHz + (HEAP32[$sf_length_4kHz >> 2] << 2 << 2);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] >> 1 | 0)) break;
  HEAP32[$basis_ptr >> 2] = (HEAP32[$target_ptr >> 2] | 0) + (0 - (HEAP32[$min_lag_4kHz >> 2] | 0) << 2);
  _celt_pitch_xcorr_c(HEAP32[$target_ptr >> 2] | 0, (HEAP32[$target_ptr >> 2] | 0) + (0 - (HEAP32[$max_lag_4kHz >> 2] | 0) << 2) | 0, $xcorr, HEAP32[$sf_length_8kHz >> 2] | 0, (HEAP32[$max_lag_4kHz >> 2] | 0) - (HEAP32[$min_lag_4kHz >> 2] | 0) + 1 | 0, HEAP32[$arch$addr >> 2] | 0);
  HEAPF64[$cross_corr >> 3] = +HEAPF32[$xcorr + ((HEAP32[$max_lag_4kHz >> 2] | 0) - (HEAP32[$min_lag_4kHz >> 2] | 0) << 2) >> 2];
  $call = +_silk_energy_FLP(HEAP32[$target_ptr >> 2] | 0, HEAP32[$sf_length_8kHz >> 2] | 0);
  $add81 = $call + +_silk_energy_FLP(HEAP32[$basis_ptr >> 2] | 0, HEAP32[$sf_length_8kHz >> 2] | 0);
  HEAPF64[$normalizer >> 3] = $add81 + +(HEAP32[$sf_length_8kHz >> 2] | 0) * 4.0e3;
  $arrayidx89 = $C + (HEAP32[$min_lag_4kHz >> 2] << 2) | 0;
  HEAPF32[$arrayidx89 >> 2] = +HEAPF32[$arrayidx89 >> 2] + +HEAPF64[$cross_corr >> 3] * 2.0 / +HEAPF64[$normalizer >> 3];
  HEAP32[$d >> 2] = (HEAP32[$min_lag_4kHz >> 2] | 0) + 1;
  while (1) {
   if ((HEAP32[$d >> 2] | 0) > (HEAP32[$max_lag_4kHz >> 2] | 0)) break;
   HEAP32[$basis_ptr >> 2] = (HEAP32[$basis_ptr >> 2] | 0) + -4;
   HEAPF64[$cross_corr >> 3] = +HEAPF32[$xcorr + ((HEAP32[$max_lag_4kHz >> 2] | 0) - (HEAP32[$d >> 2] | 0) << 2) >> 2];
   HEAPF64[$normalizer >> 3] = +HEAPF64[$normalizer >> 3] + (+HEAPF32[HEAP32[$basis_ptr >> 2] >> 2] * +HEAPF32[HEAP32[$basis_ptr >> 2] >> 2] - +HEAPF32[(HEAP32[$basis_ptr >> 2] | 0) + (HEAP32[$sf_length_8kHz >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$basis_ptr >> 2] | 0) + (HEAP32[$sf_length_8kHz >> 2] << 2) >> 2]);
   $arrayidx115 = $C + (HEAP32[$d >> 2] << 2) | 0;
   HEAPF32[$arrayidx115 >> 2] = +HEAPF32[$arrayidx115 >> 2] + +HEAPF64[$cross_corr >> 3] * 2.0 / +HEAPF64[$normalizer >> 3];
   HEAP32[$d >> 2] = (HEAP32[$d >> 2] | 0) + 1;
  }
  HEAP32[$target_ptr >> 2] = (HEAP32[$target_ptr >> 2] | 0) + (HEAP32[$sf_length_8kHz >> 2] << 2);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = HEAP32[$max_lag_4kHz >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < (HEAP32[$min_lag_4kHz >> 2] | 0)) break;
  $arrayidx133 = $C + (HEAP32[$i >> 2] << 2) | 0;
  HEAPF32[$arrayidx133 >> 2] = +HEAPF32[$arrayidx133 >> 2] - +HEAPF32[$C + (HEAP32[$i >> 2] << 2) >> 2] * +(HEAP32[$i >> 2] | 0) / 4096.0;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 HEAP32[$length_d_srch >> 2] = 4 + (HEAP32[$complexity$addr >> 2] << 1);
 _silk_insertion_sort_decreasing_FLP($C + (HEAP32[$min_lag_4kHz >> 2] << 2) | 0, $d_srch, (HEAP32[$max_lag_4kHz >> 2] | 0) - (HEAP32[$min_lag_4kHz >> 2] | 0) + 1 | 0, HEAP32[$length_d_srch >> 2] | 0);
 HEAPF32[$Cmax >> 2] = +HEAPF32[$C + (HEAP32[$min_lag_4kHz >> 2] << 2) >> 2];
 if (+HEAPF32[$Cmax >> 2] < .20000000298023224) {
  _memset(HEAP32[$pitch_out$addr >> 2] | 0, 0, HEAP32[$nb_subfr$addr >> 2] << 2 | 0) | 0;
  HEAPF32[HEAP32[$LTPCorr$addr >> 2] >> 2] = 0.0;
  HEAP16[HEAP32[$lagIndex$addr >> 2] >> 1] = 0;
  HEAP8[HEAP32[$contourIndex$addr >> 2] >> 0] = 0;
  HEAP32[$retval >> 2] = 1;
  $434 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $434 | 0;
 }
 HEAPF32[$threshold >> 2] = +HEAPF32[$search_thres1$addr >> 2] * +HEAPF32[$Cmax >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$length_d_srch >> 2] | 0)) break;
  $118 = HEAP32[$i >> 2] | 0;
  if (!(+HEAPF32[$C + ((HEAP32[$min_lag_4kHz >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] > +HEAPF32[$threshold >> 2])) {
   label = 27;
   break;
  }
  HEAP32[$d_srch + (HEAP32[$i >> 2] << 2) >> 2] = (HEAP32[$d_srch + ($118 << 2) >> 2] | 0) + (HEAP32[$min_lag_4kHz >> 2] | 0) << 1;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((label | 0) == 27) HEAP32[$length_d_srch >> 2] = $118;
 HEAP32[$i >> 2] = (HEAP32[$min_lag_8kHz >> 2] | 0) - 5;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$max_lag_8kHz >> 2] | 0) + 5 | 0)) break;
  HEAP16[$d_comp + (HEAP32[$i >> 2] << 1) >> 1] = 0;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$length_d_srch >> 2] | 0)) break;
  HEAP16[$d_comp + (HEAP32[$d_srch + (HEAP32[$i >> 2] << 2) >> 2] << 1) >> 1] = 1;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = (HEAP32[$max_lag_8kHz >> 2] | 0) + 3;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < (HEAP32[$min_lag_8kHz >> 2] | 0)) break;
  $arrayidx203 = $d_comp + (HEAP32[$i >> 2] << 1) | 0;
  HEAP16[$arrayidx203 >> 1] = (HEAP16[$arrayidx203 >> 1] | 0) + ((HEAP16[$d_comp + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[$d_comp + ((HEAP32[$i >> 2] | 0) - 2 << 1) >> 1] | 0));
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 HEAP32[$length_d_srch >> 2] = 0;
 HEAP32[$i >> 2] = HEAP32[$min_lag_8kHz >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$max_lag_8kHz >> 2] | 0) + 1 | 0)) break;
  if ((HEAP16[$d_comp + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) > 0) {
   HEAP32[$d_srch + (HEAP32[$length_d_srch >> 2] << 2) >> 2] = HEAP32[$i >> 2];
   HEAP32[$length_d_srch >> 2] = (HEAP32[$length_d_srch >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = (HEAP32[$max_lag_8kHz >> 2] | 0) + 3;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < (HEAP32[$min_lag_8kHz >> 2] | 0)) break;
  $arrayidx243 = $d_comp + (HEAP32[$i >> 2] << 1) | 0;
  HEAP16[$arrayidx243 >> 1] = (HEAP16[$arrayidx243 >> 1] | 0) + ((HEAP16[$d_comp + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[$d_comp + ((HEAP32[$i >> 2] | 0) - 2 << 1) >> 1] | 0) + (HEAP16[$d_comp + ((HEAP32[$i >> 2] | 0) - 3 << 1) >> 1] | 0));
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 HEAP32[$length_d_comp >> 2] = 0;
 HEAP32[$i >> 2] = HEAP32[$min_lag_8kHz >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$max_lag_8kHz >> 2] | 0) + 4 | 0)) break;
  if ((HEAP16[$d_comp + (HEAP32[$i >> 2] << 1) >> 1] | 0) > 0) {
   HEAP16[$d_comp + (HEAP32[$length_d_comp >> 2] << 1) >> 1] = (HEAP32[$i >> 2] | 0) - 2;
   HEAP32[$length_d_comp >> 2] = (HEAP32[$length_d_comp >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _memset($C | 0, 0, 2384) | 0;
 if ((HEAP32[$Fs_kHz$addr >> 2] | 0) == 8) HEAP32[$target_ptr >> 2] = (HEAP32[$frame$addr >> 2] | 0) + 640; else HEAP32[$target_ptr >> 2] = $frame_8kHz + 640;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  HEAPF64[$energy_tmp >> 3] = +_silk_energy_FLP(HEAP32[$target_ptr >> 2] | 0, HEAP32[$sf_length_8kHz >> 2] | 0) + 1.0;
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$length_d_comp >> 2] | 0)) break;
   HEAP32[$d >> 2] = HEAP16[$d_comp + (HEAP32[$j >> 2] << 1) >> 1];
   HEAP32[$basis_ptr >> 2] = (HEAP32[$target_ptr >> 2] | 0) + (0 - (HEAP32[$d >> 2] | 0) << 2);
   HEAPF64[$cross_corr >> 3] = +_silk_inner_product_FLP(HEAP32[$basis_ptr >> 2] | 0, HEAP32[$target_ptr >> 2] | 0, HEAP32[$sf_length_8kHz >> 2] | 0);
   if (+HEAPF64[$cross_corr >> 3] > 0.0) {
    HEAPF64[$energy >> 3] = +_silk_energy_FLP(HEAP32[$basis_ptr >> 2] | 0, HEAP32[$sf_length_8kHz >> 2] | 0);
    $$sink = +HEAPF64[$cross_corr >> 3] * 2.0 / (+HEAPF64[$energy >> 3] + +HEAPF64[$energy_tmp >> 3]);
    $arrayidx303$sink = $C + ((HEAP32[$k >> 2] | 0) * 596 | 0) + (HEAP32[$d >> 2] << 2) | 0;
   } else {
    $$sink = 0.0;
    $arrayidx303$sink = $C + ((HEAP32[$k >> 2] | 0) * 596 | 0) + (HEAP32[$d >> 2] << 2) | 0;
   }
   HEAPF32[$arrayidx303$sink >> 2] = $$sink;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$target_ptr >> 2] = (HEAP32[$target_ptr >> 2] | 0) + (HEAP32[$sf_length_8kHz >> 2] << 2);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAPF32[$CCmax >> 2] = 0.0;
 HEAPF32[$CCmax_b >> 2] = -1.0e3;
 HEAP32[$CBimax >> 2] = 0;
 HEAP32[$lag >> 2] = -1;
 if ((HEAP32[$prevLag$addr >> 2] | 0) > 0) {
  if ((HEAP32[$Fs_kHz$addr >> 2] | 0) == 12) HEAP32[$prevLag$addr >> 2] = (HEAP32[$prevLag$addr >> 2] << 1 | 0) / 3 | 0; else if ((HEAP32[$Fs_kHz$addr >> 2] | 0) == 16) HEAP32[$prevLag$addr >> 2] = HEAP32[$prevLag$addr >> 2] >> 1;
  HEAPF32[$prevLag_log2 >> 2] = +_silk_log2_327(+(HEAP32[$prevLag$addr >> 2] | 0));
 } else HEAPF32[$prevLag_log2 >> 2] = 0.0;
 do if ((HEAP32[$nb_subfr$addr >> 2] | 0) == 4) {
  HEAP32[$cbk_size >> 2] = 11;
  HEAP32[$Lag_CB_ptr >> 2] = 35293;
  if ((HEAP32[$Fs_kHz$addr >> 2] | 0) == 8 & (HEAP32[$complexity$addr >> 2] | 0) > 0) {
   HEAP32[$nb_cbk_search >> 2] = 11;
   break;
  } else {
   HEAP32[$nb_cbk_search >> 2] = 3;
   break;
  }
 } else {
  HEAP32[$cbk_size >> 2] = 3;
  HEAP32[$Lag_CB_ptr >> 2] = 35259;
  HEAP32[$nb_cbk_search >> 2] = 3;
 } while (0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$length_d_srch >> 2] | 0)) break;
  HEAP32[$d >> 2] = HEAP32[$d_srch + (HEAP32[$k >> 2] << 2) >> 2];
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$nb_cbk_search >> 2] | 0)) break;
   HEAPF32[$CC + (HEAP32[$j >> 2] << 2) >> 2] = 0.0;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
    $mul359 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$cbk_size >> 2] | 0) | 0;
    $arrayidx365 = $CC + (HEAP32[$j >> 2] << 2) | 0;
    HEAPF32[$arrayidx365 >> 2] = +HEAPF32[$arrayidx365 >> 2] + +HEAPF32[$C + ((HEAP32[$i >> 2] | 0) * 596 | 0) + ((HEAP32[$d >> 2] | 0) + (HEAP8[(HEAP32[$Lag_CB_ptr >> 2] | 0) + ($mul359 + (HEAP32[$j >> 2] | 0)) >> 0] | 0) << 2) >> 2];
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAPF32[$CCmax_new >> 2] = -1.0e3;
  HEAP32[$CBimax_new >> 2] = 0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nb_cbk_search >> 2] | 0)) break;
   if (+HEAPF32[$CC + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[$CCmax_new >> 2]) {
    HEAPF32[$CCmax_new >> 2] = +HEAPF32[$CC + (HEAP32[$i >> 2] << 2) >> 2];
    HEAP32[$CBimax_new >> 2] = HEAP32[$i >> 2];
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[$lag_log2 >> 2] = +_silk_log2_327(+(HEAP32[$d >> 2] | 0));
  HEAPF32[$CCmax_new_b >> 2] = +HEAPF32[$CCmax_new >> 2] - +(HEAP32[$nb_subfr$addr >> 2] | 0) * .20000000298023224 * +HEAPF32[$lag_log2 >> 2];
  if ((HEAP32[$prevLag$addr >> 2] | 0) > 0) {
   HEAPF32[$delta_lag_log2_sqr >> 2] = +HEAPF32[$lag_log2 >> 2] - +HEAPF32[$prevLag_log2 >> 2];
   HEAPF32[$delta_lag_log2_sqr >> 2] = +HEAPF32[$delta_lag_log2_sqr >> 2] * +HEAPF32[$delta_lag_log2_sqr >> 2];
   HEAPF32[$CCmax_new_b >> 2] = +HEAPF32[$CCmax_new_b >> 2] - +(HEAP32[$nb_subfr$addr >> 2] | 0) * .20000000298023224 * +HEAPF32[HEAP32[$LTPCorr$addr >> 2] >> 2] * +HEAPF32[$delta_lag_log2_sqr >> 2] / (+HEAPF32[$delta_lag_log2_sqr >> 2] + .5);
  }
  if (+HEAPF32[$CCmax_new_b >> 2] > +HEAPF32[$CCmax_b >> 2]) if (+HEAPF32[$CCmax_new >> 2] > +(HEAP32[$nb_subfr$addr >> 2] | 0) * +HEAPF32[$search_thres2$addr >> 2]) {
   HEAPF32[$CCmax_b >> 2] = +HEAPF32[$CCmax_new_b >> 2];
   HEAPF32[$CCmax >> 2] = +HEAPF32[$CCmax_new >> 2];
   HEAP32[$lag >> 2] = HEAP32[$d >> 2];
   HEAP32[$CBimax >> 2] = HEAP32[$CBimax_new >> 2];
  }
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 if ((HEAP32[$lag >> 2] | 0) == -1) {
  $267 = HEAP32[$pitch_out$addr >> 2] | 0;
  HEAP32[$267 >> 2] = 0;
  HEAP32[$267 + 4 >> 2] = 0;
  HEAP32[$267 + 8 >> 2] = 0;
  HEAP32[$267 + 12 >> 2] = 0;
  HEAPF32[HEAP32[$LTPCorr$addr >> 2] >> 2] = 0.0;
  HEAP16[HEAP32[$lagIndex$addr >> 2] >> 1] = 0;
  HEAP8[HEAP32[$contourIndex$addr >> 2] >> 0] = 0;
  HEAP32[$retval >> 2] = 1;
  $434 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $434 | 0;
 }
 HEAPF32[HEAP32[$LTPCorr$addr >> 2] >> 2] = +HEAPF32[$CCmax >> 2] / +(HEAP32[$nb_subfr$addr >> 2] | 0);
 if ((HEAP32[$Fs_kHz$addr >> 2] | 0) > 8) {
  $276 = HEAP32[$lag >> 2] | 0;
  if ((HEAP32[$Fs_kHz$addr >> 2] | 0) == 12) HEAP32[$lag >> 2] = ((($276 & 65535) << 16 >> 16) * 3 >> 1) + (((HEAP32[$lag >> 2] & 65535) << 16 >> 16) * 3 & 1); else HEAP32[$lag >> 2] = $276 << 1;
  $280 = HEAP32[$lag >> 2] | 0;
  do if ((HEAP32[$min_lag >> 2] | 0) > (HEAP32[$max_lag >> 2] | 0)) if (($280 | 0) > (HEAP32[$min_lag >> 2] | 0)) {
   $cond470 = HEAP32[$min_lag >> 2] | 0;
   break;
  } else {
   $cond470 = (HEAP32[$lag >> 2] | 0) < (HEAP32[$max_lag >> 2] | 0) ? HEAP32[$max_lag >> 2] | 0 : HEAP32[$lag >> 2] | 0;
   break;
  } else if (($280 | 0) > (HEAP32[$max_lag >> 2] | 0)) {
   $cond470 = HEAP32[$max_lag >> 2] | 0;
   break;
  } else {
   $cond470 = (HEAP32[$lag >> 2] | 0) < (HEAP32[$min_lag >> 2] | 0) ? HEAP32[$min_lag >> 2] | 0 : HEAP32[$lag >> 2] | 0;
   break;
  } while (0);
  HEAP32[$lag >> 2] = $cond470;
  HEAP32[$start_lag >> 2] = _silk_max_int_328((HEAP32[$lag >> 2] | 0) - 2 | 0, HEAP32[$min_lag >> 2] | 0) | 0;
  HEAP32[$end_lag >> 2] = _silk_min_int_329((HEAP32[$lag >> 2] | 0) + 2 | 0, HEAP32[$max_lag >> 2] | 0) | 0;
  HEAP32[$lag_new >> 2] = HEAP32[$lag >> 2];
  HEAP32[$CBimax >> 2] = 0;
  HEAPF32[$CCmax >> 2] = -1.0e3;
  _silk_P_Ana_calc_corr_st3($cross_corr_st3, HEAP32[$frame$addr >> 2] | 0, HEAP32[$start_lag >> 2] | 0, HEAP32[$sf_length >> 2] | 0, HEAP32[$nb_subfr$addr >> 2] | 0, HEAP32[$complexity$addr >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
  _silk_P_Ana_calc_energy_st3($energies_st3, HEAP32[$frame$addr >> 2] | 0, HEAP32[$start_lag >> 2] | 0, HEAP32[$sf_length >> 2] | 0, HEAP32[$nb_subfr$addr >> 2] | 0, HEAP32[$complexity$addr >> 2] | 0);
  HEAP32[$lag_counter >> 2] = 0;
  HEAPF32[$contour_bias >> 2] = .05000000074505806 / +(HEAP32[$lag >> 2] | 0);
  if ((HEAP32[$nb_subfr$addr >> 2] | 0) == 4) {
   HEAP32[$nb_cbk_search >> 2] = HEAP8[35497 + (HEAP32[$complexity$addr >> 2] | 0) >> 0];
   HEAP32[$cbk_size >> 2] = 34;
   HEAP32[$Lag_CB_ptr >> 2] = 35337;
  } else {
   HEAP32[$nb_cbk_search >> 2] = 12;
   HEAP32[$cbk_size >> 2] = 12;
   HEAP32[$Lag_CB_ptr >> 2] = 35265;
  }
  HEAP32[$target_ptr >> 2] = (HEAP32[$frame$addr >> 2] | 0) + ((HEAP32[$Fs_kHz$addr >> 2] | 0) * 20 << 2);
  HEAPF64[$energy_tmp >> 3] = +_silk_energy_FLP(HEAP32[$target_ptr >> 2] | 0, Math_imul(HEAP32[$nb_subfr$addr >> 2] | 0, HEAP32[$sf_length >> 2] | 0) | 0) + 1.0;
  HEAP32[$d >> 2] = HEAP32[$start_lag >> 2];
  while (1) {
   if ((HEAP32[$d >> 2] | 0) > (HEAP32[$end_lag >> 2] | 0)) break;
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$nb_cbk_search >> 2] | 0)) break;
    HEAPF64[$cross_corr >> 3] = 0.0;
    HEAPF64[$energy >> 3] = +HEAPF64[$energy_tmp >> 3];
    HEAP32[$k >> 2] = 0;
    while (1) {
     if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
     HEAPF64[$cross_corr >> 3] = +HEAPF64[$cross_corr >> 3] + +HEAPF32[$cross_corr_st3 + ((HEAP32[$k >> 2] | 0) * 680 | 0) + ((HEAP32[$j >> 2] | 0) * 20 | 0) + (HEAP32[$lag_counter >> 2] << 2) >> 2];
     HEAPF64[$energy >> 3] = +HEAPF64[$energy >> 3] + +HEAPF32[$energies_st3 + ((HEAP32[$k >> 2] | 0) * 680 | 0) + ((HEAP32[$j >> 2] | 0) * 20 | 0) + (HEAP32[$lag_counter >> 2] << 2) >> 2];
     HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
    }
    if (+HEAPF64[$cross_corr >> 3] > 0.0) {
     HEAPF32[$CCmax_new >> 2] = +HEAPF64[$cross_corr >> 3] * 2.0 / +HEAPF64[$energy >> 3];
     HEAPF32[$CCmax_new >> 2] = +HEAPF32[$CCmax_new >> 2] * (1.0 - +HEAPF32[$contour_bias >> 2] * +(HEAP32[$j >> 2] | 0));
    } else HEAPF32[$CCmax_new >> 2] = 0.0;
    if (+HEAPF32[$CCmax_new >> 2] > +HEAPF32[$CCmax >> 2]) if (((HEAP32[$d >> 2] | 0) + (HEAP8[35337 + (HEAP32[$j >> 2] | 0) >> 0] | 0) | 0) <= (HEAP32[$max_lag >> 2] | 0)) {
     HEAPF32[$CCmax >> 2] = +HEAPF32[$CCmax_new >> 2];
     HEAP32[$lag_new >> 2] = HEAP32[$d >> 2];
     HEAP32[$CBimax >> 2] = HEAP32[$j >> 2];
    }
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$lag_counter >> 2] = (HEAP32[$lag_counter >> 2] | 0) + 1;
   HEAP32[$d >> 2] = (HEAP32[$d >> 2] | 0) + 1;
  }
  HEAP32[$k >> 2] = 0;
  while (1) {
   $357 = HEAP32[$lag_new >> 2] | 0;
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
   $mul549 = Math_imul(HEAP32[$k >> 2] | 0, HEAP32[$cbk_size >> 2] | 0) | 0;
   HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = $357 + (HEAP8[(HEAP32[$Lag_CB_ptr >> 2] | 0) + ($mul549 + (HEAP32[$CBimax >> 2] | 0)) >> 0] | 0);
   $369 = HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
   do if ((HEAP32[$min_lag >> 2] | 0) > ((HEAP32[$Fs_kHz$addr >> 2] | 0) * 18 | 0)) {
    if (($369 | 0) > (HEAP32[$min_lag >> 2] | 0)) {
     $cond595 = HEAP32[$min_lag >> 2] | 0;
     break;
    }
    if ((HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) < ((HEAP32[$Fs_kHz$addr >> 2] | 0) * 18 | 0)) {
     $cond595 = (HEAP32[$Fs_kHz$addr >> 2] | 0) * 18 | 0;
     break;
    } else {
     $cond595 = HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
     break;
    }
   } else {
    if (($369 | 0) > ((HEAP32[$Fs_kHz$addr >> 2] | 0) * 18 | 0)) {
     $cond595 = (HEAP32[$Fs_kHz$addr >> 2] | 0) * 18 | 0;
     break;
    }
    if ((HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) < (HEAP32[$min_lag >> 2] | 0)) {
     $cond595 = HEAP32[$min_lag >> 2] | 0;
     break;
    } else {
     $cond595 = HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
     break;
    }
   } while (0);
   HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = $cond595;
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP16[HEAP32[$lagIndex$addr >> 2] >> 1] = $357 - (HEAP32[$min_lag >> 2] | 0);
  HEAP8[HEAP32[$contourIndex$addr >> 2] >> 0] = HEAP32[$CBimax >> 2];
 } else {
  HEAP32[$k >> 2] = 0;
  while (1) {
   $399 = HEAP32[$lag >> 2] | 0;
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
   $mul608 = Math_imul(HEAP32[$k >> 2] | 0, HEAP32[$cbk_size >> 2] | 0) | 0;
   HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = $399 + (HEAP8[(HEAP32[$Lag_CB_ptr >> 2] | 0) + ($mul608 + (HEAP32[$CBimax >> 2] | 0)) >> 0] | 0);
   $410 = HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
   do if ((HEAP32[$min_lag_8kHz >> 2] | 0) > 144) {
    if (($410 | 0) > (HEAP32[$min_lag_8kHz >> 2] | 0)) {
     $cond649 = HEAP32[$min_lag_8kHz >> 2] | 0;
     break;
    }
    if ((HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) < 144) $cond649 = 144; else $cond649 = HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
   } else if (($410 | 0) > 144) $cond649 = 144; else if ((HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) < (HEAP32[$min_lag_8kHz >> 2] | 0)) {
    $cond649 = HEAP32[$min_lag_8kHz >> 2] | 0;
    break;
   } else {
    $cond649 = HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
    break;
   } while (0);
   HEAP32[(HEAP32[$pitch_out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = $cond649;
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP16[HEAP32[$lagIndex$addr >> 2] >> 1] = $399 - (HEAP32[$min_lag_8kHz >> 2] | 0);
  HEAP8[HEAP32[$contourIndex$addr >> 2] >> 0] = HEAP32[$CBimax >> 2];
 }
 HEAP32[$retval >> 2] = 0;
 $434 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $434 | 0;
}

function _celt_decode_with_ec($st, $data, $len, $pcm, $frame_size, $dec, $accum) {
 $st = $st | 0;
 $data = $data | 0;
 $len = $len | 0;
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $dec = $dec | 0;
 $accum = $accum | 0;
 var $111 = 0, $147 = 0, $179 = 0, $212 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $508 = 0, $66 = 0, $C = 0, $CC = 0, $LM = 0, $M = 0, $N = 0, $_dec = 0, $accum$addr = 0, $add$ptr34 = 0, $add113 = 0, $add73$sink = 0, $alloc_trim = 0, $anti_collapse_on = 0, $anti_collapse_rsv = 0, $arrayidx448$sink = 0, $backgroundLogE = 0, $balance = 0, $bits = 0, $boost = 0, $c = 0, $call503 = 0, $cleanup$dest$slot = 0, $codedBands = 0, $cond147 = 0, $cond190 = 0, $cond229 = 0, $cond316 = 0, $cond324 = 0, $cond430 = 0.0, $data$addr = 0, $dec$addr = 0, $decode_mem = 0, $dual_stereo = 0, $dynalloc_logp = 0, $dynalloc_loop_logp = 0, $eBands = 0, $effEnd = 0, $end = 0, $flag = 0, $frame_size$addr = 0, $i = 0, $inc264 = 0, $inc352 = 0, $inc39 = 0, $inc490 = 0, $intensity = 0, $intra_ener = 0, $isTransient = 0, $len$addr = 0, $lpc = 0, $max_background_increase = 0, $mode = 0, $mul169 = 0, $mul286 = 0, $mul461 = 0, $mul464 = 0, $mul467 = 0, $mul477 = 0, $mul480 = 0, $mul483 = 0, $nbEBands = 0, $nbits_total = 0, $octave = 0, $oldBandE = 0, $oldLogE = 0, $oldLogE2 = 0, $out_syn = 0, $overlap = 0, $pcm$addr = 0, $postfilter_gain = 0, $postfilter_pitch = 0, $postfilter_tapset = 0, $qg = 0, $quanta = 0, $retval = 0, $saved_stack = 0, $shl106 = 0, $shl231 = 0, $shortBlocks = 0, $silence = 0, $spread_decision = 0, $st$addr = 0, $start = 0, $sub = 0, $sub288 = 0, $tell = 0, $total_bits = 0, $vla = 0, $vla155 = 0, $vla156 = 0, $vla221 = 0, $vla247 = 0, $vla248 = 0, $vla269 = 0, $vla269$alloca_mul = 0, $vla271 = 0, $vla271$alloca_mul = 0, $width = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 304 | 0;
 $retval = sp + 288 | 0;
 $st$addr = sp + 284 | 0;
 $data$addr = sp + 280 | 0;
 $len$addr = sp + 276 | 0;
 $pcm$addr = sp + 272 | 0;
 $frame_size$addr = sp + 268 | 0;
 $dec$addr = sp + 264 | 0;
 $accum$addr = sp + 260 | 0;
 $c = sp + 256 | 0;
 $i = sp + 252 | 0;
 $N = sp + 248 | 0;
 $spread_decision = sp + 244 | 0;
 $bits = sp + 240 | 0;
 $_dec = sp + 192 | 0;
 $decode_mem = sp + 184 | 0;
 $out_syn = sp + 176 | 0;
 $lpc = sp + 168 | 0;
 $oldBandE = sp + 164 | 0;
 $oldLogE = sp + 160 | 0;
 $oldLogE2 = sp + 156 | 0;
 $backgroundLogE = sp + 152 | 0;
 $shortBlocks = sp + 148 | 0;
 $isTransient = sp + 144 | 0;
 $intra_ener = sp + 140 | 0;
 $CC = sp + 136 | 0;
 $LM = sp + 132 | 0;
 $M = sp + 128 | 0;
 $start = sp + 124 | 0;
 $end = sp + 120 | 0;
 $effEnd = sp + 116 | 0;
 $codedBands = sp + 112 | 0;
 $alloc_trim = sp + 108 | 0;
 $postfilter_pitch = sp + 104 | 0;
 $postfilter_gain = sp + 100 | 0;
 $intensity = sp + 96 | 0;
 $dual_stereo = sp + 92 | 0;
 $total_bits = sp + 88 | 0;
 $balance = sp + 84 | 0;
 $tell = sp + 80 | 0;
 $dynalloc_logp = sp + 76 | 0;
 $postfilter_tapset = sp + 72 | 0;
 $anti_collapse_rsv = sp + 68 | 0;
 $anti_collapse_on = sp + 64 | 0;
 $silence = sp + 60 | 0;
 $C = sp + 56 | 0;
 $mode = sp + 52 | 0;
 $nbEBands = sp + 48 | 0;
 $overlap = sp + 44 | 0;
 $eBands = sp + 40 | 0;
 $qg = sp + 36 | 0;
 $octave = sp + 32 | 0;
 $saved_stack = sp + 28 | 0;
 $width = sp + 24 | 0;
 $quanta = sp + 20 | 0;
 $dynalloc_loop_logp = sp + 16 | 0;
 $boost = sp + 12 | 0;
 $flag = sp + 8 | 0;
 $max_background_increase = sp + 4 | 0;
 $cleanup$dest$slot = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$dec$addr >> 2] = $dec;
 HEAP32[$accum$addr >> 2] = $accum;
 HEAP32[$CC >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2];
 HEAP32[$intensity >> 2] = 0;
 HEAP32[$dual_stereo >> 2] = 0;
 HEAP32[$anti_collapse_on >> 2] = 0;
 HEAP32[$C >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2];
 HEAP32[$mode >> 2] = HEAP32[HEAP32[$st$addr >> 2] >> 2];
 HEAP32[$nbEBands >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 8 >> 2];
 HEAP32[$overlap >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 4 >> 2];
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 32 >> 2];
 HEAP32[$start >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 20 >> 2];
 HEAP32[$end >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2];
 HEAP32[$frame_size$addr >> 2] = Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0) | 0;
 HEAP32[$lpc >> 2] = (HEAP32[$st$addr >> 2] | 0) + 92 + ((Math_imul(2048 + (HEAP32[$overlap >> 2] | 0) | 0, HEAP32[$CC >> 2] | 0) | 0) << 2);
 HEAP32[$oldBandE >> 2] = (HEAP32[$lpc >> 2] | 0) + ((HEAP32[$CC >> 2] | 0) * 24 << 2);
 HEAP32[$oldLogE >> 2] = (HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$nbEBands >> 2] << 1 << 2);
 HEAP32[$oldLogE2 >> 2] = (HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$nbEBands >> 2] << 1 << 2);
 HEAP32[$backgroundLogE >> 2] = (HEAP32[$oldLogE2 >> 2] | 0) + (HEAP32[$nbEBands >> 2] << 1 << 2);
 HEAP32[$LM >> 2] = 0;
 while (1) {
  if ((HEAP32[$LM >> 2] | 0) > (HEAP32[(HEAP32[$mode >> 2] | 0) + 36 >> 2] | 0)) break;
  if ((HEAP32[(HEAP32[$mode >> 2] | 0) + 44 >> 2] << HEAP32[$LM >> 2] | 0) == (HEAP32[$frame_size$addr >> 2] | 0)) break;
  HEAP32[$LM >> 2] = (HEAP32[$LM >> 2] | 0) + 1;
 }
 if ((HEAP32[$LM >> 2] | 0) > (HEAP32[(HEAP32[$mode >> 2] | 0) + 36 >> 2] | 0)) {
  HEAP32[$retval >> 2] = -1;
  $508 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $508 | 0;
 }
 HEAP32[$M >> 2] = 1 << HEAP32[$LM >> 2];
 if ((HEAP32[$len$addr >> 2] | 0) < 0 | (HEAP32[$len$addr >> 2] | 0) > 1275 | (HEAP32[$pcm$addr >> 2] | 0) == 0) {
  HEAP32[$retval >> 2] = -1;
  $508 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $508 | 0;
 }
 HEAP32[$N >> 2] = Math_imul(HEAP32[$M >> 2] | 0, HEAP32[(HEAP32[$mode >> 2] | 0) + 44 >> 2] | 0) | 0;
 HEAP32[$c >> 2] = 0;
 do {
  $add$ptr34 = (HEAP32[$st$addr >> 2] | 0) + 92 + ((Math_imul(HEAP32[$c >> 2] | 0, 2048 + (HEAP32[$overlap >> 2] | 0) | 0) | 0) << 2) | 0;
  HEAP32[$decode_mem + (HEAP32[$c >> 2] << 2) >> 2] = $add$ptr34;
  HEAP32[$out_syn + (HEAP32[$c >> 2] << 2) >> 2] = (HEAP32[$decode_mem + (HEAP32[$c >> 2] << 2) >> 2] | 0) + 8192 + (0 - (HEAP32[$N >> 2] | 0) << 2);
  $inc39 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc39;
 } while (($inc39 | 0) < (HEAP32[$CC >> 2] | 0));
 HEAP32[$effEnd >> 2] = HEAP32[$end >> 2];
 if ((HEAP32[$effEnd >> 2] | 0) > (HEAP32[(HEAP32[$mode >> 2] | 0) + 12 >> 2] | 0)) HEAP32[$effEnd >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 12 >> 2];
 $66 = HEAP32[$st$addr >> 2] | 0;
 if ((HEAP32[$data$addr >> 2] | 0) == 0 | (HEAP32[$len$addr >> 2] | 0) <= 1) {
  _celt_decode_lost($66, HEAP32[$N >> 2] | 0, HEAP32[$LM >> 2] | 0);
  _deemphasis($out_syn, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$N >> 2] | 0, HEAP32[$CC >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0, (HEAP32[$mode >> 2] | 0) + 16 | 0, (HEAP32[$st$addr >> 2] | 0) + 84 | 0, HEAP32[$accum$addr >> 2] | 0);
  HEAP32[$retval >> 2] = (HEAP32[$frame_size$addr >> 2] | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0) | 0;
  $508 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $508 | 0;
 }
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] = (HEAP32[$66 + 52 >> 2] | 0) != 0 & 1;
 if (!(HEAP32[$dec$addr >> 2] | 0)) {
  _ec_dec_init($_dec, HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0);
  HEAP32[$dec$addr >> 2] = $_dec;
 }
 L27 : do if ((HEAP32[$C >> 2] | 0) == 1) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nbEBands >> 2] | 0)) break L27;
   if (+HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ((HEAP32[$nbEBands >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2]) $add73$sink = HEAP32[$i >> 2] | 0; else $add73$sink = (HEAP32[$nbEBands >> 2] | 0) + (HEAP32[$i >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ($add73$sink << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$total_bits >> 2] = HEAP32[$len$addr >> 2] << 3;
 HEAP32[$tell >> 2] = _ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0;
 do if ((HEAP32[$tell >> 2] | 0) >= (HEAP32[$total_bits >> 2] | 0)) HEAP32[$silence >> 2] = 1; else if ((HEAP32[$tell >> 2] | 0) == 1) {
  HEAP32[$silence >> 2] = _ec_dec_bit_logp(HEAP32[$dec$addr >> 2] | 0, 15) | 0;
  break;
 } else {
  HEAP32[$silence >> 2] = 0;
  break;
 } while (0);
 if (HEAP32[$silence >> 2] | 0) {
  HEAP32[$tell >> 2] = HEAP32[$len$addr >> 2] << 3;
  $111 = HEAP32[$tell >> 2] | 0;
  $sub = $111 - (_ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0) | 0;
  $nbits_total = (HEAP32[$dec$addr >> 2] | 0) + 20 | 0;
  HEAP32[$nbits_total >> 2] = (HEAP32[$nbits_total >> 2] | 0) + $sub;
 }
 HEAPF32[$postfilter_gain >> 2] = 0.0;
 HEAP32[$postfilter_pitch >> 2] = 0;
 HEAP32[$postfilter_tapset >> 2] = 0;
 if (!(HEAP32[$start >> 2] | 0)) if (((HEAP32[$tell >> 2] | 0) + 16 | 0) <= (HEAP32[$total_bits >> 2] | 0)) {
  if (_ec_dec_bit_logp(HEAP32[$dec$addr >> 2] | 0, 1) | 0) {
   HEAP32[$octave >> 2] = _ec_dec_uint(HEAP32[$dec$addr >> 2] | 0, 6) | 0;
   $shl106 = 16 << HEAP32[$octave >> 2];
   HEAP32[$postfilter_pitch >> 2] = $shl106 + (_ec_dec_bits(HEAP32[$dec$addr >> 2] | 0, 4 + (HEAP32[$octave >> 2] | 0) | 0) | 0) - 1;
   HEAP32[$qg >> 2] = _ec_dec_bits(HEAP32[$dec$addr >> 2] | 0, 3) | 0;
   $add113 = (_ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0) + 2 | 0;
   if (($add113 | 0) <= (HEAP32[$total_bits >> 2] | 0)) HEAP32[$postfilter_tapset >> 2] = _ec_dec_icdf(HEAP32[$dec$addr >> 2] | 0, 30488, 2) | 0;
   HEAPF32[$postfilter_gain >> 2] = +((HEAP32[$qg >> 2] | 0) + 1 | 0) * .09375;
  }
  HEAP32[$tell >> 2] = _ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0;
 }
 if ((HEAP32[$LM >> 2] | 0) > 0) if (((HEAP32[$tell >> 2] | 0) + 3 | 0) <= (HEAP32[$total_bits >> 2] | 0)) {
  HEAP32[$isTransient >> 2] = _ec_dec_bit_logp(HEAP32[$dec$addr >> 2] | 0, 3) | 0;
  HEAP32[$tell >> 2] = _ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0;
 } else label = 41; else label = 41;
 if ((label | 0) == 41) HEAP32[$isTransient >> 2] = 0;
 if (HEAP32[$isTransient >> 2] | 0) HEAP32[$shortBlocks >> 2] = HEAP32[$M >> 2]; else HEAP32[$shortBlocks >> 2] = 0;
 if (((HEAP32[$tell >> 2] | 0) + 3 | 0) <= (HEAP32[$total_bits >> 2] | 0)) $cond147 = _ec_dec_bit_logp(HEAP32[$dec$addr >> 2] | 0, 3) | 0; else $cond147 = 0;
 HEAP32[$intra_ener >> 2] = $cond147;
 _unquant_coarse_energy(HEAP32[$mode >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, HEAP32[$oldBandE >> 2] | 0, HEAP32[$intra_ener >> 2] | 0, HEAP32[$dec$addr >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$LM >> 2] | 0);
 $147 = HEAP32[$nbEBands >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($147 << 2) | 0) + 15 & -16) | 0;
 _tf_decode(HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, HEAP32[$isTransient >> 2] | 0, $vla, HEAP32[$LM >> 2] | 0, HEAP32[$dec$addr >> 2] | 0);
 HEAP32[$tell >> 2] = _ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0;
 HEAP32[$spread_decision >> 2] = 2;
 if (((HEAP32[$tell >> 2] | 0) + 4 | 0) <= (HEAP32[$total_bits >> 2] | 0)) HEAP32[$spread_decision >> 2] = _ec_dec_icdf(HEAP32[$dec$addr >> 2] | 0, 30491, 5) | 0;
 $vla155 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 _init_caps(HEAP32[$mode >> 2] | 0, $vla155, HEAP32[$LM >> 2] | 0, HEAP32[$C >> 2] | 0);
 $vla156 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[$dynalloc_logp >> 2] = 6;
 HEAP32[$total_bits >> 2] = HEAP32[$total_bits >> 2] << 3;
 HEAP32[$tell >> 2] = _ec_tell_frac(HEAP32[$dec$addr >> 2] | 0) | 0;
 HEAP32[$i >> 2] = HEAP32[$start >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
  $mul169 = Math_imul(HEAP32[$C >> 2] | 0, (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) | 0;
  HEAP32[$width >> 2] = $mul169 << HEAP32[$LM >> 2];
  $179 = HEAP32[$width >> 2] | 0;
  if ((HEAP32[$width >> 2] << 3 | 0) < ((48 > (HEAP32[$width >> 2] | 0) ? 48 : HEAP32[$width >> 2] | 0) | 0)) $cond190 = $179 << 3; else $cond190 = 48 > ($179 | 0) ? 48 : HEAP32[$width >> 2] | 0;
  HEAP32[$quanta >> 2] = $cond190;
  HEAP32[$dynalloc_loop_logp >> 2] = HEAP32[$dynalloc_logp >> 2];
  HEAP32[$boost >> 2] = 0;
  while (1) {
   if (((HEAP32[$tell >> 2] | 0) + (HEAP32[$dynalloc_loop_logp >> 2] << 3) | 0) >= (HEAP32[$total_bits >> 2] | 0)) break;
   if ((HEAP32[$boost >> 2] | 0) >= (HEAP32[$vla155 + (HEAP32[$i >> 2] << 2) >> 2] | 0)) break;
   HEAP32[$flag >> 2] = _ec_dec_bit_logp(HEAP32[$dec$addr >> 2] | 0, HEAP32[$dynalloc_loop_logp >> 2] | 0) | 0;
   HEAP32[$tell >> 2] = _ec_tell_frac(HEAP32[$dec$addr >> 2] | 0) | 0;
   if (!(HEAP32[$flag >> 2] | 0)) break;
   HEAP32[$boost >> 2] = (HEAP32[$boost >> 2] | 0) + (HEAP32[$quanta >> 2] | 0);
   HEAP32[$total_bits >> 2] = (HEAP32[$total_bits >> 2] | 0) - (HEAP32[$quanta >> 2] | 0);
   HEAP32[$dynalloc_loop_logp >> 2] = 1;
  }
  HEAP32[$vla156 + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$boost >> 2];
  if ((HEAP32[$boost >> 2] | 0) > 0) HEAP32[$dynalloc_logp >> 2] = 2 > ((HEAP32[$dynalloc_logp >> 2] | 0) - 1 | 0) ? 2 : (HEAP32[$dynalloc_logp >> 2] | 0) - 1 | 0;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 $vla221 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 if (((HEAP32[$tell >> 2] | 0) + 48 | 0) <= (HEAP32[$total_bits >> 2] | 0)) $cond229 = _ec_dec_icdf(HEAP32[$dec$addr >> 2] | 0, 30495, 7) | 0; else $cond229 = 5;
 HEAP32[$alloc_trim >> 2] = $cond229;
 $shl231 = HEAP32[$len$addr >> 2] << 3 << 3;
 HEAP32[$bits >> 2] = $shl231 - (_ec_tell_frac(HEAP32[$dec$addr >> 2] | 0) | 0) - 1;
 if ((HEAP32[$isTransient >> 2] | 0) != 0 & (HEAP32[$LM >> 2] | 0) >= 2) $212 = (HEAP32[$bits >> 2] | 0) >= ((HEAP32[$LM >> 2] | 0) + 2 << 3 | 0); else $212 = 0;
 HEAP32[$anti_collapse_rsv >> 2] = $212 ? 8 : 0;
 HEAP32[$bits >> 2] = (HEAP32[$bits >> 2] | 0) - (HEAP32[$anti_collapse_rsv >> 2] | 0);
 $vla247 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla248 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[$codedBands >> 2] = _compute_allocation(HEAP32[$mode >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, $vla156, $vla155, HEAP32[$alloc_trim >> 2] | 0, $intensity, $dual_stereo, HEAP32[$bits >> 2] | 0, $balance, $vla247, $vla221, $vla248, HEAP32[$C >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[$dec$addr >> 2] | 0, 0, 0, 0) | 0;
 _unquant_fine_energy(HEAP32[$mode >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, HEAP32[$oldBandE >> 2] | 0, $vla221, HEAP32[$dec$addr >> 2] | 0, HEAP32[$C >> 2] | 0);
 HEAP32[$c >> 2] = 0;
 do {
  _memmove(HEAP32[$decode_mem + (HEAP32[$c >> 2] << 2) >> 2] | 0, (HEAP32[$decode_mem + (HEAP32[$c >> 2] << 2) >> 2] | 0) + (HEAP32[$N >> 2] << 2) | 0, (2048 - (HEAP32[$N >> 2] | 0) + ((HEAP32[$overlap >> 2] | 0) / 2 | 0) << 2) + 0 | 0) | 0;
  $inc264 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc264;
 } while (($inc264 | 0) < (HEAP32[$CC >> 2] | 0));
 $vla269$alloca_mul = Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
 $vla269 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla269$alloca_mul | 0) + 15 & -16) | 0;
 $vla271$alloca_mul = (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$N >> 2] | 0) | 0) << 2;
 $vla271 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla271$alloca_mul | 0) + 15 & -16) | 0;
 _quant_all_bands(0, HEAP32[$mode >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, $vla271, (HEAP32[$C >> 2] | 0) == 2 ? $vla271 + (HEAP32[$N >> 2] << 2) | 0 : 0, $vla269, 0, $vla247, HEAP32[$shortBlocks >> 2] | 0, HEAP32[$spread_decision >> 2] | 0, HEAP32[$dual_stereo >> 2] | 0, HEAP32[$intensity >> 2] | 0, $vla, (HEAP32[$len$addr >> 2] << 6) - (HEAP32[$anti_collapse_rsv >> 2] | 0) | 0, HEAP32[$balance >> 2] | 0, HEAP32[$dec$addr >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[$codedBands >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 40 | 0, 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 32 >> 2] | 0);
 if ((HEAP32[$anti_collapse_rsv >> 2] | 0) > 0) HEAP32[$anti_collapse_on >> 2] = _ec_dec_bits(HEAP32[$dec$addr >> 2] | 0, 1) | 0;
 $271 = HEAP32[$mode >> 2] | 0;
 $272 = HEAP32[$start >> 2] | 0;
 $273 = HEAP32[$end >> 2] | 0;
 $274 = HEAP32[$oldBandE >> 2] | 0;
 $mul286 = HEAP32[$len$addr >> 2] << 3;
 $sub288 = $mul286 - (_ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0) | 0;
 _unquant_energy_finalise($271, $272, $273, $274, $vla221, $vla248, $sub288, HEAP32[$dec$addr >> 2] | 0, HEAP32[$C >> 2] | 0);
 if (HEAP32[$anti_collapse_on >> 2] | 0) _anti_collapse(HEAP32[$mode >> 2] | 0, $vla271, $vla269, HEAP32[$LM >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$N >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$end >> 2] | 0, HEAP32[$oldBandE >> 2] | 0, HEAP32[$oldLogE >> 2] | 0, HEAP32[$oldLogE2 >> 2] | 0, $vla247, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0);
 L105 : do if (HEAP32[$silence >> 2] | 0) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0)) break L105;
   HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = -28.0;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 _celt_synthesis(HEAP32[$mode >> 2] | 0, $vla271, $out_syn, HEAP32[$oldBandE >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$effEnd >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$CC >> 2] | 0, HEAP32[$isTransient >> 2] | 0, HEAP32[$LM >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0, HEAP32[$silence >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0);
 HEAP32[$c >> 2] = 0;
 do {
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0) > 15) $cond316 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0; else $cond316 = 15;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] = $cond316;
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0) > 15) $cond324 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0; else $cond324 = 15;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] = $cond324;
  _comb_filter(HEAP32[$out_syn + (HEAP32[$c >> 2] << 2) >> 2] | 0, HEAP32[$out_syn + (HEAP32[$c >> 2] << 2) >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[(HEAP32[$mode >> 2] | 0) + 44 >> 2] | 0, +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2], +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2], HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2] | 0, HEAP32[(HEAP32[$mode >> 2] | 0) + 60 >> 2] | 0, HEAP32[$overlap >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0);
  if (HEAP32[$LM >> 2] | 0) _comb_filter((HEAP32[$out_syn + (HEAP32[$c >> 2] << 2) >> 2] | 0) + (HEAP32[(HEAP32[$mode >> 2] | 0) + 44 >> 2] << 2) | 0, (HEAP32[$out_syn + (HEAP32[$c >> 2] << 2) >> 2] | 0) + (HEAP32[(HEAP32[$mode >> 2] | 0) + 44 >> 2] << 2) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[$postfilter_pitch >> 2] | 0, (HEAP32[$N >> 2] | 0) - (HEAP32[(HEAP32[$mode >> 2] | 0) + 44 >> 2] | 0) | 0, +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2], +HEAPF32[$postfilter_gain >> 2], HEAP32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2] | 0, HEAP32[$postfilter_tapset >> 2] | 0, HEAP32[(HEAP32[$mode >> 2] | 0) + 60 >> 2] | 0, HEAP32[$overlap >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0);
  $inc352 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc352;
 } while (($inc352 | 0) < (HEAP32[$CC >> 2] | 0));
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2];
 HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] = +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] = HEAP32[$postfilter_pitch >> 2];
 HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2] = +HEAPF32[$postfilter_gain >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2] = HEAP32[$postfilter_tapset >> 2];
 if (HEAP32[$LM >> 2] | 0) {
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2];
  HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] = +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2];
 }
 if ((HEAP32[$C >> 2] | 0) == 1) _memcpy((HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$nbEBands >> 2] << 2) | 0, HEAP32[$oldBandE >> 2] | 0, (HEAP32[$nbEBands >> 2] << 2) + 0 | 0) | 0;
 L129 : do if (HEAP32[$isTransient >> 2] | 0) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nbEBands >> 2] << 1 | 0)) break L129;
   if (+HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] < +HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $arrayidx448$sink = (HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0; else $arrayidx448$sink = (HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$arrayidx448$sink >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } else {
  _memcpy(HEAP32[$oldLogE2 >> 2] | 0, HEAP32[$oldLogE >> 2] | 0, (HEAP32[$nbEBands >> 2] << 1 << 2) + 0 | 0) | 0;
  _memcpy(HEAP32[$oldLogE >> 2] | 0, HEAP32[$oldBandE >> 2] | 0, (HEAP32[$nbEBands >> 2] << 1 << 2) + 0 | 0) | 0;
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] | 0) < 10) HEAPF32[$max_background_increase >> 2] = +(HEAP32[$M >> 2] | 0) * 1.0000000474974513e-03; else HEAPF32[$max_background_increase >> 2] = 1.0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nbEBands >> 2] << 1 | 0)) break L129;
   if (+HEAPF32[(HEAP32[$backgroundLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[$max_background_increase >> 2] < +HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $cond430 = +HEAPF32[(HEAP32[$backgroundLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[$max_background_increase >> 2]; else $cond430 = +HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[(HEAP32[$backgroundLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $cond430;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$start >> 2] | 0)) break;
   $mul461 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ($mul461 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = 0.0;
   $mul464 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldLogE2 >> 2] | 0) + ($mul464 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = -28.0;
   $mul467 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + ($mul467 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = -28.0;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = HEAP32[$end >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nbEBands >> 2] | 0)) break;
   $mul477 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ($mul477 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = 0.0;
   $mul480 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldLogE2 >> 2] | 0) + ($mul480 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = -28.0;
   $mul483 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + ($mul483 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = -28.0;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc490 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc490;
 } while (($inc490 | 0) < 2);
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] = HEAP32[(HEAP32[$dec$addr >> 2] | 0) + 28 >> 2];
 _deemphasis($out_syn, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$N >> 2] | 0, HEAP32[$CC >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0, (HEAP32[$mode >> 2] | 0) + 16 | 0, (HEAP32[$st$addr >> 2] | 0) + 84 | 0, HEAP32[$accum$addr >> 2] | 0);
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] = 0;
 $call503 = _ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0;
 if (($call503 | 0) > (HEAP32[$len$addr >> 2] << 3 | 0)) {
  HEAP32[$retval >> 2] = -3;
  HEAP32[$cleanup$dest$slot >> 2] = 1;
 } else {
  if (_ec_get_error_68(HEAP32[$dec$addr >> 2] | 0) | 0) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] = 1;
  HEAP32[$retval >> 2] = (HEAP32[$frame_size$addr >> 2] | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0) | 0;
  HEAP32[$cleanup$dest$slot >> 2] = 1;
 }
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 $508 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $508 | 0;
}
function _silk_resampler_private_down_FIR_INTERPOL($out, $buf, $FIR_Coefs, $FIR_Order, $FIR_Fracs, $max_index_Q16, $index_increment_Q16) {
 $out = $out | 0;
 $buf = $buf | 0;
 $FIR_Coefs = $FIR_Coefs | 0;
 $FIR_Order = $FIR_Order | 0;
 $FIR_Fracs = $FIR_Fracs | 0;
 $max_index_Q16 = $max_index_Q16 | 0;
 $index_increment_Q16 = $index_increment_Q16 | 0;
 var $178 = 0, $343 = 0, $586 = 0, $589 = 0, $FIR_Coefs$addr = 0, $FIR_Fracs$addr = 0, $FIR_Order$addr = 0, $buf$addr = 0, $buf_ptr = 0, $cond262 = 0, $cond495 = 0, $cond833 = 0, $index_Q16 = 0, $index_increment_Q16$addr = 0, $interpol_ind = 0, $interpol_ptr = 0, $max_index_Q16$addr = 0, $mul = 0, $mul104 = 0, $mul117 = 0, $mul133 = 0, $mul14 = 0, $mul146 = 0, $mul159 = 0, $mul172 = 0, $mul185 = 0, $mul198 = 0, $mul211 = 0, $mul224 = 0, $mul237 = 0, $mul26 = 0, $mul278 = 0, $mul294 = 0, $mul311 = 0, $mul328 = 0, $mul345 = 0, $mul362 = 0, $mul379 = 0, $mul39 = 0, $mul396 = 0, $mul413 = 0, $mul430 = 0, $mul447 = 0, $mul464 = 0, $mul514 = 0, $mul52 = 0, $mul530 = 0, $mul547 = 0, $mul564 = 0, $mul581 = 0, $mul598 = 0, $mul615 = 0, $mul632 = 0, $mul649 = 0, $mul65 = 0, $mul666 = 0, $mul683 = 0, $mul700 = 0, $mul717 = 0, $mul734 = 0, $mul751 = 0, $mul768 = 0, $mul78 = 0, $mul785 = 0, $mul802 = 0, $mul91 = 0, $out$addr = 0, $res_Q6 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $out$addr = sp + 44 | 0;
 $buf$addr = sp + 40 | 0;
 $FIR_Coefs$addr = sp + 36 | 0;
 $FIR_Order$addr = sp + 32 | 0;
 $FIR_Fracs$addr = sp + 28 | 0;
 $max_index_Q16$addr = sp + 24 | 0;
 $index_increment_Q16$addr = sp + 20 | 0;
 $index_Q16 = sp + 16 | 0;
 $res_Q6 = sp + 12 | 0;
 $buf_ptr = sp + 8 | 0;
 $interpol_ind = sp + 4 | 0;
 $interpol_ptr = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$buf$addr >> 2] = $buf;
 HEAP32[$FIR_Coefs$addr >> 2] = $FIR_Coefs;
 HEAP32[$FIR_Order$addr >> 2] = $FIR_Order;
 HEAP32[$FIR_Fracs$addr >> 2] = $FIR_Fracs;
 HEAP32[$max_index_Q16$addr >> 2] = $max_index_Q16;
 HEAP32[$index_increment_Q16$addr >> 2] = $index_increment_Q16;
 switch (HEAP32[$FIR_Order$addr >> 2] | 0) {
 case 18:
  {
   HEAP32[$index_Q16 >> 2] = 0;
   while (1) {
    if ((HEAP32[$index_Q16 >> 2] | 0) >= (HEAP32[$max_index_Q16$addr >> 2] | 0)) break;
    HEAP32[$buf_ptr >> 2] = (HEAP32[$buf$addr >> 2] | 0) + (HEAP32[$index_Q16 >> 2] >> 16 << 2);
    $mul = Math_imul((HEAP32[$index_Q16 >> 2] & 65535) >> 16, (HEAP32[$FIR_Fracs$addr >> 2] & 65535) << 16 >> 16) | 0;
    HEAP32[$interpol_ind >> 2] = $mul + ((Math_imul(HEAP32[$index_Q16 >> 2] & 65535, (HEAP32[$FIR_Fracs$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16);
    HEAP32[$interpol_ptr >> 2] = (HEAP32[$FIR_Coefs$addr >> 2] | 0) + ((HEAP32[$interpol_ind >> 2] | 0) * 9 << 1);
    $mul14 = Math_imul(HEAP32[HEAP32[$buf_ptr >> 2] >> 2] >> 16, HEAP16[HEAP32[$interpol_ptr >> 2] >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = $mul14 + ((Math_imul(HEAP32[HEAP32[$buf_ptr >> 2] >> 2] & 65535, HEAP16[HEAP32[$interpol_ptr >> 2] >> 1] | 0) | 0) >> 16);
    $mul26 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 2 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul26 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
    $mul39 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 4 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul39 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
    $mul52 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 6 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul52 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
    $mul65 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 16 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 8 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul65 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 16 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
    $mul78 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 20 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 10 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul78 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 20 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 10 >> 1] | 0) | 0) >> 16));
    $mul91 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 24 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 12 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul91 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 24 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 12 >> 1] | 0) | 0) >> 16));
    $mul104 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 28 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 14 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul104 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 28 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 14 >> 1] | 0) | 0) >> 16));
    $mul117 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 32 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 16 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul117 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 32 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 16 >> 1] | 0) | 0) >> 16));
    HEAP32[$interpol_ptr >> 2] = (HEAP32[$FIR_Coefs$addr >> 2] | 0) + (((HEAP32[$FIR_Fracs$addr >> 2] | 0) - 1 - (HEAP32[$interpol_ind >> 2] | 0) | 0) * 9 << 1);
    $mul133 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 68 >> 2] >> 16, HEAP16[HEAP32[$interpol_ptr >> 2] >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul133 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 68 >> 2] & 65535, HEAP16[HEAP32[$interpol_ptr >> 2] >> 1] | 0) | 0) >> 16));
    $mul146 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 64 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 2 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul146 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 64 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
    $mul159 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 60 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 4 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul159 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 60 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
    $mul172 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 56 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 6 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul172 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 56 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
    $mul185 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 52 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 8 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul185 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 52 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
    $mul198 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 48 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 10 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul198 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 48 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 10 >> 1] | 0) | 0) >> 16));
    $mul211 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 44 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 12 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul211 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 44 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 12 >> 1] | 0) | 0) >> 16));
    $mul224 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 40 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 14 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul224 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 40 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 14 >> 1] | 0) | 0) >> 16));
    $mul237 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 36 >> 2] >> 16, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 16 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul237 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 36 >> 2] & 65535, HEAP16[(HEAP32[$interpol_ptr >> 2] | 0) + 16 >> 1] | 0) | 0) >> 16));
    if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) > 32767) $cond262 = 32767; else if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) < -32768) $cond262 = -32768; else $cond262 = (HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1;
    $178 = HEAP32[$out$addr >> 2] | 0;
    HEAP32[$out$addr >> 2] = $178 + 2;
    HEAP16[$178 >> 1] = $cond262;
    HEAP32[$index_Q16 >> 2] = (HEAP32[$index_Q16 >> 2] | 0) + (HEAP32[$index_increment_Q16$addr >> 2] | 0);
   }
   $589 = HEAP32[$out$addr >> 2] | 0;
   STACKTOP = sp;
   return $589 | 0;
  }
 case 24:
  {
   HEAP32[$index_Q16 >> 2] = 0;
   while (1) {
    if ((HEAP32[$index_Q16 >> 2] | 0) >= (HEAP32[$max_index_Q16$addr >> 2] | 0)) break;
    HEAP32[$buf_ptr >> 2] = (HEAP32[$buf$addr >> 2] | 0) + (HEAP32[$index_Q16 >> 2] >> 16 << 2);
    $mul278 = Math_imul((HEAP32[HEAP32[$buf_ptr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 92 >> 2] | 0) >> 16, HEAP16[HEAP32[$FIR_Coefs$addr >> 2] >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = $mul278 + ((Math_imul((HEAP32[HEAP32[$buf_ptr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 92 >> 2] | 0) & 65535, HEAP16[HEAP32[$FIR_Coefs$addr >> 2] >> 1] | 0) | 0) >> 16);
    $mul294 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 88 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 2 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul294 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 88 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
    $mul311 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 84 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 4 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul311 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 84 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
    $mul328 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 80 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 6 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul328 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 80 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
    $mul345 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 16 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 76 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 8 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul345 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 16 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 76 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
    $mul362 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 20 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 72 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 10 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul362 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 20 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 72 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 10 >> 1] | 0) | 0) >> 16));
    $mul379 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 24 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 68 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 12 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul379 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 24 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 68 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 12 >> 1] | 0) | 0) >> 16));
    $mul396 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 28 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 64 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 14 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul396 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 28 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 64 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 14 >> 1] | 0) | 0) >> 16));
    $mul413 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 60 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 16 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul413 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 60 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 16 >> 1] | 0) | 0) >> 16));
    $mul430 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 36 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 56 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 18 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul430 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 36 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 56 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 18 >> 1] | 0) | 0) >> 16));
    $mul447 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 40 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 52 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 20 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul447 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 40 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 52 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 20 >> 1] | 0) | 0) >> 16));
    $mul464 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 44 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 48 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 22 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul464 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 44 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 48 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 22 >> 1] | 0) | 0) >> 16));
    if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) > 32767) $cond495 = 32767; else if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) < -32768) $cond495 = -32768; else $cond495 = (HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1;
    $343 = HEAP32[$out$addr >> 2] | 0;
    HEAP32[$out$addr >> 2] = $343 + 2;
    HEAP16[$343 >> 1] = $cond495;
    HEAP32[$index_Q16 >> 2] = (HEAP32[$index_Q16 >> 2] | 0) + (HEAP32[$index_increment_Q16$addr >> 2] | 0);
   }
   $589 = HEAP32[$out$addr >> 2] | 0;
   STACKTOP = sp;
   return $589 | 0;
  }
 case 36:
  {
   HEAP32[$index_Q16 >> 2] = 0;
   while (1) {
    if ((HEAP32[$index_Q16 >> 2] | 0) >= (HEAP32[$max_index_Q16$addr >> 2] | 0)) break;
    HEAP32[$buf_ptr >> 2] = (HEAP32[$buf$addr >> 2] | 0) + (HEAP32[$index_Q16 >> 2] >> 16 << 2);
    $mul514 = Math_imul((HEAP32[HEAP32[$buf_ptr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 140 >> 2] | 0) >> 16, HEAP16[HEAP32[$FIR_Coefs$addr >> 2] >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = $mul514 + ((Math_imul((HEAP32[HEAP32[$buf_ptr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 140 >> 2] | 0) & 65535, HEAP16[HEAP32[$FIR_Coefs$addr >> 2] >> 1] | 0) | 0) >> 16);
    $mul530 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 136 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 2 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul530 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 136 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
    $mul547 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 132 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 4 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul547 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 132 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
    $mul564 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 128 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 6 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul564 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 128 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
    $mul581 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 16 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 124 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 8 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul581 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 16 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 124 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
    $mul598 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 20 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 120 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 10 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul598 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 20 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 120 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 10 >> 1] | 0) | 0) >> 16));
    $mul615 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 24 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 116 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 12 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul615 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 24 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 116 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 12 >> 1] | 0) | 0) >> 16));
    $mul632 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 28 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 112 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 14 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul632 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 28 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 112 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 14 >> 1] | 0) | 0) >> 16));
    $mul649 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 108 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 16 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul649 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 108 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 16 >> 1] | 0) | 0) >> 16));
    $mul666 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 36 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 104 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 18 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul666 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 36 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 104 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 18 >> 1] | 0) | 0) >> 16));
    $mul683 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 40 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 100 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 20 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul683 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 40 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 100 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 20 >> 1] | 0) | 0) >> 16));
    $mul700 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 44 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 96 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 22 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul700 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 44 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 96 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 22 >> 1] | 0) | 0) >> 16));
    $mul717 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 48 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 92 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 24 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul717 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 48 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 92 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 24 >> 1] | 0) | 0) >> 16));
    $mul734 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 52 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 88 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 26 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul734 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 52 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 88 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 26 >> 1] | 0) | 0) >> 16));
    $mul751 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 56 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 84 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 28 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul751 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 56 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 84 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 28 >> 1] | 0) | 0) >> 16));
    $mul768 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 60 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 80 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 30 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul768 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 60 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 80 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 30 >> 1] | 0) | 0) >> 16));
    $mul785 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 64 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 76 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 32 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul785 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 64 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 76 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 32 >> 1] | 0) | 0) >> 16));
    $mul802 = Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 68 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 72 >> 2] | 0) >> 16, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 34 >> 1] | 0) | 0;
    HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul802 + ((Math_imul((HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 68 >> 2] | 0) + (HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 72 >> 2] | 0) & 65535, HEAP16[(HEAP32[$FIR_Coefs$addr >> 2] | 0) + 34 >> 1] | 0) | 0) >> 16));
    if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) > 32767) $cond833 = 32767; else if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) < -32768) $cond833 = -32768; else $cond833 = (HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1;
    $586 = HEAP32[$out$addr >> 2] | 0;
    HEAP32[$out$addr >> 2] = $586 + 2;
    HEAP16[$586 >> 1] = $cond833;
    HEAP32[$index_Q16 >> 2] = (HEAP32[$index_Q16 >> 2] | 0) + (HEAP32[$index_increment_Q16$addr >> 2] | 0);
   }
   $589 = HEAP32[$out$addr >> 2] | 0;
   STACKTOP = sp;
   return $589 | 0;
  }
 default:
  {
   $589 = HEAP32[$out$addr >> 2] | 0;
   STACKTOP = sp;
   return $589 | 0;
  }
 }
 return 0;
}

function _silk_PLC_conceal($psDec, $psDecCtrl, $frame, $arch) {
 $psDec = $psDec | 0;
 $psDecCtrl = $psDecCtrl | 0;
 $frame = $frame | 0;
 $arch = $arch | 0;
 var $213 = 0, $26 = 0, $330 = 0, $A_Q12 = 0, $B_Q14 = 0, $LPC_pred_Q10 = 0, $LTP_pred_Q12 = 0, $add = 0, $add126 = 0, $add606 = 0, $add637 = 0, $add668 = 0, $add703 = 0, $add734 = 0, $add765 = 0, $add800 = 0, $add831 = 0, $add862 = 0, $arch$addr = 0, $call272 = 0, $call33 = 0, $cmp29 = 0, $cmp511 = 0, $cond502 = 0, $cond522 = 0, $cond543 = 0, $cond562 = 0, $cond582 = 0, $cond588 = 0, $cond683 = 0, $cond780 = 0, $cond881 = 0, $conv240 = 0, $down_scale_Q30 = 0, $energy1 = 0, $energy2 = 0, $exc_Q1413 = 0, $frame$addr = 0, $harm_Gain_Q15 = 0, $i = 0, $idx = 0, $invGain_Q30 = 0, $inv_gain_Q30 = 0, $j = 0, $k = 0, $lag = 0, $mul120 = 0, $mul148 = 0, $mul161 = 0, $mul174 = 0, $mul187 = 0, $mul200 = 0, $mul216 = 0, $mul298 = 0, $mul315 = 0, $mul332 = 0, $mul349 = 0, $mul366 = 0, $mul383 = 0, $mul400 = 0, $mul417 = 0, $mul434 = 0, $mul451 = 0, $mul474 = 0, $mul597 = 0, $mul628 = 0, $mul659 = 0, $mul694 = 0, $mul725 = 0, $mul756 = 0, $mul791 = 0, $mul80 = 0, $mul822 = 0, $mul853 = 0, $pred_lag_ptr = 0, $prevGain_Q10 = 0, $psDec$addr = 0, $psDecCtrl$addr = 0, $psPLC = 0, $rand_Gain_Q15 = 0, $rand_ptr = 0, $rand_scale_Q14 = 0, $rand_seed = 0, $sLPC_Q14_ptr = 0, $sLTP_buf_idx = 0, $saved_stack = 0, $shift1 = 0, $shift2 = 0, $shl224 = 0, $vla = 0, $vla2 = 0, dest = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 $psDec$addr = sp + 120 | 0;
 $psDecCtrl$addr = sp + 116 | 0;
 $frame$addr = sp + 112 | 0;
 $arch$addr = sp + 108 | 0;
 $i = sp + 104 | 0;
 $j = sp + 100 | 0;
 $k = sp + 96 | 0;
 $lag = sp + 92 | 0;
 $idx = sp + 88 | 0;
 $sLTP_buf_idx = sp + 84 | 0;
 $shift1 = sp + 80 | 0;
 $shift2 = sp + 76 | 0;
 $rand_seed = sp + 72 | 0;
 $harm_Gain_Q15 = sp + 68 | 0;
 $rand_Gain_Q15 = sp + 64 | 0;
 $inv_gain_Q30 = sp + 60 | 0;
 $energy1 = sp + 56 | 0;
 $energy2 = sp + 52 | 0;
 $rand_ptr = sp + 48 | 0;
 $pred_lag_ptr = sp + 44 | 0;
 $LPC_pred_Q10 = sp + 40 | 0;
 $LTP_pred_Q12 = sp + 36 | 0;
 $rand_scale_Q14 = sp + 160 | 0;
 $B_Q14 = sp + 32 | 0;
 $sLPC_Q14_ptr = sp + 28 | 0;
 $A_Q12 = sp + 128 | 0;
 $psPLC = sp + 24 | 0;
 $prevGain_Q10 = sp + 16 | 0;
 $saved_stack = sp + 8 | 0;
 $invGain_Q30 = sp + 4 | 0;
 $down_scale_Q30 = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$psDecCtrl$addr >> 2] = $psDecCtrl;
 HEAP32[$frame$addr >> 2] = $frame;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$psPLC >> 2] = (HEAP32[$psDec$addr >> 2] | 0) + 4172;
 $add = (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add << 2) | 0) + 15 & -16) | 0;
 $vla2 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] << 1) | 0) + 15 & -16) | 0;
 HEAP32[$prevGain_Q10 >> 2] = HEAP32[(HEAP32[$psPLC >> 2] | 0) + 72 >> 2] >> 6;
 HEAP32[$prevGain_Q10 + 4 >> 2] = HEAP32[(HEAP32[$psPLC >> 2] | 0) + 72 + 4 >> 2] >> 6;
 if (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2376 >> 2] | 0) {
  dest = (HEAP32[$psPLC >> 2] | 0) + 14 | 0;
  stop = dest + 32 | 0;
  do {
   HEAP16[dest >> 1] = 0;
   dest = dest + 2 | 0;
  } while ((dest | 0) < (stop | 0));
 }
 _silk_PLC_energy($energy1, $shift1, $energy2, $shift2, (HEAP32[$psDec$addr >> 2] | 0) + 4 | 0, $prevGain_Q10, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0);
 $exc_Q1413 = (HEAP32[$psDec$addr >> 2] | 0) + 4 | 0;
 $26 = HEAP32[(HEAP32[$psPLC >> 2] | 0) + 84 >> 2] | 0;
 if ((HEAP32[$energy1 >> 2] >> HEAP32[$shift2 >> 2] | 0) < (HEAP32[$energy2 >> 2] >> HEAP32[$shift1 >> 2] | 0)) HEAP32[$rand_ptr >> 2] = $exc_Q1413 + ((_silk_max_int_432(0, (Math_imul($26 - 1 | 0, HEAP32[(HEAP32[$psPLC >> 2] | 0) + 88 >> 2] | 0) | 0) - 128 | 0) | 0) << 2); else HEAP32[$rand_ptr >> 2] = $exc_Q1413 + ((_silk_max_int_432(0, (Math_imul($26, HEAP32[(HEAP32[$psPLC >> 2] | 0) + 88 >> 2] | 0) | 0) - 128 | 0) | 0) << 2);
 HEAP32[$B_Q14 >> 2] = (HEAP32[$psPLC >> 2] | 0) + 4;
 HEAP16[$rand_scale_Q14 >> 1] = HEAP16[(HEAP32[$psPLC >> 2] | 0) + 56 >> 1] | 0;
 HEAP32[$harm_Gain_Q15 >> 2] = HEAP16[23352 + ((_silk_min_int_433(1, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4160 >> 2] | 0) | 0) << 1) >> 1];
 $cmp29 = (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4164 >> 2] | 0) == 2;
 $call33 = _silk_min_int_433(1, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4160 >> 2] | 0) | 0;
 if ($cmp29) HEAP32[$rand_Gain_Q15 >> 2] = HEAP16[23356 + ($call33 << 1) >> 1]; else HEAP32[$rand_Gain_Q15 >> 2] = HEAP16[23360 + ($call33 << 1) >> 1];
 _silk_bwexpander((HEAP32[$psPLC >> 2] | 0) + 14 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0, 64881);
 _memcpy($A_Q12 | 0, (HEAP32[$psPLC >> 2] | 0) + 14 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] << 1 | 0) | 0;
 do if (!(HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4160 >> 2] | 0)) {
  HEAP16[$rand_scale_Q14 >> 1] = 16384;
  if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4164 >> 2] | 0) != 2) {
   HEAP32[$invGain_Q30 >> 2] = _silk_LPC_inverse_pred_gain_c((HEAP32[$psPLC >> 2] | 0) + 14 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0) | 0;
   HEAP32[$down_scale_Q30 >> 2] = _silk_min_32_434(134217728, HEAP32[$invGain_Q30 >> 2] | 0) | 0;
   HEAP32[$down_scale_Q30 >> 2] = _silk_max_32(4194304, HEAP32[$down_scale_Q30 >> 2] | 0) | 0;
   HEAP32[$down_scale_Q30 >> 2] = HEAP32[$down_scale_Q30 >> 2] << 3;
   $mul80 = Math_imul(HEAP32[$down_scale_Q30 >> 2] >> 16, (HEAP32[$rand_Gain_Q15 >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$rand_Gain_Q15 >> 2] = $mul80 + ((Math_imul(HEAP32[$down_scale_Q30 >> 2] & 65535, (HEAP32[$rand_Gain_Q15 >> 2] & 65535) << 16 >> 16) | 0) >> 16) >> 14;
   break;
  }
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 5) break;
   HEAP16[$rand_scale_Q14 >> 1] = (HEAP16[$rand_scale_Q14 >> 1] | 0) - (HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0);
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP16[$rand_scale_Q14 >> 1] = _silk_max_16(3277, HEAP16[$rand_scale_Q14 >> 1] | 0) | 0;
  HEAP16[$rand_scale_Q14 >> 1] = (Math_imul(HEAP16[$rand_scale_Q14 >> 1] | 0, HEAP16[(HEAP32[$psPLC >> 2] | 0) + 68 >> 1] | 0) | 0) >> 14;
 } while (0);
 HEAP32[$rand_seed >> 2] = HEAP32[(HEAP32[$psPLC >> 2] | 0) + 52 >> 2];
 HEAP32[$lag >> 2] = (HEAP32[HEAP32[$psPLC >> 2] >> 2] >> 7) + 1 >> 1;
 HEAP32[$sLTP_buf_idx >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2];
 HEAP32[$idx >> 2] = (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) - (HEAP32[$lag >> 2] | 0) - (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0) - 2;
 _silk_LPC_analysis_filter($vla2 + (HEAP32[$idx >> 2] << 1) | 0, (HEAP32[$psDec$addr >> 2] | 0) + 1348 + (HEAP32[$idx >> 2] << 1) | 0, $A_Q12, (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) - (HEAP32[$idx >> 2] | 0) | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
 HEAP32[$inv_gain_Q30 >> 2] = _silk_INVERSE32_varQ_435(HEAP32[(HEAP32[$psPLC >> 2] | 0) + 72 + 4 >> 2] | 0, 46) | 0;
 HEAP32[$inv_gain_Q30 >> 2] = (HEAP32[$inv_gain_Q30 >> 2] | 0) < 1073741823 ? HEAP32[$inv_gain_Q30 >> 2] | 0 : 1073741823;
 HEAP32[$i >> 2] = (HEAP32[$idx >> 2] | 0) + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0);
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0)) break;
  $mul120 = Math_imul(HEAP32[$inv_gain_Q30 >> 2] >> 16, HEAP16[$vla2 + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
  $add126 = $mul120 + ((Math_imul(HEAP32[$inv_gain_Q30 >> 2] & 65535, HEAP16[$vla2 + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) >> 16) | 0;
  HEAP32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = $add126;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0)) break;
  HEAP32[$pred_lag_ptr >> 2] = $vla + ((HEAP32[$sLTP_buf_idx >> 2] | 0) - (HEAP32[$lag >> 2] | 0) + 2 << 2);
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] | 0)) break;
   HEAP32[$LTP_pred_Q12 >> 2] = 2;
   $mul148 = Math_imul(HEAP32[HEAP32[$pred_lag_ptr >> 2] >> 2] >> 16, HEAP16[HEAP32[$B_Q14 >> 2] >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q12 >> 2] = (HEAP32[$LTP_pred_Q12 >> 2] | 0) + ($mul148 + ((Math_imul(HEAP32[HEAP32[$pred_lag_ptr >> 2] >> 2] & 65535, HEAP16[HEAP32[$B_Q14 >> 2] >> 1] | 0) | 0) >> 16));
   $mul161 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -4 >> 2] >> 16, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 2 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q12 >> 2] = (HEAP32[$LTP_pred_Q12 >> 2] | 0) + ($mul161 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -4 >> 2] & 65535, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
   $mul174 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -8 >> 2] >> 16, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 4 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q12 >> 2] = (HEAP32[$LTP_pred_Q12 >> 2] | 0) + ($mul174 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -8 >> 2] & 65535, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
   $mul187 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -12 >> 2] >> 16, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 6 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q12 >> 2] = (HEAP32[$LTP_pred_Q12 >> 2] | 0) + ($mul187 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -12 >> 2] & 65535, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
   $mul200 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -16 >> 2] >> 16, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 8 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q12 >> 2] = (HEAP32[$LTP_pred_Q12 >> 2] | 0) + ($mul200 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -16 >> 2] & 65535, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
   HEAP32[$pred_lag_ptr >> 2] = (HEAP32[$pred_lag_ptr >> 2] | 0) + 4;
   HEAP32[$rand_seed >> 2] = 907633515 + (Math_imul(HEAP32[$rand_seed >> 2] | 0, 196314165) | 0);
   HEAP32[$idx >> 2] = HEAP32[$rand_seed >> 2] >> 25 & 127;
   $mul216 = Math_imul(HEAP32[(HEAP32[$rand_ptr >> 2] | 0) + (HEAP32[$idx >> 2] << 2) >> 2] >> 16, HEAP16[$rand_scale_Q14 >> 1] | 0) | 0;
   $shl224 = (HEAP32[$LTP_pred_Q12 >> 2] | 0) + ($mul216 + ((Math_imul(HEAP32[(HEAP32[$rand_ptr >> 2] | 0) + (HEAP32[$idx >> 2] << 2) >> 2] & 65535, HEAP16[$rand_scale_Q14 >> 1] | 0) | 0) >> 16)) << 2;
   HEAP32[$vla + (HEAP32[$sLTP_buf_idx >> 2] << 2) >> 2] = $shl224;
   HEAP32[$sLTP_buf_idx >> 2] = (HEAP32[$sLTP_buf_idx >> 2] | 0) + 1;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= 5) break;
   $conv240 = (Math_imul((HEAP32[$harm_Gain_Q15 >> 2] & 65535) << 16 >> 16, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0) >> 15 & 65535;
   HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] = $conv240;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  if (HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] | 0) HEAP16[$rand_scale_Q14 >> 1] = (Math_imul(HEAP16[$rand_scale_Q14 >> 1] | 0, (HEAP32[$rand_Gain_Q15 >> 2] & 65535) << 16 >> 16) | 0) >> 15;
  HEAP32[HEAP32[$psPLC >> 2] >> 2] = (HEAP32[HEAP32[$psPLC >> 2] >> 2] | 0) + (((HEAP32[HEAP32[$psPLC >> 2] >> 2] >> 16) * 655 | 0) + ((HEAP32[HEAP32[$psPLC >> 2] >> 2] & 65535) * 655 >> 16));
  $call272 = _silk_min_32_434(HEAP32[HEAP32[$psPLC >> 2] >> 2] | 0, ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] & 65535) << 16 >> 16) * 18 << 8) | 0;
  HEAP32[HEAP32[$psPLC >> 2] >> 2] = $call272;
  HEAP32[$lag >> 2] = (HEAP32[HEAP32[$psPLC >> 2] >> 2] >> 7) + 1 >> 1;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$sLPC_Q14_ptr >> 2] = $vla + ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) - 16 << 2);
 dest = HEAP32[$sLPC_Q14_ptr >> 2] | 0;
 src = (HEAP32[$psDec$addr >> 2] | 0) + 1284 | 0;
 stop = dest + 64 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[$i >> 2] = 0;
 while (1) {
  $213 = HEAP32[$psDec$addr >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] | 0)) break;
  HEAP32[$LPC_pred_Q10 >> 2] = HEAP32[$213 + 2340 >> 2] >> 1;
  $mul298 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] >> 16, HEAP16[$A_Q12 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul298 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] & 65535, HEAP16[$A_Q12 >> 1] | 0) | 0) >> 16));
  $mul315 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 2 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 2 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul315 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 2 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 2 >> 1] | 0) | 0) >> 16));
  $mul332 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 3 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 4 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul332 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 3 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 4 >> 1] | 0) | 0) >> 16));
  $mul349 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 4 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 6 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul349 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 4 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 6 >> 1] | 0) | 0) >> 16));
  $mul366 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 5 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 8 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul366 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 5 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 8 >> 1] | 0) | 0) >> 16));
  $mul383 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 6 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 10 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul383 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 6 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 10 >> 1] | 0) | 0) >> 16));
  $mul400 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 7 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 12 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul400 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 7 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 12 >> 1] | 0) | 0) >> 16));
  $mul417 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 8 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 14 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul417 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 8 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 14 >> 1] | 0) | 0) >> 16));
  $mul434 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 9 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 16 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul434 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 9 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 16 >> 1] | 0) | 0) >> 16));
  $mul451 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 10 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 18 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul451 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - 10 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 18 >> 1] | 0) | 0) >> 16));
  HEAP32[$j >> 2] = 10;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0)) break;
   $mul474 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - (HEAP32[$j >> 2] | 0) - 1 << 2) >> 2] >> 16, HEAP16[$A_Q12 + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul474 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) - (HEAP32[$j >> 2] | 0) - 1 << 2) >> 2] & 65535, HEAP16[$A_Q12 + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0) >> 16));
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  if ((HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727) $cond502 = 134217727; else $cond502 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
  $330 = HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0;
  $cmp511 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727;
  if (!((HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0) + ($cond502 << 4) & -2147483648)) {
   if ($cmp511) $cond522 = 134217727; else $cond522 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
   if ($330 & $cond522 << 4 & -2147483648 | 0) $cond588 = -2147483648; else {
    if ((HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727) $cond543 = 134217727; else $cond543 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
    $cond588 = (HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0) + ($cond543 << 4) | 0;
   }
  } else {
   if ($cmp511) $cond562 = 134217727; else $cond562 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
   if (!(($330 | $cond562 << 4) & -2147483648)) $cond588 = 2147483647; else {
    if ((HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727) $cond582 = 134217727; else $cond582 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
    $cond588 = (HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0) + ($cond582 << 4) | 0;
   }
  }
  HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = $cond588;
  $mul597 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0;
  $add606 = $mul597 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  if ((($add606 + (Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$prevGain_Q10 + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond683 = 32767; else {
   $mul628 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0;
   $add637 = $mul628 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   if ((($add637 + (Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$prevGain_Q10 + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond683 = -32768; else {
    $mul659 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0;
    $add668 = $mul659 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    $cond683 = ($add668 + (Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$prevGain_Q10 + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
   }
  }
  if (($cond683 | 0) > 32767) $cond881 = 32767; else {
   $mul694 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0;
   $add703 = $mul694 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   if ((($add703 + (Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$prevGain_Q10 + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond780 = 32767; else {
    $mul725 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0;
    $add734 = $mul725 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    if ((($add734 + (Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$prevGain_Q10 + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond780 = -32768; else {
     $mul756 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0;
     $add765 = $mul756 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
     $cond780 = ($add765 + (Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$prevGain_Q10 + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
    }
   }
   if (($cond780 | 0) < -32768) $cond881 = -32768; else {
    $mul791 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0;
    $add800 = $mul791 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    if ((($add800 + (Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$prevGain_Q10 + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond881 = 32767; else {
     $mul822 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0;
     $add831 = $mul822 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
     if ((($add831 + (Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$prevGain_Q10 + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond881 = -32768; else {
      $mul853 = Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0;
      $add862 = $mul853 + ((Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$prevGain_Q10 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
      $cond881 = ($add862 + (Math_imul(HEAP32[(HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$prevGain_Q10 + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
     }
    }
   }
  }
  HEAP16[(HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $cond881;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 dest = $213 + 1284 | 0;
 src = (HEAP32[$sLPC_Q14_ptr >> 2] | 0) + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] << 2) | 0;
 stop = dest + 64 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[(HEAP32[$psPLC >> 2] | 0) + 52 >> 2] = HEAP32[$rand_seed >> 2];
 HEAP16[(HEAP32[$psPLC >> 2] | 0) + 56 >> 1] = HEAP16[$rand_scale_Q14 >> 1] | 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 4) break;
  HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$lag >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _opus_decode_frame($st, $data, $len, $pcm, $frame_size, $decode_fec) {
 $st = $st | 0;
 $data = $data | 0;
 $len = $len | 0;
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $decode_fec = $decode_fec | 0;
 var $$sink = 0, $$sink11 = 0, $$sink2 = 0, $126 = 0, $128 = 0, $169 = 0, $178 = 0, $180 = 0, $200 = 0, $206 = 0, $207 = 0, $243 = 0, $262 = 0, $268 = 0, $274 = 0, $337 = 0, $394 = 0, $401 = 0, $54 = 0, $88 = 0, $F10 = 0, $F20 = 0, $F2_5 = 0, $F5 = 0, $add$ptr404 = 0, $add$ptr407 = 0, $add$ptr411 = 0, $add$ptr444 = 0, $add$ptr447 = 0, $add$ptr450 = 0, $add$ptr472 = 0, $add$ptr475 = 0, $add$ptr478 = 0, $add206 = 0, $audiosize = 0, $c = 0, $celt_accum = 0, $celt_dec = 0, $celt_frame_size = 0, $celt_mode = 0, $celt_ret = 0, $celt_to_silk = 0, $cleanup$dest$slot = 0, $cmp141 = 0, $cmp462 = 0, $cond = 0, $cond111 = 0, $cond130 = 0, $cond18 = 0, $cond236 = 0, $cond286 = 0, $data$addr = 0, $dec = 0, $decode_fec$addr = 0, $decoded_samples = 0, $endband = 0, $first_frame = 0, $frame_size$addr = 0, $gain = 0, $i = 0, $len$addr = 0, $lost_flag = 0, $mode = 0, $mul190 = 0, $mul238 = 0, $mul40 = 0, $mul429 = 0, $mul433 = 0, $mul77 = 0, $pcm$addr = 0, $pcm_ptr = 0, $pcm_silk_size = 0, $pcm_transition = 0, $pcm_transition_celt_size = 0, $pcm_transition_silk_size = 0, $redundancy = 0, $redundancy_bytes = 0, $redundant_audio_size = 0, $redundant_rng = 0, $ret = 0, $retval = 0, $saved_stack = 0, $silence = 0, $silk_dec = 0, $silk_frame_size = 0, $silk_ret = 0, $st$addr = 0, $start_band = 0, $storage = 0, $transition = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer16 = 0, $vararg_buffer19 = 0, $vararg_buffer22 = 0, $vararg_buffer25 = 0, $vararg_buffer27 = 0, $vararg_buffer30 = 0, $vararg_buffer33 = 0, $vararg_buffer35 = 0, $vararg_buffer38 = 0, $vla = 0, $vla112 = 0, $vla266 = 0, $vla287 = 0, $window = 0, $x = 0, $xor$sink = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 320 | 0;
 $vararg_buffer38 = sp + 80 | 0;
 $vararg_buffer35 = sp + 72 | 0;
 $vararg_buffer33 = sp + 64 | 0;
 $vararg_buffer30 = sp + 56 | 0;
 $vararg_buffer27 = sp + 48 | 0;
 $vararg_buffer25 = sp + 40 | 0;
 $vararg_buffer22 = sp + 32 | 0;
 $vararg_buffer19 = sp + 24 | 0;
 $vararg_buffer16 = sp + 16 | 0;
 $vararg_buffer13 = sp + 8 | 0;
 $vararg_buffer = sp;
 $retval = sp + 308 | 0;
 $st$addr = sp + 304 | 0;
 $data$addr = sp + 300 | 0;
 $len$addr = sp + 296 | 0;
 $pcm$addr = sp + 292 | 0;
 $frame_size$addr = sp + 288 | 0;
 $decode_fec$addr = sp + 284 | 0;
 $silk_dec = sp + 280 | 0;
 $celt_dec = sp + 276 | 0;
 $i = sp + 272 | 0;
 $silk_ret = sp + 268 | 0;
 $celt_ret = sp + 264 | 0;
 $dec = sp + 216 | 0;
 $silk_frame_size = sp + 212 | 0;
 $pcm_silk_size = sp + 208 | 0;
 $pcm_transition_silk_size = sp + 204 | 0;
 $pcm_transition_celt_size = sp + 200 | 0;
 $pcm_transition = sp + 196 | 0;
 $redundant_audio_size = sp + 192 | 0;
 $audiosize = sp + 188 | 0;
 $mode = sp + 184 | 0;
 $transition = sp + 180 | 0;
 $start_band = sp + 176 | 0;
 $redundancy = sp + 172 | 0;
 $redundancy_bytes = sp + 168 | 0;
 $celt_to_silk = sp + 164 | 0;
 $c = sp + 160 | 0;
 $F2_5 = sp + 156 | 0;
 $F5 = sp + 152 | 0;
 $F10 = sp + 148 | 0;
 $F20 = sp + 144 | 0;
 $window = sp + 140 | 0;
 $redundant_rng = sp + 136 | 0;
 $celt_accum = sp + 132 | 0;
 $ret = sp + 128 | 0;
 $saved_stack = sp + 124 | 0;
 $cleanup$dest$slot = sp + 120 | 0;
 $lost_flag = sp + 116 | 0;
 $decoded_samples = sp + 112 | 0;
 $pcm_ptr = sp + 108 | 0;
 $first_frame = sp + 104 | 0;
 $endband = sp + 100 | 0;
 $celt_frame_size = sp + 96 | 0;
 $silence = sp + 312 | 0;
 $celt_mode = sp + 92 | 0;
 $gain = sp + 88 | 0;
 $x = sp + 84 | 0;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$decode_fec$addr >> 2] = $decode_fec;
 HEAP32[$silk_ret >> 2] = 0;
 HEAP32[$celt_ret >> 2] = 0;
 HEAP32[$pcm_transition >> 2] = 0;
 HEAP32[$transition >> 2] = 0;
 HEAP32[$redundancy >> 2] = 0;
 HEAP32[$redundancy_bytes >> 2] = 0;
 HEAP32[$celt_to_silk >> 2] = 0;
 HEAP32[$redundant_rng >> 2] = 0;
 HEAP32[$silk_dec >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0);
 HEAP32[$celt_dec >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0);
 HEAP32[$F20 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0) / 50 | 0;
 HEAP32[$F10 >> 2] = HEAP32[$F20 >> 2] >> 1;
 HEAP32[$F5 >> 2] = HEAP32[$F10 >> 2] >> 1;
 HEAP32[$F2_5 >> 2] = HEAP32[$F5 >> 2] >> 1;
 if ((HEAP32[$frame_size$addr >> 2] | 0) < (HEAP32[$F2_5 >> 2] | 0)) {
  HEAP32[$retval >> 2] = -2;
  $401 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $401 | 0;
 }
 if ((HEAP32[$frame_size$addr >> 2] | 0) < (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0) / 25 | 0) * 3 | 0)) $cond = HEAP32[$frame_size$addr >> 2] | 0; else $cond = ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0) / 25 | 0) * 3 | 0;
 HEAP32[$frame_size$addr >> 2] = $cond;
 if ((HEAP32[$len$addr >> 2] | 0) <= 1) {
  HEAP32[$data$addr >> 2] = 0;
  if ((HEAP32[$frame_size$addr >> 2] | 0) < (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0)) $cond18 = HEAP32[$frame_size$addr >> 2] | 0; else $cond18 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] | 0;
  HEAP32[$frame_size$addr >> 2] = $cond18;
 }
 do if (HEAP32[$data$addr >> 2] | 0) {
  HEAP32[$audiosize >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2];
  HEAP32[$mode >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2];
  _ec_dec_init($dec, HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0);
 } else {
  HEAP32[$audiosize >> 2] = HEAP32[$frame_size$addr >> 2];
  HEAP32[$mode >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2];
  if (!(HEAP32[$mode >> 2] | 0)) {
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$audiosize >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0)) break;
    HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = 0.0;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP32[$retval >> 2] = HEAP32[$audiosize >> 2];
   $401 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $401 | 0;
  }
  if ((HEAP32[$audiosize >> 2] | 0) > (HEAP32[$F20 >> 2] | 0)) {
   while (1) {
    HEAP32[$ret >> 2] = _opus_decode_frame(HEAP32[$st$addr >> 2] | 0, 0, 0, HEAP32[$pcm$addr >> 2] | 0, (HEAP32[$audiosize >> 2] | 0) < (HEAP32[$F20 >> 2] | 0) ? HEAP32[$audiosize >> 2] | 0 : HEAP32[$F20 >> 2] | 0, 0) | 0;
    $54 = HEAP32[$ret >> 2] | 0;
    if ((HEAP32[$ret >> 2] | 0) < 0) {
     label = 20;
     break;
    }
    $mul40 = Math_imul($54, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
    HEAP32[$pcm$addr >> 2] = (HEAP32[$pcm$addr >> 2] | 0) + ($mul40 << 2);
    HEAP32[$audiosize >> 2] = (HEAP32[$audiosize >> 2] | 0) - (HEAP32[$ret >> 2] | 0);
    if ((HEAP32[$audiosize >> 2] | 0) <= 0) {
     label = 22;
     break;
    }
   }
   if ((label | 0) == 20) {
    HEAP32[$retval >> 2] = $54;
    $401 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $401 | 0;
   } else if ((label | 0) == 22) {
    HEAP32[$retval >> 2] = HEAP32[$frame_size$addr >> 2];
    $401 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $401 | 0;
   }
  }
  if ((HEAP32[$audiosize >> 2] | 0) < (HEAP32[$F20 >> 2] | 0)) {
   if ((HEAP32[$audiosize >> 2] | 0) > (HEAP32[$F10 >> 2] | 0)) {
    HEAP32[$audiosize >> 2] = HEAP32[$F10 >> 2];
    break;
   }
   if ((HEAP32[$mode >> 2] | 0) != 1e3) if ((HEAP32[$audiosize >> 2] | 0) > (HEAP32[$F5 >> 2] | 0)) if ((HEAP32[$audiosize >> 2] | 0) < (HEAP32[$F10 >> 2] | 0)) HEAP32[$audiosize >> 2] = HEAP32[$F5 >> 2];
  }
 } while (0);
 HEAP32[$celt_accum >> 2] = 0;
 HEAP32[$pcm_transition_silk_size >> 2] = 1;
 HEAP32[$pcm_transition_celt_size >> 2] = 1;
 do if (HEAP32[$data$addr >> 2] | 0) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0) > 0) {
  if ((HEAP32[$mode >> 2] | 0) == 1002) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0) != 1002) {
   if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2] | 0) label = 35;
  } else label = 35; else label = 35;
  if ((label | 0) == 35) {
   if ((HEAP32[$mode >> 2] | 0) == 1002) break;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0) != 1002) break;
  }
  HEAP32[$transition >> 2] = 1;
  $mul77 = Math_imul(HEAP32[$F5 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
  if ((HEAP32[$mode >> 2] | 0) == 1002) {
   HEAP32[$pcm_transition_celt_size >> 2] = $mul77;
   break;
  } else {
   HEAP32[$pcm_transition_silk_size >> 2] = $mul77;
   break;
  }
 } while (0);
 $88 = HEAP32[$pcm_transition_celt_size >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($88 << 2) | 0) + 15 & -16) | 0;
 if ((HEAP32[$transition >> 2] | 0) != 0 & (HEAP32[$mode >> 2] | 0) == 1002) {
  HEAP32[$pcm_transition >> 2] = $vla;
  _opus_decode_frame(HEAP32[$st$addr >> 2] | 0, 0, 0, HEAP32[$pcm_transition >> 2] | 0, (HEAP32[$F5 >> 2] | 0) < (HEAP32[$audiosize >> 2] | 0) ? HEAP32[$F5 >> 2] | 0 : HEAP32[$audiosize >> 2] | 0, 0) | 0;
 }
 L62 : do if ((HEAP32[$audiosize >> 2] | 0) > (HEAP32[$frame_size$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = -1;
  HEAP32[$cleanup$dest$slot >> 2] = 1;
 } else {
  HEAP32[$frame_size$addr >> 2] = HEAP32[$audiosize >> 2];
  if ((HEAP32[$mode >> 2] | 0) == 1002 | (HEAP32[$celt_accum >> 2] | 0) != 0) $cond111 = 1; else $cond111 = Math_imul((HEAP32[$F10 >> 2] | 0) > (HEAP32[$frame_size$addr >> 2] | 0) ? HEAP32[$F10 >> 2] | 0 : HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
  HEAP32[$pcm_silk_size >> 2] = $cond111;
  $vla112 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (HEAP32[$pcm_silk_size >> 2] << 1) | 0) + 15 & -16) | 0;
  L68 : do if ((HEAP32[$mode >> 2] | 0) != 1002) {
   HEAP32[$pcm_ptr >> 2] = $vla112;
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0) == 1002) _silk_InitDecoder(HEAP32[$silk_dec >> 2] | 0) | 0;
   if (10 > (((HEAP32[$audiosize >> 2] | 0) * 1e3 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0) | 0 | 0)) $cond130 = 10; else $cond130 = ((HEAP32[$audiosize >> 2] | 0) * 1e3 | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0) | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 + 16 >> 2] = $cond130;
   if (HEAP32[$data$addr >> 2] | 0) {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 + 4 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2];
    $126 = HEAP32[$st$addr >> 2] | 0;
    if ((HEAP32[$mode >> 2] | 0) == 1e3) {
     $128 = HEAP32[$st$addr >> 2] | 0;
     if ((HEAP32[$126 + 52 >> 2] | 0) == 1101) {
      $$sink = 8e3;
      $$sink2 = $128;
     } else {
      $cmp141 = (HEAP32[$128 + 52 >> 2] | 0) == 1102;
      $$sink = $cmp141 ? 12e3 : 16e3;
      $$sink2 = $cmp141 ? HEAP32[$st$addr >> 2] | 0 : HEAP32[$st$addr >> 2] | 0;
     }
    } else {
     $$sink = 16e3;
     $$sink2 = $126;
    }
    HEAP32[$$sink2 + 16 + 12 >> 2] = $$sink;
   }
   HEAP32[$lost_flag >> 2] = (HEAP32[$data$addr >> 2] | 0) == 0 ? 1 : HEAP32[$decode_fec$addr >> 2] << 1;
   HEAP32[$decoded_samples >> 2] = 0;
   L83 : while (1) {
    HEAP32[$first_frame >> 2] = (HEAP32[$decoded_samples >> 2] | 0) == 0 & 1;
    HEAP32[$silk_ret >> 2] = _silk_Decode(HEAP32[$silk_dec >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 16 | 0, HEAP32[$lost_flag >> 2] | 0, HEAP32[$first_frame >> 2] | 0, $dec, HEAP32[$pcm_ptr >> 2] | 0, $silk_frame_size, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] | 0) | 0;
    L85 : do if (HEAP32[$silk_ret >> 2] | 0) {
     if (!(HEAP32[$lost_flag >> 2] | 0)) break L83;
     HEAP32[$silk_frame_size >> 2] = HEAP32[$frame_size$addr >> 2];
     HEAP32[$i >> 2] = 0;
     while (1) {
      if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0)) break L85;
      HEAP16[(HEAP32[$pcm_ptr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = 0;
      HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
     }
    } while (0);
    $mul190 = Math_imul(HEAP32[$silk_frame_size >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
    HEAP32[$pcm_ptr >> 2] = (HEAP32[$pcm_ptr >> 2] | 0) + ($mul190 << 1);
    HEAP32[$decoded_samples >> 2] = (HEAP32[$decoded_samples >> 2] | 0) + (HEAP32[$silk_frame_size >> 2] | 0);
    if ((HEAP32[$decoded_samples >> 2] | 0) >= (HEAP32[$frame_size$addr >> 2] | 0)) break L68;
   }
   HEAP32[$retval >> 2] = -3;
   HEAP32[$cleanup$dest$slot >> 2] = 1;
   break L62;
  } while (0);
  HEAP32[$start_band >> 2] = 0;
  if ((HEAP32[$decode_fec$addr >> 2] | 0) == 0 & (HEAP32[$mode >> 2] | 0) != 1002 & (HEAP32[$data$addr >> 2] | 0) != 0) {
   $add206 = (_ec_tell($dec) | 0) + 17 | 0;
   if (($add206 + (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] | 0) == 1001 & 1) * 20 | 0) | 0) <= (HEAP32[$len$addr >> 2] << 3 | 0)) {
    if ((HEAP32[$mode >> 2] | 0) == 1001) HEAP32[$redundancy >> 2] = _ec_dec_bit_logp($dec, 12) | 0; else HEAP32[$redundancy >> 2] = 1;
    if (HEAP32[$redundancy >> 2] | 0) {
     HEAP32[$celt_to_silk >> 2] = _ec_dec_bit_logp($dec, 1) | 0;
     if ((HEAP32[$mode >> 2] | 0) == 1001) $cond236 = (_ec_dec_uint($dec, 256) | 0) + 2 | 0; else {
      $169 = HEAP32[$len$addr >> 2] | 0;
      $cond236 = $169 - ((_ec_tell($dec) | 0) + 7 >> 3) | 0;
     }
     HEAP32[$redundancy_bytes >> 2] = $cond236;
     HEAP32[$len$addr >> 2] = (HEAP32[$len$addr >> 2] | 0) - (HEAP32[$redundancy_bytes >> 2] | 0);
     $mul238 = HEAP32[$len$addr >> 2] << 3;
     if (($mul238 | 0) < (_ec_tell($dec) | 0)) {
      HEAP32[$len$addr >> 2] = 0;
      HEAP32[$redundancy_bytes >> 2] = 0;
      HEAP32[$redundancy >> 2] = 0;
     }
     $storage = $dec + 4 | 0;
     HEAP32[$storage >> 2] = (HEAP32[$storage >> 2] | 0) - (HEAP32[$redundancy_bytes >> 2] | 0);
    }
   }
  }
  if ((HEAP32[$mode >> 2] | 0) != 1002) HEAP32[$start_band >> 2] = 17;
  HEAP32[$endband >> 2] = 21;
  switch (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] | 0) {
  case 1101:
   {
    HEAP32[$endband >> 2] = 13;
    break;
   }
  case 1103:
  case 1102:
   {
    HEAP32[$endband >> 2] = 17;
    break;
   }
  case 1104:
   {
    HEAP32[$endband >> 2] = 19;
    break;
   }
  case 1105:
   {
    HEAP32[$endband >> 2] = 21;
    break;
   }
  default:
   {}
  }
  $178 = HEAP32[$celt_dec >> 2] | 0;
  HEAP32[$vararg_buffer >> 2] = HEAP32[$endband >> 2];
  _opus_custom_decoder_ctl($178, 10012, $vararg_buffer) | 0;
  $180 = HEAP32[$celt_dec >> 2] | 0;
  HEAP32[$vararg_buffer13 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2];
  _opus_custom_decoder_ctl($180, 10008, $vararg_buffer13) | 0;
  if (HEAP32[$redundancy >> 2] | 0) {
   HEAP32[$transition >> 2] = 0;
   HEAP32[$pcm_transition_silk_size >> 2] = 1;
  }
  $vla266 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (HEAP32[$pcm_transition_silk_size >> 2] << 2) | 0) + 15 & -16) | 0;
  if ((HEAP32[$transition >> 2] | 0) != 0 & (HEAP32[$mode >> 2] | 0) != 1002) {
   HEAP32[$pcm_transition >> 2] = $vla266;
   _opus_decode_frame(HEAP32[$st$addr >> 2] | 0, 0, 0, HEAP32[$pcm_transition >> 2] | 0, (HEAP32[$F5 >> 2] | 0) < (HEAP32[$audiosize >> 2] | 0) ? HEAP32[$F5 >> 2] | 0 : HEAP32[$audiosize >> 2] | 0, 0) | 0;
  }
  if (HEAP32[$redundancy >> 2] | 0) $cond286 = Math_imul(HEAP32[$F5 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0; else $cond286 = 1;
  HEAP32[$redundant_audio_size >> 2] = $cond286;
  $vla287 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (HEAP32[$redundant_audio_size >> 2] << 2) | 0) + 15 & -16) | 0;
  if ((HEAP32[$redundancy >> 2] | 0) != 0 & (HEAP32[$celt_to_silk >> 2] | 0) != 0) {
   $200 = HEAP32[$celt_dec >> 2] | 0;
   HEAP32[$vararg_buffer16 >> 2] = 0;
   _opus_custom_decoder_ctl($200, 10010, $vararg_buffer16) | 0;
   _celt_decode_with_ec(HEAP32[$celt_dec >> 2] | 0, (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$len$addr >> 2] | 0) | 0, HEAP32[$redundancy_bytes >> 2] | 0, $vla287, HEAP32[$F5 >> 2] | 0, 0, 0) | 0;
   $206 = HEAP32[$celt_dec >> 2] | 0;
   HEAP32[$vararg_buffer19 >> 2] = $redundant_rng + ((($redundant_rng - $redundant_rng | 0) / 4 | 0) << 2);
   _opus_custom_decoder_ctl($206, 4031, $vararg_buffer19) | 0;
  }
  $207 = HEAP32[$celt_dec >> 2] | 0;
  HEAP32[$vararg_buffer22 >> 2] = HEAP32[$start_band >> 2];
  _opus_custom_decoder_ctl($207, 10010, $vararg_buffer22) | 0;
  do if ((HEAP32[$mode >> 2] | 0) != 1e3) {
   HEAP32[$celt_frame_size >> 2] = (HEAP32[$F20 >> 2] | 0) < (HEAP32[$frame_size$addr >> 2] | 0) ? HEAP32[$F20 >> 2] | 0 : HEAP32[$frame_size$addr >> 2] | 0;
   do if ((HEAP32[$mode >> 2] | 0) != (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0)) {
    if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0) <= 0) break;
    if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2] | 0) break;
    _opus_custom_decoder_ctl(HEAP32[$celt_dec >> 2] | 0, 4028, $vararg_buffer25) | 0;
   } while (0);
   HEAP32[$celt_ret >> 2] = _celt_decode_with_ec(HEAP32[$celt_dec >> 2] | 0, HEAP32[$decode_fec$addr >> 2] | 0 ? 0 : HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$celt_frame_size >> 2] | 0, $dec, HEAP32[$celt_accum >> 2] | 0) | 0;
  } else {
   HEAP8[$silence >> 0] = HEAP8[25354] | 0;
   HEAP8[$silence + 1 >> 0] = HEAP8[25355] | 0;
   L139 : do if (!(HEAP32[$celt_accum >> 2] | 0)) {
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0)) break L139;
     HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = 0.0;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   } while (0);
   if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0) == 1001) {
    if ((HEAP32[$redundancy >> 2] | 0) != 0 & (HEAP32[$celt_to_silk >> 2] | 0) != 0) if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2] | 0) break;
    $243 = HEAP32[$celt_dec >> 2] | 0;
    HEAP32[$vararg_buffer27 >> 2] = 0;
    _opus_custom_decoder_ctl($243, 10010, $vararg_buffer27) | 0;
    _celt_decode_with_ec(HEAP32[$celt_dec >> 2] | 0, $silence, 2, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$F2_5 >> 2] | 0, 0, HEAP32[$celt_accum >> 2] | 0) | 0;
   }
  } while (0);
  L150 : do if (!((HEAP32[$mode >> 2] | 0) == 1002 | (HEAP32[$celt_accum >> 2] | 0) != 0)) {
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0)) break L150;
    HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] + +(HEAP16[$vla112 + (HEAP32[$i >> 2] << 1) >> 1] | 0) * .000030517578125;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  } while (0);
  $262 = HEAP32[$celt_dec >> 2] | 0;
  HEAP32[$vararg_buffer30 >> 2] = $celt_mode + ((($celt_mode - $celt_mode | 0) / 4 | 0) << 2);
  _opus_custom_decoder_ctl($262, 10015, $vararg_buffer30) | 0;
  HEAP32[$window >> 2] = HEAP32[(HEAP32[$celt_mode >> 2] | 0) + 60 >> 2];
  if (!((HEAP32[$redundancy >> 2] | 0) == 0 | (HEAP32[$celt_to_silk >> 2] | 0) != 0)) {
   _opus_custom_decoder_ctl(HEAP32[$celt_dec >> 2] | 0, 4028, $vararg_buffer33) | 0;
   $268 = HEAP32[$celt_dec >> 2] | 0;
   HEAP32[$vararg_buffer35 >> 2] = 0;
   _opus_custom_decoder_ctl($268, 10010, $vararg_buffer35) | 0;
   _celt_decode_with_ec(HEAP32[$celt_dec >> 2] | 0, (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$len$addr >> 2] | 0) | 0, HEAP32[$redundancy_bytes >> 2] | 0, $vla287, HEAP32[$F5 >> 2] | 0, 0, 0) | 0;
   $274 = HEAP32[$celt_dec >> 2] | 0;
   HEAP32[$vararg_buffer38 >> 2] = $redundant_rng + ((($redundant_rng - $redundant_rng | 0) / 4 | 0) << 2);
   _opus_custom_decoder_ctl($274, 4031, $vararg_buffer38) | 0;
   $add$ptr404 = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$F2_5 >> 2] | 0) | 0) | 0) << 2) | 0;
   $add$ptr407 = $vla287 + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$F2_5 >> 2] | 0) | 0) << 2) | 0;
   $add$ptr411 = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$F2_5 >> 2] | 0) | 0) | 0) << 2) | 0;
   _smooth_fade($add$ptr404, $add$ptr407, $add$ptr411, HEAP32[$F2_5 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$window >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0);
  }
  if ((HEAP32[$redundancy >> 2] | 0) != 0 & (HEAP32[$celt_to_silk >> 2] | 0) != 0) {
   HEAP32[$c >> 2] = 0;
   while (1) {
    if ((HEAP32[$c >> 2] | 0) >= (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0)) break;
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$F2_5 >> 2] | 0)) break;
     $mul429 = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$i >> 2] | 0) | 0;
     $mul433 = Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$i >> 2] | 0) | 0;
     HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + ($mul433 + (HEAP32[$c >> 2] | 0) << 2) >> 2] = +HEAPF32[$vla287 + ($mul429 + (HEAP32[$c >> 2] | 0) << 2) >> 2];
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
    HEAP32[$c >> 2] = (HEAP32[$c >> 2] | 0) + 1;
   }
   $add$ptr444 = $vla287 + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$F2_5 >> 2] | 0) | 0) << 2) | 0;
   $add$ptr447 = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$F2_5 >> 2] | 0) | 0) << 2) | 0;
   $add$ptr450 = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$F2_5 >> 2] | 0) | 0) << 2) | 0;
   _smooth_fade($add$ptr444, $add$ptr447, $add$ptr450, HEAP32[$F2_5 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$window >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0);
  }
  do if (HEAP32[$transition >> 2] | 0) {
   if ((HEAP32[$audiosize >> 2] | 0) < (HEAP32[$F5 >> 2] | 0)) {
    _smooth_fade(HEAP32[$pcm_transition >> 2] | 0, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$F2_5 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$window >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0);
    break;
   }
   HEAP32[$i >> 2] = 0;
   while (1) {
    $cmp462 = (HEAP32[$i >> 2] | 0) < (Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$F2_5 >> 2] | 0) | 0);
    $337 = HEAP32[$pcm_transition >> 2] | 0;
    if (!$cmp462) break;
    HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$337 + (HEAP32[$i >> 2] << 2) >> 2];
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   $add$ptr472 = $337 + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$F2_5 >> 2] | 0) | 0) << 2) | 0;
   $add$ptr475 = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$F2_5 >> 2] | 0) | 0) << 2) | 0;
   $add$ptr478 = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$F2_5 >> 2] | 0) | 0) << 2) | 0;
   _smooth_fade($add$ptr472, $add$ptr475, $add$ptr478, HEAP32[$F2_5 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$window >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0);
  } while (0);
  L180 : do if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0) {
   HEAPF32[$gain >> 2] = +Math_exp(+(+(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] | 0) * 6.488140788860619e-04 * .6931471805599453));
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0)) break L180;
    HEAPF32[$x >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[$gain >> 2];
    HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$x >> 2];
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  } while (0);
  if ((HEAP32[$len$addr >> 2] | 0) <= 1) {
   $$sink11 = HEAP32[$st$addr >> 2] | 0;
   $xor$sink = 0;
  } else {
   $$sink11 = HEAP32[$st$addr >> 2] | 0;
   $xor$sink = HEAP32[$dec + 28 >> 2] ^ HEAP32[$redundant_rng >> 2];
  }
  HEAP32[$$sink11 + 84 >> 2] = $xor$sink;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] = HEAP32[$mode >> 2];
  if (HEAP32[$redundancy >> 2] | 0) $394 = (HEAP32[$celt_to_silk >> 2] | 0) != 0 ^ 1; else $394 = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2] = $394 & 1;
  if ((HEAP32[$celt_ret >> 2] | 0) >= 0) __opus_false() | 0;
  HEAP32[$retval >> 2] = (HEAP32[$celt_ret >> 2] | 0) < 0 ? HEAP32[$celt_ret >> 2] | 0 : HEAP32[$audiosize >> 2] | 0;
  HEAP32[$cleanup$dest$slot >> 2] = 1;
 } while (0);
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 $401 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $401 | 0;
}

function _dynalloc_analysis($bandLogE, $bandLogE2, $nbEBands, $start, $end, $C, $offsets, $lsb_depth, $logN, $isTransient, $vbr, $constrained_vbr, $eBands, $LM, $effectiveBytes, $tot_boost_, $lfe, $surround_dynalloc, $analysis, $importance, $spread_weight) {
 $bandLogE = $bandLogE | 0;
 $bandLogE2 = $bandLogE2 | 0;
 $nbEBands = $nbEBands | 0;
 $start = $start | 0;
 $end = $end | 0;
 $C = $C | 0;
 $offsets = $offsets | 0;
 $lsb_depth = $lsb_depth | 0;
 $logN = $logN | 0;
 $isTransient = $isTransient | 0;
 $vbr = $vbr | 0;
 $constrained_vbr = $constrained_vbr | 0;
 $eBands = $eBands | 0;
 $LM = $LM | 0;
 $effectiveBytes = $effectiveBytes | 0;
 $tot_boost_ = $tot_boost_ | 0;
 $lfe = $lfe | 0;
 $surround_dynalloc = $surround_dynalloc | 0;
 $analysis = $analysis | 0;
 $importance = $importance | 0;
 $spread_weight = $spread_weight | 0;
 var $126 = 0.0, $181 = 0, $182 = 0, $205 = 0.0, $40 = 0, $429 = 0.0, $458 = 0, $459 = 0, $460 = 0.0, $461 = 0, $80 = 0, $91 = 0, $C$addr = 0, $LM$addr = 0, $add14 = 0.0, $analysis$addr = 0, $arrayidx388$sink = 0, $arrayidx504$sink = 0, $arrayidx559 = 0, $bandLogE$addr = 0, $bandLogE2$addr = 0, $boost = 0, $boost_bits = 0, $c = 0, $call306 = 0.0, $call317 = 0.0, $call327 = 0.0, $call351 = 0.0, $cap = 0, $cmp400 = 0, $cond = 0.0, $cond121 = 0.0, $cond153 = 0.0, $cond172 = 0.0, $cond188 = 0, $cond238 = 0.0, $cond266 = 0.0, $cond291 = 0.0, $cond320 = 0.0, $cond336 = 0.0, $cond345 = 0.0, $cond362 = 0.0, $cond374 = 0.0, $cond420 = 0.0, $cond436 = 0.0, $cond449 = 0.0, $cond465 = 0.0, $cond487 = 0.0, $cond522 = 0.0, $cond606 = 0.0, $cond73 = 0.0, $cond98 = 0.0, $constrained_vbr$addr = 0, $conv531 = 0, $eBands$addr = 0, $effectiveBytes$addr = 0, $end$addr = 0, $f = 0, $i = 0, $importance$addr = 0, $inc35 = 0, $inc396 = 0, $isTransient$addr = 0, $last = 0, $lfe$addr = 0, $logN$addr = 0, $lsb_depth$addr = 0, $maxDepth = 0, $mul = 0, $mul20 = 0, $mul209 = 0, $mul212 = 0, $mul224 = 0, $mul234 = 0, $mul252 = 0, $mul262 = 0, $mul27 = 0, $mul275 = 0, $mul285 = 0, $mul302 = 0, $mul313 = 0, $mul347 = 0, $mul614 = 0, $nbEBands$addr = 0, $offset = 0, $offsets$addr = 0, $saved_stack = 0, $saved_stack38 = 0, $smr = 0, $spread_weight$addr = 0, $start$addr = 0, $surround_dynalloc$addr = 0, $tmp = 0, $tot_boost = 0, $tot_boost_$addr = 0, $vbr$addr = 0, $vla = 0, $vla2 = 0, $vla2$alloca_mul = 0, $vla39 = 0, $vla40 = 0, $width = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $bandLogE$addr = sp + 140 | 0;
 $bandLogE2$addr = sp + 136 | 0;
 $nbEBands$addr = sp + 132 | 0;
 $start$addr = sp + 128 | 0;
 $end$addr = sp + 124 | 0;
 $C$addr = sp + 120 | 0;
 $offsets$addr = sp + 116 | 0;
 $lsb_depth$addr = sp + 112 | 0;
 $logN$addr = sp + 108 | 0;
 $isTransient$addr = sp + 104 | 0;
 $vbr$addr = sp + 100 | 0;
 $constrained_vbr$addr = sp + 96 | 0;
 $eBands$addr = sp + 92 | 0;
 $LM$addr = sp + 88 | 0;
 $effectiveBytes$addr = sp + 84 | 0;
 $tot_boost_$addr = sp + 80 | 0;
 $lfe$addr = sp + 76 | 0;
 $surround_dynalloc$addr = sp + 72 | 0;
 $analysis$addr = sp + 68 | 0;
 $importance$addr = sp + 64 | 0;
 $spread_weight$addr = sp + 60 | 0;
 $i = sp + 56 | 0;
 $c = sp + 52 | 0;
 $tot_boost = sp + 48 | 0;
 $maxDepth = sp + 44 | 0;
 $saved_stack = sp + 40 | 0;
 $saved_stack38 = sp + 36 | 0;
 $smr = sp + 32 | 0;
 $last = sp + 28 | 0;
 $offset = sp + 24 | 0;
 $tmp = sp + 20 | 0;
 $f = sp + 16 | 0;
 $width = sp + 12 | 0;
 $boost = sp + 8 | 0;
 $boost_bits = sp + 4 | 0;
 $cap = sp;
 HEAP32[$bandLogE$addr >> 2] = $bandLogE;
 HEAP32[$bandLogE2$addr >> 2] = $bandLogE2;
 HEAP32[$nbEBands$addr >> 2] = $nbEBands;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$offsets$addr >> 2] = $offsets;
 HEAP32[$lsb_depth$addr >> 2] = $lsb_depth;
 HEAP32[$logN$addr >> 2] = $logN;
 HEAP32[$isTransient$addr >> 2] = $isTransient;
 HEAP32[$vbr$addr >> 2] = $vbr;
 HEAP32[$constrained_vbr$addr >> 2] = $constrained_vbr;
 HEAP32[$eBands$addr >> 2] = $eBands;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$effectiveBytes$addr >> 2] = $effectiveBytes;
 HEAP32[$tot_boost_$addr >> 2] = $tot_boost_;
 HEAP32[$lfe$addr >> 2] = $lfe;
 HEAP32[$surround_dynalloc$addr >> 2] = $surround_dynalloc;
 HEAP32[$analysis$addr >> 2] = $analysis;
 HEAP32[$importance$addr >> 2] = $importance;
 HEAP32[$spread_weight$addr >> 2] = $spread_weight;
 HEAP32[$tot_boost >> 2] = 0;
 $mul = Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($mul << 2) | 0) + 15 & -16) | 0;
 $vla2$alloca_mul = (Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0) << 2;
 $vla2 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla2$alloca_mul | 0) + 15 & -16) | 0;
 _memset(HEAP32[$offsets$addr >> 2] | 0, 0, HEAP32[$nbEBands$addr >> 2] << 2 | 0) | 0;
 HEAPF32[$maxDepth >> 2] = -31.899999618530273;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  $add14 = +(HEAP16[(HEAP32[$logN$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) * .0625 + .5 + +(9 - (HEAP32[$lsb_depth$addr >> 2] | 0) | 0) - +HEAPF32[14900 + (HEAP32[$i >> 2] << 2) >> 2] + +(Math_imul((HEAP32[$i >> 2] | 0) + 5 | 0, (HEAP32[$i >> 2] | 0) + 5 | 0) | 0) * .006200000178068876;
  HEAPF32[$vla2 + (HEAP32[$i >> 2] << 2) >> 2] = $add14;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   $mul20 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
   if (+HEAPF32[$maxDepth >> 2] > +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + ($mul20 + (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[$vla2 + (HEAP32[$i >> 2] << 2) >> 2]) $cond = +HEAPF32[$maxDepth >> 2]; else {
    $mul27 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
    $cond = +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + ($mul27 + (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[$vla2 + (HEAP32[$i >> 2] << 2) >> 2];
   }
   HEAPF32[$maxDepth >> 2] = $cond;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc35 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc35;
 } while (($inc35 | 0) < (HEAP32[$C$addr >> 2] | 0));
 $40 = HEAP32[$nbEBands$addr >> 2] | 0;
 HEAP32[$saved_stack38 >> 2] = _llvm_stacksave() | 0;
 $vla39 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($40 << 2) | 0) + 15 & -16) | 0;
 $vla40 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nbEBands$addr >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[$vla2 + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L20 : do if ((HEAP32[$C$addr >> 2] | 0) == 2) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break L20;
   if (+HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[$vla2 + (HEAP32[$i >> 2] << 2) >> 2]) $cond73 = +HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2]; else $cond73 = +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[$vla2 + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2] = $cond73;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 _memcpy($vla40 | 0, $vla39 | 0, (HEAP32[$end$addr >> 2] << 2) + 0 | 0) | 0;
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  $80 = HEAP32[$i >> 2] | 0;
  if (+HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[$vla39 + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] - 2.0) $cond98 = +HEAPF32[$vla39 + ($80 << 2) >> 2]; else $cond98 = +HEAPF32[$vla39 + ($80 - 1 << 2) >> 2] - 2.0;
  HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2] = $cond98;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = (HEAP32[$end$addr >> 2] | 0) - 2;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < 0) break;
  $91 = HEAP32[$i >> 2] | 0;
  if (+HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[$vla39 + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] - 3.0) $cond121 = +HEAPF32[$vla39 + ($91 << 2) >> 2]; else $cond121 = +HEAPF32[$vla39 + ($91 + 1 << 2) >> 2] - 3.0;
  HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2] = $cond121;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  if ((0.0 > +HEAPF32[$maxDepth >> 2] - 12.0 ? 0.0 : +HEAPF32[$maxDepth >> 2] - 12.0) > +HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2]) $cond153 = 0.0 > +HEAPF32[$maxDepth >> 2] - 12.0 ? 0.0 : +HEAPF32[$maxDepth >> 2] - 12.0; else $cond153 = +HEAPF32[$vla39 + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$smr >> 2] = +HEAPF32[$vla40 + (HEAP32[$i >> 2] << 2) >> 2] - $cond153;
  if (-5.0 > (0.0 < +HEAPF32[$smr >> 2] ? 0.0 : +HEAPF32[$smr >> 2])) $cond172 = -5.0; else $cond172 = 0.0 < +HEAPF32[$smr >> 2] ? 0.0 : +HEAPF32[$smr >> 2];
  HEAPF32[$smr >> 2] = $cond172;
  if (1 > (32 >> 0 - ~~+Math_floor(+(+HEAPF32[$smr >> 2] + .5)) | 0)) $cond188 = 1; else $cond188 = 32 >> 0 - ~~+Math_floor(+(+HEAPF32[$smr >> 2] + .5));
  HEAP32[(HEAP32[$spread_weight$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $cond188;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _llvm_stackrestore(HEAP32[$saved_stack38 >> 2] | 0);
 if ((HEAP32[$effectiveBytes$addr >> 2] | 0) > 50 & (HEAP32[$LM$addr >> 2] | 0) >= 1 ^ 1 | (HEAP32[$lfe$addr >> 2] | 0) != 0) {
  HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   HEAP32[(HEAP32[$importance$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = 13;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $458 = HEAP32[$tot_boost >> 2] | 0;
  $459 = HEAP32[$tot_boost_$addr >> 2] | 0;
  HEAP32[$459 >> 2] = $458;
  $460 = +HEAPF32[$maxDepth >> 2];
  $461 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($461 | 0);
  STACKTOP = sp;
  return +$460;
 }
 HEAP32[$last >> 2] = 0;
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$f >> 2] = $vla + ((Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0) << 2);
  $126 = +HEAPF32[(HEAP32[$bandLogE2$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[HEAP32[$f >> 2] >> 2] = $126;
  HEAP32[$i >> 2] = 1;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   $mul209 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
   $mul212 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
   if (+HEAPF32[(HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul209 + (HEAP32[$i >> 2] | 0) << 2) >> 2] > +HEAPF32[(HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul212 + (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] + .5) HEAP32[$last >> 2] = HEAP32[$i >> 2];
   $mul224 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
   if (+HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] + 1.5 < +HEAPF32[(HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul224 + (HEAP32[$i >> 2] | 0) << 2) >> 2]) $cond238 = +HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] + 1.5; else {
    $mul234 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
    $cond238 = +HEAPF32[(HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul234 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
   }
   HEAPF32[(HEAP32[$f >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $cond238;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$last >> 2] | 0) - 1;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) < 0) break;
   $mul252 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
   if (+HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] + 2.0 < +HEAPF32[(HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul252 + (HEAP32[$i >> 2] | 0) << 2) >> 2]) $cond266 = +HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] + 2.0; else {
    $mul262 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
    $cond266 = +HEAPF32[(HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul262 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
   }
   $181 = HEAP32[$f >> 2] | 0;
   $182 = HEAP32[$i >> 2] | 0;
   do if (+HEAPF32[(HEAP32[$f >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] < $cond266) $cond291 = +HEAPF32[$181 + ($182 << 2) >> 2]; else {
    $mul275 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
    if (+HEAPF32[$181 + ($182 + 1 << 2) >> 2] + 2.0 < +HEAPF32[(HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul275 + (HEAP32[$i >> 2] | 0) << 2) >> 2]) {
     $cond291 = +HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] + 2.0;
     break;
    } else {
     $mul285 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
     $cond291 = +HEAPF32[(HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul285 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
     break;
    }
   } while (0);
   HEAPF32[(HEAP32[$f >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $cond291;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
  }
  HEAPF32[$offset >> 2] = 1.0;
  HEAP32[$i >> 2] = 2;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$end$addr >> 2] | 0) - 2 | 0)) break;
   $205 = +HEAPF32[(HEAP32[$f >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   $mul302 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
   $call306 = +_median_of_5((HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul302 + (HEAP32[$i >> 2] | 0) - 2 << 2) | 0);
   if ($205 > $call306 - +HEAPF32[$offset >> 2]) $cond320 = +HEAPF32[(HEAP32[$f >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]; else {
    $mul313 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
    $call317 = +_median_of_5((HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul313 + (HEAP32[$i >> 2] | 0) - 2 << 2) | 0);
    $cond320 = $call317 - +HEAPF32[$offset >> 2];
   }
   HEAPF32[(HEAP32[$f >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $cond320;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $call327 = +_median_of_3((HEAP32[$bandLogE2$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0) << 2) | 0);
  HEAPF32[$tmp >> 2] = $call327 - +HEAPF32[$offset >> 2];
  if (+HEAPF32[HEAP32[$f >> 2] >> 2] > +HEAPF32[$tmp >> 2]) $cond336 = +HEAPF32[HEAP32[$f >> 2] >> 2]; else $cond336 = +HEAPF32[$tmp >> 2];
  HEAPF32[HEAP32[$f >> 2] >> 2] = $cond336;
  if (+HEAPF32[(HEAP32[$f >> 2] | 0) + 4 >> 2] > +HEAPF32[$tmp >> 2]) $cond345 = +HEAPF32[(HEAP32[$f >> 2] | 0) + 4 >> 2]; else $cond345 = +HEAPF32[$tmp >> 2];
  HEAPF32[(HEAP32[$f >> 2] | 0) + 4 >> 2] = $cond345;
  $mul347 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0;
  $call351 = +_median_of_3((HEAP32[$bandLogE2$addr >> 2] | 0) + ($mul347 + (HEAP32[$end$addr >> 2] | 0) - 3 << 2) | 0);
  HEAPF32[$tmp >> 2] = $call351 - +HEAPF32[$offset >> 2];
  if (+HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$end$addr >> 2] | 0) - 2 << 2) >> 2] > +HEAPF32[$tmp >> 2]) $cond362 = +HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$end$addr >> 2] | 0) - 2 << 2) >> 2]; else $cond362 = +HEAPF32[$tmp >> 2];
  HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$end$addr >> 2] | 0) - 2 << 2) >> 2] = $cond362;
  if (+HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$end$addr >> 2] | 0) - 1 << 2) >> 2] > +HEAPF32[$tmp >> 2]) $cond374 = +HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$end$addr >> 2] | 0) - 1 << 2) >> 2]; else $cond374 = +HEAPF32[$tmp >> 2];
  HEAPF32[(HEAP32[$f >> 2] | 0) + ((HEAP32[$end$addr >> 2] | 0) - 1 << 2) >> 2] = $cond374;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   if (+HEAPF32[(HEAP32[$f >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[$vla2 + (HEAP32[$i >> 2] << 2) >> 2]) $arrayidx388$sink = (HEAP32[$f >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0; else $arrayidx388$sink = $vla2 + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[(HEAP32[$f >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$arrayidx388$sink >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc396 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc396;
 } while (($inc396 | 0) < (HEAP32[$C$addr >> 2] | 0));
 $cmp400 = (HEAP32[$C$addr >> 2] | 0) == 2;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 L128 : do if ($cmp400) while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break L128;
  if (+HEAPF32[$vla + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] > +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] - 4.0) $cond420 = +HEAPF32[$vla + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2]; else $cond420 = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] - 4.0;
  HEAPF32[$vla + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] = $cond420;
  if (+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[$vla + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] - 4.0) $cond436 = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2]; else $cond436 = +HEAPF32[$vla + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] - 4.0;
  HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = $cond436;
  if (0.0 > +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2]) $cond449 = 0.0; else $cond449 = +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2];
  if (0.0 > +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[$vla + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2]) $cond465 = 0.0; else $cond465 = +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[$vla + ((HEAP32[$nbEBands$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
  HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = ($cond449 + $cond465) * .5;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 } else while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break L128;
  if (0.0 > +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2]) $cond487 = 0.0; else $cond487 = +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = $cond487;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 } while (0);
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  if (+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[(HEAP32[$surround_dynalloc$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $arrayidx504$sink = $vla + (HEAP32[$i >> 2] << 2) | 0; else $arrayidx504$sink = (HEAP32[$surround_dynalloc$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
  HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$arrayidx504$sink >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  if (+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] < 4.0) $cond522 = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2]; else $cond522 = 4.0;
  $conv531 = ~~+Math_floor(+(+Math_exp(+(.6931471805599453 * $cond522)) * 13.0 + .5));
  HEAP32[(HEAP32[$importance$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $conv531;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L168 : do if (!(((HEAP32[$vbr$addr >> 2] | 0) == 0 | (HEAP32[$constrained_vbr$addr >> 2] | 0) != 0) ^ 1 | (HEAP32[$isTransient$addr >> 2] | 0) != 0)) {
  HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break L168;
   HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] * .5;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  if ((HEAP32[$i >> 2] | 0) < 8) {
   $arrayidx559 = $vla + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[$arrayidx559 >> 2] = +HEAPF32[$arrayidx559 >> 2] * 2.0;
  }
  if ((HEAP32[$i >> 2] | 0) >= 12) HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] * .5;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L184 : do if (HEAP32[HEAP32[$analysis$addr >> 2] >> 2] | 0) {
  HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= ((19 < (HEAP32[$end$addr >> 2] | 0) ? 19 : HEAP32[$end$addr >> 2] | 0) | 0)) break L184;
   HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] + +(HEAPU8[(HEAP32[$analysis$addr >> 2] | 0) + 44 + (HEAP32[$i >> 2] | 0) >> 0] | 0) * .015625;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) {
   label = 150;
   break;
  }
  if (+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] < 4.0) $cond606 = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2]; else $cond606 = 4.0;
  HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = $cond606;
  $mul614 = Math_imul(HEAP32[$C$addr >> 2] | 0, (HEAP16[(HEAP32[$eBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) | 0;
  HEAP32[$width >> 2] = $mul614 << HEAP32[$LM$addr >> 2];
  do if ((HEAP32[$width >> 2] | 0) < 6) {
   HEAP32[$boost >> 2] = ~~+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$boost_bits >> 2] = (Math_imul(HEAP32[$boost >> 2] | 0, HEAP32[$width >> 2] | 0) | 0) << 3;
  } else {
   $429 = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2];
   if ((HEAP32[$width >> 2] | 0) > 48) {
    HEAP32[$boost >> 2] = ~~($429 * 8.0);
    HEAP32[$boost_bits >> 2] = ((Math_imul(HEAP32[$boost >> 2] | 0, HEAP32[$width >> 2] | 0) | 0) << 3 | 0) / 8 | 0;
    break;
   } else {
    HEAP32[$boost >> 2] = ~~($429 * +(HEAP32[$width >> 2] | 0) / 6.0);
    HEAP32[$boost_bits >> 2] = (HEAP32[$boost >> 2] | 0) * 6 << 3;
    break;
   }
  } while (0);
  if (HEAP32[$vbr$addr >> 2] | 0) {
   if (!((HEAP32[$constrained_vbr$addr >> 2] | 0) == 0 | (HEAP32[$isTransient$addr >> 2] | 0) != 0)) label = 144;
  } else label = 144;
  if ((label | 0) == 144) {
   label = 0;
   if (((HEAP32[$tot_boost >> 2] | 0) + (HEAP32[$boost_bits >> 2] | 0) >> 3 >> 3 | 0) > ((HEAP32[$effectiveBytes$addr >> 2] << 1 | 0) / 3 | 0 | 0)) break;
  }
  HEAP32[(HEAP32[$offsets$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$boost >> 2];
  HEAP32[$tot_boost >> 2] = (HEAP32[$tot_boost >> 2] | 0) + (HEAP32[$boost_bits >> 2] | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((label | 0) == 150) {
  $458 = HEAP32[$tot_boost >> 2] | 0;
  $459 = HEAP32[$tot_boost_$addr >> 2] | 0;
  HEAP32[$459 >> 2] = $458;
  $460 = +HEAPF32[$maxDepth >> 2];
  $461 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($461 | 0);
  STACKTOP = sp;
  return +$460;
 }
 HEAP32[$cap >> 2] = ((HEAP32[$effectiveBytes$addr >> 2] << 1 | 0) / 3 | 0) << 3 << 3;
 HEAP32[(HEAP32[$offsets$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = (HEAP32[$cap >> 2] | 0) - (HEAP32[$tot_boost >> 2] | 0);
 HEAP32[$tot_boost >> 2] = HEAP32[$cap >> 2];
 $458 = HEAP32[$tot_boost >> 2] | 0;
 $459 = HEAP32[$tot_boost_$addr >> 2] | 0;
 HEAP32[$459 >> 2] = $458;
 $460 = +HEAPF32[$maxDepth >> 2];
 $461 = HEAP32[$saved_stack >> 2] | 0;
 _llvm_stackrestore($461 | 0);
 STACKTOP = sp;
 return +$460;
}

function _silk_decode_core($psDec, $psDecCtrl, $xq, $pulses, $arch) {
 $psDec = $psDec | 0;
 $psDecCtrl = $psDecCtrl | 0;
 $xq = $xq | 0;
 $pulses = $pulses | 0;
 $arch = $arch | 0;
 var $1 = 0, $109 = 0, $34 = 0, $379 = 0, $A_Q12 = 0, $A_Q12_tmp = 0, $B_Q14 = 0, $Gain_Q10 = 0, $LPC_pred_Q10 = 0, $LTP_pred_Q13 = 0, $NLSF_interpolation_flag = 0, $add101 = 0, $add107 = 0, $add203 = 0, $add234 = 0, $add242 = 0, $add731 = 0, $add759 = 0, $add787 = 0, $arch$addr = 0, $arrayidx163 = 0, $arrayidx29 = 0, $arrayidx37 = 0, $arrayidx43 = 0, $cmp641 = 0, $cond633 = 0, $cond652 = 0, $cond672 = 0, $cond690 = 0, $cond709 = 0, $cond715 = 0, $cond801 = 0, $gain_adj_Q16 = 0, $i = 0, $inv_gain_Q31 = 0, $k = 0, $lag = 0, $mul173 = 0, $mul194 = 0, $mul225 = 0, $mul267 = 0, $mul280 = 0, $mul293 = 0, $mul306 = 0, $mul319 = 0, $mul354 = 0, $mul371 = 0, $mul388 = 0, $mul405 = 0, $mul422 = 0, $mul439 = 0, $mul456 = 0, $mul473 = 0, $mul490 = 0, $mul507 = 0, $mul528 = 0, $mul545 = 0, $mul562 = 0, $mul579 = 0, $mul596 = 0, $mul613 = 0, $mul723 = 0, $mul751 = 0, $mul779 = 0, $mul95 = 0, $offset_Q10 = 0, $pexc_Q14 = 0, $pred_lag_ptr = 0, $pres_Q14 = 0, $psDec$addr = 0, $psDecCtrl$addr = 0, $pulses$addr = 0, $pxq = 0, $rand_seed = 0, $sLTP_buf_idx = 0, $saved_stack = 0, $signalType = 0, $start_idx = 0, $vla = 0, $vla2 = 0, $vla3 = 0, $vla6 = 0, $xq$addr = 0, dest = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $psDec$addr = sp + 100 | 0;
 $psDecCtrl$addr = sp + 96 | 0;
 $xq$addr = sp + 92 | 0;
 $pulses$addr = sp + 88 | 0;
 $arch$addr = sp + 84 | 0;
 $i = sp + 80 | 0;
 $k = sp + 76 | 0;
 $lag = sp + 72 | 0;
 $start_idx = sp + 68 | 0;
 $sLTP_buf_idx = sp + 64 | 0;
 $NLSF_interpolation_flag = sp + 60 | 0;
 $signalType = sp + 56 | 0;
 $A_Q12 = sp + 52 | 0;
 $B_Q14 = sp + 48 | 0;
 $pxq = sp + 44 | 0;
 $A_Q12_tmp = sp + 104 | 0;
 $LTP_pred_Q13 = sp + 40 | 0;
 $LPC_pred_Q10 = sp + 36 | 0;
 $Gain_Q10 = sp + 32 | 0;
 $inv_gain_Q31 = sp + 28 | 0;
 $gain_adj_Q16 = sp + 24 | 0;
 $rand_seed = sp + 20 | 0;
 $offset_Q10 = sp + 16 | 0;
 $pred_lag_ptr = sp + 12 | 0;
 $pexc_Q14 = sp + 8 | 0;
 $pres_Q14 = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$psDecCtrl$addr >> 2] = $psDecCtrl;
 HEAP32[$xq$addr >> 2] = $xq;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$lag >> 2] = 0;
 $1 = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($1 << 1) | 0) + 15 & -16) | 0;
 $vla2 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] | 0) << 2) | 0) + 15 & -16) | 0;
 $vla3 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla6 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] | 0) + 16 << 2) | 0) + 15 & -16) | 0;
 HEAP32[$offset_Q10 >> 2] = HEAP16[22956 + (HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] >> 1 << 2) + (HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 30 >> 0] << 1) >> 1];
 if ((HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 31 >> 0] | 0) < 4) HEAP32[$NLSF_interpolation_flag >> 2] = 1; else HEAP32[$NLSF_interpolation_flag >> 2] = 0;
 HEAP32[$rand_seed >> 2] = HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 34 >> 0];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] | 0)) break;
  HEAP32[$rand_seed >> 2] = 907633515 + (Math_imul(HEAP32[$rand_seed >> 2] | 0, 196314165) | 0);
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 2) >> 2] = HEAP16[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << 14;
  $arrayidx29 = (HEAP32[$psDec$addr >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 2) | 0;
  $34 = HEAP32[$arrayidx29 >> 2] | 0;
  if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 2) >> 2] | 0) > 0) HEAP32[$arrayidx29 >> 2] = $34 - 1280; else if (($34 | 0) < 0) {
   $arrayidx37 = (HEAP32[$psDec$addr >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 2) | 0;
   HEAP32[$arrayidx37 >> 2] = (HEAP32[$arrayidx37 >> 2] | 0) + 1280;
  }
  $arrayidx43 = (HEAP32[$psDec$addr >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 2) | 0;
  HEAP32[$arrayidx43 >> 2] = (HEAP32[$arrayidx43 >> 2] | 0) + (HEAP32[$offset_Q10 >> 2] << 4);
  if ((HEAP32[$rand_seed >> 2] | 0) < 0) HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 2) >> 2] = 0 - (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 2) >> 2] | 0);
  HEAP32[$rand_seed >> 2] = (HEAP32[$rand_seed >> 2] | 0) + (HEAP16[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 dest = $vla6;
 src = (HEAP32[$psDec$addr >> 2] | 0) + 1284 | 0;
 stop = dest + 64 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[$pexc_Q14 >> 2] = (HEAP32[$psDec$addr >> 2] | 0) + 4;
 HEAP32[$pxq >> 2] = HEAP32[$xq$addr >> 2];
 HEAP32[$sLTP_buf_idx >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2];
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0)) break;
  HEAP32[$pres_Q14 >> 2] = $vla3;
  HEAP32[$A_Q12 >> 2] = (HEAP32[$psDecCtrl$addr >> 2] | 0) + 32 + (HEAP32[$k >> 2] >> 1 << 5);
  _memcpy($A_Q12_tmp | 0, HEAP32[$A_Q12 >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] << 1 | 0) | 0;
  HEAP32[$B_Q14 >> 2] = (HEAP32[$psDecCtrl$addr >> 2] | 0) + 96 + ((HEAP32[$k >> 2] | 0) * 5 << 1);
  HEAP32[$signalType >> 2] = HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0];
  HEAP32[$Gain_Q10 >> 2] = HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + (HEAP32[$k >> 2] << 2) >> 2] >> 6;
  HEAP32[$inv_gain_Q31 >> 2] = _silk_INVERSE32_varQ_551(HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + (HEAP32[$k >> 2] << 2) >> 2] | 0, 47) | 0;
  L20 : do if ((HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + (HEAP32[$k >> 2] << 2) >> 2] | 0) != (HEAP32[HEAP32[$psDec$addr >> 2] >> 2] | 0)) {
   HEAP32[$gain_adj_Q16 >> 2] = _silk_DIV32_varQ_552(HEAP32[HEAP32[$psDec$addr >> 2] >> 2] | 0, HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + (HEAP32[$k >> 2] << 2) >> 2] | 0, 16) | 0;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= 16) break L20;
    $mul95 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[$vla6 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
    $add101 = $mul95 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[$vla6 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    $add107 = $add101 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[$vla6 + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
    HEAP32[$vla6 + (HEAP32[$i >> 2] << 2) >> 2] = $add107;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  } else HEAP32[$gain_adj_Q16 >> 2] = 65536; while (0);
  HEAP32[HEAP32[$psDec$addr >> 2] >> 2] = HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + (HEAP32[$k >> 2] << 2) >> 2];
  if (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4160 >> 2] | 0) if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4164 >> 2] | 0) == 2) if ((HEAP32[$k >> 2] | 0) < 2 ? (HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] | 0) != 2 : 0) {
   $109 = HEAP32[$B_Q14 >> 2] | 0;
   HEAP16[$109 >> 1] = 0;
   HEAP16[$109 + 2 >> 1] = 0;
   HEAP16[$109 + 4 >> 1] = 0;
   HEAP16[$109 + 6 >> 1] = 0;
   HEAP16[$109 + 8 >> 1] = 0;
   HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 4 >> 1] = 4096;
   HEAP32[$signalType >> 2] = 2;
   HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2308 >> 2];
  }
  L32 : do if ((HEAP32[$signalType >> 2] | 0) == 2) {
   HEAP32[$lag >> 2] = HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2];
   if (HEAP32[$k >> 2] | 0) if (!((HEAP32[$k >> 2] | 0) == 2 & (HEAP32[$NLSF_interpolation_flag >> 2] | 0) != 0)) {
    if ((HEAP32[$gain_adj_Q16 >> 2] | 0) == 65536) break;
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$lag >> 2] | 0) + 2 | 0)) break L32;
     $mul225 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[$vla2 + ((HEAP32[$sLTP_buf_idx >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] & 65535) << 16 >> 16) | 0;
     $add234 = $mul225 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[$vla2 + ((HEAP32[$sLTP_buf_idx >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
     $add242 = $add234 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[$vla2 + ((HEAP32[$sLTP_buf_idx >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
     HEAP32[$vla2 + ((HEAP32[$sLTP_buf_idx >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] = $add242;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   }
   HEAP32[$start_idx >> 2] = (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) - (HEAP32[$lag >> 2] | 0) - (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0) - 2;
   if ((HEAP32[$k >> 2] | 0) == 2) _memcpy((HEAP32[$psDec$addr >> 2] | 0) + 1348 + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] << 1) | 0, HEAP32[$xq$addr >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] << 1 << 1 | 0) | 0;
   $arrayidx163 = (HEAP32[$psDec$addr >> 2] | 0) + 1348 + ((HEAP32[$start_idx >> 2] | 0) + (Math_imul(HEAP32[$k >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] | 0) | 0) << 1) | 0;
   _silk_LPC_analysis_filter($vla + (HEAP32[$start_idx >> 2] << 1) | 0, $arrayidx163, HEAP32[$A_Q12 >> 2] | 0, (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) - (HEAP32[$start_idx >> 2] | 0) | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
   if (!(HEAP32[$k >> 2] | 0)) {
    $mul173 = Math_imul(HEAP32[$inv_gain_Q31 >> 2] >> 16, (HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 136 >> 2] & 65535) << 16 >> 16) | 0;
    HEAP32[$inv_gain_Q31 >> 2] = $mul173 + ((Math_imul(HEAP32[$inv_gain_Q31 >> 2] & 65535, (HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 136 >> 2] & 65535) << 16 >> 16) | 0) >> 16) << 2;
   }
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$lag >> 2] | 0) + 2 | 0)) break L32;
    $mul194 = Math_imul(HEAP32[$inv_gain_Q31 >> 2] >> 16, HEAP16[$vla + ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0) | 0;
    $add203 = $mul194 + ((Math_imul(HEAP32[$inv_gain_Q31 >> 2] & 65535, HEAP16[$vla + ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) >> 16) | 0;
    HEAP32[$vla2 + ((HEAP32[$sLTP_buf_idx >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] = $add203;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  } while (0);
  L52 : do if ((HEAP32[$signalType >> 2] | 0) == 2) {
   HEAP32[$pred_lag_ptr >> 2] = $vla2 + ((HEAP32[$sLTP_buf_idx >> 2] | 0) - (HEAP32[$lag >> 2] | 0) + 2 << 2);
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] | 0)) break L52;
    HEAP32[$LTP_pred_Q13 >> 2] = 2;
    $mul267 = Math_imul(HEAP32[HEAP32[$pred_lag_ptr >> 2] >> 2] >> 16, HEAP16[HEAP32[$B_Q14 >> 2] >> 1] | 0) | 0;
    HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul267 + ((Math_imul(HEAP32[HEAP32[$pred_lag_ptr >> 2] >> 2] & 65535, HEAP16[HEAP32[$B_Q14 >> 2] >> 1] | 0) | 0) >> 16));
    $mul280 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -4 >> 2] >> 16, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 2 >> 1] | 0) | 0;
    HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul280 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -4 >> 2] & 65535, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
    $mul293 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -8 >> 2] >> 16, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 4 >> 1] | 0) | 0;
    HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul293 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -8 >> 2] & 65535, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
    $mul306 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -12 >> 2] >> 16, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 6 >> 1] | 0) | 0;
    HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul306 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -12 >> 2] & 65535, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
    $mul319 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -16 >> 2] >> 16, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 8 >> 1] | 0) | 0;
    HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul319 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -16 >> 2] & 65535, HEAP16[(HEAP32[$B_Q14 >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
    HEAP32[$pred_lag_ptr >> 2] = (HEAP32[$pred_lag_ptr >> 2] | 0) + 4;
    HEAP32[(HEAP32[$pres_Q14 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = (HEAP32[(HEAP32[$pexc_Q14 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + (HEAP32[$LTP_pred_Q13 >> 2] << 1);
    HEAP32[$vla2 + (HEAP32[$sLTP_buf_idx >> 2] << 2) >> 2] = HEAP32[(HEAP32[$pres_Q14 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] << 1;
    HEAP32[$sLTP_buf_idx >> 2] = (HEAP32[$sLTP_buf_idx >> 2] | 0) + 1;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  } else HEAP32[$pres_Q14 >> 2] = HEAP32[$pexc_Q14 >> 2]; while (0);
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] | 0)) break;
   HEAP32[$LPC_pred_Q10 >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] >> 1;
   $mul354 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul354 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp >> 1] | 0) | 0) >> 16));
   $mul371 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 2 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 2 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul371 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 2 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 2 >> 1] | 0) | 0) >> 16));
   $mul388 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 3 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 4 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul388 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 3 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 4 >> 1] | 0) | 0) >> 16));
   $mul405 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 4 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 6 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul405 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 4 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 6 >> 1] | 0) | 0) >> 16));
   $mul422 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 5 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 8 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul422 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 5 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 8 >> 1] | 0) | 0) >> 16));
   $mul439 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 6 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 10 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul439 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 6 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 10 >> 1] | 0) | 0) >> 16));
   $mul456 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 7 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 12 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul456 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 7 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 12 >> 1] | 0) | 0) >> 16));
   $mul473 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 8 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 14 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul473 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 8 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 14 >> 1] | 0) | 0) >> 16));
   $mul490 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 9 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 16 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul490 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 9 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 16 >> 1] | 0) | 0) >> 16));
   $mul507 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 10 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 18 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul507 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 10 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 18 >> 1] | 0) | 0) >> 16));
   if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0) == 16) {
    $mul528 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 11 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 20 >> 1] | 0) | 0;
    HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul528 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 11 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 20 >> 1] | 0) | 0) >> 16));
    $mul545 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 12 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 22 >> 1] | 0) | 0;
    HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul545 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 12 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 22 >> 1] | 0) | 0) >> 16));
    $mul562 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 13 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 24 >> 1] | 0) | 0;
    HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul562 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 13 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 24 >> 1] | 0) | 0) >> 16));
    $mul579 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 14 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 26 >> 1] | 0) | 0;
    HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul579 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 14 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 26 >> 1] | 0) | 0) >> 16));
    $mul596 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 15 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 28 >> 1] | 0) | 0;
    HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul596 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 15 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 28 >> 1] | 0) | 0) >> 16));
    $mul613 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 16 << 2) >> 2] >> 16, HEAP16[$A_Q12_tmp + 30 >> 1] | 0) | 0;
    HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul613 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) - 16 << 2) >> 2] & 65535, HEAP16[$A_Q12_tmp + 30 >> 1] | 0) | 0) >> 16));
   }
   if ((HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727) $cond633 = 134217727; else $cond633 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
   $379 = HEAP32[(HEAP32[$pres_Q14 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0;
   $cmp641 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727;
   if (!((HEAP32[(HEAP32[$pres_Q14 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + ($cond633 << 4) & -2147483648)) {
    if ($cmp641) $cond652 = 134217727; else $cond652 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
    if ($379 & $cond652 << 4 & -2147483648 | 0) $cond715 = -2147483648; else {
     if ((HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727) $cond672 = 134217727; else $cond672 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
     $cond715 = (HEAP32[(HEAP32[$pres_Q14 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + ($cond672 << 4) | 0;
    }
   } else {
    if ($cmp641) $cond690 = 134217727; else $cond690 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
    if (!(($379 | $cond690 << 4) & -2147483648)) $cond715 = 2147483647; else {
     if ((HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727) $cond709 = 134217727; else $cond709 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
     $cond715 = (HEAP32[(HEAP32[$pres_Q14 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) + ($cond709 << 4) | 0;
    }
   }
   HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = $cond715;
   $mul723 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
   $add731 = $mul723 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   if ((($add731 + (Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$Gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond801 = 32767; else {
    $mul751 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
    $add759 = $mul751 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    if ((($add759 + (Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$Gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond801 = -32768; else {
     $mul779 = Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
     $add787 = $mul779 + ((Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
     $cond801 = ($add787 + (Math_imul(HEAP32[$vla6 + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$Gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
    }
   }
   HEAP16[(HEAP32[$pxq >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $cond801;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  dest = $vla6;
  src = $vla6 + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] << 2) | 0;
  stop = dest + 64 | 0;
  do {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  } while ((dest | 0) < (stop | 0));
  HEAP32[$pexc_Q14 >> 2] = (HEAP32[$pexc_Q14 >> 2] | 0) + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] << 2);
  HEAP32[$pxq >> 2] = (HEAP32[$pxq >> 2] | 0) + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] << 1);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 dest = (HEAP32[$psDec$addr >> 2] | 0) + 1284 | 0;
 src = $vla6;
 stop = dest + 64 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_Decode($decState, $decControl, $lostFlag, $newPacketFlag, $psRangeDec, $samplesOut, $nSamplesOut, $arch) {
 $decState = $decState | 0;
 $decControl = $decControl | 0;
 $lostFlag = $lostFlag | 0;
 $newPacketFlag = $newPacketFlag | 0;
 $psRangeDec = $psRangeDec | 0;
 $samplesOut = $samplesOut | 0;
 $nSamplesOut = $nSamplesOut | 0;
 $arch = $arch | 0;
 var $$sink = 0, $$sink6 = 0, $$sink7 = 0, $$sink8 = 0, $23 = 0, $248 = 0, $292 = 0, $329 = 0, $399 = 0, $FrameIndex = 0, $LBRR_flags = 0, $LBRR_symbol = 0, $MS_pred_Q13 = 0, $arch$addr = 0, $arrayidx123 = 0, $arrayidx31$sink = 0, $arrayidx440 = 0, $call = 0, $call122 = 0, $call405 = 0, $call509 = 0, $call544 = 0, $call73 = 0, $channel_state = 0, $cmp120 = 0, $cond = 0, $cond455 = 0, $cond472 = 0, $condCoding = 0, $condCoding374 = 0, $decControl$addr = 0, $decState$addr = 0, $decode_only_middle = 0, $delay_stack_alloc = 0, $fs_kHz_dec = 0, $has_side = 0, $i = 0, $lostFlag$addr = 0, $mul313 = 0, $mul443 = 0, $mul481 = 0, $mul585 = 0, $mult_tab = 0, $n = 0, $nFramesDecoded413 = 0, $nSamplesOut$addr = 0, $nSamplesOutDec = 0, $newPacketFlag$addr = 0, $psDec = 0, $psRangeDec$addr = 0, $pulses = 0, $resample_out_ptr = 0, $ret = 0, $retval = 0, $sMid = 0, $sMid437 = 0, $samplesOut$addr = 0, $samplesOut1_tmp = 0, $saved_stack = 0, $stereo_to_mono = 0, $vla = 0, $vla$sink = 0, $vla456 = 0, $vla473 = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 784 | 0;
 $retval = sp + 128 | 0;
 $decState$addr = sp + 124 | 0;
 $decControl$addr = sp + 120 | 0;
 $lostFlag$addr = sp + 116 | 0;
 $newPacketFlag$addr = sp + 112 | 0;
 $psRangeDec$addr = sp + 108 | 0;
 $samplesOut$addr = sp + 104 | 0;
 $nSamplesOut$addr = sp + 100 | 0;
 $arch$addr = sp + 96 | 0;
 $i = sp + 92 | 0;
 $n = sp + 88 | 0;
 $decode_only_middle = sp + 84 | 0;
 $ret = sp + 80 | 0;
 $nSamplesOutDec = sp + 76 | 0;
 $LBRR_symbol = sp + 72 | 0;
 $samplesOut1_tmp = sp + 64 | 0;
 $MS_pred_Q13 = sp + 56 | 0;
 $resample_out_ptr = sp + 52 | 0;
 $psDec = sp + 48 | 0;
 $channel_state = sp + 44 | 0;
 $has_side = sp + 40 | 0;
 $stereo_to_mono = sp + 36 | 0;
 $delay_stack_alloc = sp + 32 | 0;
 $fs_kHz_dec = sp + 28 | 0;
 $pulses = sp + 136 | 0;
 $condCoding = sp + 24 | 0;
 $saved_stack = sp + 20 | 0;
 $FrameIndex = sp + 16 | 0;
 $condCoding374 = sp + 12 | 0;
 $mult_tab = sp;
 HEAP32[$decState$addr >> 2] = $decState;
 HEAP32[$decControl$addr >> 2] = $decControl;
 HEAP32[$lostFlag$addr >> 2] = $lostFlag;
 HEAP32[$newPacketFlag$addr >> 2] = $newPacketFlag;
 HEAP32[$psRangeDec$addr >> 2] = $psRangeDec;
 HEAP32[$samplesOut$addr >> 2] = $samplesOut;
 HEAP32[$nSamplesOut$addr >> 2] = $nSamplesOut;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$decode_only_middle >> 2] = 0;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$MS_pred_Q13 >> 2] = 0;
 HEAP32[$MS_pred_Q13 + 4 >> 2] = 0;
 HEAP32[$psDec >> 2] = HEAP32[$decState$addr >> 2];
 HEAP32[$channel_state >> 2] = HEAP32[$psDec >> 2];
 L1 : do if (HEAP32[$newPacketFlag$addr >> 2] | 0) {
  HEAP32[$n >> 2] = 0;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0)) break L1;
   HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2388 >> 2] = 0;
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
 } while (0);
 if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) > (HEAP32[(HEAP32[$psDec >> 2] | 0) + 8544 >> 2] | 0)) {
  $call = _silk_init_decoder((HEAP32[$channel_state >> 2] | 0) + 4264 | 0) | 0;
  HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call;
 }
 if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) == 1) if ((HEAP32[(HEAP32[$psDec >> 2] | 0) + 8544 >> 2] | 0) == 2) $23 = (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 12 >> 2] | 0) == ((HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2316 >> 2] | 0) * 1e3 | 0); else $23 = 0; else $23 = 0;
 HEAP32[$stereo_to_mono >> 2] = $23 & 1;
 L14 : do if (!(HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2388 >> 2] | 0)) {
  HEAP32[$n >> 2] = 0;
  L16 : while (1) {
   if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0)) break L14;
   do if (!(HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 16 >> 2] | 0)) {
    HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2392 >> 2] = 1;
    $$sink8 = 2;
    $arrayidx31$sink = (HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0;
   } else {
    if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 16 >> 2] | 0) == 10) {
     HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2392 >> 2] = 1;
     $$sink8 = 2;
     $arrayidx31$sink = (HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0;
     break;
    }
    if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 16 >> 2] | 0) == 20) {
     HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2392 >> 2] = 1;
     $$sink8 = 4;
     $arrayidx31$sink = (HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0;
     break;
    }
    if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 16 >> 2] | 0) == 40) {
     HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2392 >> 2] = 2;
     $$sink8 = 4;
     $arrayidx31$sink = (HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0;
     break;
    }
    if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 16 >> 2] | 0) != 60) {
     label = 23;
     break L16;
    }
    HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2392 >> 2] = 3;
    $$sink8 = 4;
    $arrayidx31$sink = (HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0;
   } while (0);
   HEAP32[$arrayidx31$sink + 2324 >> 2] = $$sink8;
   HEAP32[$fs_kHz_dec >> 2] = (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 12 >> 2] >> 10) + 1;
   if ((HEAP32[$fs_kHz_dec >> 2] | 0) != 8 & (HEAP32[$fs_kHz_dec >> 2] | 0) != 12 & (HEAP32[$fs_kHz_dec >> 2] | 0) != 16) {
    label = 25;
    break;
   }
   $call73 = _silk_decoder_set_fs((HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0, HEAP32[$fs_kHz_dec >> 2] | 0, HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
   HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call73;
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
  if ((label | 0) == 23) {
   HEAP32[$retval >> 2] = -203;
   $399 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $399 | 0;
  } else if ((label | 0) == 25) {
   HEAP32[$retval >> 2] = -200;
   $399 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $399 | 0;
  }
 } while (0);
 do if ((HEAP32[HEAP32[$decControl$addr >> 2] >> 2] | 0) == 2) if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) == 2) {
  if ((HEAP32[(HEAP32[$psDec >> 2] | 0) + 8540 >> 2] | 0) != 1) if ((HEAP32[(HEAP32[$psDec >> 2] | 0) + 8544 >> 2] | 0) != 1) break;
  HEAP32[(HEAP32[$psDec >> 2] | 0) + 8528 >> 2] = 0;
  HEAP32[(HEAP32[$psDec >> 2] | 0) + 8528 + 8 >> 2] = 0;
  _memcpy((HEAP32[$channel_state >> 2] | 0) + 4264 + 2432 | 0, (HEAP32[$channel_state >> 2] | 0) + 2432 | 0, 300) | 0;
 } while (0);
 HEAP32[(HEAP32[$psDec >> 2] | 0) + 8540 >> 2] = HEAP32[HEAP32[$decControl$addr >> 2] >> 2];
 HEAP32[(HEAP32[$psDec >> 2] | 0) + 8544 >> 2] = HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2];
 if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 8 >> 2] | 0) <= 48e3) if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 8 >> 2] | 0) >= 8e3) {
  L50 : do if ((HEAP32[$lostFlag$addr >> 2] | 0) != 1) if (!(HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2388 >> 2] | 0)) {
   HEAP32[$n >> 2] = 0;
   while (1) {
    if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
    HEAP32[$i >> 2] = 0;
    while (1) {
     $cmp120 = (HEAP32[$i >> 2] | 0) < (HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2392 >> 2] | 0);
     $call122 = _ec_dec_bit_logp(HEAP32[$psRangeDec$addr >> 2] | 0, 1) | 0;
     $arrayidx123 = (HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0;
     if (!$cmp120) break;
     HEAP32[$arrayidx123 + 2404 + (HEAP32[$i >> 2] << 2) >> 2] = $call122;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
    HEAP32[$arrayidx123 + 2416 >> 2] = $call122;
    HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
   }
   HEAP32[$n >> 2] = 0;
   while (1) {
    if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
    $LBRR_flags = (HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2420 | 0;
    HEAP32[$LBRR_flags >> 2] = 0;
    HEAP32[$LBRR_flags + 4 >> 2] = 0;
    HEAP32[$LBRR_flags + 8 >> 2] = 0;
    L64 : do if (HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2416 >> 2] | 0) {
     if ((HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2392 >> 2] | 0) == 1) {
      HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2420 >> 2] = 1;
      break;
     }
     HEAP32[$LBRR_symbol >> 2] = (_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[15200 + ((HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2392 >> 2] | 0) - 2 << 2) >> 2] | 0, 8) | 0) + 1;
     HEAP32[$i >> 2] = 0;
     while (1) {
      if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2392 >> 2] | 0)) break L64;
      HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2420 + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$LBRR_symbol >> 2] >> HEAP32[$i >> 2] & 1;
      HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
     }
    } while (0);
    HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
   }
   if (!(HEAP32[$lostFlag$addr >> 2] | 0)) {
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2392 >> 2] | 0)) break L50;
     HEAP32[$n >> 2] = 0;
     while (1) {
      if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
      if (HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2420 + (HEAP32[$i >> 2] << 2) >> 2] | 0) {
       do if ((HEAP32[$n >> 2] | 0) == 0 ? (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) == 2 : 0) {
        _silk_stereo_decode_pred(HEAP32[$psRangeDec$addr >> 2] | 0, $MS_pred_Q13);
        if (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 4264 + 2420 + (HEAP32[$i >> 2] << 2) >> 2] | 0) break;
        _silk_stereo_decode_mid_only(HEAP32[$psRangeDec$addr >> 2] | 0, $decode_only_middle);
       } while (0);
       do if ((HEAP32[$i >> 2] | 0) > 0) {
        if (!(HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2420 + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] | 0)) {
         label = 64;
         break;
        }
        HEAP32[$condCoding >> 2] = 2;
       } else label = 64; while (0);
       if ((label | 0) == 64) {
        label = 0;
        HEAP32[$condCoding >> 2] = 0;
       }
       _silk_decode_indices((HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[$i >> 2] | 0, 1, HEAP32[$condCoding >> 2] | 0);
       _silk_decode_pulses(HEAP32[$psRangeDec$addr >> 2] | 0, $pulses, HEAP8[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2736 + 29 >> 0] | 0, HEAP8[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2736 + 30 >> 0] | 0, HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2328 >> 2] | 0);
      }
      HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
     }
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   }
  } while (0);
  L96 : do if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) == 2) {
   do if (HEAP32[$lostFlag$addr >> 2] | 0) {
    if ((HEAP32[$lostFlag$addr >> 2] | 0) == 2) if ((HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2420 + (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2388 >> 2] << 2) >> 2] | 0) == 1) break;
    HEAP32[$n >> 2] = 0;
    while (1) {
     if ((HEAP32[$n >> 2] | 0) >= 2) break L96;
     HEAP32[$MS_pred_Q13 + (HEAP32[$n >> 2] << 2) >> 2] = HEAP16[(HEAP32[$psDec >> 2] | 0) + 8528 + (HEAP32[$n >> 2] << 1) >> 1];
     HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
    }
   } while (0);
   _silk_stereo_decode_pred(HEAP32[$psRangeDec$addr >> 2] | 0, $MS_pred_Q13);
   if (!(HEAP32[$lostFlag$addr >> 2] | 0)) {
    if (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 4264 + 2404 + (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2388 >> 2] << 2) >> 2] | 0) label = 74;
   } else label = 74;
   do if ((label | 0) == 74) {
    if ((HEAP32[$lostFlag$addr >> 2] | 0) == 2) if (!(HEAP32[(HEAP32[$channel_state >> 2] | 0) + 4264 + 2420 + (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2388 >> 2] << 2) >> 2] | 0)) break;
    HEAP32[$decode_only_middle >> 2] = 0;
    break L96;
   } while (0);
   _silk_stereo_decode_mid_only(HEAP32[$psRangeDec$addr >> 2] | 0, $decode_only_middle);
  } while (0);
  if ((HEAP32[$decode_only_middle >> 2] | 0) == 0 ? (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) == 2 : 0) if ((HEAP32[(HEAP32[$psDec >> 2] | 0) + 8548 >> 2] | 0) == 1) {
   _memset((HEAP32[$psDec >> 2] | 0) + 4264 + 1348 | 0, 0, 960) | 0;
   dest = (HEAP32[$psDec >> 2] | 0) + 4264 + 1284 | 0;
   stop = dest + 64 | 0;
   do {
    HEAP32[dest >> 2] = 0;
    dest = dest + 4 | 0;
   } while ((dest | 0) < (stop | 0));
   HEAP32[(HEAP32[$psDec >> 2] | 0) + 4264 + 2308 >> 2] = 100;
   HEAP8[(HEAP32[$psDec >> 2] | 0) + 4264 + 2312 >> 0] = 10;
   HEAP32[(HEAP32[$psDec >> 2] | 0) + 4264 + 4164 >> 2] = 0;
   HEAP32[(HEAP32[$psDec >> 2] | 0) + 4264 + 2376 >> 2] = 1;
  }
  $mul313 = Math_imul(HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 12 >> 2] | 0, HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) | 0;
  HEAP32[$delay_stack_alloc >> 2] = ($mul313 | 0) < (Math_imul(HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[HEAP32[$decControl$addr >> 2] >> 2] | 0) | 0) & 1;
  if (HEAP32[$delay_stack_alloc >> 2] | 0) $cond = 1; else $cond = Math_imul(HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0, (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2328 >> 2] | 0) + 2 | 0) | 0;
  HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
  $vla = STACKTOP;
  STACKTOP = STACKTOP + ((1 * ($cond << 1) | 0) + 15 & -16) | 0;
  if (HEAP32[$delay_stack_alloc >> 2] | 0) {
   HEAP32[$samplesOut1_tmp >> 2] = HEAP32[$samplesOut$addr >> 2];
   $$sink = HEAP32[$channel_state >> 2] | 0;
   $vla$sink = HEAP32[$samplesOut$addr >> 2] | 0;
  } else {
   HEAP32[$samplesOut1_tmp >> 2] = $vla;
   $$sink = HEAP32[$channel_state >> 2] | 0;
   $vla$sink = $vla;
  }
  HEAP32[$samplesOut1_tmp + 4 >> 2] = $vla$sink + (HEAP32[$$sink + 2328 >> 2] << 1) + 4;
  if (!(HEAP32[$lostFlag$addr >> 2] | 0)) HEAP32[$has_side >> 2] = ((HEAP32[$decode_only_middle >> 2] | 0) != 0 ^ 1) & 1; else {
   if (HEAP32[(HEAP32[$psDec >> 2] | 0) + 8548 >> 2] | 0) if ((HEAP32[$lostFlag$addr >> 2] | 0) == 2 ? (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) == 2 : 0) $248 = (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 4264 + 2420 + (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 4264 + 2388 >> 2] << 2) >> 2] | 0) == 1; else $248 = 0; else $248 = 1;
   HEAP32[$has_side >> 2] = $248 & 1;
  }
  HEAP32[$n >> 2] = 0;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0)) break;
   if ((HEAP32[$n >> 2] | 0) == 0 | (HEAP32[$has_side >> 2] | 0) != 0) {
    HEAP32[$FrameIndex >> 2] = (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2388 >> 2] | 0) - (HEAP32[$n >> 2] | 0);
    L140 : do if ((HEAP32[$FrameIndex >> 2] | 0) <= 0) HEAP32[$condCoding374 >> 2] = 0; else {
     if ((HEAP32[$lostFlag$addr >> 2] | 0) == 2) {
      HEAP32[$condCoding374 >> 2] = HEAP32[(HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2420 + ((HEAP32[$FrameIndex >> 2] | 0) - 1 << 2) >> 2] | 0 ? 2 : 0;
      break;
     }
     do if ((HEAP32[$n >> 2] | 0) > 0) {
      if (!(HEAP32[(HEAP32[$psDec >> 2] | 0) + 8548 >> 2] | 0)) break;
      HEAP32[$condCoding374 >> 2] = 1;
      break L140;
     } while (0);
     HEAP32[$condCoding374 >> 2] = 2;
    } while (0);
    $call405 = _silk_decode_frame((HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0, HEAP32[$psRangeDec$addr >> 2] | 0, (HEAP32[$samplesOut1_tmp + (HEAP32[$n >> 2] << 2) >> 2] | 0) + 4 | 0, $nSamplesOutDec, HEAP32[$lostFlag$addr >> 2] | 0, HEAP32[$condCoding374 >> 2] | 0, HEAP32[$arch$addr >> 2] | 0) | 0;
    HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call405;
   } else _memset((HEAP32[$samplesOut1_tmp + (HEAP32[$n >> 2] << 2) >> 2] | 0) + 4 | 0, 0, HEAP32[$nSamplesOutDec >> 2] << 1 | 0) | 0;
   $nFramesDecoded413 = (HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2388 | 0;
   HEAP32[$nFramesDecoded413 >> 2] = (HEAP32[$nFramesDecoded413 >> 2] | 0) + 1;
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
  if ((HEAP32[HEAP32[$decControl$addr >> 2] >> 2] | 0) == 2) if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) == 2) _silk_stereo_MS_to_LR((HEAP32[$psDec >> 2] | 0) + 8528 | 0, HEAP32[$samplesOut1_tmp >> 2] | 0, HEAP32[$samplesOut1_tmp + 4 >> 2] | 0, $MS_pred_Q13, HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2316 >> 2] | 0, HEAP32[$nSamplesOutDec >> 2] | 0); else label = 112; else label = 112;
  if ((label | 0) == 112) {
   $292 = HEAP32[$samplesOut1_tmp >> 2] | 0;
   $sMid = (HEAP32[$psDec >> 2] | 0) + 8528 + 4 | 0;
   HEAP16[$292 >> 1] = HEAP16[$sMid >> 1] | 0;
   HEAP16[$292 + 2 >> 1] = HEAP16[$sMid + 2 >> 1] | 0;
   $sMid437 = (HEAP32[$psDec >> 2] | 0) + 8528 + 4 | 0;
   $arrayidx440 = (HEAP32[$samplesOut1_tmp >> 2] | 0) + (HEAP32[$nSamplesOutDec >> 2] << 1) | 0;
   HEAP16[$sMid437 >> 1] = HEAP16[$arrayidx440 >> 1] | 0;
   HEAP16[$sMid437 + 2 >> 1] = HEAP16[$arrayidx440 + 2 >> 1] | 0;
  }
  $mul443 = Math_imul(HEAP32[$nSamplesOutDec >> 2] | 0, HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
  HEAP32[HEAP32[$nSamplesOut$addr >> 2] >> 2] = ($mul443 | 0) / (((HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2316 >> 2] & 65535) << 16 >> 16) * 1e3 | 0) | 0;
  if ((HEAP32[HEAP32[$decControl$addr >> 2] >> 2] | 0) == 2) $cond455 = HEAP32[HEAP32[$nSamplesOut$addr >> 2] >> 2] | 0; else $cond455 = 1;
  $vla456 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * ($cond455 << 1) | 0) + 15 & -16) | 0;
  if ((HEAP32[HEAP32[$decControl$addr >> 2] >> 2] | 0) == 2) HEAP32[$resample_out_ptr >> 2] = $vla456; else HEAP32[$resample_out_ptr >> 2] = HEAP32[$samplesOut$addr >> 2];
  if (HEAP32[$delay_stack_alloc >> 2] | 0) $cond472 = Math_imul(HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0, (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2328 >> 2] | 0) + 2 | 0) | 0; else $cond472 = 1;
  $vla473 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * ($cond472 << 1) | 0) + 15 & -16) | 0;
  if (HEAP32[$delay_stack_alloc >> 2] | 0) {
   $mul481 = (Math_imul(HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0, (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2328 >> 2] | 0) + 2 | 0) | 0) << 1;
   _memcpy($vla473 | 0, HEAP32[$samplesOut$addr >> 2] | 0, $mul481 + 0 | 0) | 0;
   HEAP32[$samplesOut1_tmp >> 2] = $vla473;
   HEAP32[$samplesOut1_tmp + 4 >> 2] = $vla473 + (HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2328 >> 2] << 1) + 4;
  }
  HEAP32[$n >> 2] = 0;
  while (1) {
   $329 = HEAP32[$decControl$addr >> 2] | 0;
   if ((HEAP32[$n >> 2] | 0) >= (HEAP32[((HEAP32[HEAP32[$decControl$addr >> 2] >> 2] | 0) < (HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) ? $329 : $329 + 4 | 0) >> 2] | 0)) break;
   $call509 = _silk_resampler((HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) + 2432 | 0, HEAP32[$resample_out_ptr >> 2] | 0, (HEAP32[$samplesOut1_tmp + (HEAP32[$n >> 2] << 2) >> 2] | 0) + 2 | 0, HEAP32[$nSamplesOutDec >> 2] | 0) | 0;
   HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call509;
   L176 : do if ((HEAP32[HEAP32[$decControl$addr >> 2] >> 2] | 0) == 2) {
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[HEAP32[$nSamplesOut$addr >> 2] >> 2] | 0)) break L176;
     HEAP16[(HEAP32[$samplesOut$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + (HEAP32[$i >> 2] << 1) << 1) >> 1] = HEAP16[(HEAP32[$resample_out_ptr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   } while (0);
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
  L183 : do if ((HEAP32[HEAP32[$decControl$addr >> 2] >> 2] | 0) == 2) {
   if ((HEAP32[(HEAP32[$decControl$addr >> 2] | 0) + 4 >> 2] | 0) != 1) break;
   if (HEAP32[$stereo_to_mono >> 2] | 0) {
    $call544 = _silk_resampler((HEAP32[$channel_state >> 2] | 0) + 4264 + 2432 | 0, HEAP32[$resample_out_ptr >> 2] | 0, (HEAP32[$samplesOut1_tmp >> 2] | 0) + 2 | 0, HEAP32[$nSamplesOutDec >> 2] | 0) | 0;
    HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call544;
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[HEAP32[$nSamplesOut$addr >> 2] >> 2] | 0)) break L183;
     HEAP16[(HEAP32[$samplesOut$addr >> 2] | 0) + (1 + (HEAP32[$i >> 2] << 1) << 1) >> 1] = HEAP16[(HEAP32[$resample_out_ptr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   } else {
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[HEAP32[$nSamplesOut$addr >> 2] >> 2] | 0)) break L183;
     HEAP16[(HEAP32[$samplesOut$addr >> 2] | 0) + (1 + (HEAP32[$i >> 2] << 1) << 1) >> 1] = HEAP16[(HEAP32[$samplesOut$addr >> 2] | 0) + (0 + (HEAP32[$i >> 2] << 1) << 1) >> 1] | 0;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   }
  } while (0);
  if ((HEAP32[(HEAP32[$channel_state >> 2] | 0) + 4164 >> 2] | 0) == 2) {
   HEAP32[$mult_tab >> 2] = HEAP32[3761];
   HEAP32[$mult_tab + 4 >> 2] = HEAP32[3762];
   HEAP32[$mult_tab + 8 >> 2] = HEAP32[3763];
   $mul585 = Math_imul(HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2308 >> 2] | 0, HEAP32[$mult_tab + ((HEAP32[(HEAP32[$channel_state >> 2] | 0) + 2316 >> 2] | 0) - 8 >> 2 << 2) >> 2] | 0) | 0;
   $$sink6 = $mul585;
   $$sink7 = HEAP32[$decControl$addr >> 2] | 0;
  } else {
   $$sink6 = 0;
   $$sink7 = HEAP32[$decControl$addr >> 2] | 0;
  }
  HEAP32[$$sink7 + 20 >> 2] = $$sink6;
  L200 : do if ((HEAP32[$lostFlag$addr >> 2] | 0) == 1) {
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec >> 2] | 0) + 8544 >> 2] | 0)) break L200;
    HEAP8[(HEAP32[$psDec >> 2] | 0) + ((HEAP32[$i >> 2] | 0) * 4264 | 0) + 2312 >> 0] = 10;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  } else HEAP32[(HEAP32[$psDec >> 2] | 0) + 8548 >> 2] = HEAP32[$decode_only_middle >> 2]; while (0);
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
  $399 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $399 | 0;
 }
 HEAP32[$ret >> 2] = -200;
 HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
 $399 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $399 | 0;
}

function _LPC_inverse_pred_gain_QA_c($A_QA, $order) {
 $A_QA = $A_QA | 0;
 $order = $order | 0;
 var $101 = 0, $103 = 0, $105 = 0, $106 = 0, $109 = 0, $11 = 0, $112 = 0, $114 = 0, $116 = 0, $118 = 0, $122 = 0, $125 = 0, $127 = 0, $128 = 0, $129 = 0, $130 = 0, $133 = 0, $136 = 0, $138 = 0, $14 = 0, $140 = 0, $142 = 0, $144 = 0, $145 = 0, $148 = 0, $151 = 0, $153 = 0, $155 = 0, $157 = 0, $159 = 0, $160 = 0, $163 = 0, $166 = 0, $168 = 0, $17 = 0, $170 = 0, $172 = 0, $174 = 0, $177 = 0, $180 = 0, $182 = 0, $184 = 0, $186 = 0, $188 = 0, $189 = 0, $19 = 0, $192 = 0, $195 = 0, $197 = 0, $199 = 0, $201 = 0, $205 = 0, $208 = 0, $21 = 0, $211 = 0, $213 = 0, $216 = 0, $219 = 0, $221 = 0, $223 = 0, $225 = 0, $227 = 0, $228 = 0, $231 = 0, $234 = 0, $236 = 0, $238 = 0, $24 = 0, $240 = 0, $242 = 0, $245 = 0, $248 = 0, $250 = 0, $252 = 0, $254 = 0, $256 = 0, $257 = 0, $260 = 0, $263 = 0, $265 = 0, $267 = 0, $269 = 0, $27 = 0, $273 = 0, $276 = 0, $279 = 0, $281 = 0, $283 = 0, $285 = 0, $287 = 0, $29 = 0, $290 = 0, $291 = 0, $296 = 0, $302 = 0, $307 = 0, $322 = 0, $323 = 0, $326 = 0, $329 = 0, $33 = 0, $331 = 0, $333 = 0, $335 = 0, $337 = 0, $338 = 0, $341 = 0, $344 = 0, $346 = 0, $348 = 0, $350 = 0, $352 = 0, $353 = 0, $356 = 0, $359 = 0, $361 = 0, $363 = 0, $365 = 0, $367 = 0, $370 = 0, $373 = 0, $375 = 0, $377 = 0, $379 = 0, $381 = 0, $382 = 0, $385 = 0, $388 = 0, $390 = 0, $392 = 0, $394 = 0, $398 = 0, $401 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $409 = 0, $412 = 0, $414 = 0, $416 = 0, $418 = 0, $420 = 0, $421 = 0, $424 = 0, $427 = 0, $429 = 0, $431 = 0, $433 = 0, $435 = 0, $436 = 0, $439 = 0, $442 = 0, $444 = 0, $446 = 0, $448 = 0, $450 = 0, $453 = 0, $456 = 0, $458 = 0, $46 = 0, $460 = 0, $462 = 0, $464 = 0, $465 = 0, $468 = 0, $47 = 0, $471 = 0, $473 = 0, $475 = 0, $477 = 0, $481 = 0, $484 = 0, $487 = 0, $489 = 0, $492 = 0, $495 = 0, $497 = 0, $499 = 0, $50 = 0, $501 = 0, $503 = 0, $504 = 0, $507 = 0, $510 = 0, $512 = 0, $514 = 0, $516 = 0, $518 = 0, $521 = 0, $524 = 0, $526 = 0, $528 = 0, $53 = 0, $530 = 0, $532 = 0, $533 = 0, $536 = 0, $539 = 0, $541 = 0, $543 = 0, $545 = 0, $549 = 0, $55 = 0, $552 = 0, $555 = 0, $557 = 0, $559 = 0, $561 = 0, $563 = 0, $566 = 0, $567 = 0, $57 = 0, $572 = 0, $578 = 0, $583 = 0, $59 = 0, $605 = 0, $608 = 0, $61 = 0, $611 = 0, $613 = 0, $615 = 0, $618 = 0, $62 = 0, $621 = 0, $623 = 0, $627 = 0, $65 = 0, $68 = 0, $70 = 0, $72 = 0, $74 = 0, $76 = 0, $77 = 0, $80 = 0, $83 = 0, $85 = 0, $87 = 0, $89 = 0, $91 = 0, $94 = 0, $97 = 0, $99 = 0, $A_QA$addr = 0, $cmp1 = 0, $cmp245 = 0, $cmp257 = 0, $cmp34 = 0, $cmp45 = 0, $cond159 = 0, $cond226 = 0, $cond308 = 0, $cond373 = 0, $cond440 = 0, $cond94 = 0, $invGain_Q30 = 0, $k = 0, $mult2Q = 0, $n = 0, $order$addr = 0, $rc_Q31 = 0, $rc_mult1_Q30 = 0, $rc_mult2 = 0, $retval = 0, $tmp1 = 0, $tmp2 = 0, $tmp64 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $retval = sp + 52 | 0;
 $A_QA$addr = sp + 48 | 0;
 $order$addr = sp + 44 | 0;
 $k = sp + 40 | 0;
 $n = sp + 36 | 0;
 $mult2Q = sp + 32 | 0;
 $invGain_Q30 = sp + 28 | 0;
 $rc_Q31 = sp + 24 | 0;
 $rc_mult1_Q30 = sp + 20 | 0;
 $rc_mult2 = sp + 16 | 0;
 $tmp1 = sp + 12 | 0;
 $tmp2 = sp + 8 | 0;
 $tmp64 = sp;
 HEAP32[$A_QA$addr >> 2] = $A_QA;
 HEAP32[$order$addr >> 2] = $order;
 HEAP32[$invGain_Q30 >> 2] = 1073741824;
 HEAP32[$k >> 2] = (HEAP32[$order$addr >> 2] | 0) - 1;
 L1 : while (1) {
  $cmp1 = (HEAP32[(HEAP32[$A_QA$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) > 16773022;
  if ((HEAP32[$k >> 2] | 0) <= 0) {
   label = 52;
   break;
  }
  if ($cmp1) {
   label = 5;
   break;
  }
  if ((HEAP32[(HEAP32[$A_QA$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) < -16773022) {
   label = 5;
   break;
  }
  HEAP32[$rc_Q31 >> 2] = 0 - (HEAP32[(HEAP32[$A_QA$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] << 7);
  $11 = HEAP32[$rc_Q31 >> 2] | 0;
  $14 = HEAP32[$rc_Q31 >> 2] | 0;
  $17 = ___muldi3($11 | 0, (($11 | 0) < 0) << 31 >> 31 | 0, $14 | 0, (($14 | 0) < 0) << 31 >> 31 | 0) | 0;
  $19 = _bitshift64Ashr($17 | 0, tempRet0 | 0, 32) | 0;
  HEAP32[$rc_mult1_Q30 >> 2] = 1073741824 - $19;
  $21 = HEAP32[$invGain_Q30 >> 2] | 0;
  $24 = HEAP32[$rc_mult1_Q30 >> 2] | 0;
  $27 = ___muldi3($21 | 0, (($21 | 0) < 0) << 31 >> 31 | 0, $24 | 0, (($24 | 0) < 0) << 31 >> 31 | 0) | 0;
  $29 = _bitshift64Ashr($27 | 0, tempRet0 | 0, 32) | 0;
  HEAP32[$invGain_Q30 >> 2] = $29 << 2;
  if ((HEAP32[$invGain_Q30 >> 2] | 0) < 107374) {
   label = 7;
   break;
  }
  $33 = HEAP32[$rc_mult1_Q30 >> 2] | 0;
  HEAP32[$mult2Q >> 2] = 32 - (_silk_CLZ32_487((HEAP32[$rc_mult1_Q30 >> 2] | 0) > 0 ? $33 : 0 - $33 | 0) | 0);
  HEAP32[$rc_mult2 >> 2] = _silk_INVERSE32_varQ_488(HEAP32[$rc_mult1_Q30 >> 2] | 0, (HEAP32[$mult2Q >> 2] | 0) + 30 | 0) | 0;
  HEAP32[$n >> 2] = 0;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= ((HEAP32[$k >> 2] | 0) + 1 >> 1 | 0)) break;
   HEAP32[$tmp1 >> 2] = HEAP32[(HEAP32[$A_QA$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2];
   HEAP32[$tmp2 >> 2] = HEAP32[(HEAP32[$A_QA$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - (HEAP32[$n >> 2] | 0) - 1 << 2) >> 2];
   $cmp34 = (HEAP32[$mult2Q >> 2] | 0) == 1;
   $46 = HEAP32[$tmp1 >> 2] | 0;
   $47 = HEAP32[$tmp2 >> 2] | 0;
   $50 = HEAP32[$rc_Q31 >> 2] | 0;
   $53 = ___muldi3($47 | 0, (($47 | 0) < 0) << 31 >> 31 | 0, $50 | 0, (($50 | 0) < 0) << 31 >> 31 | 0) | 0;
   $55 = _bitshift64Ashr($53 | 0, tempRet0 | 0, 30) | 0;
   $57 = _i64Add($55 | 0, tempRet0 | 0, 1, 0) | 0;
   $59 = _bitshift64Ashr($57 | 0, tempRet0 | 0, 1) | 0;
   $cmp45 = ($46 - $59 & -2147483648 | 0) == 0;
   $61 = HEAP32[$tmp1 >> 2] | 0;
   if ($cmp34) {
    if ($cmp45) {
     $62 = HEAP32[$tmp2 >> 2] | 0;
     $65 = HEAP32[$rc_Q31 >> 2] | 0;
     $68 = ___muldi3($62 | 0, (($62 | 0) < 0) << 31 >> 31 | 0, $65 | 0, (($65 | 0) < 0) << 31 >> 31 | 0) | 0;
     $70 = _bitshift64Ashr($68 | 0, tempRet0 | 0, 30) | 0;
     $72 = _i64Add($70 | 0, tempRet0 | 0, 1, 0) | 0;
     $74 = _bitshift64Ashr($72 | 0, tempRet0 | 0, 1) | 0;
     if ($61 & ($74 ^ -2147483648) & -2147483648 | 0) $cond94 = -2147483648; else {
      $76 = HEAP32[$tmp1 >> 2] | 0;
      $77 = HEAP32[$tmp2 >> 2] | 0;
      $80 = HEAP32[$rc_Q31 >> 2] | 0;
      $83 = ___muldi3($77 | 0, (($77 | 0) < 0) << 31 >> 31 | 0, $80 | 0, (($80 | 0) < 0) << 31 >> 31 | 0) | 0;
      $85 = _bitshift64Ashr($83 | 0, tempRet0 | 0, 30) | 0;
      $87 = _i64Add($85 | 0, tempRet0 | 0, 1, 0) | 0;
      $89 = _bitshift64Ashr($87 | 0, tempRet0 | 0, 1) | 0;
      $cond94 = $76 - $89 | 0;
     }
    } else {
     $91 = HEAP32[$tmp2 >> 2] | 0;
     $94 = HEAP32[$rc_Q31 >> 2] | 0;
     $97 = ___muldi3($91 | 0, (($91 | 0) < 0) << 31 >> 31 | 0, $94 | 0, (($94 | 0) < 0) << 31 >> 31 | 0) | 0;
     $99 = _bitshift64Ashr($97 | 0, tempRet0 | 0, 30) | 0;
     $101 = _i64Add($99 | 0, tempRet0 | 0, 1, 0) | 0;
     $103 = _bitshift64Ashr($101 | 0, tempRet0 | 0, 1) | 0;
     if (($61 ^ -2147483648) & $103 & -2147483648 | 0) $cond94 = 2147483647; else {
      $105 = HEAP32[$tmp1 >> 2] | 0;
      $106 = HEAP32[$tmp2 >> 2] | 0;
      $109 = HEAP32[$rc_Q31 >> 2] | 0;
      $112 = ___muldi3($106 | 0, (($106 | 0) < 0) << 31 >> 31 | 0, $109 | 0, (($109 | 0) < 0) << 31 >> 31 | 0) | 0;
      $114 = _bitshift64Ashr($112 | 0, tempRet0 | 0, 30) | 0;
      $116 = _i64Add($114 | 0, tempRet0 | 0, 1, 0) | 0;
      $118 = _bitshift64Ashr($116 | 0, tempRet0 | 0, 1) | 0;
      $cond94 = $105 - $118 | 0;
     }
    }
    $122 = HEAP32[$rc_mult2 >> 2] | 0;
    $125 = ___muldi3($cond94 | 0, (($cond94 | 0) < 0) << 31 >> 31 | 0, $122 | 0, (($122 | 0) < 0) << 31 >> 31 | 0) | 0;
    $127 = _bitshift64Ashr($125 | 0, tempRet0 | 0, 1) | 0;
    $128 = tempRet0;
    $129 = HEAP32[$tmp1 >> 2] | 0;
    $130 = HEAP32[$tmp2 >> 2] | 0;
    $133 = HEAP32[$rc_Q31 >> 2] | 0;
    $136 = ___muldi3($130 | 0, (($130 | 0) < 0) << 31 >> 31 | 0, $133 | 0, (($133 | 0) < 0) << 31 >> 31 | 0) | 0;
    $138 = _bitshift64Ashr($136 | 0, tempRet0 | 0, 30) | 0;
    $140 = _i64Add($138 | 0, tempRet0 | 0, 1, 0) | 0;
    $142 = _bitshift64Ashr($140 | 0, tempRet0 | 0, 1) | 0;
    $144 = HEAP32[$tmp1 >> 2] | 0;
    if (!($129 - $142 & -2147483648)) {
     $145 = HEAP32[$tmp2 >> 2] | 0;
     $148 = HEAP32[$rc_Q31 >> 2] | 0;
     $151 = ___muldi3($145 | 0, (($145 | 0) < 0) << 31 >> 31 | 0, $148 | 0, (($148 | 0) < 0) << 31 >> 31 | 0) | 0;
     $153 = _bitshift64Ashr($151 | 0, tempRet0 | 0, 30) | 0;
     $155 = _i64Add($153 | 0, tempRet0 | 0, 1, 0) | 0;
     $157 = _bitshift64Ashr($155 | 0, tempRet0 | 0, 1) | 0;
     if ($144 & ($157 ^ -2147483648) & -2147483648 | 0) $cond159 = -2147483648; else {
      $159 = HEAP32[$tmp1 >> 2] | 0;
      $160 = HEAP32[$tmp2 >> 2] | 0;
      $163 = HEAP32[$rc_Q31 >> 2] | 0;
      $166 = ___muldi3($160 | 0, (($160 | 0) < 0) << 31 >> 31 | 0, $163 | 0, (($163 | 0) < 0) << 31 >> 31 | 0) | 0;
      $168 = _bitshift64Ashr($166 | 0, tempRet0 | 0, 30) | 0;
      $170 = _i64Add($168 | 0, tempRet0 | 0, 1, 0) | 0;
      $172 = _bitshift64Ashr($170 | 0, tempRet0 | 0, 1) | 0;
      $cond159 = $159 - $172 | 0;
     }
    } else {
     $174 = HEAP32[$tmp2 >> 2] | 0;
     $177 = HEAP32[$rc_Q31 >> 2] | 0;
     $180 = ___muldi3($174 | 0, (($174 | 0) < 0) << 31 >> 31 | 0, $177 | 0, (($177 | 0) < 0) << 31 >> 31 | 0) | 0;
     $182 = _bitshift64Ashr($180 | 0, tempRet0 | 0, 30) | 0;
     $184 = _i64Add($182 | 0, tempRet0 | 0, 1, 0) | 0;
     $186 = _bitshift64Ashr($184 | 0, tempRet0 | 0, 1) | 0;
     if (($144 ^ -2147483648) & $186 & -2147483648 | 0) $cond159 = 2147483647; else {
      $188 = HEAP32[$tmp1 >> 2] | 0;
      $189 = HEAP32[$tmp2 >> 2] | 0;
      $192 = HEAP32[$rc_Q31 >> 2] | 0;
      $195 = ___muldi3($189 | 0, (($189 | 0) < 0) << 31 >> 31 | 0, $192 | 0, (($192 | 0) < 0) << 31 >> 31 | 0) | 0;
      $197 = _bitshift64Ashr($195 | 0, tempRet0 | 0, 30) | 0;
      $199 = _i64Add($197 | 0, tempRet0 | 0, 1, 0) | 0;
      $201 = _bitshift64Ashr($199 | 0, tempRet0 | 0, 1) | 0;
      $cond159 = $188 - $201 | 0;
     }
    }
    $205 = HEAP32[$rc_mult2 >> 2] | 0;
    $208 = ___muldi3($cond159 | 0, (($cond159 | 0) < 0) << 31 >> 31 | 0, $205 | 0, (($205 | 0) < 0) << 31 >> 31 | 0) | 0;
    $211 = _i64Add($127 | 0, $128 | 0, $208 & 1 | 0, 0) | 0;
    $287 = $211;
    $290 = tempRet0;
   } else {
    if ($cmp45) {
     $213 = HEAP32[$tmp2 >> 2] | 0;
     $216 = HEAP32[$rc_Q31 >> 2] | 0;
     $219 = ___muldi3($213 | 0, (($213 | 0) < 0) << 31 >> 31 | 0, $216 | 0, (($216 | 0) < 0) << 31 >> 31 | 0) | 0;
     $221 = _bitshift64Ashr($219 | 0, tempRet0 | 0, 30) | 0;
     $223 = _i64Add($221 | 0, tempRet0 | 0, 1, 0) | 0;
     $225 = _bitshift64Ashr($223 | 0, tempRet0 | 0, 1) | 0;
     if ($61 & ($225 ^ -2147483648) & -2147483648 | 0) $cond226 = -2147483648; else {
      $227 = HEAP32[$tmp1 >> 2] | 0;
      $228 = HEAP32[$tmp2 >> 2] | 0;
      $231 = HEAP32[$rc_Q31 >> 2] | 0;
      $234 = ___muldi3($228 | 0, (($228 | 0) < 0) << 31 >> 31 | 0, $231 | 0, (($231 | 0) < 0) << 31 >> 31 | 0) | 0;
      $236 = _bitshift64Ashr($234 | 0, tempRet0 | 0, 30) | 0;
      $238 = _i64Add($236 | 0, tempRet0 | 0, 1, 0) | 0;
      $240 = _bitshift64Ashr($238 | 0, tempRet0 | 0, 1) | 0;
      $cond226 = $227 - $240 | 0;
     }
    } else {
     $242 = HEAP32[$tmp2 >> 2] | 0;
     $245 = HEAP32[$rc_Q31 >> 2] | 0;
     $248 = ___muldi3($242 | 0, (($242 | 0) < 0) << 31 >> 31 | 0, $245 | 0, (($245 | 0) < 0) << 31 >> 31 | 0) | 0;
     $250 = _bitshift64Ashr($248 | 0, tempRet0 | 0, 30) | 0;
     $252 = _i64Add($250 | 0, tempRet0 | 0, 1, 0) | 0;
     $254 = _bitshift64Ashr($252 | 0, tempRet0 | 0, 1) | 0;
     if (($61 ^ -2147483648) & $254 & -2147483648 | 0) $cond226 = 2147483647; else {
      $256 = HEAP32[$tmp1 >> 2] | 0;
      $257 = HEAP32[$tmp2 >> 2] | 0;
      $260 = HEAP32[$rc_Q31 >> 2] | 0;
      $263 = ___muldi3($257 | 0, (($257 | 0) < 0) << 31 >> 31 | 0, $260 | 0, (($260 | 0) < 0) << 31 >> 31 | 0) | 0;
      $265 = _bitshift64Ashr($263 | 0, tempRet0 | 0, 30) | 0;
      $267 = _i64Add($265 | 0, tempRet0 | 0, 1, 0) | 0;
      $269 = _bitshift64Ashr($267 | 0, tempRet0 | 0, 1) | 0;
      $cond226 = $256 - $269 | 0;
     }
    }
    $273 = HEAP32[$rc_mult2 >> 2] | 0;
    $276 = ___muldi3($cond226 | 0, (($cond226 | 0) < 0) << 31 >> 31 | 0, $273 | 0, (($273 | 0) < 0) << 31 >> 31 | 0) | 0;
    $279 = _bitshift64Ashr($276 | 0, tempRet0 | 0, (HEAP32[$mult2Q >> 2] | 0) - 1 | 0) | 0;
    $281 = _i64Add($279 | 0, tempRet0 | 0, 1, 0) | 0;
    $283 = _bitshift64Ashr($281 | 0, tempRet0 | 0, 1) | 0;
    $287 = $283;
    $290 = tempRet0;
   }
   $285 = $tmp64;
   HEAP32[$285 >> 2] = $287;
   HEAP32[$285 + 4 >> 2] = $290;
   $291 = $tmp64;
   $296 = HEAP32[$291 + 4 >> 2] | 0;
   $302 = $tmp64;
   $307 = HEAP32[$302 + 4 >> 2] | 0;
   if (($296 | 0) > 0 | ($296 | 0) == 0 & (HEAP32[$291 >> 2] | 0) >>> 0 > 2147483647 | (($307 | 0) < -1 | ($307 | 0) == -1 & (HEAP32[$302 >> 2] | 0) >>> 0 < 2147483648)) {
    label = 29;
    break L1;
   }
   HEAP32[(HEAP32[$A_QA$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2] = HEAP32[$tmp64 >> 2];
   $cmp245 = (HEAP32[$mult2Q >> 2] | 0) == 1;
   $322 = HEAP32[$tmp2 >> 2] | 0;
   $323 = HEAP32[$tmp1 >> 2] | 0;
   $326 = HEAP32[$rc_Q31 >> 2] | 0;
   $329 = ___muldi3($323 | 0, (($323 | 0) < 0) << 31 >> 31 | 0, $326 | 0, (($326 | 0) < 0) << 31 >> 31 | 0) | 0;
   $331 = _bitshift64Ashr($329 | 0, tempRet0 | 0, 30) | 0;
   $333 = _i64Add($331 | 0, tempRet0 | 0, 1, 0) | 0;
   $335 = _bitshift64Ashr($333 | 0, tempRet0 | 0, 1) | 0;
   $cmp257 = ($322 - $335 & -2147483648 | 0) == 0;
   $337 = HEAP32[$tmp2 >> 2] | 0;
   if ($cmp245) {
    if ($cmp257) {
     $338 = HEAP32[$tmp1 >> 2] | 0;
     $341 = HEAP32[$rc_Q31 >> 2] | 0;
     $344 = ___muldi3($338 | 0, (($338 | 0) < 0) << 31 >> 31 | 0, $341 | 0, (($341 | 0) < 0) << 31 >> 31 | 0) | 0;
     $346 = _bitshift64Ashr($344 | 0, tempRet0 | 0, 30) | 0;
     $348 = _i64Add($346 | 0, tempRet0 | 0, 1, 0) | 0;
     $350 = _bitshift64Ashr($348 | 0, tempRet0 | 0, 1) | 0;
     if ($337 & ($350 ^ -2147483648) & -2147483648 | 0) $cond308 = -2147483648; else {
      $352 = HEAP32[$tmp2 >> 2] | 0;
      $353 = HEAP32[$tmp1 >> 2] | 0;
      $356 = HEAP32[$rc_Q31 >> 2] | 0;
      $359 = ___muldi3($353 | 0, (($353 | 0) < 0) << 31 >> 31 | 0, $356 | 0, (($356 | 0) < 0) << 31 >> 31 | 0) | 0;
      $361 = _bitshift64Ashr($359 | 0, tempRet0 | 0, 30) | 0;
      $363 = _i64Add($361 | 0, tempRet0 | 0, 1, 0) | 0;
      $365 = _bitshift64Ashr($363 | 0, tempRet0 | 0, 1) | 0;
      $cond308 = $352 - $365 | 0;
     }
    } else {
     $367 = HEAP32[$tmp1 >> 2] | 0;
     $370 = HEAP32[$rc_Q31 >> 2] | 0;
     $373 = ___muldi3($367 | 0, (($367 | 0) < 0) << 31 >> 31 | 0, $370 | 0, (($370 | 0) < 0) << 31 >> 31 | 0) | 0;
     $375 = _bitshift64Ashr($373 | 0, tempRet0 | 0, 30) | 0;
     $377 = _i64Add($375 | 0, tempRet0 | 0, 1, 0) | 0;
     $379 = _bitshift64Ashr($377 | 0, tempRet0 | 0, 1) | 0;
     if (($337 ^ -2147483648) & $379 & -2147483648 | 0) $cond308 = 2147483647; else {
      $381 = HEAP32[$tmp2 >> 2] | 0;
      $382 = HEAP32[$tmp1 >> 2] | 0;
      $385 = HEAP32[$rc_Q31 >> 2] | 0;
      $388 = ___muldi3($382 | 0, (($382 | 0) < 0) << 31 >> 31 | 0, $385 | 0, (($385 | 0) < 0) << 31 >> 31 | 0) | 0;
      $390 = _bitshift64Ashr($388 | 0, tempRet0 | 0, 30) | 0;
      $392 = _i64Add($390 | 0, tempRet0 | 0, 1, 0) | 0;
      $394 = _bitshift64Ashr($392 | 0, tempRet0 | 0, 1) | 0;
      $cond308 = $381 - $394 | 0;
     }
    }
    $398 = HEAP32[$rc_mult2 >> 2] | 0;
    $401 = ___muldi3($cond308 | 0, (($cond308 | 0) < 0) << 31 >> 31 | 0, $398 | 0, (($398 | 0) < 0) << 31 >> 31 | 0) | 0;
    $403 = _bitshift64Ashr($401 | 0, tempRet0 | 0, 1) | 0;
    $404 = tempRet0;
    $405 = HEAP32[$tmp2 >> 2] | 0;
    $406 = HEAP32[$tmp1 >> 2] | 0;
    $409 = HEAP32[$rc_Q31 >> 2] | 0;
    $412 = ___muldi3($406 | 0, (($406 | 0) < 0) << 31 >> 31 | 0, $409 | 0, (($409 | 0) < 0) << 31 >> 31 | 0) | 0;
    $414 = _bitshift64Ashr($412 | 0, tempRet0 | 0, 30) | 0;
    $416 = _i64Add($414 | 0, tempRet0 | 0, 1, 0) | 0;
    $418 = _bitshift64Ashr($416 | 0, tempRet0 | 0, 1) | 0;
    $420 = HEAP32[$tmp2 >> 2] | 0;
    if (!($405 - $418 & -2147483648)) {
     $421 = HEAP32[$tmp1 >> 2] | 0;
     $424 = HEAP32[$rc_Q31 >> 2] | 0;
     $427 = ___muldi3($421 | 0, (($421 | 0) < 0) << 31 >> 31 | 0, $424 | 0, (($424 | 0) < 0) << 31 >> 31 | 0) | 0;
     $429 = _bitshift64Ashr($427 | 0, tempRet0 | 0, 30) | 0;
     $431 = _i64Add($429 | 0, tempRet0 | 0, 1, 0) | 0;
     $433 = _bitshift64Ashr($431 | 0, tempRet0 | 0, 1) | 0;
     if ($420 & ($433 ^ -2147483648) & -2147483648 | 0) $cond373 = -2147483648; else {
      $435 = HEAP32[$tmp2 >> 2] | 0;
      $436 = HEAP32[$tmp1 >> 2] | 0;
      $439 = HEAP32[$rc_Q31 >> 2] | 0;
      $442 = ___muldi3($436 | 0, (($436 | 0) < 0) << 31 >> 31 | 0, $439 | 0, (($439 | 0) < 0) << 31 >> 31 | 0) | 0;
      $444 = _bitshift64Ashr($442 | 0, tempRet0 | 0, 30) | 0;
      $446 = _i64Add($444 | 0, tempRet0 | 0, 1, 0) | 0;
      $448 = _bitshift64Ashr($446 | 0, tempRet0 | 0, 1) | 0;
      $cond373 = $435 - $448 | 0;
     }
    } else {
     $450 = HEAP32[$tmp1 >> 2] | 0;
     $453 = HEAP32[$rc_Q31 >> 2] | 0;
     $456 = ___muldi3($450 | 0, (($450 | 0) < 0) << 31 >> 31 | 0, $453 | 0, (($453 | 0) < 0) << 31 >> 31 | 0) | 0;
     $458 = _bitshift64Ashr($456 | 0, tempRet0 | 0, 30) | 0;
     $460 = _i64Add($458 | 0, tempRet0 | 0, 1, 0) | 0;
     $462 = _bitshift64Ashr($460 | 0, tempRet0 | 0, 1) | 0;
     if (($420 ^ -2147483648) & $462 & -2147483648 | 0) $cond373 = 2147483647; else {
      $464 = HEAP32[$tmp2 >> 2] | 0;
      $465 = HEAP32[$tmp1 >> 2] | 0;
      $468 = HEAP32[$rc_Q31 >> 2] | 0;
      $471 = ___muldi3($465 | 0, (($465 | 0) < 0) << 31 >> 31 | 0, $468 | 0, (($468 | 0) < 0) << 31 >> 31 | 0) | 0;
      $473 = _bitshift64Ashr($471 | 0, tempRet0 | 0, 30) | 0;
      $475 = _i64Add($473 | 0, tempRet0 | 0, 1, 0) | 0;
      $477 = _bitshift64Ashr($475 | 0, tempRet0 | 0, 1) | 0;
      $cond373 = $464 - $477 | 0;
     }
    }
    $481 = HEAP32[$rc_mult2 >> 2] | 0;
    $484 = ___muldi3($cond373 | 0, (($cond373 | 0) < 0) << 31 >> 31 | 0, $481 | 0, (($481 | 0) < 0) << 31 >> 31 | 0) | 0;
    $487 = _i64Add($403 | 0, $404 | 0, $484 & 1 | 0, 0) | 0;
    $563 = $487;
    $566 = tempRet0;
   } else {
    if ($cmp257) {
     $489 = HEAP32[$tmp1 >> 2] | 0;
     $492 = HEAP32[$rc_Q31 >> 2] | 0;
     $495 = ___muldi3($489 | 0, (($489 | 0) < 0) << 31 >> 31 | 0, $492 | 0, (($492 | 0) < 0) << 31 >> 31 | 0) | 0;
     $497 = _bitshift64Ashr($495 | 0, tempRet0 | 0, 30) | 0;
     $499 = _i64Add($497 | 0, tempRet0 | 0, 1, 0) | 0;
     $501 = _bitshift64Ashr($499 | 0, tempRet0 | 0, 1) | 0;
     if ($337 & ($501 ^ -2147483648) & -2147483648 | 0) $cond440 = -2147483648; else {
      $503 = HEAP32[$tmp2 >> 2] | 0;
      $504 = HEAP32[$tmp1 >> 2] | 0;
      $507 = HEAP32[$rc_Q31 >> 2] | 0;
      $510 = ___muldi3($504 | 0, (($504 | 0) < 0) << 31 >> 31 | 0, $507 | 0, (($507 | 0) < 0) << 31 >> 31 | 0) | 0;
      $512 = _bitshift64Ashr($510 | 0, tempRet0 | 0, 30) | 0;
      $514 = _i64Add($512 | 0, tempRet0 | 0, 1, 0) | 0;
      $516 = _bitshift64Ashr($514 | 0, tempRet0 | 0, 1) | 0;
      $cond440 = $503 - $516 | 0;
     }
    } else {
     $518 = HEAP32[$tmp1 >> 2] | 0;
     $521 = HEAP32[$rc_Q31 >> 2] | 0;
     $524 = ___muldi3($518 | 0, (($518 | 0) < 0) << 31 >> 31 | 0, $521 | 0, (($521 | 0) < 0) << 31 >> 31 | 0) | 0;
     $526 = _bitshift64Ashr($524 | 0, tempRet0 | 0, 30) | 0;
     $528 = _i64Add($526 | 0, tempRet0 | 0, 1, 0) | 0;
     $530 = _bitshift64Ashr($528 | 0, tempRet0 | 0, 1) | 0;
     if (($337 ^ -2147483648) & $530 & -2147483648 | 0) $cond440 = 2147483647; else {
      $532 = HEAP32[$tmp2 >> 2] | 0;
      $533 = HEAP32[$tmp1 >> 2] | 0;
      $536 = HEAP32[$rc_Q31 >> 2] | 0;
      $539 = ___muldi3($533 | 0, (($533 | 0) < 0) << 31 >> 31 | 0, $536 | 0, (($536 | 0) < 0) << 31 >> 31 | 0) | 0;
      $541 = _bitshift64Ashr($539 | 0, tempRet0 | 0, 30) | 0;
      $543 = _i64Add($541 | 0, tempRet0 | 0, 1, 0) | 0;
      $545 = _bitshift64Ashr($543 | 0, tempRet0 | 0, 1) | 0;
      $cond440 = $532 - $545 | 0;
     }
    }
    $549 = HEAP32[$rc_mult2 >> 2] | 0;
    $552 = ___muldi3($cond440 | 0, (($cond440 | 0) < 0) << 31 >> 31 | 0, $549 | 0, (($549 | 0) < 0) << 31 >> 31 | 0) | 0;
    $555 = _bitshift64Ashr($552 | 0, tempRet0 | 0, (HEAP32[$mult2Q >> 2] | 0) - 1 | 0) | 0;
    $557 = _i64Add($555 | 0, tempRet0 | 0, 1, 0) | 0;
    $559 = _bitshift64Ashr($557 | 0, tempRet0 | 0, 1) | 0;
    $563 = $559;
    $566 = tempRet0;
   }
   $561 = $tmp64;
   HEAP32[$561 >> 2] = $563;
   HEAP32[$561 + 4 >> 2] = $566;
   $567 = $tmp64;
   $572 = HEAP32[$567 + 4 >> 2] | 0;
   $578 = $tmp64;
   $583 = HEAP32[$578 + 4 >> 2] | 0;
   if (($572 | 0) > 0 | ($572 | 0) == 0 & (HEAP32[$567 >> 2] | 0) >>> 0 > 2147483647 | (($583 | 0) < -1 | ($583 | 0) == -1 & (HEAP32[$578 >> 2] | 0) >>> 0 < 2147483648)) {
    label = 49;
    break L1;
   }
   HEAP32[(HEAP32[$A_QA$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - (HEAP32[$n >> 2] | 0) - 1 << 2) >> 2] = HEAP32[$tmp64 >> 2];
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + -1;
 }
 if ((label | 0) == 5) {
  HEAP32[$retval >> 2] = 0;
  $627 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $627 | 0;
 } else if ((label | 0) == 7) {
  HEAP32[$retval >> 2] = 0;
  $627 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $627 | 0;
 } else if ((label | 0) == 29) {
  HEAP32[$retval >> 2] = 0;
  $627 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $627 | 0;
 } else if ((label | 0) == 49) {
  HEAP32[$retval >> 2] = 0;
  $627 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $627 | 0;
 } else if ((label | 0) == 52) {
  if (!$cmp1) if ((HEAP32[(HEAP32[$A_QA$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) >= -16773022) {
   HEAP32[$rc_Q31 >> 2] = 0 - (HEAP32[HEAP32[$A_QA$addr >> 2] >> 2] << 7);
   $605 = HEAP32[$rc_Q31 >> 2] | 0;
   $608 = HEAP32[$rc_Q31 >> 2] | 0;
   $611 = ___muldi3($605 | 0, (($605 | 0) < 0) << 31 >> 31 | 0, $608 | 0, (($608 | 0) < 0) << 31 >> 31 | 0) | 0;
   $613 = _bitshift64Ashr($611 | 0, tempRet0 | 0, 32) | 0;
   HEAP32[$rc_mult1_Q30 >> 2] = 1073741824 - $613;
   $615 = HEAP32[$invGain_Q30 >> 2] | 0;
   $618 = HEAP32[$rc_mult1_Q30 >> 2] | 0;
   $621 = ___muldi3($615 | 0, (($615 | 0) < 0) << 31 >> 31 | 0, $618 | 0, (($618 | 0) < 0) << 31 >> 31 | 0) | 0;
   $623 = _bitshift64Ashr($621 | 0, tempRet0 | 0, 32) | 0;
   HEAP32[$invGain_Q30 >> 2] = $623 << 2;
   if ((HEAP32[$invGain_Q30 >> 2] | 0) < 107374) {
    HEAP32[$retval >> 2] = 0;
    $627 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $627 | 0;
   } else {
    HEAP32[$retval >> 2] = HEAP32[$invGain_Q30 >> 2];
    $627 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $627 | 0;
   }
  }
  HEAP32[$retval >> 2] = 0;
  $627 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $627 | 0;
 }
 return 0;
}
function _interp_bits2pulses($m, $start, $end, $skip_start, $bits1, $bits2, $thresh, $cap, $total, $_balance, $skip_rsv, $intensity, $intensity_rsv, $dual_stereo, $dual_stereo_rsv, $bits, $ebits, $fine_priority, $C, $LM, $ec, $encode, $prev, $signalBandwidth) {
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $skip_start = $skip_start | 0;
 $bits1 = $bits1 | 0;
 $bits2 = $bits2 | 0;
 $thresh = $thresh | 0;
 $cap = $cap | 0;
 $total = $total | 0;
 $_balance = $_balance | 0;
 $skip_rsv = $skip_rsv | 0;
 $intensity = $intensity | 0;
 $intensity_rsv = $intensity_rsv | 0;
 $dual_stereo = $dual_stereo | 0;
 $dual_stereo_rsv = $dual_stereo_rsv | 0;
 $bits = $bits | 0;
 $ebits = $ebits | 0;
 $fine_priority = $fine_priority | 0;
 $C = $C | 0;
 $LM = $LM | 0;
 $ec = $ec | 0;
 $encode = $encode | 0;
 $prev = $prev | 0;
 $signalBandwidth = $signalBandwidth | 0;
 var $$sink = 0, $190 = 0, $203 = 0, $291 = 0, $312 = 0, $36 = 0, $39 = 0, $7 = 0, $C$addr = 0, $LM$addr = 0, $N = 0, $N0 = 0, $NClogN = 0, $_balance$addr = 0, $add117 = 0, $add206 = 0, $alloc_floor = 0, $arrayidx183$sink = 0, $arrayidx256 = 0, $arrayidx288 = 0, $arrayidx422 = 0, $arrayidx457 = 0, $balance = 0, $band_bits = 0, $band_width = 0, $bit = 0, $bits$addr = 0, $bits1$addr = 0, $bits2$addr = 0, $call221 = 0, $cap$addr = 0, $codedBands = 0, $cond = 0, $cond107 = 0, $cond128 = 0, $cond198 = 0, $cond287 = 0, $cond321 = 0, $cond384 = 0, $cond409 = 0, $cond434 = 0, $cond456 = 0, $cond60 = 0, $den = 0, $depth_threshold = 0, $done = 0, $dual_stereo$addr = 0, $dual_stereo_rsv$addr = 0, $ebits$addr = 0, $ec$addr = 0, $encode$addr = 0, $end$addr = 0, $excess = 0, $extra_bits = 0, $extra_fine = 0, $fine_priority$addr = 0, $hi = 0, $i = 0, $intensity$addr = 0, $intensity_rsv$addr = 0, $j = 0, $left = 0, $lo = 0, $logM = 0, $m$addr = 0, $mid = 0, $mul146 = 0, $mul241 = 0, $mul255 = 0, $mul324 = 0, $mul391 = 0, $mul413 = 0, $mul84 = 0, $offset = 0, $percoeff = 0, $prev$addr = 0, $psum = 0, $rem = 0, $shl421 = 0, $shr388 = 0, $signalBandwidth$addr = 0, $skip_rsv$addr = 0, $skip_start$addr = 0, $start$addr = 0, $stereo = 0, $thresh$addr = 0, $tmp = 0, $tmp265 = 0, $tmp35 = 0, $total$addr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 $m$addr = sp + 212 | 0;
 $start$addr = sp + 208 | 0;
 $end$addr = sp + 204 | 0;
 $skip_start$addr = sp + 200 | 0;
 $bits1$addr = sp + 196 | 0;
 $bits2$addr = sp + 192 | 0;
 $thresh$addr = sp + 188 | 0;
 $cap$addr = sp + 184 | 0;
 $total$addr = sp + 180 | 0;
 $_balance$addr = sp + 176 | 0;
 $skip_rsv$addr = sp + 172 | 0;
 $intensity$addr = sp + 168 | 0;
 $intensity_rsv$addr = sp + 164 | 0;
 $dual_stereo$addr = sp + 160 | 0;
 $dual_stereo_rsv$addr = sp + 156 | 0;
 $bits$addr = sp + 152 | 0;
 $ebits$addr = sp + 148 | 0;
 $fine_priority$addr = sp + 144 | 0;
 $C$addr = sp + 140 | 0;
 $LM$addr = sp + 136 | 0;
 $ec$addr = sp + 132 | 0;
 $encode$addr = sp + 128 | 0;
 $prev$addr = sp + 124 | 0;
 $signalBandwidth$addr = sp + 120 | 0;
 $psum = sp + 116 | 0;
 $lo = sp + 112 | 0;
 $hi = sp + 108 | 0;
 $i = sp + 104 | 0;
 $j = sp + 100 | 0;
 $logM = sp + 96 | 0;
 $stereo = sp + 92 | 0;
 $codedBands = sp + 88 | 0;
 $alloc_floor = sp + 84 | 0;
 $left = sp + 80 | 0;
 $percoeff = sp + 76 | 0;
 $done = sp + 72 | 0;
 $balance = sp + 68 | 0;
 $mid = sp + 64 | 0;
 $tmp = sp + 60 | 0;
 $tmp35 = sp + 56 | 0;
 $band_width = sp + 52 | 0;
 $band_bits = sp + 48 | 0;
 $rem = sp + 44 | 0;
 $depth_threshold = sp + 40 | 0;
 $tmp265 = sp + 36 | 0;
 $N0 = sp + 32 | 0;
 $N = sp + 28 | 0;
 $den = sp + 24 | 0;
 $offset = sp + 20 | 0;
 $NClogN = sp + 16 | 0;
 $excess = sp + 12 | 0;
 $bit = sp + 8 | 0;
 $extra_fine = sp + 4 | 0;
 $extra_bits = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$skip_start$addr >> 2] = $skip_start;
 HEAP32[$bits1$addr >> 2] = $bits1;
 HEAP32[$bits2$addr >> 2] = $bits2;
 HEAP32[$thresh$addr >> 2] = $thresh;
 HEAP32[$cap$addr >> 2] = $cap;
 HEAP32[$total$addr >> 2] = $total;
 HEAP32[$_balance$addr >> 2] = $_balance;
 HEAP32[$skip_rsv$addr >> 2] = $skip_rsv;
 HEAP32[$intensity$addr >> 2] = $intensity;
 HEAP32[$intensity_rsv$addr >> 2] = $intensity_rsv;
 HEAP32[$dual_stereo$addr >> 2] = $dual_stereo;
 HEAP32[$dual_stereo_rsv$addr >> 2] = $dual_stereo_rsv;
 HEAP32[$bits$addr >> 2] = $bits;
 HEAP32[$ebits$addr >> 2] = $ebits;
 HEAP32[$fine_priority$addr >> 2] = $fine_priority;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$ec$addr >> 2] = $ec;
 HEAP32[$encode$addr >> 2] = $encode;
 HEAP32[$prev$addr >> 2] = $prev;
 HEAP32[$signalBandwidth$addr >> 2] = $signalBandwidth;
 HEAP32[$codedBands >> 2] = -1;
 HEAP32[$alloc_floor >> 2] = HEAP32[$C$addr >> 2] << 3;
 HEAP32[$stereo >> 2] = (HEAP32[$C$addr >> 2] | 0) > 1 & 1;
 HEAP32[$logM >> 2] = HEAP32[$LM$addr >> 2] << 3;
 HEAP32[$lo >> 2] = 0;
 HEAP32[$hi >> 2] = 64;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 6) break;
  HEAP32[$mid >> 2] = (HEAP32[$lo >> 2] | 0) + (HEAP32[$hi >> 2] | 0) >> 1;
  HEAP32[$psum >> 2] = 0;
  HEAP32[$done >> 2] = 0;
  HEAP32[$j >> 2] = HEAP32[$end$addr >> 2];
  while (1) {
   $7 = HEAP32[$j >> 2] | 0;
   HEAP32[$j >> 2] = $7 + -1;
   if (($7 | 0) <= (HEAP32[$start$addr >> 2] | 0)) break;
   HEAP32[$tmp >> 2] = (HEAP32[(HEAP32[$bits1$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + ((Math_imul(HEAP32[$mid >> 2] | 0, HEAP32[(HEAP32[$bits2$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0) >> 6);
   if (!(HEAP32[$done >> 2] | 0 ? 1 : (HEAP32[$tmp >> 2] | 0) >= (HEAP32[(HEAP32[$thresh$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0))) {
    if ((HEAP32[$tmp >> 2] | 0) < (HEAP32[$alloc_floor >> 2] | 0)) continue;
    HEAP32[$psum >> 2] = (HEAP32[$psum >> 2] | 0) + (HEAP32[$alloc_floor >> 2] | 0);
    continue;
   }
   HEAP32[$done >> 2] = 1;
   if ((HEAP32[$tmp >> 2] | 0) < (HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0)) $cond = HEAP32[$tmp >> 2] | 0; else $cond = HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0;
   HEAP32[$psum >> 2] = (HEAP32[$psum >> 2] | 0) + $cond;
  }
  $36 = HEAP32[$mid >> 2] | 0;
  if ((HEAP32[$psum >> 2] | 0) > (HEAP32[$total$addr >> 2] | 0)) HEAP32[$hi >> 2] = $36; else HEAP32[$lo >> 2] = $36;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$psum >> 2] = 0;
 HEAP32[$done >> 2] = 0;
 HEAP32[$j >> 2] = HEAP32[$end$addr >> 2];
 while (1) {
  $39 = HEAP32[$j >> 2] | 0;
  HEAP32[$j >> 2] = $39 + -1;
  if (($39 | 0) <= (HEAP32[$start$addr >> 2] | 0)) break;
  HEAP32[$tmp35 >> 2] = (HEAP32[(HEAP32[$bits1$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + ((Math_imul(HEAP32[$lo >> 2] | 0, HEAP32[(HEAP32[$bits2$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0) >> 6);
  do if (HEAP32[$done >> 2] | 0 ? 1 : (HEAP32[$tmp35 >> 2] | 0) >= (HEAP32[(HEAP32[$thresh$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0)) HEAP32[$done >> 2] = 1; else if ((HEAP32[$tmp35 >> 2] | 0) >= (HEAP32[$alloc_floor >> 2] | 0)) {
   HEAP32[$tmp35 >> 2] = HEAP32[$alloc_floor >> 2];
   break;
  } else {
   HEAP32[$tmp35 >> 2] = 0;
   break;
  } while (0);
  if ((HEAP32[$tmp35 >> 2] | 0) < (HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0)) $cond60 = HEAP32[$tmp35 >> 2] | 0; else $cond60 = HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0;
  HEAP32[$tmp35 >> 2] = $cond60;
  HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = HEAP32[$tmp35 >> 2];
  HEAP32[$psum >> 2] = (HEAP32[$psum >> 2] | 0) + (HEAP32[$tmp35 >> 2] | 0);
 }
 HEAP32[$codedBands >> 2] = HEAP32[$end$addr >> 2];
 while (1) {
  HEAP32[$j >> 2] = (HEAP32[$codedBands >> 2] | 0) - 1;
  if ((HEAP32[$j >> 2] | 0) <= (HEAP32[$skip_start$addr >> 2] | 0)) {
   label = 29;
   break;
  }
  HEAP32[$left >> 2] = (HEAP32[$total$addr >> 2] | 0) - (HEAP32[$psum >> 2] | 0);
  HEAP32[$percoeff >> 2] = _celt_udiv_138(HEAP32[$left >> 2] | 0, (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$codedBands >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0) | 0) | 0;
  $mul84 = Math_imul((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$codedBands >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0) | 0, HEAP32[$percoeff >> 2] | 0) | 0;
  HEAP32[$left >> 2] = (HEAP32[$left >> 2] | 0) - $mul84;
  if (((HEAP32[$left >> 2] | 0) - ((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0)) | 0) > 0) $cond107 = (HEAP32[$left >> 2] | 0) - ((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0)) | 0; else $cond107 = 0;
  HEAP32[$rem >> 2] = $cond107;
  HEAP32[$band_width >> 2] = (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$codedBands >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0);
  $add117 = (HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + (Math_imul(HEAP32[$percoeff >> 2] | 0, HEAP32[$band_width >> 2] | 0) | 0) | 0;
  HEAP32[$band_bits >> 2] = $add117 + (HEAP32[$rem >> 2] | 0);
  if ((HEAP32[(HEAP32[$thresh$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) > ((HEAP32[$alloc_floor >> 2] | 0) + 8 | 0)) $cond128 = HEAP32[(HEAP32[$thresh$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0; else $cond128 = (HEAP32[$alloc_floor >> 2] | 0) + 8 | 0;
  if ((HEAP32[$band_bits >> 2] | 0) >= ($cond128 | 0)) {
   if (HEAP32[$encode$addr >> 2] | 0) {
    if ((HEAP32[$codedBands >> 2] | 0) > 17) HEAP32[$depth_threshold >> 2] = (HEAP32[$j >> 2] | 0) < (HEAP32[$prev$addr >> 2] | 0) ? 7 : 9; else HEAP32[$depth_threshold >> 2] = 0;
    if ((HEAP32[$codedBands >> 2] | 0) <= ((HEAP32[$start$addr >> 2] | 0) + 2 | 0)) {
     label = 43;
     break;
    }
    $mul146 = Math_imul(HEAP32[$depth_threshold >> 2] | 0, HEAP32[$band_width >> 2] | 0) | 0;
    if ((HEAP32[$band_bits >> 2] | 0) > ($mul146 << HEAP32[$LM$addr >> 2] << 3 >> 4 | 0)) if ((HEAP32[$j >> 2] | 0) <= (HEAP32[$signalBandwidth$addr >> 2] | 0)) {
     label = 43;
     break;
    }
    _ec_enc_bit_logp(HEAP32[$ec$addr >> 2] | 0, 0, 1);
   } else if (_ec_dec_bit_logp(HEAP32[$ec$addr >> 2] | 0, 1) | 0) break;
   HEAP32[$psum >> 2] = (HEAP32[$psum >> 2] | 0) + 8;
   HEAP32[$band_bits >> 2] = (HEAP32[$band_bits >> 2] | 0) - 8;
  }
  HEAP32[$psum >> 2] = (HEAP32[$psum >> 2] | 0) - ((HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + (HEAP32[$intensity_rsv$addr >> 2] | 0));
  if ((HEAP32[$intensity_rsv$addr >> 2] | 0) > 0) HEAP32[$intensity_rsv$addr >> 2] = HEAPU8[31636 + ((HEAP32[$j >> 2] | 0) - (HEAP32[$start$addr >> 2] | 0)) >> 0];
  HEAP32[$psum >> 2] = (HEAP32[$psum >> 2] | 0) + (HEAP32[$intensity_rsv$addr >> 2] | 0);
  if ((HEAP32[$band_bits >> 2] | 0) >= (HEAP32[$alloc_floor >> 2] | 0)) {
   HEAP32[$psum >> 2] = (HEAP32[$psum >> 2] | 0) + (HEAP32[$alloc_floor >> 2] | 0);
   $$sink = HEAP32[$alloc_floor >> 2] | 0;
   $arrayidx183$sink = (HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) | 0;
  } else {
   $$sink = 0;
   $arrayidx183$sink = (HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) | 0;
  }
  HEAP32[$arrayidx183$sink >> 2] = $$sink;
  HEAP32[$codedBands >> 2] = (HEAP32[$codedBands >> 2] | 0) + -1;
 }
 if ((label | 0) == 29) HEAP32[$total$addr >> 2] = (HEAP32[$total$addr >> 2] | 0) + (HEAP32[$skip_rsv$addr >> 2] | 0); else if ((label | 0) == 43) _ec_enc_bit_logp(HEAP32[$ec$addr >> 2] | 0, 1, 1);
 do if ((HEAP32[$intensity_rsv$addr >> 2] | 0) > 0) {
  if (!(HEAP32[$encode$addr >> 2] | 0)) {
   $190 = HEAP32[$start$addr >> 2] | 0;
   $add206 = $190 + (_ec_dec_uint(HEAP32[$ec$addr >> 2] | 0, (HEAP32[$codedBands >> 2] | 0) + 1 - (HEAP32[$start$addr >> 2] | 0) | 0) | 0) | 0;
   HEAP32[HEAP32[$intensity$addr >> 2] >> 2] = $add206;
   break;
  }
  if ((HEAP32[HEAP32[$intensity$addr >> 2] >> 2] | 0) < (HEAP32[$codedBands >> 2] | 0)) $cond198 = HEAP32[HEAP32[$intensity$addr >> 2] >> 2] | 0; else $cond198 = HEAP32[$codedBands >> 2] | 0;
  HEAP32[HEAP32[$intensity$addr >> 2] >> 2] = $cond198;
  _ec_enc_uint(HEAP32[$ec$addr >> 2] | 0, (HEAP32[HEAP32[$intensity$addr >> 2] >> 2] | 0) - (HEAP32[$start$addr >> 2] | 0) | 0, (HEAP32[$codedBands >> 2] | 0) + 1 - (HEAP32[$start$addr >> 2] | 0) | 0);
 } else HEAP32[HEAP32[$intensity$addr >> 2] >> 2] = 0; while (0);
 if ((HEAP32[HEAP32[$intensity$addr >> 2] >> 2] | 0) <= (HEAP32[$start$addr >> 2] | 0)) {
  HEAP32[$total$addr >> 2] = (HEAP32[$total$addr >> 2] | 0) + (HEAP32[$dual_stereo_rsv$addr >> 2] | 0);
  HEAP32[$dual_stereo_rsv$addr >> 2] = 0;
 }
 do if ((HEAP32[$dual_stereo_rsv$addr >> 2] | 0) > 0) {
  $203 = HEAP32[$ec$addr >> 2] | 0;
  if (HEAP32[$encode$addr >> 2] | 0) {
   _ec_enc_bit_logp($203, HEAP32[HEAP32[$dual_stereo$addr >> 2] >> 2] | 0, 1);
   break;
  } else {
   $call221 = _ec_dec_bit_logp($203, 1) | 0;
   HEAP32[HEAP32[$dual_stereo$addr >> 2] >> 2] = $call221;
   break;
  }
 } else HEAP32[HEAP32[$dual_stereo$addr >> 2] >> 2] = 0; while (0);
 HEAP32[$left >> 2] = (HEAP32[$total$addr >> 2] | 0) - (HEAP32[$psum >> 2] | 0);
 HEAP32[$percoeff >> 2] = _celt_udiv_138(HEAP32[$left >> 2] | 0, (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$codedBands >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0) | 0) | 0;
 $mul241 = Math_imul((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$codedBands >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0) | 0, HEAP32[$percoeff >> 2] | 0) | 0;
 HEAP32[$left >> 2] = (HEAP32[$left >> 2] | 0) - $mul241;
 HEAP32[$j >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$codedBands >> 2] | 0)) break;
  $mul255 = Math_imul(HEAP32[$percoeff >> 2] | 0, (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0) | 0;
  $arrayidx256 = (HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) | 0;
  HEAP32[$arrayidx256 >> 2] = (HEAP32[$arrayidx256 >> 2] | 0) + $mul255;
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAP32[$j >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$codedBands >> 2] | 0)) break;
  if ((HEAP32[$left >> 2] | 0) < ((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0)) $cond287 = HEAP32[$left >> 2] | 0; else $cond287 = (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0;
  HEAP32[$tmp265 >> 2] = $cond287;
  $arrayidx288 = (HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) | 0;
  HEAP32[$arrayidx288 >> 2] = (HEAP32[$arrayidx288 >> 2] | 0) + (HEAP32[$tmp265 >> 2] | 0);
  HEAP32[$left >> 2] = (HEAP32[$left >> 2] | 0) - (HEAP32[$tmp265 >> 2] | 0);
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAP32[$balance >> 2] = 0;
 HEAP32[$j >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$codedBands >> 2] | 0)) break;
  HEAP32[$N0 >> 2] = (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0);
  HEAP32[$N >> 2] = HEAP32[$N0 >> 2] << HEAP32[$LM$addr >> 2];
  HEAP32[$bit >> 2] = (HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + (HEAP32[$balance >> 2] | 0);
  $291 = HEAP32[$bit >> 2] | 0;
  if ((HEAP32[$N >> 2] | 0) > 1) {
   if (($291 - (HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0) > 0) $cond321 = (HEAP32[$bit >> 2] | 0) - (HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0; else $cond321 = 0;
   HEAP32[$excess >> 2] = $cond321;
   HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = (HEAP32[$bit >> 2] | 0) - (HEAP32[$excess >> 2] | 0);
   $mul324 = Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
   if ((HEAP32[$C$addr >> 2] | 0) == 2 & (HEAP32[$N >> 2] | 0) > 2) if (HEAP32[HEAP32[$dual_stereo$addr >> 2] >> 2] | 0) $312 = 0; else $312 = (HEAP32[$j >> 2] | 0) < (HEAP32[HEAP32[$intensity$addr >> 2] >> 2] | 0); else $312 = 0;
   HEAP32[$den >> 2] = $mul324 + ($312 ? 1 : 0);
   HEAP32[$NClogN >> 2] = Math_imul(HEAP32[$den >> 2] | 0, (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 56 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) + (HEAP32[$logM >> 2] | 0) | 0) | 0;
   HEAP32[$offset >> 2] = (HEAP32[$NClogN >> 2] >> 1) - ((HEAP32[$den >> 2] | 0) * 21 | 0);
   if ((HEAP32[$N >> 2] | 0) == 2) HEAP32[$offset >> 2] = (HEAP32[$offset >> 2] | 0) + (HEAP32[$den >> 2] << 3 >> 2);
   if (((HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + (HEAP32[$offset >> 2] | 0) | 0) < (HEAP32[$den >> 2] << 1 << 3 | 0)) HEAP32[$offset >> 2] = (HEAP32[$offset >> 2] | 0) + (HEAP32[$NClogN >> 2] >> 2); else if (((HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + (HEAP32[$offset >> 2] | 0) | 0) < ((HEAP32[$den >> 2] | 0) * 3 << 3 | 0)) HEAP32[$offset >> 2] = (HEAP32[$offset >> 2] | 0) + (HEAP32[$NClogN >> 2] >> 3);
   if (0 > ((HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + (HEAP32[$offset >> 2] | 0) + (HEAP32[$den >> 2] << 2) | 0)) $cond384 = 0; else $cond384 = (HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + (HEAP32[$offset >> 2] | 0) + (HEAP32[$den >> 2] << 2) | 0;
   HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = $cond384;
   $shr388 = (_celt_udiv_138(HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0, HEAP32[$den >> 2] | 0) | 0) >>> 3;
   HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = $shr388;
   $mul391 = Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0;
   if (($mul391 | 0) > (HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] >> 3 | 0)) HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] >> HEAP32[$stereo >> 2] >> 3;
   if ((HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) < 8) $cond409 = HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0; else $cond409 = 8;
   HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = $cond409;
   $mul413 = Math_imul(HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0, HEAP32[$den >> 2] << 3) | 0;
   HEAP32[(HEAP32[$fine_priority$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = ($mul413 | 0) >= ((HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) + (HEAP32[$offset >> 2] | 0) | 0) & 1;
   $shl421 = (Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0) << 3;
   $arrayidx422 = (HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) | 0;
   HEAP32[$arrayidx422 >> 2] = (HEAP32[$arrayidx422 >> 2] | 0) - $shl421;
  } else {
   if (0 > ($291 - (HEAP32[$C$addr >> 2] << 3) | 0)) $cond434 = 0; else $cond434 = (HEAP32[$bit >> 2] | 0) - (HEAP32[$C$addr >> 2] << 3) | 0;
   HEAP32[$excess >> 2] = $cond434;
   HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = (HEAP32[$bit >> 2] | 0) - (HEAP32[$excess >> 2] | 0);
   HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = 0;
   HEAP32[(HEAP32[$fine_priority$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = 1;
  }
  if ((HEAP32[$excess >> 2] | 0) > 0) {
   if ((HEAP32[$excess >> 2] >> (HEAP32[$stereo >> 2] | 0) + 3 | 0) < (8 - (HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0)) $cond456 = HEAP32[$excess >> 2] >> (HEAP32[$stereo >> 2] | 0) + 3; else $cond456 = 8 - (HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0;
   HEAP32[$extra_fine >> 2] = $cond456;
   $arrayidx457 = (HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) | 0;
   HEAP32[$arrayidx457 >> 2] = (HEAP32[$arrayidx457 >> 2] | 0) + (HEAP32[$extra_fine >> 2] | 0);
   HEAP32[$extra_bits >> 2] = (Math_imul(HEAP32[$extra_fine >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 3;
   HEAP32[(HEAP32[$fine_priority$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = (HEAP32[$extra_bits >> 2] | 0) >= ((HEAP32[$excess >> 2] | 0) - (HEAP32[$balance >> 2] | 0) | 0) & 1;
   HEAP32[$excess >> 2] = (HEAP32[$excess >> 2] | 0) - (HEAP32[$extra_bits >> 2] | 0);
  }
  HEAP32[$balance >> 2] = HEAP32[$excess >> 2];
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAP32[HEAP32[$_balance$addr >> 2] >> 2] = HEAP32[$balance >> 2];
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] >> HEAP32[$stereo >> 2] >> 3;
  HEAP32[(HEAP32[$bits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = 0;
  HEAP32[(HEAP32[$fine_priority$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = (HEAP32[(HEAP32[$ebits$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) < 1 & 1;
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return HEAP32[$codedBands >> 2] | 0;
}
function _silk_NSQ_del_dec_c($psEncC, $NSQ, $psIndices, $x16, $pulses, $PredCoef_Q12, $LTPCoef_Q14, $AR_Q13, $HarmShapeGain_Q14, $Tilt_Q14, $LF_shp_Q14, $Gains_Q16, $pitchL, $Lambda_Q10, $LTP_scale_Q14) {
 $psEncC = $psEncC | 0;
 $NSQ = $NSQ | 0;
 $psIndices = $psIndices | 0;
 $x16 = $x16 | 0;
 $pulses = $pulses | 0;
 $PredCoef_Q12 = $PredCoef_Q12 | 0;
 $LTPCoef_Q14 = $LTPCoef_Q14 | 0;
 $AR_Q13 = $AR_Q13 | 0;
 $HarmShapeGain_Q14 = $HarmShapeGain_Q14 | 0;
 $Tilt_Q14 = $Tilt_Q14 | 0;
 $LF_shp_Q14 = $LF_shp_Q14 | 0;
 $Gains_Q16 = $Gains_Q16 | 0;
 $pitchL = $pitchL | 0;
 $Lambda_Q10 = $Lambda_Q10 | 0;
 $LTP_scale_Q14 = $LTP_scale_Q14 | 0;
 var $227 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $239 = 0, $242 = 0, $245 = 0, $246 = 0, $247 = 0, $249 = 0, $250 = 0, $3 = 0, $AR_Q13$addr = 0, $AR_shp_Q13 = 0, $A_Q12 = 0, $B_Q14 = 0, $Gain_Q10 = 0, $Gains_Q16$addr = 0, $HarmShapeFIRPacked_Q14 = 0, $HarmShapeGain_Q14$addr = 0, $LF_shp_Q14$addr = 0, $LSF_interpolation_flag = 0, $LTPCoef_Q14$addr = 0, $LTP_scale_Q14$addr = 0, $Lambda_Q10$addr = 0, $NSQ$addr = 0, $PredCoef_Q12$addr = 0, $RD_Q10117 = 0, $RDmin_Q10 = 0, $Tilt_Q14$addr = 0, $Winner_ind = 0, $add156 = 0, $add185 = 0, $add216 = 0, $add343 = 0, $add371 = 0, $add399 = 0, $arrayidx253 = 0, $cond229 = 0, $cond413 = 0, $conv266 = 0, $decisionDelay = 0, $delayedGain_Q10 = 0, $i = 0, $k = 0, $lag = 0, $last_smple_idx = 0, $mul147 = 0, $mul176 = 0, $mul207 = 0, $mul335 = 0, $mul363 = 0, $mul391 = 0, $offset_Q10 = 0, $pitchL$addr = 0, $psDD = 0, $psEncC$addr = 0, $psIndices$addr = 0, $pulses$addr = 0, $pxq = 0, $saved_stack = 0, $smpl_buf_idx = 0, $start_idx = 0, $subfr = 0, $vla = 0, $vla46 = 0, $vla50 = 0, $vla52 = 0, $x16$addr = 0, dest = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 304 | 0;
 $psEncC$addr = sp + 296 | 0;
 $NSQ$addr = sp + 292 | 0;
 $psIndices$addr = sp + 288 | 0;
 $x16$addr = sp + 284 | 0;
 $pulses$addr = sp + 280 | 0;
 $PredCoef_Q12$addr = sp + 276 | 0;
 $LTPCoef_Q14$addr = sp + 272 | 0;
 $AR_Q13$addr = sp + 268 | 0;
 $HarmShapeGain_Q14$addr = sp + 264 | 0;
 $Tilt_Q14$addr = sp + 260 | 0;
 $LF_shp_Q14$addr = sp + 256 | 0;
 $Gains_Q16$addr = sp + 252 | 0;
 $pitchL$addr = sp + 248 | 0;
 $Lambda_Q10$addr = sp + 244 | 0;
 $LTP_scale_Q14$addr = sp + 240 | 0;
 $i = sp + 236 | 0;
 $k = sp + 232 | 0;
 $lag = sp + 228 | 0;
 $start_idx = sp + 224 | 0;
 $LSF_interpolation_flag = sp + 220 | 0;
 $Winner_ind = sp + 216 | 0;
 $subfr = sp + 212 | 0;
 $last_smple_idx = sp + 208 | 0;
 $smpl_buf_idx = sp + 204 | 0;
 $decisionDelay = sp + 200 | 0;
 $A_Q12 = sp + 196 | 0;
 $B_Q14 = sp + 192 | 0;
 $AR_shp_Q13 = sp + 188 | 0;
 $pxq = sp + 184 | 0;
 $HarmShapeFIRPacked_Q14 = sp + 180 | 0;
 $offset_Q10 = sp + 176 | 0;
 $RDmin_Q10 = sp + 172 | 0;
 $Gain_Q10 = sp + 168 | 0;
 $psDD = sp + 164 | 0;
 $saved_stack = sp + 160 | 0;
 $delayedGain_Q10 = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$NSQ$addr >> 2] = $NSQ;
 HEAP32[$psIndices$addr >> 2] = $psIndices;
 HEAP32[$x16$addr >> 2] = $x16;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$PredCoef_Q12$addr >> 2] = $PredCoef_Q12;
 HEAP32[$LTPCoef_Q14$addr >> 2] = $LTPCoef_Q14;
 HEAP32[$AR_Q13$addr >> 2] = $AR_Q13;
 HEAP32[$HarmShapeGain_Q14$addr >> 2] = $HarmShapeGain_Q14;
 HEAP32[$Tilt_Q14$addr >> 2] = $Tilt_Q14;
 HEAP32[$LF_shp_Q14$addr >> 2] = $LF_shp_Q14;
 HEAP32[$Gains_Q16$addr >> 2] = $Gains_Q16;
 HEAP32[$pitchL$addr >> 2] = $pitchL;
 HEAP32[$Lambda_Q10$addr >> 2] = $Lambda_Q10;
 HEAP32[$LTP_scale_Q14$addr >> 2] = $LTP_scale_Q14;
 HEAP32[$lag >> 2] = HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4328 >> 2];
 $3 = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($3 * 1300 | 0) | 0) + 15 & -16) | 0;
 _memset($vla | 0, 0, (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] | 0) * 1300 | 0) | 0;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] | 0)) break;
  HEAP32[$psDD >> 2] = $vla + ((HEAP32[$k >> 2] | 0) * 1300 | 0);
  HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2] = (HEAP32[$k >> 2] | 0) + (HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 34 >> 0] | 0) & 3;
  HEAP32[(HEAP32[$psDD >> 2] | 0) + 1292 >> 2] = HEAP32[(HEAP32[$psDD >> 2] | 0) + 1288 >> 2];
  HEAP32[(HEAP32[$psDD >> 2] | 0) + 1296 >> 2] = 0;
  HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] = HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2];
  HEAP32[(HEAP32[$psDD >> 2] | 0) + 1284 >> 2] = HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4324 >> 2];
  HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 >> 2] = HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0) - 1 << 2) >> 2];
  dest = HEAP32[$psDD >> 2] | 0;
  src = (HEAP32[$NSQ$addr >> 2] | 0) + 3840 | 0;
  stop = dest + 64 | 0;
  do {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  } while ((dest | 0) < (stop | 0));
  dest = (HEAP32[$psDD >> 2] | 0) + 1184 | 0;
  src = (HEAP32[$NSQ$addr >> 2] | 0) + 4224 | 0;
  stop = dest + 96 | 0;
  do {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  } while ((dest | 0) < (stop | 0));
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$offset_Q10 >> 2] = HEAP16[22956 + (HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] >> 1 << 2) + (HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 30 >> 0] << 1) >> 1];
 HEAP32[$smpl_buf_idx >> 2] = 0;
 HEAP32[$decisionDelay >> 2] = _silk_min_int_423(40, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0) | 0;
 L5 : do if ((HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] | 0) == 2) {
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0)) break L5;
   HEAP32[$decisionDelay >> 2] = _silk_min_int_423(HEAP32[$decisionDelay >> 2] | 0, (HEAP32[(HEAP32[$pitchL$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) - 2 - 1 | 0) | 0;
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
 } else if ((HEAP32[$lag >> 2] | 0) > 0) HEAP32[$decisionDelay >> 2] = _silk_min_int_423(HEAP32[$decisionDelay >> 2] | 0, (HEAP32[$lag >> 2] | 0) - 2 - 1 | 0) | 0; while (0);
 if ((HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 31 >> 0] | 0) == 4) HEAP32[$LSF_interpolation_flag >> 2] = 0; else HEAP32[$LSF_interpolation_flag >> 2] = 1;
 $vla46 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0) << 2) | 0) + 15 & -16) | 0;
 $vla50 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0) << 1) | 0) + 15 & -16) | 0;
 $vla52 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[$pxq >> 2] = (HEAP32[$NSQ$addr >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] << 1);
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2];
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2];
 HEAP32[$subfr >> 2] = 0;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  HEAP32[$A_Q12 >> 2] = (HEAP32[$PredCoef_Q12$addr >> 2] | 0) + ((HEAP32[$k >> 2] >> 1 | 1 - (HEAP32[$LSF_interpolation_flag >> 2] | 0)) << 4 << 1);
  HEAP32[$B_Q14 >> 2] = (HEAP32[$LTPCoef_Q14$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 5 << 1);
  HEAP32[$AR_shp_Q13 >> 2] = (HEAP32[$AR_Q13$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 24 << 1);
  HEAP32[$HarmShapeFIRPacked_Q14 >> 2] = HEAP32[(HEAP32[$HarmShapeGain_Q14$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] >> 2;
  HEAP32[$HarmShapeFIRPacked_Q14 >> 2] = HEAP32[$HarmShapeFIRPacked_Q14 >> 2] | HEAP32[(HEAP32[$HarmShapeGain_Q14$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] >> 1 << 16;
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4348 >> 2] = 0;
  if ((HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] | 0) == 2) {
   HEAP32[$lag >> 2] = HEAP32[(HEAP32[$pitchL$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2];
   if (!(HEAP32[$k >> 2] & 3 - (HEAP32[$LSF_interpolation_flag >> 2] << 1))) {
    if ((HEAP32[$k >> 2] | 0) == 2) {
     HEAP32[$RDmin_Q10 >> 2] = HEAP32[$vla + 1296 >> 2];
     HEAP32[$Winner_ind >> 2] = 0;
     HEAP32[$i >> 2] = 1;
     while (1) {
      if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] | 0)) break;
      if ((HEAP32[$vla + ((HEAP32[$i >> 2] | 0) * 1300 | 0) + 1296 >> 2] | 0) < (HEAP32[$RDmin_Q10 >> 2] | 0)) {
       HEAP32[$RDmin_Q10 >> 2] = HEAP32[$vla + ((HEAP32[$i >> 2] | 0) * 1300 | 0) + 1296 >> 2];
       HEAP32[$Winner_ind >> 2] = HEAP32[$i >> 2];
      }
      HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
     }
     HEAP32[$i >> 2] = 0;
     while (1) {
      if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] | 0)) break;
      if ((HEAP32[$i >> 2] | 0) != (HEAP32[$Winner_ind >> 2] | 0)) {
       $RD_Q10117 = $vla + ((HEAP32[$i >> 2] | 0) * 1300 | 0) + 1296 | 0;
       HEAP32[$RD_Q10117 >> 2] = (HEAP32[$RD_Q10117 >> 2] | 0) + 134217727;
      }
      HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
     }
     HEAP32[$psDD >> 2] = $vla + ((HEAP32[$Winner_ind >> 2] | 0) * 1300 | 0);
     HEAP32[$last_smple_idx >> 2] = (HEAP32[$smpl_buf_idx >> 2] | 0) + (HEAP32[$decisionDelay >> 2] | 0);
     HEAP32[$i >> 2] = 0;
     while (1) {
      if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$decisionDelay >> 2] | 0)) break;
      HEAP32[$last_smple_idx >> 2] = ((HEAP32[$last_smple_idx >> 2] | 0) - 1 | 0) % 40 | 0;
      if ((HEAP32[$last_smple_idx >> 2] | 0) < 0) HEAP32[$last_smple_idx >> 2] = (HEAP32[$last_smple_idx >> 2] | 0) + 40;
      HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$decisionDelay >> 2] | 0)) >> 0] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 544 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 9) + 1 >> 1;
      $mul147 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 16, (HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + 4 >> 2] & 65535) << 16 >> 16) | 0;
      $add156 = $mul147 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535, (HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
      if ((($add156 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0, (HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 13) + 1 >> 1 | 0) > 32767) $cond229 = 32767; else {
       $mul176 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 16, (HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + 4 >> 2] & 65535) << 16 >> 16) | 0;
       $add185 = $mul176 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535, (HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
       if ((($add185 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0, (HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 13) + 1 >> 1 | 0) < -32768) $cond229 = -32768; else {
        $mul207 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 16, (HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + 4 >> 2] & 65535) << 16 >> 16) | 0;
        $add216 = $mul207 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535, (HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
        $cond229 = ($add216 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0, (HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + 4 >> 2] >> 15) + 1 >> 1) | 0) >> 13) + 1 >> 1;
       }
      }
      HEAP16[(HEAP32[$pxq >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$decisionDelay >> 2] | 0) << 1) >> 1] = $cond229;
      HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0) - (HEAP32[$decisionDelay >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] = HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2];
      HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
     }
     HEAP32[$subfr >> 2] = 0;
    }
    HEAP32[$start_idx >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0) - (HEAP32[$lag >> 2] | 0) - (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0) - 2;
    $arrayidx253 = (HEAP32[$NSQ$addr >> 2] | 0) + ((HEAP32[$start_idx >> 2] | 0) + (Math_imul(HEAP32[$k >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0) | 0) << 1) | 0;
    _silk_LPC_analysis_filter($vla50 + (HEAP32[$start_idx >> 2] << 1) | 0, $arrayidx253, HEAP32[$A_Q12 >> 2] | 0, (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0) - (HEAP32[$start_idx >> 2] | 0) | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 5088 >> 2] | 0);
    HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2];
    HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4348 >> 2] = 1;
   }
  }
  _silk_nsq_del_dec_scale_states(HEAP32[$psEncC$addr >> 2] | 0, HEAP32[$NSQ$addr >> 2] | 0, $vla, HEAP32[$x16$addr >> 2] | 0, $vla52, $vla50, $vla46, HEAP32[$k >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] | 0, HEAP32[$LTP_scale_Q14$addr >> 2] | 0, HEAP32[$Gains_Q16$addr >> 2] | 0, HEAP32[$pitchL$addr >> 2] | 0, HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] | 0, HEAP32[$decisionDelay >> 2] | 0);
  $227 = HEAP32[$NSQ$addr >> 2] | 0;
  $conv266 = HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] | 0;
  $230 = HEAP32[$pulses$addr >> 2] | 0;
  $231 = HEAP32[$pxq >> 2] | 0;
  $232 = HEAP32[$A_Q12 >> 2] | 0;
  $233 = HEAP32[$B_Q14 >> 2] | 0;
  $234 = HEAP32[$AR_shp_Q13 >> 2] | 0;
  $235 = HEAP32[$lag >> 2] | 0;
  $236 = HEAP32[$HarmShapeFIRPacked_Q14 >> 2] | 0;
  $239 = HEAP32[(HEAP32[$Tilt_Q14$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
  $242 = HEAP32[(HEAP32[$LF_shp_Q14$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
  $245 = HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
  $246 = HEAP32[$Lambda_Q10$addr >> 2] | 0;
  $247 = HEAP32[$offset_Q10 >> 2] | 0;
  $249 = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0;
  $250 = HEAP32[$subfr >> 2] | 0;
  HEAP32[$subfr >> 2] = $250 + 1;
  _silk_noise_shape_quantizer_del_dec($227, $vla, $conv266, $vla52, $230, $231, $vla46, $delayedGain_Q10, $232, $233, $234, $235, $236, $239, $242, $245, $246, $247, $249, $250, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4632 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4668 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] | 0, $smpl_buf_idx, HEAP32[$decisionDelay >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 5088 >> 2] | 0);
  HEAP32[$x16$addr >> 2] = (HEAP32[$x16$addr >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] << 1);
  HEAP32[$pulses$addr >> 2] = (HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0);
  HEAP32[$pxq >> 2] = (HEAP32[$pxq >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] << 1);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$RDmin_Q10 >> 2] = HEAP32[$vla + 1296 >> 2];
 HEAP32[$Winner_ind >> 2] = 0;
 HEAP32[$k >> 2] = 1;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] | 0)) break;
  if ((HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 1300 | 0) + 1296 >> 2] | 0) < (HEAP32[$RDmin_Q10 >> 2] | 0)) {
   HEAP32[$RDmin_Q10 >> 2] = HEAP32[$vla + ((HEAP32[$k >> 2] | 0) * 1300 | 0) + 1296 >> 2];
   HEAP32[$Winner_ind >> 2] = HEAP32[$k >> 2];
  }
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$psDD >> 2] = $vla + ((HEAP32[$Winner_ind >> 2] | 0) * 1300 | 0);
 HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 34 >> 0] = HEAP32[(HEAP32[$psDD >> 2] | 0) + 1292 >> 2];
 HEAP32[$last_smple_idx >> 2] = (HEAP32[$smpl_buf_idx >> 2] | 0) + (HEAP32[$decisionDelay >> 2] | 0);
 HEAP32[$Gain_Q10 >> 2] = HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0) - 1 << 2) >> 2] >> 6;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$decisionDelay >> 2] | 0)) break;
  HEAP32[$last_smple_idx >> 2] = ((HEAP32[$last_smple_idx >> 2] | 0) - 1 | 0) % 40 | 0;
  if ((HEAP32[$last_smple_idx >> 2] | 0) < 0) HEAP32[$last_smple_idx >> 2] = (HEAP32[$last_smple_idx >> 2] | 0) + 40;
  HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$decisionDelay >> 2] | 0)) >> 0] = (HEAP32[(HEAP32[$psDD >> 2] | 0) + 544 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 9) + 1 >> 1;
  $mul335 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 16, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
  $add343 = $mul335 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  if ((($add343 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0, (HEAP32[$Gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond413 = 32767; else {
   $mul363 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 16, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
   $add371 = $mul363 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   if ((($add371 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0, (HEAP32[$Gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond413 = -32768; else {
    $mul391 = Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] >> 16, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
    $add399 = $mul391 + ((Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] & 65535, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    $cond413 = ($add399 + (Math_imul(HEAP32[(HEAP32[$psDD >> 2] | 0) + 704 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2] | 0, (HEAP32[$Gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
   }
  }
  HEAP16[(HEAP32[$pxq >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$decisionDelay >> 2] | 0) << 1) >> 1] = $cond413;
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0) - (HEAP32[$decisionDelay >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] = HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[$last_smple_idx >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 dest = (HEAP32[$NSQ$addr >> 2] | 0) + 3840 | 0;
 src = (HEAP32[$psDD >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] << 2) | 0;
 stop = dest + 64 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 dest = (HEAP32[$NSQ$addr >> 2] | 0) + 4224 | 0;
 src = (HEAP32[$psDD >> 2] | 0) + 1184 | 0;
 stop = dest + 96 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] = HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2];
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4324 >> 2] = HEAP32[(HEAP32[$psDD >> 2] | 0) + 1284 >> 2];
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4328 >> 2] = HEAP32[(HEAP32[$pitchL$addr >> 2] | 0) + ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0) - 1 << 2) >> 2];
 _memmove(HEAP32[$NSQ$addr >> 2] | 0, (HEAP32[$NSQ$addr >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] << 1) | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] << 1 | 0) | 0;
 _memmove((HEAP32[$NSQ$addr >> 2] | 0) + 1280 | 0, (HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] << 2) | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] << 2 | 0) | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_CNG($psDec, $psDecCtrl, $frame, $length) {
 $psDec = $psDec | 0;
 $psDecCtrl = $psDecCtrl | 0;
 $frame = $frame | 0;
 $length = $length | 0;
 var $256 = 0, $A_Q12 = 0, $CNG_smth_Gain_Q1670 = 0, $LPC_pred_Q10 = 0, $add134 = 0, $add153 = 0, $add160 = 0, $add570 = 0, $add598 = 0, $add626 = 0, $add661 = 0, $add689 = 0, $add717 = 0, $add752 = 0, $add78 = 0, $add780 = 0, $add808 = 0, $add97 = 0, $arrayidx20 = 0, $arrayidx49 = 0, $cmp475 = 0, $cond466 = 0, $cond486 = 0, $cond507 = 0, $cond526 = 0, $cond546 = 0, $cond552 = 0, $cond640 = 0, $cond731 = 0, $cond822 = 0, $cond827 = 0, $conv556 = 0, $conv647 = 0, $conv738 = 0, $frame$addr = 0, $gain_Q10 = 0, $gain_Q16 = 0, $i = 0, $length$addr = 0, $max_Gain_Q16 = 0, $mul122 = 0, $mul128 = 0, $mul145 = 0, $mul186 = 0, $mul203 = 0, $mul220 = 0, $mul237 = 0, $mul254 = 0, $mul271 = 0, $mul288 = 0, $mul305 = 0, $mul322 = 0, $mul339 = 0, $mul360 = 0, $mul377 = 0, $mul394 = 0, $mul411 = 0, $mul428 = 0, $mul445 = 0, $mul562 = 0, $mul590 = 0, $mul618 = 0, $mul653 = 0, $mul681 = 0, $mul709 = 0, $mul744 = 0, $mul772 = 0, $mul800 = 0, $mul85 = 0, $psCNG = 0, $psDec$addr = 0, $psDecCtrl$addr = 0, $saved_stack = 0, $subfr = 0, $vla = 0, dest = 0, label = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $psDec$addr = sp + 44 | 0;
 $psDecCtrl$addr = sp + 40 | 0;
 $frame$addr = sp + 36 | 0;
 $length$addr = sp + 32 | 0;
 $i = sp + 28 | 0;
 $subfr = sp + 24 | 0;
 $LPC_pred_Q10 = sp + 20 | 0;
 $max_Gain_Q16 = sp + 16 | 0;
 $gain_Q16 = sp + 12 | 0;
 $gain_Q10 = sp + 8 | 0;
 $A_Q12 = sp + 48 | 0;
 $psCNG = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$psDecCtrl$addr >> 2] = $psDecCtrl;
 HEAP32[$frame$addr >> 2] = $frame;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$psCNG >> 2] = (HEAP32[$psDec$addr >> 2] | 0) + 2772;
 if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] | 0) != (HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1384 >> 2] | 0)) {
  _silk_CNG_Reset(HEAP32[$psDec$addr >> 2] | 0);
  HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1384 >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2];
 }
 L4 : do if (!(HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4160 >> 2] | 0)) if (!(HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4164 >> 2] | 0)) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0)) break;
   $arrayidx20 = (HEAP32[$psCNG >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 1) | 0;
   HEAP16[$arrayidx20 >> 1] = (HEAP16[$arrayidx20 >> 1] | 0) + ((((HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2344 + (HEAP32[$i >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[$psCNG >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 1) >> 1] | 0) >> 16) * 16348 | 0) + (((HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2344 + (HEAP32[$i >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[$psCNG >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 1) >> 1] | 0) & 65535) * 16348 >> 16));
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$max_Gain_Q16 >> 2] = 0;
  HEAP32[$subfr >> 2] = 0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0)) break;
   if ((HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + (HEAP32[$i >> 2] << 2) >> 2] | 0) > (HEAP32[$max_Gain_Q16 >> 2] | 0)) {
    HEAP32[$max_Gain_Q16 >> 2] = HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + (HEAP32[$i >> 2] << 2) >> 2];
    HEAP32[$subfr >> 2] = HEAP32[$i >> 2];
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  _memmove((HEAP32[$psCNG >> 2] | 0) + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] << 2) | 0, HEAP32[$psCNG >> 2] | 0, (Math_imul((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) - 1 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] | 0) | 0) << 2 | 0) | 0;
  $arrayidx49 = (HEAP32[$psDec$addr >> 2] | 0) + 4 + ((Math_imul(HEAP32[$subfr >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] | 0) | 0) << 2) | 0;
  _memcpy(HEAP32[$psCNG >> 2] | 0, $arrayidx49 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] << 2 | 0) | 0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0)) break L4;
   $CNG_smth_Gain_Q1670 = (HEAP32[$psCNG >> 2] | 0) + 1376 | 0;
   HEAP32[$CNG_smth_Gain_Q1670 >> 2] = (HEAP32[$CNG_smth_Gain_Q1670 >> 2] | 0) + ((((HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + (HEAP32[$i >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] | 0) >> 16) * 4634 | 0) + (((HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + (HEAP32[$i >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] | 0) & 65535) * 4634 >> 16));
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 if (!(HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4160 >> 2] | 0)) {
  _memset((HEAP32[$psCNG >> 2] | 0) + 1312 | 0, 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] << 2 | 0) | 0;
  STACKTOP = sp;
  return;
 }
 $add78 = (HEAP32[$length$addr >> 2] | 0) + 16 | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add78 << 2) | 0) + 15 & -16) | 0;
 $mul85 = Math_imul(HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 56 >> 1] >> 16, (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 72 + 4 >> 2] & 65535) << 16 >> 16) | 0;
 $add97 = $mul85 + ((Math_imul(HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 56 >> 1] & 65535, (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 72 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
 HEAP32[$gain_Q16 >> 2] = $add97 + (Math_imul(HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 56 >> 1] | 0, (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 72 + 4 >> 2] >> 15) + 1 >> 1) | 0);
 if ((HEAP32[$gain_Q16 >> 2] | 0) >= 2097152) label = 19; else if ((HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] | 0) > 8388608) label = 19; else {
  $mul128 = Math_imul(HEAP32[$gain_Q16 >> 2] >> 16, (HEAP32[$gain_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add134 = $mul128 + ((Math_imul(HEAP32[$gain_Q16 >> 2] & 65535, (HEAP32[$gain_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  HEAP32[$gain_Q16 >> 2] = $add134 + (Math_imul(HEAP32[$gain_Q16 >> 2] | 0, (HEAP32[$gain_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  $mul145 = Math_imul(HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] >> 16, (HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] & 65535) << 16 >> 16) | 0;
  $add153 = $mul145 + ((Math_imul(HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] & 65535, (HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add160 = $add153 + (Math_imul(HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] | 0, (HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[$gain_Q16 >> 2] = $add160 - (HEAP32[$gain_Q16 >> 2] << 5);
  HEAP32[$gain_Q16 >> 2] = (_silk_SQRT_APPROX_545(HEAP32[$gain_Q16 >> 2] | 0) | 0) << 8;
 }
 if ((label | 0) == 19) {
  HEAP32[$gain_Q16 >> 2] = Math_imul(HEAP32[$gain_Q16 >> 2] >> 16, HEAP32[$gain_Q16 >> 2] >> 16) | 0;
  $mul122 = Math_imul(HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] >> 16, HEAP32[(HEAP32[$psCNG >> 2] | 0) + 1376 >> 2] >> 16) | 0;
  HEAP32[$gain_Q16 >> 2] = $mul122 - (HEAP32[$gain_Q16 >> 2] << 5);
  HEAP32[$gain_Q16 >> 2] = (_silk_SQRT_APPROX_545(HEAP32[$gain_Q16 >> 2] | 0) | 0) << 16;
 }
 HEAP32[$gain_Q10 >> 2] = HEAP32[$gain_Q16 >> 2] >> 6;
 _silk_CNG_exc($vla + 64 | 0, HEAP32[$psCNG >> 2] | 0, HEAP32[$length$addr >> 2] | 0, (HEAP32[$psCNG >> 2] | 0) + 1380 | 0);
 _silk_NLSF2A($A_Q12, (HEAP32[$psCNG >> 2] | 0) + 1280 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4168 >> 2] | 0);
 dest = $vla;
 src = (HEAP32[$psCNG >> 2] | 0) + 1312 | 0;
 stop = dest + 64 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$LPC_pred_Q10 >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] >> 1;
  $mul186 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] >> 16, HEAP16[$A_Q12 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul186 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] & 65535, HEAP16[$A_Q12 >> 1] | 0) | 0) >> 16));
  $mul203 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 2 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 2 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul203 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 2 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 2 >> 1] | 0) | 0) >> 16));
  $mul220 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 3 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 4 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul220 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 3 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 4 >> 1] | 0) | 0) >> 16));
  $mul237 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 4 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 6 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul237 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 4 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 6 >> 1] | 0) | 0) >> 16));
  $mul254 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 5 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 8 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul254 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 5 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 8 >> 1] | 0) | 0) >> 16));
  $mul271 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 6 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 10 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul271 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 6 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 10 >> 1] | 0) | 0) >> 16));
  $mul288 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 7 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 12 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul288 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 7 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 12 >> 1] | 0) | 0) >> 16));
  $mul305 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 8 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 14 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul305 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 8 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 14 >> 1] | 0) | 0) >> 16));
  $mul322 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 9 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 16 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul322 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 9 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 16 >> 1] | 0) | 0) >> 16));
  $mul339 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 10 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 18 >> 1] | 0) | 0;
  HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul339 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 10 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 18 >> 1] | 0) | 0) >> 16));
  if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0) == 16) {
   $mul360 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 11 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 20 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul360 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 11 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 20 >> 1] | 0) | 0) >> 16));
   $mul377 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 12 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 22 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul377 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 12 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 22 >> 1] | 0) | 0) >> 16));
   $mul394 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 13 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 24 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul394 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 13 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 24 >> 1] | 0) | 0) >> 16));
   $mul411 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 14 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 26 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul411 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 14 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 26 >> 1] | 0) | 0) >> 16));
   $mul428 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 15 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 28 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul428 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 15 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 28 >> 1] | 0) | 0) >> 16));
   $mul445 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 16 << 2) >> 2] >> 16, HEAP16[$A_Q12 + 30 >> 1] | 0) | 0;
   HEAP32[$LPC_pred_Q10 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] | 0) + ($mul445 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) - 16 << 2) >> 2] & 65535, HEAP16[$A_Q12 + 30 >> 1] | 0) | 0) >> 16));
  }
  if ((HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727) $cond466 = 134217727; else $cond466 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
  $256 = HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0;
  $cmp475 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727;
  if (!((HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0) + ($cond466 << 4) & -2147483648)) {
   if ($cmp475) $cond486 = 134217727; else $cond486 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
   if ($256 & $cond486 << 4 & -2147483648 | 0) $cond552 = -2147483648; else {
    if ((HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727) $cond507 = 134217727; else $cond507 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
    $cond552 = (HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0) + ($cond507 << 4) | 0;
   }
  } else {
   if ($cmp475) $cond526 = 134217727; else $cond526 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
   if (!(($256 | $cond526 << 4) & -2147483648)) $cond552 = 2147483647; else {
    if ((HEAP32[$LPC_pred_Q10 >> 2] | 0) > 134217727) $cond546 = 134217727; else $cond546 = (HEAP32[$LPC_pred_Q10 >> 2] | 0) < -134217728 ? -134217728 : HEAP32[$LPC_pred_Q10 >> 2] | 0;
    $cond552 = (HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0) + ($cond546 << 4) | 0;
   }
  }
  HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = $cond552;
  $conv556 = HEAP16[(HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0;
  $mul562 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
  $add570 = $mul562 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  if ((($add570 + (Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond640 = 32767; else {
   $mul590 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
   $add598 = $mul590 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   if ((($add598 + (Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond640 = -32768; else {
    $mul618 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
    $add626 = $mul618 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    $cond640 = ($add626 + (Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
   }
  }
  if (($conv556 + $cond640 | 0) > 32767) $cond827 = 32767; else {
   $conv647 = HEAP16[(HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0;
   $mul653 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
   $add661 = $mul653 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   if ((($add661 + (Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond731 = 32767; else {
    $mul681 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
    $add689 = $mul681 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    if ((($add689 + (Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond731 = -32768; else {
     $mul709 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
     $add717 = $mul709 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
     $cond731 = ($add717 + (Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
    }
   }
   if (($conv647 + $cond731 | 0) < -32768) $cond827 = -32768; else {
    $conv738 = HEAP16[(HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0;
    $mul744 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
    $add752 = $mul744 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    if ((($add752 + (Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond822 = 32767; else {
     $mul772 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
     $add780 = $mul772 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
     if ((($add780 + (Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond822 = -32768; else {
      $mul800 = Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] >> 16, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
      $add808 = $mul800 + ((Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] & 65535, (HEAP32[$gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
      $cond822 = ($add808 + (Math_imul(HEAP32[$vla + (16 + (HEAP32[$i >> 2] | 0) << 2) >> 2] | 0, (HEAP32[$gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
     }
    }
    $cond827 = $conv738 + $cond822 | 0;
   }
  }
  HEAP16[(HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $cond827;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 dest = (HEAP32[$psCNG >> 2] | 0) + 1312 | 0;
 src = $vla + (HEAP32[$length$addr >> 2] << 2) | 0;
 stop = dest + 64 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_stereo_LR_to_MS($state, $x1, $x2, $ix, $mid_only_flag, $mid_side_rates_bps, $total_rate_bps, $prev_speech_act_Q8, $toMono, $fs_kHz, $frame_length) {
 $state = $state | 0;
 $x1 = $x1 | 0;
 $x2 = $x2 | 0;
 $ix = $ix | 0;
 $mid_only_flag = $mid_only_flag | 0;
 $mid_side_rates_bps = $mid_side_rates_bps | 0;
 $total_rate_bps = $total_rate_bps | 0;
 $prev_speech_act_Q8 = $prev_speech_act_Q8 | 0;
 $toMono = $toMono | 0;
 $fs_kHz = $fs_kHz | 0;
 $frame_length = $frame_length | 0;
 var $29 = 0, $HP_ratio_Q14 = 0, $LP_ratio_Q14 = 0, $add = 0, $add459 = 0, $add550 = 0, $and121 = 0, $arrayidx39 = 0, $arrayidx42 = 0, $call154 = 0, $call369 = 0, $cond191 = 0, $cond33 = 0, $cond510 = 0, $cond601 = 0, $conv214 = 0, $delta0_Q13 = 0, $delta1_Q13 = 0, $deltaw_Q24 = 0, $denom_Q16 = 0, $diff = 0, $frac_3_Q16 = 0, $frac_Q16 = 0, $frame_length$addr = 0, $fs_kHz$addr = 0, $is10msFrame = 0, $ix$addr = 0, $mid = 0, $mid_only_flag$addr = 0, $mid_side_rates_bps$addr = 0, $min_mid_rate_bps = 0, $mul115 = 0, $mul171 = 0, $mul203 = 0, $mul232 = 0, $mul277 = 0, $mul417 = 0, $mul452 = 0, $mul463 = 0, $mul478 = 0, $mul543 = 0, $mul554 = 0, $mul569 = 0, $n = 0, $pred0_Q13 = 0, $pred1_Q13 = 0, $pred_Q13 = 0, $prev_speech_act_Q8$addr = 0, $sMid = 0, $sMid37 = 0, $sSide = 0, $sSide40 = 0, $saved_stack = 0, $shr112 = 0, $silent_side_len = 0, $smooth_coef_Q16 = 0, $state$addr = 0, $sub145 = 0, $sum = 0, $toMono$addr = 0, $total_rate_bps$addr = 0, $vla = 0, $vla43 = 0, $vla44 = 0, $vla73 = 0, $vla74 = 0, $w_Q24 = 0, $width_Q14 = 0, $x1$addr = 0, $x2$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $state$addr = sp + 128 | 0;
 $x1$addr = sp + 124 | 0;
 $x2$addr = sp + 120 | 0;
 $ix$addr = sp + 116 | 0;
 $mid_only_flag$addr = sp + 112 | 0;
 $mid_side_rates_bps$addr = sp + 108 | 0;
 $total_rate_bps$addr = sp + 104 | 0;
 $prev_speech_act_Q8$addr = sp + 100 | 0;
 $toMono$addr = sp + 96 | 0;
 $fs_kHz$addr = sp + 92 | 0;
 $frame_length$addr = sp + 88 | 0;
 $n = sp + 84 | 0;
 $is10msFrame = sp + 80 | 0;
 $denom_Q16 = sp + 76 | 0;
 $delta0_Q13 = sp + 72 | 0;
 $delta1_Q13 = sp + 68 | 0;
 $sum = sp + 64 | 0;
 $diff = sp + 60 | 0;
 $smooth_coef_Q16 = sp + 56 | 0;
 $pred_Q13 = sp + 48 | 0;
 $pred0_Q13 = sp + 44 | 0;
 $pred1_Q13 = sp + 40 | 0;
 $LP_ratio_Q14 = sp + 36 | 0;
 $HP_ratio_Q14 = sp + 32 | 0;
 $frac_Q16 = sp + 28 | 0;
 $frac_3_Q16 = sp + 24 | 0;
 $min_mid_rate_bps = sp + 20 | 0;
 $width_Q14 = sp + 16 | 0;
 $w_Q24 = sp + 12 | 0;
 $deltaw_Q24 = sp + 8 | 0;
 $mid = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$state$addr >> 2] = $state;
 HEAP32[$x1$addr >> 2] = $x1;
 HEAP32[$x2$addr >> 2] = $x2;
 HEAP32[$ix$addr >> 2] = $ix;
 HEAP32[$mid_only_flag$addr >> 2] = $mid_only_flag;
 HEAP32[$mid_side_rates_bps$addr >> 2] = $mid_side_rates_bps;
 HEAP32[$total_rate_bps$addr >> 2] = $total_rate_bps;
 HEAP32[$prev_speech_act_Q8$addr >> 2] = $prev_speech_act_Q8;
 HEAP32[$toMono$addr >> 2] = $toMono;
 HEAP32[$fs_kHz$addr >> 2] = $fs_kHz;
 HEAP32[$frame_length$addr >> 2] = $frame_length;
 HEAP32[$mid >> 2] = (HEAP32[$x1$addr >> 2] | 0) + -4;
 $add = (HEAP32[$frame_length$addr >> 2] | 0) + 2 | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add << 1) | 0) + 15 & -16) | 0;
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= ((HEAP32[$frame_length$addr >> 2] | 0) + 2 | 0)) break;
  HEAP32[$sum >> 2] = (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - 2 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - 2 << 1) >> 1] | 0);
  HEAP32[$diff >> 2] = (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - 2 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - 2 << 1) >> 1] | 0);
  HEAP16[(HEAP32[$mid >> 2] | 0) + (HEAP32[$n >> 2] << 1) >> 1] = (HEAP32[$sum >> 2] >> 1) + (HEAP32[$sum >> 2] & 1);
  if (((HEAP32[$diff >> 2] >> 1) + (HEAP32[$diff >> 2] & 1) | 0) > 32767) $cond33 = 32767; else if (((HEAP32[$diff >> 2] >> 1) + (HEAP32[$diff >> 2] & 1) | 0) < -32768) $cond33 = -32768; else $cond33 = (HEAP32[$diff >> 2] >> 1) + (HEAP32[$diff >> 2] & 1) | 0;
  HEAP16[$vla + (HEAP32[$n >> 2] << 1) >> 1] = $cond33;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 $29 = HEAP32[$mid >> 2] | 0;
 $sMid = (HEAP32[$state$addr >> 2] | 0) + 4 | 0;
 HEAP16[$29 >> 1] = HEAP16[$sMid >> 1] | 0;
 HEAP16[$29 + 2 >> 1] = HEAP16[$sMid + 2 >> 1] | 0;
 $sSide = (HEAP32[$state$addr >> 2] | 0) + 8 | 0;
 HEAP16[$vla >> 1] = HEAP16[$sSide >> 1] | 0;
 HEAP16[$vla + 2 >> 1] = HEAP16[$sSide + 2 >> 1] | 0;
 $sMid37 = (HEAP32[$state$addr >> 2] | 0) + 4 | 0;
 $arrayidx39 = (HEAP32[$mid >> 2] | 0) + (HEAP32[$frame_length$addr >> 2] << 1) | 0;
 HEAP16[$sMid37 >> 1] = HEAP16[$arrayidx39 >> 1] | 0;
 HEAP16[$sMid37 + 2 >> 1] = HEAP16[$arrayidx39 + 2 >> 1] | 0;
 $sSide40 = (HEAP32[$state$addr >> 2] | 0) + 8 | 0;
 $arrayidx42 = $vla + (HEAP32[$frame_length$addr >> 2] << 1) | 0;
 HEAP16[$sSide40 >> 1] = HEAP16[$arrayidx42 >> 1] | 0;
 HEAP16[$sSide40 + 2 >> 1] = HEAP16[$arrayidx42 + 2 >> 1] | 0;
 $vla43 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$frame_length$addr >> 2] << 1) | 0) + 15 & -16) | 0;
 $vla44 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$frame_length$addr >> 2] << 1) | 0) + 15 & -16) | 0;
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$frame_length$addr >> 2] | 0)) break;
  HEAP32[$sum >> 2] = ((HEAP16[(HEAP32[$mid >> 2] | 0) + (HEAP32[$n >> 2] << 1) >> 1] | 0) + (HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 2 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 1) >> 1) + 1 >> 1;
  HEAP16[$vla43 + (HEAP32[$n >> 2] << 1) >> 1] = HEAP32[$sum >> 2];
  HEAP16[$vla44 + (HEAP32[$n >> 2] << 1) >> 1] = (HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP32[$sum >> 2] | 0);
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 $vla73 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$frame_length$addr >> 2] << 1) | 0) + 15 & -16) | 0;
 $vla74 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$frame_length$addr >> 2] << 1) | 0) + 15 & -16) | 0;
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$frame_length$addr >> 2] | 0)) break;
  HEAP32[$sum >> 2] = ((HEAP16[$vla + (HEAP32[$n >> 2] << 1) >> 1] | 0) + (HEAP16[$vla + ((HEAP32[$n >> 2] | 0) + 2 << 1) >> 1] | 0) + (HEAP16[$vla + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 1) >> 1) + 1 >> 1;
  HEAP16[$vla73 + (HEAP32[$n >> 2] << 1) >> 1] = HEAP32[$sum >> 2];
  HEAP16[$vla74 + (HEAP32[$n >> 2] << 1) >> 1] = (HEAP16[$vla + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP32[$sum >> 2] | 0);
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 HEAP32[$is10msFrame >> 2] = (HEAP32[$frame_length$addr >> 2] | 0) == ((HEAP32[$fs_kHz$addr >> 2] | 0) * 10 | 0) & 1;
 HEAP32[$smooth_coef_Q16 >> 2] = HEAP32[$is10msFrame >> 2] | 0 ? 328 : 655;
 $shr112 = (Math_imul((HEAP32[$prev_speech_act_Q8$addr >> 2] & 65535) << 16 >> 16, (HEAP32[$prev_speech_act_Q8$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16;
 $mul115 = Math_imul($shr112, (HEAP32[$smooth_coef_Q16 >> 2] & 65535) << 16 >> 16) | 0;
 $and121 = (Math_imul((HEAP32[$prev_speech_act_Q8$addr >> 2] & 65535) << 16 >> 16, (HEAP32[$prev_speech_act_Q8$addr >> 2] & 65535) << 16 >> 16) | 0) & 65535;
 HEAP32[$smooth_coef_Q16 >> 2] = $mul115 + ((Math_imul($and121, (HEAP32[$smooth_coef_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 HEAP32[$pred_Q13 >> 2] = _silk_stereo_find_predictor($LP_ratio_Q14, $vla43, $vla73, (HEAP32[$state$addr >> 2] | 0) + 12 | 0, HEAP32[$frame_length$addr >> 2] | 0, HEAP32[$smooth_coef_Q16 >> 2] | 0) | 0;
 HEAP32[$pred_Q13 + 4 >> 2] = _silk_stereo_find_predictor($HP_ratio_Q14, $vla44, $vla74, (HEAP32[$state$addr >> 2] | 0) + 12 + 8 | 0, HEAP32[$frame_length$addr >> 2] | 0, HEAP32[$smooth_coef_Q16 >> 2] | 0) | 0;
 HEAP32[$frac_Q16 >> 2] = (HEAP32[$HP_ratio_Q14 >> 2] | 0) + (((HEAP32[$LP_ratio_Q14 >> 2] & 65535) << 16 >> 16) * 3 | 0);
 HEAP32[$frac_Q16 >> 2] = (HEAP32[$frac_Q16 >> 2] | 0) < 65536 ? HEAP32[$frac_Q16 >> 2] | 0 : 65536;
 $sub145 = (HEAP32[$total_rate_bps$addr >> 2] | 0) - (HEAP32[$is10msFrame >> 2] | 0 ? 1200 : 600) | 0;
 HEAP32[$total_rate_bps$addr >> 2] = $sub145;
 HEAP32[$total_rate_bps$addr >> 2] = (HEAP32[$total_rate_bps$addr >> 2] | 0) < 1 ? 1 : $sub145;
 HEAP32[$min_mid_rate_bps >> 2] = 2e3 + (((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 600 | 0);
 HEAP32[$frac_3_Q16 >> 2] = (HEAP32[$frac_Q16 >> 2] | 0) * 3;
 $call154 = _silk_DIV32_varQ(HEAP32[$total_rate_bps$addr >> 2] | 0, 851968 + (HEAP32[$frac_3_Q16 >> 2] | 0) | 0, 19) | 0;
 HEAP32[HEAP32[$mid_side_rates_bps$addr >> 2] >> 2] = $call154;
 if ((HEAP32[HEAP32[$mid_side_rates_bps$addr >> 2] >> 2] | 0) < (HEAP32[$min_mid_rate_bps >> 2] | 0)) {
  HEAP32[HEAP32[$mid_side_rates_bps$addr >> 2] >> 2] = HEAP32[$min_mid_rate_bps >> 2];
  HEAP32[(HEAP32[$mid_side_rates_bps$addr >> 2] | 0) + 4 >> 2] = (HEAP32[$total_rate_bps$addr >> 2] | 0) - (HEAP32[HEAP32[$mid_side_rates_bps$addr >> 2] >> 2] | 0);
  $mul171 = Math_imul(65536 + (HEAP32[$frac_3_Q16 >> 2] | 0) >> 16, (HEAP32[$min_mid_rate_bps >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$width_Q14 >> 2] = _silk_DIV32_varQ((HEAP32[(HEAP32[$mid_side_rates_bps$addr >> 2] | 0) + 4 >> 2] << 1) - (HEAP32[$min_mid_rate_bps >> 2] | 0) | 0, $mul171 + ((Math_imul(65536 + (HEAP32[$frac_3_Q16 >> 2] | 0) & 65535, (HEAP32[$min_mid_rate_bps >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0, 16) | 0;
  if ((HEAP32[$width_Q14 >> 2] | 0) > 16384) $cond191 = 16384; else $cond191 = (HEAP32[$width_Q14 >> 2] | 0) < 0 ? 0 : HEAP32[$width_Q14 >> 2] | 0;
  HEAP32[$width_Q14 >> 2] = $cond191;
 } else {
  HEAP32[(HEAP32[$mid_side_rates_bps$addr >> 2] | 0) + 4 >> 2] = (HEAP32[$total_rate_bps$addr >> 2] | 0) - (HEAP32[HEAP32[$mid_side_rates_bps$addr >> 2] >> 2] | 0);
  HEAP32[$width_Q14 >> 2] = 16384;
 }
 $mul203 = Math_imul((HEAP32[$width_Q14 >> 2] | 0) - (HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0) >> 16, (HEAP32[$smooth_coef_Q16 >> 2] & 65535) << 16 >> 16) | 0;
 $conv214 = (HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0) + ($mul203 + ((Math_imul((HEAP32[$width_Q14 >> 2] | 0) - (HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0) & 65535, (HEAP32[$smooth_coef_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) & 65535;
 HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] = $conv214;
 HEAP8[HEAP32[$mid_only_flag$addr >> 2] >> 0] = 0;
 L24 : do if (HEAP32[$toMono$addr >> 2] | 0) {
  HEAP32[$width_Q14 >> 2] = 0;
  HEAP32[$pred_Q13 >> 2] = 0;
  HEAP32[$pred_Q13 + 4 >> 2] = 0;
  _silk_stereo_quant_pred($pred_Q13, HEAP32[$ix$addr >> 2] | 0);
 } else {
  do if (!(HEAP16[(HEAP32[$state$addr >> 2] | 0) + 30 >> 1] | 0)) {
   if ((HEAP32[$total_rate_bps$addr >> 2] << 3 | 0) >= ((HEAP32[$min_mid_rate_bps >> 2] | 0) * 13 | 0)) {
    $mul232 = Math_imul(HEAP32[$frac_Q16 >> 2] >> 16, HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0) | 0;
    if (($mul232 + ((Math_imul(HEAP32[$frac_Q16 >> 2] & 65535, HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0) | 0) >> 16) | 0) >= 819) break;
   }
   HEAP32[$pred_Q13 >> 2] = (Math_imul(HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0, (HEAP32[$pred_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 14;
   HEAP32[$pred_Q13 + 4 >> 2] = (Math_imul(HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0, (HEAP32[$pred_Q13 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 14;
   _silk_stereo_quant_pred($pred_Q13, HEAP32[$ix$addr >> 2] | 0);
   HEAP32[$width_Q14 >> 2] = 0;
   HEAP32[$pred_Q13 >> 2] = 0;
   HEAP32[$pred_Q13 + 4 >> 2] = 0;
   HEAP32[HEAP32[$mid_side_rates_bps$addr >> 2] >> 2] = HEAP32[$total_rate_bps$addr >> 2];
   HEAP32[(HEAP32[$mid_side_rates_bps$addr >> 2] | 0) + 4 >> 2] = 0;
   HEAP8[HEAP32[$mid_only_flag$addr >> 2] >> 0] = 1;
   break L24;
  } while (0);
  do if (HEAP16[(HEAP32[$state$addr >> 2] | 0) + 30 >> 1] | 0) {
   if ((HEAP32[$total_rate_bps$addr >> 2] << 3 | 0) >= ((HEAP32[$min_mid_rate_bps >> 2] | 0) * 11 | 0)) {
    $mul277 = Math_imul(HEAP32[$frac_Q16 >> 2] >> 16, HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0) | 0;
    if (($mul277 + ((Math_imul(HEAP32[$frac_Q16 >> 2] & 65535, HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0) | 0) >> 16) | 0) >= 328) break;
   }
   HEAP32[$pred_Q13 >> 2] = (Math_imul(HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0, (HEAP32[$pred_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 14;
   HEAP32[$pred_Q13 + 4 >> 2] = (Math_imul(HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0, (HEAP32[$pred_Q13 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 14;
   _silk_stereo_quant_pred($pred_Q13, HEAP32[$ix$addr >> 2] | 0);
   HEAP32[$width_Q14 >> 2] = 0;
   HEAP32[$pred_Q13 >> 2] = 0;
   HEAP32[$pred_Q13 + 4 >> 2] = 0;
   break L24;
  } while (0);
  if ((HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0) > 15565) {
   _silk_stereo_quant_pred($pred_Q13, HEAP32[$ix$addr >> 2] | 0);
   HEAP32[$width_Q14 >> 2] = 16384;
   break;
  } else {
   HEAP32[$pred_Q13 >> 2] = (Math_imul(HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0, (HEAP32[$pred_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 14;
   HEAP32[$pred_Q13 + 4 >> 2] = (Math_imul(HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1] | 0, (HEAP32[$pred_Q13 + 4 >> 2] & 65535) << 16 >> 16) | 0) >> 14;
   _silk_stereo_quant_pred($pred_Q13, HEAP32[$ix$addr >> 2] | 0);
   HEAP32[$width_Q14 >> 2] = HEAP16[(HEAP32[$state$addr >> 2] | 0) + 28 >> 1];
   break;
  }
 } while (0);
 do if ((HEAP8[HEAP32[$mid_only_flag$addr >> 2] >> 0] | 0) == 1) {
  $silent_side_len = (HEAP32[$state$addr >> 2] | 0) + 32 | 0;
  HEAP16[$silent_side_len >> 1] = (HEAP16[$silent_side_len >> 1] | 0) + ((HEAP32[$frame_length$addr >> 2] | 0) - (HEAP32[$fs_kHz$addr >> 2] << 3));
  if ((HEAP16[(HEAP32[$state$addr >> 2] | 0) + 32 >> 1] | 0) < ((HEAP32[$fs_kHz$addr >> 2] | 0) * 5 | 0)) {
   HEAP8[HEAP32[$mid_only_flag$addr >> 2] >> 0] = 0;
   break;
  } else {
   HEAP16[(HEAP32[$state$addr >> 2] | 0) + 32 >> 1] = 1e4;
   break;
  }
 } else HEAP16[(HEAP32[$state$addr >> 2] | 0) + 32 >> 1] = 0; while (0);
 if (!(HEAP8[HEAP32[$mid_only_flag$addr >> 2] >> 0] | 0)) if ((HEAP32[(HEAP32[$mid_side_rates_bps$addr >> 2] | 0) + 4 >> 2] | 0) < 1) {
  HEAP32[(HEAP32[$mid_side_rates_bps$addr >> 2] | 0) + 4 >> 2] = 1;
  $call369 = _silk_max_int(1, (HEAP32[$total_rate_bps$addr >> 2] | 0) - (HEAP32[(HEAP32[$mid_side_rates_bps$addr >> 2] | 0) + 4 >> 2] | 0) | 0) | 0;
  HEAP32[HEAP32[$mid_side_rates_bps$addr >> 2] >> 2] = $call369;
 }
 HEAP32[$pred0_Q13 >> 2] = 0 - (HEAP16[HEAP32[$state$addr >> 2] >> 1] | 0);
 HEAP32[$pred1_Q13 >> 2] = 0 - (HEAP16[(HEAP32[$state$addr >> 2] | 0) + 2 >> 1] | 0);
 HEAP32[$w_Q24 >> 2] = HEAP16[(HEAP32[$state$addr >> 2] | 0) + 30 >> 1] << 10;
 HEAP32[$denom_Q16 >> 2] = 65536 / (HEAP32[$fs_kHz$addr >> 2] << 3 | 0) | 0;
 HEAP32[$delta0_Q13 >> 2] = 0 - (((Math_imul(((HEAP32[$pred_Q13 >> 2] | 0) - (HEAP16[HEAP32[$state$addr >> 2] >> 1] | 0) & 65535) << 16 >> 16, (HEAP32[$denom_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 15) + 1 >> 1);
 HEAP32[$delta1_Q13 >> 2] = 0 - (((Math_imul(((HEAP32[$pred_Q13 + 4 >> 2] | 0) - (HEAP16[(HEAP32[$state$addr >> 2] | 0) + 2 >> 1] | 0) & 65535) << 16 >> 16, (HEAP32[$denom_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 15) + 1 >> 1);
 $mul417 = Math_imul((HEAP32[$width_Q14 >> 2] | 0) - (HEAP16[(HEAP32[$state$addr >> 2] | 0) + 30 >> 1] | 0) >> 16, (HEAP32[$denom_Q16 >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$deltaw_Q24 >> 2] = $mul417 + ((Math_imul((HEAP32[$width_Q14 >> 2] | 0) - (HEAP16[(HEAP32[$state$addr >> 2] | 0) + 30 >> 1] | 0) & 65535, (HEAP32[$denom_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16) << 10;
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$fs_kHz$addr >> 2] << 3 | 0)) break;
  HEAP32[$pred0_Q13 >> 2] = (HEAP32[$pred0_Q13 >> 2] | 0) + (HEAP32[$delta0_Q13 >> 2] | 0);
  HEAP32[$pred1_Q13 >> 2] = (HEAP32[$pred1_Q13 >> 2] | 0) + (HEAP32[$delta1_Q13 >> 2] | 0);
  HEAP32[$w_Q24 >> 2] = (HEAP32[$w_Q24 >> 2] | 0) + (HEAP32[$deltaw_Q24 >> 2] | 0);
  HEAP32[$sum >> 2] = (HEAP16[(HEAP32[$mid >> 2] | 0) + (HEAP32[$n >> 2] << 1) >> 1] | 0) + (HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 2 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 1) << 9;
  $mul452 = Math_imul(HEAP32[$w_Q24 >> 2] >> 16, HEAP16[$vla + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0) | 0;
  $add459 = $mul452 + ((Math_imul(HEAP32[$w_Q24 >> 2] & 65535, HEAP16[$vla + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0) | 0) >> 16) | 0;
  $mul463 = Math_imul(HEAP32[$sum >> 2] >> 16, (HEAP32[$pred0_Q13 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$sum >> 2] = $add459 + ($mul463 + ((Math_imul(HEAP32[$sum >> 2] & 65535, (HEAP32[$pred0_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  $mul478 = Math_imul(HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 11 >> 16, (HEAP32[$pred1_Q13 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$sum >> 2] = (HEAP32[$sum >> 2] | 0) + ($mul478 + ((Math_imul(HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 11 & 65535, (HEAP32[$pred1_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  if (((HEAP32[$sum >> 2] >> 7) + 1 >> 1 | 0) > 32767) $cond510 = 32767; else if (((HEAP32[$sum >> 2] >> 7) + 1 >> 1 | 0) < -32768) $cond510 = -32768; else $cond510 = (HEAP32[$sum >> 2] >> 7) + 1 >> 1;
  HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - 1 << 1) >> 1] = $cond510;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 HEAP32[$pred0_Q13 >> 2] = 0 - (HEAP32[$pred_Q13 >> 2] | 0);
 HEAP32[$pred1_Q13 >> 2] = 0 - (HEAP32[$pred_Q13 + 4 >> 2] | 0);
 HEAP32[$w_Q24 >> 2] = HEAP32[$width_Q14 >> 2] << 10;
 HEAP32[$n >> 2] = HEAP32[$fs_kHz$addr >> 2] << 3;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$frame_length$addr >> 2] | 0)) break;
  HEAP32[$sum >> 2] = (HEAP16[(HEAP32[$mid >> 2] | 0) + (HEAP32[$n >> 2] << 1) >> 1] | 0) + (HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 2 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 1) << 9;
  $mul543 = Math_imul(HEAP32[$w_Q24 >> 2] >> 16, HEAP16[$vla + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0) | 0;
  $add550 = $mul543 + ((Math_imul(HEAP32[$w_Q24 >> 2] & 65535, HEAP16[$vla + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0) | 0) >> 16) | 0;
  $mul554 = Math_imul(HEAP32[$sum >> 2] >> 16, (HEAP32[$pred0_Q13 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$sum >> 2] = $add550 + ($mul554 + ((Math_imul(HEAP32[$sum >> 2] & 65535, (HEAP32[$pred0_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  $mul569 = Math_imul(HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 11 >> 16, (HEAP32[$pred1_Q13 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$sum >> 2] = (HEAP32[$sum >> 2] | 0) + ($mul569 + ((Math_imul(HEAP16[(HEAP32[$mid >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 11 & 65535, (HEAP32[$pred1_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  if (((HEAP32[$sum >> 2] >> 7) + 1 >> 1 | 0) > 32767) $cond601 = 32767; else if (((HEAP32[$sum >> 2] >> 7) + 1 >> 1 | 0) < -32768) $cond601 = -32768; else $cond601 = (HEAP32[$sum >> 2] >> 7) + 1 >> 1;
  HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - 1 << 1) >> 1] = $cond601;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 HEAP16[HEAP32[$state$addr >> 2] >> 1] = HEAP32[$pred_Q13 >> 2];
 HEAP16[(HEAP32[$state$addr >> 2] | 0) + 2 >> 1] = HEAP32[$pred_Q13 + 4 >> 2];
 HEAP16[(HEAP32[$state$addr >> 2] | 0) + 30 >> 1] = HEAP32[$width_Q14 >> 2];
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_encode_frame_FLP($psEnc, $pnBytesOut, $psRangeEnc, $condCoding, $maxBits, $useCBR) {
 $psEnc = $psEnc | 0;
 $pnBytesOut = $pnBytesOut | 0;
 $psRangeEnc = $psRangeEnc | 0;
 $condCoding = $condCoding | 0;
 $maxBits = $maxBits | 0;
 $useCBR = $useCBR | 0;
 var $1 = 0, $119 = 0, $312 = 0, $LastGainIndex_copy2 = 0, $arrayidx = 0, $best_gain_mult = 0, $best_sum = 0, $call251 = 0, $cond = 0.0, $cond399 = 0, $condCoding$addr = 0, $ec_buf_copy = 0, $ec_prevLagIndex_copy = 0, $ec_prevSignalType_copy = 0, $found_lower = 0, $found_upper = 0, $frameCounter = 0, $gainMult_Q8 = 0, $gainMult_lower = 0, $gainMult_upper = 0, $gain_factor_Q16 = 0, $gain_lock = 0, $gainsID = 0, $gainsID_lower = 0, $gainsID_upper = 0, $i = 0, $iter = 0, $j = 0, $maxBits$addr = 0, $maxIter = 0, $mul299 = 0, $mul310 = 0, $mul356 = 0, $mul372 = 0, $mul388 = 0, $nBits = 0, $nBits_lower = 0, $nBits_upper = 0, $pGains_Q16 = 0, $pnBytesOut$addr = 0, $psEnc$addr = 0, $psRangeEnc$addr = 0, $res_pitch = 0, $res_pitch_frame = 0, $ret = 0, $retval = 0, $sEncCtrl = 0, $sNSQ_copy = 0, $sNSQ_copy2 = 0, $sRangeEnc_copy = 0, $sRangeEnc_copy2 = 0, $seed_copy = 0, $shr473 = 0, $sum = 0, $tmp = 0, $useCBR$addr = 0, $x_frame = 0, dest = 0, label = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 13696 | 0;
 $retval = sp + 12396 | 0;
 $psEnc$addr = sp + 12392 | 0;
 $pnBytesOut$addr = sp + 12388 | 0;
 $psRangeEnc$addr = sp + 12384 | 0;
 $condCoding$addr = sp + 12380 | 0;
 $maxBits$addr = sp + 12376 | 0;
 $useCBR$addr = sp + 12372 | 0;
 $sEncCtrl = sp + 11624 | 0;
 $i = sp + 11620 | 0;
 $iter = sp + 11616 | 0;
 $maxIter = sp + 11612 | 0;
 $found_upper = sp + 11608 | 0;
 $found_lower = sp + 11604 | 0;
 $ret = sp + 11600 | 0;
 $x_frame = sp + 11596 | 0;
 $res_pitch_frame = sp + 11592 | 0;
 $res_pitch = sp + 8904 | 0;
 $sRangeEnc_copy = sp + 8856 | 0;
 $sRangeEnc_copy2 = sp + 8808 | 0;
 $sNSQ_copy = sp + 4456 | 0;
 $sNSQ_copy2 = sp + 104 | 0;
 $seed_copy = sp + 100 | 0;
 $nBits = sp + 96 | 0;
 $nBits_lower = sp + 92 | 0;
 $nBits_upper = sp + 88 | 0;
 $gainMult_lower = sp + 84 | 0;
 $gainMult_upper = sp + 80 | 0;
 $gainsID = sp + 76 | 0;
 $gainsID_lower = sp + 72 | 0;
 $gainsID_upper = sp + 68 | 0;
 $gainMult_Q8 = sp + 12418 | 0;
 $ec_prevLagIndex_copy = sp + 12416 | 0;
 $ec_prevSignalType_copy = sp + 64 | 0;
 $LastGainIndex_copy2 = sp + 13695 | 0;
 $pGains_Q16 = sp + 48 | 0;
 $ec_buf_copy = sp + 12420 | 0;
 $gain_lock = sp + 32 | 0;
 $best_gain_mult = sp + 12408 | 0;
 $best_sum = sp + 16 | 0;
 $j = sp + 8 | 0;
 $sum = sp + 4 | 0;
 $gain_factor_Q16 = sp;
 $tmp = sp + 12400 | 0;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$pnBytesOut$addr >> 2] = $pnBytesOut;
 HEAP32[$psRangeEnc$addr >> 2] = $psRangeEnc;
 HEAP32[$condCoding$addr >> 2] = $condCoding;
 HEAP32[$maxBits$addr >> 2] = $maxBits;
 HEAP32[$useCBR$addr >> 2] = $useCBR;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$gain_lock >> 2] = 0;
 HEAP32[$gain_lock + 4 >> 2] = 0;
 HEAP32[$gain_lock + 8 >> 2] = 0;
 HEAP32[$gain_lock + 12 >> 2] = 0;
 HEAP32[$gainMult_upper >> 2] = 0;
 HEAP32[$gainMult_lower >> 2] = 0;
 HEAP32[$nBits_upper >> 2] = 0;
 HEAP32[$nBits_lower >> 2] = 0;
 HEAP8[$LastGainIndex_copy2 >> 0] = 0;
 $frameCounter = (HEAP32[$psEnc$addr >> 2] | 0) + 4616 | 0;
 $1 = HEAP32[$frameCounter >> 2] | 0;
 HEAP32[$frameCounter >> 2] = $1 + 1;
 HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 34 >> 0] = $1 & 3;
 HEAP32[$x_frame >> 2] = (HEAP32[$psEnc$addr >> 2] | 0) + 7176 + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4588 >> 2] << 2);
 HEAP32[$res_pitch_frame >> 2] = $res_pitch + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4588 >> 2] << 2);
 _silk_LP_variable_cutoff((HEAP32[$psEnc$addr >> 2] | 0) + 16 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 5092 + 2 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] | 0);
 _silk_short2float_array_285((HEAP32[$x_frame >> 2] | 0) + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) * 5 << 2) | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 5092 + 2 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 8) break;
  $arrayidx = (HEAP32[$x_frame >> 2] | 0) + (((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) * 5 | 0) + (Math_imul(HEAP32[$i >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] >> 3) | 0) << 2) | 0;
  HEAPF32[$arrayidx >> 2] = +HEAPF32[$arrayidx >> 2] + +(1 - (HEAP32[$i >> 2] & 2) | 0) * 9.999999974752427e-07;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L5 : do if (!(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4676 >> 2] | 0)) {
  _silk_find_pitch_lags_FLP(HEAP32[$psEnc$addr >> 2] | 0, $sEncCtrl, $res_pitch, HEAP32[$x_frame >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5088 >> 2] | 0);
  _silk_noise_shape_analysis_FLP(HEAP32[$psEnc$addr >> 2] | 0, $sEncCtrl, HEAP32[$res_pitch_frame >> 2] | 0, HEAP32[$x_frame >> 2] | 0);
  _silk_find_pred_coefs_FLP(HEAP32[$psEnc$addr >> 2] | 0, $sEncCtrl, HEAP32[$res_pitch_frame >> 2] | 0, HEAP32[$x_frame >> 2] | 0, HEAP32[$condCoding$addr >> 2] | 0);
  _silk_process_gains_FLP(HEAP32[$psEnc$addr >> 2] | 0, $sEncCtrl, HEAP32[$condCoding$addr >> 2] | 0);
  _silk_LBRR_encode_FLP(HEAP32[$psEnc$addr >> 2] | 0, $sEncCtrl, HEAP32[$x_frame >> 2] | 0, HEAP32[$condCoding$addr >> 2] | 0);
  HEAP32[$maxIter >> 2] = 6;
  HEAP16[$gainMult_Q8 >> 1] = 256;
  HEAP32[$found_lower >> 2] = 0;
  HEAP32[$found_upper >> 2] = 0;
  HEAP32[$gainsID >> 2] = _silk_gains_ID((HEAP32[$psEnc$addr >> 2] | 0) + 4732 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0) | 0;
  HEAP32[$gainsID_lower >> 2] = -1;
  HEAP32[$gainsID_upper >> 2] = -1;
  dest = $sRangeEnc_copy;
  src = HEAP32[$psRangeEnc$addr >> 2] | 0;
  stop = dest + 48 | 0;
  do {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  } while ((dest | 0) < (stop | 0));
  _memcpy($sNSQ_copy | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 144 | 0, 4352) | 0;
  HEAP32[$seed_copy >> 2] = HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 34 >> 0];
  HEAP16[$ec_prevLagIndex_copy >> 1] = HEAP16[(HEAP32[$psEnc$addr >> 2] | 0) + 5768 >> 1] | 0;
  HEAP32[$ec_prevSignalType_copy >> 2] = HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5764 >> 2];
  HEAP32[$iter >> 2] = 0;
  while (1) {
   do if ((HEAP32[$gainsID >> 2] | 0) == (HEAP32[$gainsID_lower >> 2] | 0)) HEAP32[$nBits >> 2] = HEAP32[$nBits_lower >> 2]; else {
    if ((HEAP32[$gainsID >> 2] | 0) == (HEAP32[$gainsID_upper >> 2] | 0)) {
     HEAP32[$nBits >> 2] = HEAP32[$nBits_upper >> 2];
     break;
    }
    if ((HEAP32[$iter >> 2] | 0) > 0) {
     dest = HEAP32[$psRangeEnc$addr >> 2] | 0;
     src = $sRangeEnc_copy;
     stop = dest + 48 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     _memcpy((HEAP32[$psEnc$addr >> 2] | 0) + 144 | 0, $sNSQ_copy | 0, 4352) | 0;
     HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 34 >> 0] = HEAP32[$seed_copy >> 2];
     HEAP16[(HEAP32[$psEnc$addr >> 2] | 0) + 5768 >> 1] = HEAP16[$ec_prevLagIndex_copy >> 1] | 0;
     HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5764 >> 2] = HEAP32[$ec_prevSignalType_copy >> 2];
    }
    _silk_NSQ_wrapper_FLP(HEAP32[$psEnc$addr >> 2] | 0, $sEncCtrl, (HEAP32[$psEnc$addr >> 2] | 0) + 4732 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 144 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 4768 | 0, HEAP32[$x_frame >> 2] | 0);
    if (!(HEAP32[$found_lower >> 2] | 0 ? 1 : (HEAP32[$iter >> 2] | 0) != (HEAP32[$maxIter >> 2] | 0))) {
     dest = $sRangeEnc_copy2;
     src = HEAP32[$psRangeEnc$addr >> 2] | 0;
     stop = dest + 48 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
    }
    _silk_encode_indices(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5744 >> 2] | 0, 0, HEAP32[$condCoding$addr >> 2] | 0);
    _silk_encode_pulses(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0, HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 30 >> 0] | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 4768 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] | 0);
    HEAP32[$nBits >> 2] = _ec_tell_286(HEAP32[$psRangeEnc$addr >> 2] | 0) | 0;
    if (!(HEAP32[$found_lower >> 2] | 0 ? 1 : (HEAP32[$iter >> 2] | 0) != (HEAP32[$maxIter >> 2] | 0))) if ((HEAP32[$nBits >> 2] | 0) > (HEAP32[$maxBits$addr >> 2] | 0)) {
     dest = HEAP32[$psRangeEnc$addr >> 2] | 0;
     src = $sRangeEnc_copy2;
     stop = dest + 48 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 7164 >> 0] = HEAP8[$sEncCtrl + 744 >> 0] | 0;
     HEAP32[$i >> 2] = 0;
     while (1) {
      if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
      HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + (HEAP32[$i >> 2] | 0) >> 0] = 4;
      HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
     }
     if ((HEAP32[$condCoding$addr >> 2] | 0) != 2) HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 >> 0] = HEAP8[$sEncCtrl + 744 >> 0] | 0;
     HEAP16[(HEAP32[$psEnc$addr >> 2] | 0) + 5768 >> 1] = HEAP16[$ec_prevLagIndex_copy >> 1] | 0;
     HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5764 >> 2] = HEAP32[$ec_prevSignalType_copy >> 2];
     HEAP32[$i >> 2] = 0;
     while (1) {
      $119 = HEAP32[$psEnc$addr >> 2] | 0;
      if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] | 0)) break;
      HEAP8[$119 + 4768 + (HEAP32[$i >> 2] | 0) >> 0] = 0;
      HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
     }
     _silk_encode_indices($119, HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5744 >> 2] | 0, 0, HEAP32[$condCoding$addr >> 2] | 0);
     _silk_encode_pulses(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0, HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 30 >> 0] | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 4768 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] | 0);
     HEAP32[$nBits >> 2] = _ec_tell_286(HEAP32[$psRangeEnc$addr >> 2] | 0) | 0;
    }
    if ((HEAP32[$useCBR$addr >> 2] | 0) == 0 & (HEAP32[$iter >> 2] | 0) == 0) if ((HEAP32[$nBits >> 2] | 0) <= (HEAP32[$maxBits$addr >> 2] | 0)) break L5;
   } while (0);
   if ((HEAP32[$iter >> 2] | 0) == (HEAP32[$maxIter >> 2] | 0)) break;
   do if ((HEAP32[$nBits >> 2] | 0) > (HEAP32[$maxBits$addr >> 2] | 0)) {
    if (!((HEAP32[$found_lower >> 2] | 0) == 0 & (HEAP32[$iter >> 2] | 0) >= 2)) {
     HEAP32[$found_upper >> 2] = 1;
     HEAP32[$nBits_upper >> 2] = HEAP32[$nBits >> 2];
     HEAP32[$gainMult_upper >> 2] = HEAP16[$gainMult_Q8 >> 1];
     HEAP32[$gainsID_upper >> 2] = HEAP32[$gainsID >> 2];
     break;
    }
    if (+HEAPF32[$sEncCtrl + 692 >> 2] * 1.5 > 1.5) $cond = +HEAPF32[$sEncCtrl + 692 >> 2] * 1.5; else $cond = 1.5;
    HEAPF32[$sEncCtrl + 692 >> 2] = $cond;
    HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 30 >> 0] = 0;
    HEAP32[$found_upper >> 2] = 0;
    HEAP32[$gainsID_upper >> 2] = -1;
   } else {
    if ((HEAP32[$nBits >> 2] | 0) >= ((HEAP32[$maxBits$addr >> 2] | 0) - 5 | 0)) break L5;
    HEAP32[$found_lower >> 2] = 1;
    HEAP32[$nBits_lower >> 2] = HEAP32[$nBits >> 2];
    HEAP32[$gainMult_lower >> 2] = HEAP16[$gainMult_Q8 >> 1];
    if ((HEAP32[$gainsID >> 2] | 0) != (HEAP32[$gainsID_lower >> 2] | 0)) {
     HEAP32[$gainsID_lower >> 2] = HEAP32[$gainsID >> 2];
     dest = $sRangeEnc_copy2;
     src = HEAP32[$psRangeEnc$addr >> 2] | 0;
     stop = dest + 48 | 0;
     do {
      HEAP32[dest >> 2] = HEAP32[src >> 2];
      dest = dest + 4 | 0;
      src = src + 4 | 0;
     } while ((dest | 0) < (stop | 0));
     _memcpy($ec_buf_copy | 0, HEAP32[HEAP32[$psRangeEnc$addr >> 2] >> 2] | 0, HEAP32[(HEAP32[$psRangeEnc$addr >> 2] | 0) + 24 >> 2] | 0) | 0;
     _memcpy($sNSQ_copy2 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 144 | 0, 4352) | 0;
     HEAP8[$LastGainIndex_copy2 >> 0] = HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 7164 >> 0] | 0;
    }
   } while (0);
   L51 : do if (!(HEAP32[$found_lower >> 2] | 0)) if ((HEAP32[$nBits >> 2] | 0) > (HEAP32[$maxBits$addr >> 2] | 0)) {
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break L51;
     HEAP32[$sum >> 2] = 0;
     HEAP32[$j >> 2] = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] | 0) | 0;
     while (1) {
      if ((HEAP32[$j >> 2] | 0) >= (Math_imul((HEAP32[$i >> 2] | 0) + 1 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] | 0) | 0)) break;
      $call251 = Math_abs(HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4768 + (HEAP32[$j >> 2] | 0) >> 0] | 0) | 0;
      HEAP32[$sum >> 2] = (HEAP32[$sum >> 2] | 0) + $call251;
      HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
     }
     do if (!(HEAP32[$iter >> 2] | 0)) label = 51; else {
      if ((HEAP32[$sum >> 2] | 0) < (HEAP32[$best_sum + (HEAP32[$i >> 2] << 2) >> 2] | 0)) if (!(HEAP32[$gain_lock + (HEAP32[$i >> 2] << 2) >> 2] | 0)) {
       label = 51;
       break;
      }
      HEAP32[$gain_lock + (HEAP32[$i >> 2] << 2) >> 2] = 1;
     } while (0);
     if ((label | 0) == 51) {
      label = 0;
      HEAP32[$best_sum + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$sum >> 2];
      HEAP16[$best_gain_mult + (HEAP32[$i >> 2] << 1) >> 1] = HEAP16[$gainMult_Q8 >> 1] | 0;
     }
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   } while (0);
   do if (!(HEAP32[$found_lower >> 2] & HEAP32[$found_upper >> 2])) {
    if ((HEAP32[$nBits >> 2] | 0) <= (HEAP32[$maxBits$addr >> 2] | 0)) {
     HEAP32[$gain_factor_Q16 >> 2] = _silk_log2lin((((HEAP32[$nBits >> 2] | 0) - (HEAP32[$maxBits$addr >> 2] | 0) << 7 | 0) / (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] | 0) | 0) + 2048 | 0) | 0;
     $mul299 = Math_imul(HEAP32[$gain_factor_Q16 >> 2] >> 16, HEAP16[$gainMult_Q8 >> 1] | 0) | 0;
     HEAP16[$gainMult_Q8 >> 1] = $mul299 + ((Math_imul(HEAP32[$gain_factor_Q16 >> 2] & 65535, HEAP16[$gainMult_Q8 >> 1] | 0) | 0) >> 16);
     break;
    }
    if ((HEAP16[$gainMult_Q8 >> 1] | 0) < 16384) {
     HEAP16[$gainMult_Q8 >> 1] = HEAP16[$gainMult_Q8 >> 1] << 1;
     break;
    } else {
     HEAP16[$gainMult_Q8 >> 1] = 32767;
     break;
    }
   } else {
    $mul310 = Math_imul((HEAP32[$gainMult_upper >> 2] | 0) - (HEAP32[$gainMult_lower >> 2] | 0) | 0, (HEAP32[$maxBits$addr >> 2] | 0) - (HEAP32[$nBits_lower >> 2] | 0) | 0) | 0;
    HEAP16[$gainMult_Q8 >> 1] = (HEAP32[$gainMult_lower >> 2] | 0) + (($mul310 | 0) / ((HEAP32[$nBits_upper >> 2] | 0) - (HEAP32[$nBits_lower >> 2] | 0) | 0) | 0);
    if ((HEAP16[$gainMult_Q8 >> 1] | 0) > ((HEAP32[$gainMult_lower >> 2] | 0) + ((HEAP32[$gainMult_upper >> 2] | 0) - (HEAP32[$gainMult_lower >> 2] | 0) >> 2) | 0)) {
     HEAP16[$gainMult_Q8 >> 1] = (HEAP32[$gainMult_lower >> 2] | 0) + ((HEAP32[$gainMult_upper >> 2] | 0) - (HEAP32[$gainMult_lower >> 2] | 0) >> 2);
     break;
    }
    if ((HEAP16[$gainMult_Q8 >> 1] | 0) < ((HEAP32[$gainMult_upper >> 2] | 0) - ((HEAP32[$gainMult_upper >> 2] | 0) - (HEAP32[$gainMult_lower >> 2] | 0) >> 2) | 0)) HEAP16[$gainMult_Q8 >> 1] = (HEAP32[$gainMult_upper >> 2] | 0) - ((HEAP32[$gainMult_upper >> 2] | 0) - (HEAP32[$gainMult_lower >> 2] | 0) >> 2);
   } while (0);
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
    if (HEAP32[$gain_lock + (HEAP32[$i >> 2] << 2) >> 2] | 0) HEAP16[$tmp >> 1] = HEAP16[$best_gain_mult + (HEAP32[$i >> 2] << 1) >> 1] | 0; else HEAP16[$tmp >> 1] = HEAP16[$gainMult_Q8 >> 1] | 0;
    $mul356 = Math_imul(HEAP32[$sEncCtrl + 728 + (HEAP32[$i >> 2] << 2) >> 2] >> 16, HEAP16[$tmp >> 1] | 0) | 0;
    if (($mul356 + ((Math_imul(HEAP32[$sEncCtrl + 728 + (HEAP32[$i >> 2] << 2) >> 2] & 65535, HEAP16[$tmp >> 1] | 0) | 0) >> 16) | 0) > 8388607) $cond399 = 8388607; else {
     $mul372 = Math_imul(HEAP32[$sEncCtrl + 728 + (HEAP32[$i >> 2] << 2) >> 2] >> 16, HEAP16[$tmp >> 1] | 0) | 0;
     if (($mul372 + ((Math_imul(HEAP32[$sEncCtrl + 728 + (HEAP32[$i >> 2] << 2) >> 2] & 65535, HEAP16[$tmp >> 1] | 0) | 0) >> 16) | 0) < -8388608) $cond399 = -8388608; else {
      $mul388 = Math_imul(HEAP32[$sEncCtrl + 728 + (HEAP32[$i >> 2] << 2) >> 2] >> 16, HEAP16[$tmp >> 1] | 0) | 0;
      $cond399 = $mul388 + ((Math_imul(HEAP32[$sEncCtrl + 728 + (HEAP32[$i >> 2] << 2) >> 2] & 65535, HEAP16[$tmp >> 1] | 0) | 0) >> 16) | 0;
     }
    }
    HEAP32[$pGains_Q16 + (HEAP32[$i >> 2] << 2) >> 2] = $cond399 << 8;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 7164 >> 0] = HEAP8[$sEncCtrl + 744 >> 0] | 0;
   _silk_gains_quant((HEAP32[$psEnc$addr >> 2] | 0) + 4732 | 0, $pGains_Q16, (HEAP32[$psEnc$addr >> 2] | 0) + 7164 | 0, (HEAP32[$condCoding$addr >> 2] | 0) == 2 & 1, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0);
   HEAP32[$gainsID >> 2] = _silk_gains_ID((HEAP32[$psEnc$addr >> 2] | 0) + 4732 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0) | 0;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
    HEAPF32[$sEncCtrl + (HEAP32[$i >> 2] << 2) >> 2] = +(HEAP32[$pGains_Q16 + (HEAP32[$i >> 2] << 2) >> 2] | 0) / 65536.0;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP32[$iter >> 2] = (HEAP32[$iter >> 2] | 0) + 1;
  }
  if (HEAP32[$found_lower >> 2] | 0) {
   if ((HEAP32[$gainsID >> 2] | 0) != (HEAP32[$gainsID_lower >> 2] | 0)) if ((HEAP32[$nBits >> 2] | 0) <= (HEAP32[$maxBits$addr >> 2] | 0)) break;
   dest = HEAP32[$psRangeEnc$addr >> 2] | 0;
   src = $sRangeEnc_copy2;
   stop = dest + 48 | 0;
   do {
    HEAP32[dest >> 2] = HEAP32[src >> 2];
    dest = dest + 4 | 0;
    src = src + 4 | 0;
   } while ((dest | 0) < (stop | 0));
   _memcpy(HEAP32[HEAP32[$psRangeEnc$addr >> 2] >> 2] | 0, $ec_buf_copy | 0, HEAP32[$sRangeEnc_copy2 + 24 >> 2] | 0) | 0;
   _memcpy((HEAP32[$psEnc$addr >> 2] | 0) + 144 | 0, $sNSQ_copy2 | 0, 4352) | 0;
   HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 7164 >> 0] = HEAP8[$LastGainIndex_copy2 >> 0] | 0;
  }
 } while (0);
 _memmove((HEAP32[$psEnc$addr >> 2] | 0) + 7176 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 7176 + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] << 2) | 0, (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4588 >> 2] | 0) + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) * 5 | 0) << 2 | 0) | 0;
 if (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4676 >> 2] | 0) {
  HEAP32[HEAP32[$pnBytesOut$addr >> 2] >> 2] = 0;
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $312 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $312 | 0;
 } else {
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4540 >> 2] = HEAP32[$sEncCtrl + 228 + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0) - 1 << 2) >> 2];
  HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4537 >> 0] = HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0;
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4660 >> 2] = 0;
  $shr473 = (_ec_tell_286(HEAP32[$psRangeEnc$addr >> 2] | 0) | 0) + 7 >> 3;
  HEAP32[HEAP32[$pnBytesOut$addr >> 2] >> 2] = $shr473;
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $312 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $312 | 0;
 }
 return 0;
}

function _silk_VAD_GetSA_Q8_sse4_1($psEncC, $pIn) {
 $psEncC = $psEncC | 0;
 $pIn = $pIn | 0;
 var $$compoundliteral$i = 0, $$compoundliteral$i391 = 0, $$sink = 0, $$sink1 = 0, $100 = SIMD_Int32x4(0, 0, 0, 0), $102 = SIMD_Int16x8(0, 0, 0, 0, 0, 0, 0, 0), $115 = SIMD_Int32x4(0, 0, 0, 0), $116 = SIMD_Int32x4(0, 0, 0, 0), $135 = 0, $136 = 0, $160 = 0, $163 = 0, $212 = 0, $262 = 0, $49 = 0, $68 = SIMD_Int16x8(0, 0, 0, 0, 0, 0, 0, 0), $72 = SIMD_Int32x4(0, 0, 0, 0), $73 = SIMD_Int32x4(0, 0, 0, 0), $88 = SIMD_Int32x4(0, 0, 0, 0), $89 = SIMD_Int32x4(0, 0, 0, 0), $90 = SIMD_Int32x4(0, 0, 0, 0), $93 = SIMD_Int32x4(0, 0, 0, 0), $94 = SIMD_Int32x4(0, 0, 0, 0), $95 = SIMD_Int32x4(0, 0, 0, 0), $96 = SIMD_Int32x4(0, 0, 0, 0), $98 = SIMD_Int32x4(0, 0, 0, 0), $HPstateTmp = 0, $NrgToNoiseRatio_Q8 = 0, $SA_Q15 = 0, $SNR_Q7 = 0, $X_offset = 0, $Xnrg = 0, $__a$addr$i = 0, $__a$addr$i377 = 0, $__a$addr$i379 = 0, $__a$addr$i382 = 0, $__a$addr$i384 = 0, $__a$addr$i387 = 0, $__a$addr$i388 = 0, $__b$addr$i = 0, $__b$addr$i380 = 0, $__b$addr$i383 = 0, $__b$addr$i385 = 0, $__b$addr$i389 = 0, $__b$i = 0, $__count$addr$i = 0, $__p$addr$i = 0, $__w$addr$i = 0, $add13 = 0, $add17$i = 0, $add362 = 0, $and186 = 0, $arrayidx43 = 0, $b = 0, $call302 = 0, $call372 = 0, $cond = 0, $cond$i = 0, $cond125 = 0, $cond125$sink = 0, $cond269 = 0, $cond283 = 0, $dec_subframe_length = 0, $dec_subframe_offset = 0, $decimated_framelength = 0, $decimated_framelength1 = 0, $decimated_framelength2 = 0, $div163$sink = 0, $dst$i = 0, $i = 0, $i$i = 0, $input_tilt = 0, $mul183 = 0, $mul197 = 0, $mul240 = 0, $mul291 = 0, $mul319 = 0, $mul351 = 0, $mul6$i = 0, $pIn$addr = 0, $pSNR_dB_Q7 = 0, $psEncC$addr = 0, $psSilk_VAD = 0, $ret = 0, $s = 0, $saved_stack = 0, $shl229 = 0, $shr180 = 0, $shuffle$i = SIMD_Int32x4(0, 0, 0, 0), $smooth_coef_Q16 = 0, $speech_nrg = 0, $src$i = 0, $src2$i = 0, $sumSquared = 0, $tmp = 0, $vecext$i = 0, $vla = 0, $x_tmp = 0, $xmm_X = 0, $xmm_acc = 0, sp = 0, temp_Int32x4_ptr = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 496 | 0;
 $__w$addr$i = sp + 486 | 0;
 $$compoundliteral$i391 = sp + 320 | 0;
 $__a$addr$i388 = sp + 304 | 0;
 $__b$addr$i389 = sp + 288 | 0;
 $__a$addr$i387 = sp + 272 | 0;
 $__b$i = sp + 256 | 0;
 $__a$addr$i384 = sp + 240 | 0;
 $__b$addr$i385 = sp + 224 | 0;
 $__a$addr$i382 = sp + 208 | 0;
 $__b$addr$i383 = sp + 192 | 0;
 $__a$addr$i379 = sp + 176 | 0;
 $__b$addr$i380 = sp + 160 | 0;
 $__a$addr$i377 = sp + 144 | 0;
 $__b$addr$i = sp + 128 | 0;
 $src$i = sp + 112 | 0;
 $src2$i = sp + 96 | 0;
 $dst$i = sp + 80 | 0;
 $i$i = sp + 480 | 0;
 $__a$addr$i = sp + 64 | 0;
 $__count$addr$i = sp + 476 | 0;
 $__p$addr$i = sp + 472 | 0;
 $$compoundliteral$i = sp + 48 | 0;
 $psEncC$addr = sp + 468 | 0;
 $pIn$addr = sp + 464 | 0;
 $SA_Q15 = sp + 460 | 0;
 $pSNR_dB_Q7 = sp + 456 | 0;
 $input_tilt = sp + 452 | 0;
 $decimated_framelength1 = sp + 448 | 0;
 $decimated_framelength2 = sp + 444 | 0;
 $decimated_framelength = sp + 440 | 0;
 $dec_subframe_length = sp + 436 | 0;
 $dec_subframe_offset = sp + 432 | 0;
 $SNR_Q7 = sp + 428 | 0;
 $i = sp + 424 | 0;
 $b = sp + 420 | 0;
 $s = sp + 416 | 0;
 $sumSquared = sp + 412 | 0;
 $smooth_coef_Q16 = sp + 408 | 0;
 $HPstateTmp = sp + 484 | 0;
 $Xnrg = sp + 392 | 0;
 $NrgToNoiseRatio_Q8 = sp + 376 | 0;
 $speech_nrg = sp + 372 | 0;
 $x_tmp = sp + 368 | 0;
 $X_offset = sp + 352 | 0;
 $ret = sp + 344 | 0;
 $psSilk_VAD = sp + 340 | 0;
 $saved_stack = sp + 336 | 0;
 $xmm_X = sp + 32 | 0;
 $xmm_acc = sp + 16 | 0;
 $tmp = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$pIn$addr >> 2] = $pIn;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$psSilk_VAD >> 2] = (HEAP32[$psEncC$addr >> 2] | 0) + 32;
 HEAP32[$decimated_framelength1 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] >> 1;
 HEAP32[$decimated_framelength2 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] >> 2;
 HEAP32[$decimated_framelength >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] >> 3;
 HEAP32[$X_offset >> 2] = 0;
 HEAP32[$X_offset + 4 >> 2] = (HEAP32[$decimated_framelength >> 2] | 0) + (HEAP32[$decimated_framelength2 >> 2] | 0);
 HEAP32[$X_offset + 8 >> 2] = (HEAP32[$X_offset + 4 >> 2] | 0) + (HEAP32[$decimated_framelength >> 2] | 0);
 HEAP32[$X_offset + 12 >> 2] = (HEAP32[$X_offset + 8 >> 2] | 0) + (HEAP32[$decimated_framelength2 >> 2] | 0);
 $add13 = (HEAP32[$X_offset + 12 >> 2] | 0) + (HEAP32[$decimated_framelength1 >> 2] | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add13 << 1) | 0) + 15 & -16) | 0;
 _silk_ana_filt_bank_1(HEAP32[$pIn$addr >> 2] | 0, HEAP32[$psSilk_VAD >> 2] | 0, $vla, $vla + (HEAP32[$X_offset + 12 >> 2] << 1) | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0);
 _silk_ana_filt_bank_1($vla, (HEAP32[$psSilk_VAD >> 2] | 0) + 8 | 0, $vla, $vla + (HEAP32[$X_offset + 8 >> 2] << 1) | 0, HEAP32[$decimated_framelength1 >> 2] | 0);
 _silk_ana_filt_bank_1($vla, (HEAP32[$psSilk_VAD >> 2] | 0) + 16 | 0, $vla, $vla + (HEAP32[$X_offset + 4 >> 2] << 1) | 0, HEAP32[$decimated_framelength2 >> 2] | 0);
 HEAP16[$vla + ((HEAP32[$decimated_framelength >> 2] | 0) - 1 << 1) >> 1] = HEAP16[$vla + ((HEAP32[$decimated_framelength >> 2] | 0) - 1 << 1) >> 1] >> 1;
 HEAP16[$HPstateTmp >> 1] = HEAP16[$vla + ((HEAP32[$decimated_framelength >> 2] | 0) - 1 << 1) >> 1] | 0;
 HEAP32[$i >> 2] = (HEAP32[$decimated_framelength >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) <= 0) break;
  HEAP16[$vla + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] = HEAP16[$vla + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] >> 1;
  $arrayidx43 = $vla + (HEAP32[$i >> 2] << 1) | 0;
  HEAP16[$arrayidx43 >> 1] = (HEAP16[$arrayidx43 >> 1] | 0) - (HEAP16[$vla + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 HEAP16[$vla >> 1] = (HEAP16[$vla >> 1] | 0) - (HEAP16[(HEAP32[$psSilk_VAD >> 2] | 0) + 56 >> 1] | 0);
 HEAP16[(HEAP32[$psSilk_VAD >> 2] | 0) + 56 >> 1] = HEAP16[$HPstateTmp >> 1] | 0;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  $49 = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0;
  HEAP32[$decimated_framelength >> 2] = $49 >> (_silk_min_int_340(4 - (HEAP32[$b >> 2] | 0) | 0, 3) | 0);
  HEAP32[$dec_subframe_length >> 2] = HEAP32[$decimated_framelength >> 2] >> 2;
  HEAP32[$dec_subframe_offset >> 2] = 0;
  HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] = HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 24 + (HEAP32[$b >> 2] << 2) >> 2];
  HEAP32[$s >> 2] = 0;
  while (1) {
   if ((HEAP32[$s >> 2] | 0) >= 4) break;
   HEAP32[$sumSquared >> 2] = 0;
   temp_Int32x4_ptr = $$compoundliteral$i;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_splat(0));
   temp_Int32x4_ptr = $xmm_acc;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_load(HEAPU8, $$compoundliteral$i));
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$dec_subframe_length >> 2] | 0) - 7 | 0)) break;
    HEAP32[$__p$addr$i >> 2] = $vla + ((HEAP32[$X_offset + (HEAP32[$b >> 2] << 2) >> 2] | 0) + (HEAP32[$i >> 2] | 0) + (HEAP32[$dec_subframe_offset >> 2] | 0) << 1);
    temp_Int32x4_ptr = $xmm_X;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_load(HEAPU8, HEAP32[$__p$addr$i >> 2] | 0));
    temp_Int32x4_ptr = $__a$addr$i;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_load(HEAPU8, $xmm_X));
    HEAP32[$__count$addr$i >> 2] = 3;
    $68 = SIMD_Int16x8_fromInt32x4Bits(SIMD_Int32x4_load(HEAPU8, $__a$addr$i));
    $cond$i = (HEAP32[$__count$addr$i >> 2] | 0) >>> 0 < 15 ? HEAP32[$__count$addr$i >> 2] | 0 : 15;
    temp_Int32x4_ptr = $xmm_X;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_fromInt16x8Bits(SIMD_Int16x8_check(SIMD_Int16x8_shiftRightByScalar(SIMD_Int16x8_check($68), $cond$i | 0))));
    $72 = SIMD_Int32x4_load(HEAPU8, $xmm_X);
    $73 = SIMD_Int32x4_load(HEAPU8, $xmm_X);
    temp_Int32x4_ptr = $__a$addr$i377;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $72);
    temp_Int32x4_ptr = $__b$addr$i;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $73);
    temp_Int32x4_ptr = $src$i;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_load(HEAPU8, $__a$addr$i377));
    temp_Int32x4_ptr = $src2$i;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_load(HEAPU8, $__b$addr$i));
    HEAP32[$i$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i$i >> 2] | 0) >= 4) break;
     $mul6$i = Math_imul(HEAP16[$src$i + (HEAP32[$i$i >> 2] << 1 << 1) >> 1] | 0, HEAP16[$src2$i + (HEAP32[$i$i >> 2] << 1 << 1) >> 1] | 0) | 0;
     $add17$i = $mul6$i + (Math_imul(HEAP16[$src$i + ((HEAP32[$i$i >> 2] << 1) + 1 << 1) >> 1] | 0, HEAP16[$src2$i + ((HEAP32[$i$i >> 2] << 1) + 1 << 1) >> 1] | 0) | 0) | 0;
     HEAP32[$dst$i + (HEAP32[$i$i >> 2] << 2) >> 2] = $add17$i;
     HEAP32[$i$i >> 2] = (HEAP32[$i$i >> 2] | 0) + 1;
    }
    temp_Int32x4_ptr = $xmm_X;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_load(HEAPU8, $dst$i));
    $88 = SIMD_Int32x4_load(HEAPU8, $xmm_acc);
    $89 = SIMD_Int32x4_load(HEAPU8, $xmm_X);
    temp_Int32x4_ptr = $__a$addr$i379;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $88);
    temp_Int32x4_ptr = $__b$addr$i380;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $89);
    $90 = SIMD_Int32x4_load(HEAPU8, $__a$addr$i379);
    temp_Int32x4_ptr = $xmm_acc;
    SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_add($90, SIMD_Int32x4_load(HEAPU8, $__b$addr$i380)));
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 8;
   }
   $93 = SIMD_Int32x4_load(HEAPU8, $xmm_acc);
   $94 = SIMD_Int32x4_load(HEAPU8, $xmm_acc);
   $95 = SIMD_Int32x4_load(HEAPU8, $xmm_acc);
   temp_Int32x4_ptr = $__a$addr$i382;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $94);
   temp_Int32x4_ptr = $__b$addr$i383;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $95);
   $96 = SIMD_Int32x4_load(HEAPU8, $__a$addr$i382);
   $shuffle$i = SIMD_Int32x4_shuffle($96, SIMD_Int32x4_load(HEAPU8, $__b$addr$i383), 2, 3, 6, 7);
   temp_Int32x4_ptr = $__a$addr$i384;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $93);
   temp_Int32x4_ptr = $__b$addr$i385;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $shuffle$i);
   $98 = SIMD_Int32x4_load(HEAPU8, $__a$addr$i384);
   temp_Int32x4_ptr = $xmm_acc;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_add($98, SIMD_Int32x4_load(HEAPU8, $__b$addr$i385)));
   $100 = SIMD_Int32x4_load(HEAPU8, $xmm_acc);
   $102 = SIMD_Int16x8_fromInt32x4Bits(SIMD_Int32x4_load(HEAPU8, $xmm_acc));
   HEAP16[$__w$addr$i >> 1] = 0;
   SIMD_Int16x8_store(HEAPU8, $$compoundliteral$i391, SIMD_Int16x8(HEAP16[$__w$addr$i >> 1] | 0, HEAP16[$__w$addr$i >> 1] | 0, HEAP16[$__w$addr$i >> 1] | 0, HEAP16[$__w$addr$i >> 1] | 0, HEAP16[$__w$addr$i >> 1] | 0, HEAP16[$__w$addr$i >> 1] | 0, HEAP16[$__w$addr$i >> 1] | 0, HEAP16[$__w$addr$i >> 1] | 0));
   SIMD_Int16x8_fromInt32x4Bits(SIMD_Int32x4_fromInt16x8Bits(SIMD_Int16x8_load(HEAPU8, $$compoundliteral$i391)));
   temp_Int32x4_ptr = $tmp;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_fromInt16x8Bits(SIMD_Int16x8_swizzle($102, 2, 3, 0, 0, 4, 5, 6, 7)));
   $115 = SIMD_Int32x4_load(HEAPU8, $tmp);
   temp_Int32x4_ptr = $__a$addr$i388;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $100);
   temp_Int32x4_ptr = $__b$addr$i389;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, $115);
   $116 = SIMD_Int32x4_load(HEAPU8, $__a$addr$i388);
   temp_Int32x4_ptr = $xmm_acc;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_add($116, SIMD_Int32x4_load(HEAPU8, $__b$addr$i389)));
   temp_Int32x4_ptr = $__a$addr$i387;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_load(HEAPU8, $xmm_acc));
   temp_Int32x4_ptr = $__b$i;
   SIMD_Int32x4_store(HEAPU8, temp_Int32x4_ptr, SIMD_Int32x4_load(HEAPU8, $__a$addr$i387));
   $vecext$i = SIMD_Int32x4_extractLane(SIMD_Int32x4_load(HEAPU8, $__b$i), 0) | 0;
   HEAP32[$sumSquared >> 2] = (HEAP32[$sumSquared >> 2] | 0) + $vecext$i;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$dec_subframe_length >> 2] | 0)) break;
    HEAP32[$x_tmp >> 2] = HEAP16[$vla + ((HEAP32[$X_offset + (HEAP32[$b >> 2] << 2) >> 2] | 0) + (HEAP32[$i >> 2] | 0) + (HEAP32[$dec_subframe_offset >> 2] | 0) << 1) >> 1] >> 3;
    HEAP32[$sumSquared >> 2] = (HEAP32[$sumSquared >> 2] | 0) + (Math_imul((HEAP32[$x_tmp >> 2] & 65535) << 16 >> 16, (HEAP32[$x_tmp >> 2] & 65535) << 16 >> 16) | 0);
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   $135 = HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0;
   $136 = HEAP32[$sumSquared >> 2] | 0;
   if ((HEAP32[$s >> 2] | 0) < 3) {
    if ($135 + $136 & -2147483648 | 0) $cond = 2147483647; else $cond = (HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0) + (HEAP32[$sumSquared >> 2] | 0) | 0;
    $$sink = HEAP32[$b >> 2] | 0;
    $cond125$sink = $cond;
   } else {
    if ($135 + ($136 >> 1) & -2147483648 | 0) $cond125 = 2147483647; else $cond125 = (HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0) + (HEAP32[$sumSquared >> 2] >> 1) | 0;
    $$sink = HEAP32[$b >> 2] | 0;
    $cond125$sink = $cond125;
   }
   HEAP32[$Xnrg + ($$sink << 2) >> 2] = $cond125$sink;
   HEAP32[$dec_subframe_offset >> 2] = (HEAP32[$dec_subframe_offset >> 2] | 0) + (HEAP32[$dec_subframe_length >> 2] | 0);
   HEAP32[$s >> 2] = (HEAP32[$s >> 2] | 0) + 1;
  }
  HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 24 + (HEAP32[$b >> 2] << 2) >> 2] = HEAP32[$sumSquared >> 2];
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 _silk_VAD_GetNoiseLevels($Xnrg, HEAP32[$psSilk_VAD >> 2] | 0);
 HEAP32[$sumSquared >> 2] = 0;
 HEAP32[$input_tilt >> 2] = 0;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  HEAP32[$speech_nrg >> 2] = (HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] | 0);
  $160 = HEAP32[$b >> 2] | 0;
  if ((HEAP32[$speech_nrg >> 2] | 0) > 0) {
   $163 = HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0;
   if (!(HEAP32[$Xnrg + ($160 << 2) >> 2] & -8388608)) {
    $$sink1 = HEAP32[$b >> 2] | 0;
    $div163$sink = ($163 << 8 | 0) / ((HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] | 0) + 1 | 0) | 0;
   } else {
    $$sink1 = HEAP32[$b >> 2] | 0;
    $div163$sink = ($163 | 0) / ((HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] >> 8) + 1 | 0) | 0;
   }
   HEAP32[$NrgToNoiseRatio_Q8 + ($$sink1 << 2) >> 2] = $div163$sink;
   HEAP32[$SNR_Q7 >> 2] = (_silk_lin2log(HEAP32[$NrgToNoiseRatio_Q8 + (HEAP32[$b >> 2] << 2) >> 2] | 0) | 0) - 1024;
   HEAP32[$sumSquared >> 2] = (HEAP32[$sumSquared >> 2] | 0) + (Math_imul((HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0);
   if ((HEAP32[$speech_nrg >> 2] | 0) < 1048576) {
    $shr180 = (_silk_SQRT_APPROX_341(HEAP32[$speech_nrg >> 2] | 0) | 0) << 6 >> 16;
    $mul183 = Math_imul($shr180, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0;
    $and186 = (_silk_SQRT_APPROX_341(HEAP32[$speech_nrg >> 2] | 0) | 0) << 6 & 65535;
    HEAP32[$SNR_Q7 >> 2] = $mul183 + ((Math_imul($and186, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0) >> 16);
   }
   $mul197 = Math_imul(HEAP32[20724 + (HEAP32[$b >> 2] << 2) >> 2] >> 16, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$input_tilt >> 2] = (HEAP32[$input_tilt >> 2] | 0) + ($mul197 + ((Math_imul(HEAP32[20724 + (HEAP32[$b >> 2] << 2) >> 2] & 65535, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  } else HEAP32[$NrgToNoiseRatio_Q8 + ($160 << 2) >> 2] = 256;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 HEAP32[$sumSquared >> 2] = (HEAP32[$sumSquared >> 2] | 0) / 4 | 0;
 HEAP32[$pSNR_dB_Q7 >> 2] = ((_silk_SQRT_APPROX_341(HEAP32[$sumSquared >> 2] | 0) | 0) * 3 & 65535) << 16 >> 16;
 HEAP32[$SA_Q15 >> 2] = _silk_sigm_Q15(0 + (((HEAP32[$pSNR_dB_Q7 >> 2] & 65535) << 16 >> 16) * 45e3 >> 16) - 128 | 0) | 0;
 $shl229 = (_silk_sigm_Q15(HEAP32[$input_tilt >> 2] | 0) | 0) - 16384 << 1;
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4708 >> 2] = $shl229;
 HEAP32[$speech_nrg >> 2] = 0;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  $mul240 = Math_imul((HEAP32[$b >> 2] | 0) + 1 | 0, (HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] | 0) >> 4) | 0;
  HEAP32[$speech_nrg >> 2] = (HEAP32[$speech_nrg >> 2] | 0) + $mul240;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 if ((HEAP32[$speech_nrg >> 2] | 0) <= 0) HEAP32[$SA_Q15 >> 2] = HEAP32[$SA_Q15 >> 2] >> 1; else if ((HEAP32[$speech_nrg >> 2] | 0) < 32768) {
  $212 = HEAP32[$speech_nrg >> 2] | 0;
  if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0) == ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 10 | 0)) {
   if (($212 | 0) > 32767) $cond269 = 32767; else $cond269 = (HEAP32[$speech_nrg >> 2] | 0) < -32768 ? -32768 : HEAP32[$speech_nrg >> 2] | 0;
   HEAP32[$speech_nrg >> 2] = $cond269 << 16;
  } else {
   if (($212 | 0) > 65535) $cond283 = 65535; else $cond283 = (HEAP32[$speech_nrg >> 2] | 0) < -65536 ? -65536 : HEAP32[$speech_nrg >> 2] | 0;
   HEAP32[$speech_nrg >> 2] = $cond283 << 15;
  }
  HEAP32[$speech_nrg >> 2] = _silk_SQRT_APPROX_341(HEAP32[$speech_nrg >> 2] | 0) | 0;
  $mul291 = Math_imul(32768 + (HEAP32[$speech_nrg >> 2] | 0) >> 16, (HEAP32[$SA_Q15 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$SA_Q15 >> 2] = $mul291 + ((Math_imul(32768 + (HEAP32[$speech_nrg >> 2] | 0) & 65535, (HEAP32[$SA_Q15 >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 }
 $call302 = _silk_min_int_340(HEAP32[$SA_Q15 >> 2] >> 7, 255) | 0;
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4528 >> 2] = $call302;
 $mul319 = Math_imul(HEAP32[$SA_Q15 >> 2] >> 16, (HEAP32[$SA_Q15 >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$smooth_coef_Q16 >> 2] = 0 + (($mul319 + ((Math_imul(HEAP32[$SA_Q15 >> 2] & 65535, (HEAP32[$SA_Q15 >> 2] & 65535) << 16 >> 16) | 0) >> 16) & 65535) << 16 >> 16 << 12 >> 16);
 if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0) == ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 10 | 0)) HEAP32[$smooth_coef_Q16 >> 2] = HEAP32[$smooth_coef_Q16 >> 2] >> 1;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  $mul351 = Math_imul((HEAP32[$NrgToNoiseRatio_Q8 + (HEAP32[$b >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] | 0) >> 16, (HEAP32[$smooth_coef_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add362 = (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] | 0) + ($mul351 + ((Math_imul((HEAP32[$NrgToNoiseRatio_Q8 + (HEAP32[$b >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] | 0) & 65535, (HEAP32[$smooth_coef_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] = $add362;
  HEAP32[$SNR_Q7 >> 2] = ((_silk_lin2log(HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] | 0) | 0) - 1024 | 0) * 3;
  $call372 = _silk_sigm_Q15((HEAP32[$SNR_Q7 >> 2] | 0) - 2048 >> 4) | 0;
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4692 + (HEAP32[$b >> 2] << 2) >> 2] = $call372;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 $262 = HEAP32[$ret >> 2] | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return $262 | 0;
}

function _celt_decode_lost($st, $N, $LM) {
 $st = $st | 0;
 $N = $N | 0;
 $LM = $LM | 0;
 var $163 = 0, $269 = 0, $368 = 0, $369 = 0, $39 = 0, $C = 0, $E1 = 0, $E2 = 0, $LM$addr = 0, $N$addr = 0, $S1 = 0, $S2 = 0, $_exc = 0, $ac = 0, $add$ptr = 0, $add404 = 0, $arrayidx182 = 0, $attenuation = 0, $backgroundLogE = 0, $blen = 0, $boffs = 0, $buf = 0, $c = 0, $call132 = 0, $cond = 0, $cond41 = 0, $cond64 = 0.0, $decay = 0, $decay150 = 0, $decay_length = 0, $decode_mem = 0, $e = 0, $eBands = 0, $effEnd = 0, $end = 0, $exc = 0, $exc_length = 0, $extrapolation_len = 0, $extrapolation_offset = 0, $fade = 0, $i = 0, $inc = 0, $inc121 = 0, $inc399 = 0, $inc70 = 0, $j = 0, $j151 = 0, $loss_count = 0, $loss_count405 = 0, $lpc = 0, $lpc_mem = 0, $mode = 0, $mul42 = 0, $mul47 = 0, $mul50 = 0, $mul55 = 0, $mul59 = 0, $mul65 = 0, $mul79 = 0, $nbEBands = 0, $noise_based = 0, $oldBandE = 0, $oldLogE = 0, $oldLogE2 = 0, $out_syn = 0, $overlap = 0, $pitch_index = 0, $ratio = 0, $saved_stack = 0, $saved_stack143 = 0, $seed = 0, $st$addr = 0, $start = 0, $tmp = 0, $tmp303 = 0, $tmp_g = 0, $vla = 0, $vla144 = 0, $vla145 = 0, $window = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 4608 | 0;
 $st$addr = sp + 4596 | 0;
 $N$addr = sp + 4592 | 0;
 $LM$addr = sp + 4588 | 0;
 $c = sp + 4584 | 0;
 $i = sp + 4580 | 0;
 $C = sp + 4576 | 0;
 $decode_mem = sp + 4568 | 0;
 $out_syn = sp + 4560 | 0;
 $lpc = sp + 4556 | 0;
 $oldBandE = sp + 4552 | 0;
 $oldLogE = sp + 4548 | 0;
 $oldLogE2 = sp + 4544 | 0;
 $backgroundLogE = sp + 4540 | 0;
 $mode = sp + 4536 | 0;
 $nbEBands = sp + 4532 | 0;
 $overlap = sp + 4528 | 0;
 $start = sp + 4524 | 0;
 $loss_count = sp + 4520 | 0;
 $noise_based = sp + 4516 | 0;
 $eBands = sp + 4512 | 0;
 $seed = sp + 4508 | 0;
 $end = sp + 4504 | 0;
 $effEnd = sp + 4500 | 0;
 $decay = sp + 4496 | 0;
 $saved_stack = sp + 4492 | 0;
 $j = sp + 4488 | 0;
 $boffs = sp + 4484 | 0;
 $blen = sp + 4480 | 0;
 $exc_length = sp + 4476 | 0;
 $window = sp + 4472 | 0;
 $exc = sp + 4468 | 0;
 $fade = sp + 4464 | 0;
 $pitch_index = sp + 4460 | 0;
 $saved_stack143 = sp + 4456 | 0;
 $_exc = sp + 264 | 0;
 $decay150 = sp + 256 | 0;
 $attenuation = sp + 252 | 0;
 $S1 = sp + 248 | 0;
 $buf = sp + 244 | 0;
 $extrapolation_offset = sp + 240 | 0;
 $extrapolation_len = sp + 236 | 0;
 $j151 = sp + 232 | 0;
 $ac = sp + 132 | 0;
 $E1 = sp + 128 | 0;
 $E2 = sp + 124 | 0;
 $decay_length = sp + 120 | 0;
 $e = sp + 116 | 0;
 $tmp = sp + 112 | 0;
 $lpc_mem = sp + 16 | 0;
 $S2 = sp + 12 | 0;
 $tmp303 = sp + 8 | 0;
 $ratio = sp + 4 | 0;
 $tmp_g = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$C >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2];
 HEAP32[$mode >> 2] = HEAP32[HEAP32[$st$addr >> 2] >> 2];
 HEAP32[$nbEBands >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 8 >> 2];
 HEAP32[$overlap >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 4 >> 2];
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 32 >> 2];
 HEAP32[$c >> 2] = 0;
 do {
  $add$ptr = (HEAP32[$st$addr >> 2] | 0) + 92 + ((Math_imul(HEAP32[$c >> 2] | 0, 2048 + (HEAP32[$overlap >> 2] | 0) | 0) | 0) << 2) | 0;
  HEAP32[$decode_mem + (HEAP32[$c >> 2] << 2) >> 2] = $add$ptr;
  HEAP32[$out_syn + (HEAP32[$c >> 2] << 2) >> 2] = (HEAP32[$decode_mem + (HEAP32[$c >> 2] << 2) >> 2] | 0) + 8192 + (0 - (HEAP32[$N$addr >> 2] | 0) << 2);
  $inc = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc;
 } while (($inc | 0) < (HEAP32[$C >> 2] | 0));
 HEAP32[$lpc >> 2] = (HEAP32[$st$addr >> 2] | 0) + 92 + ((Math_imul(2048 + (HEAP32[$overlap >> 2] | 0) | 0, HEAP32[$C >> 2] | 0) | 0) << 2);
 HEAP32[$oldBandE >> 2] = (HEAP32[$lpc >> 2] | 0) + ((HEAP32[$C >> 2] | 0) * 24 << 2);
 HEAP32[$oldLogE >> 2] = (HEAP32[$oldBandE >> 2] | 0) + (HEAP32[$nbEBands >> 2] << 1 << 2);
 HEAP32[$oldLogE2 >> 2] = (HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$nbEBands >> 2] << 1 << 2);
 HEAP32[$backgroundLogE >> 2] = (HEAP32[$oldLogE2 >> 2] | 0) + (HEAP32[$nbEBands >> 2] << 1 << 2);
 HEAP32[$loss_count >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2];
 HEAP32[$start >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 20 >> 2];
 if ((HEAP32[$loss_count >> 2] | 0) >= 5 | (HEAP32[$start >> 2] | 0) != 0) $39 = 1; else $39 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] | 0) != 0;
 HEAP32[$noise_based >> 2] = $39 & 1;
 if (HEAP32[$noise_based >> 2] | 0) {
  HEAP32[$end >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2];
  if ((HEAP32[$end >> 2] | 0) < (HEAP32[(HEAP32[$mode >> 2] | 0) + 12 >> 2] | 0)) $cond = HEAP32[$end >> 2] | 0; else $cond = HEAP32[(HEAP32[$mode >> 2] | 0) + 12 >> 2] | 0;
  do if ((HEAP32[$start >> 2] | 0) > ($cond | 0)) $cond41 = HEAP32[$start >> 2] | 0; else if ((HEAP32[$end >> 2] | 0) < (HEAP32[(HEAP32[$mode >> 2] | 0) + 12 >> 2] | 0)) {
   $cond41 = HEAP32[$end >> 2] | 0;
   break;
  } else {
   $cond41 = HEAP32[(HEAP32[$mode >> 2] | 0) + 12 >> 2] | 0;
   break;
  } while (0);
  HEAP32[$effEnd >> 2] = $cond41;
  $mul42 = Math_imul(HEAP32[$C >> 2] | 0, HEAP32[$N$addr >> 2] | 0) | 0;
  HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
  $vla = STACKTOP;
  STACKTOP = STACKTOP + ((1 * ($mul42 << 2) | 0) + 15 & -16) | 0;
  HEAPF32[$decay >> 2] = (HEAP32[$loss_count >> 2] | 0) == 0 ? 1.5 : .5;
  HEAP32[$c >> 2] = 0;
  do {
   HEAP32[$i >> 2] = HEAP32[$start >> 2];
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
    $mul47 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
    $mul50 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
    if (+HEAPF32[(HEAP32[$backgroundLogE >> 2] | 0) + ($mul47 + (HEAP32[$i >> 2] | 0) << 2) >> 2] > +HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ($mul50 + (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[$decay >> 2]) {
     $mul55 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
     $cond64 = +HEAPF32[(HEAP32[$backgroundLogE >> 2] | 0) + ($mul55 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
    } else {
     $mul59 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
     $cond64 = +HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ($mul59 + (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[$decay >> 2];
    }
    $mul65 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0;
    HEAPF32[(HEAP32[$oldBandE >> 2] | 0) + ($mul65 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = $cond64;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   $inc70 = (HEAP32[$c >> 2] | 0) + 1 | 0;
   HEAP32[$c >> 2] = $inc70;
  } while (($inc70 | 0) < (HEAP32[$C >> 2] | 0));
  HEAP32[$seed >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2];
  HEAP32[$c >> 2] = 0;
  while (1) {
   if ((HEAP32[$c >> 2] | 0) >= (HEAP32[$C >> 2] | 0)) break;
   HEAP32[$i >> 2] = HEAP32[$start >> 2];
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$effEnd >> 2] | 0)) break;
    $mul79 = Math_imul(HEAP32[$N$addr >> 2] | 0, HEAP32[$c >> 2] | 0) | 0;
    HEAP32[$boffs >> 2] = $mul79 + (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2]);
    HEAP32[$blen >> 2] = (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) << HEAP32[$LM$addr >> 2];
    HEAP32[$j >> 2] = 0;
    while (1) {
     if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$blen >> 2] | 0)) break;
     HEAP32[$seed >> 2] = _celt_lcg_rand(HEAP32[$seed >> 2] | 0) | 0;
     HEAPF32[$vla + ((HEAP32[$boffs >> 2] | 0) + (HEAP32[$j >> 2] | 0) << 2) >> 2] = +(HEAP32[$seed >> 2] >> 20 | 0);
     HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
    }
    _renormalise_vector($vla + (HEAP32[$boffs >> 2] << 2) | 0, HEAP32[$blen >> 2] | 0, 1.0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0);
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP32[$c >> 2] = (HEAP32[$c >> 2] | 0) + 1;
  }
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] = HEAP32[$seed >> 2];
  HEAP32[$c >> 2] = 0;
  do {
   _memmove(HEAP32[$decode_mem + (HEAP32[$c >> 2] << 2) >> 2] | 0, (HEAP32[$decode_mem + (HEAP32[$c >> 2] << 2) >> 2] | 0) + (HEAP32[$N$addr >> 2] << 2) | 0, (2048 - (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$overlap >> 2] >> 1) << 2) + 0 | 0) | 0;
   $inc121 = (HEAP32[$c >> 2] | 0) + 1 | 0;
   HEAP32[$c >> 2] = $inc121;
  } while (($inc121 | 0) < (HEAP32[$C >> 2] | 0));
  _celt_synthesis(HEAP32[$mode >> 2] | 0, $vla, $out_syn, HEAP32[$oldBandE >> 2] | 0, HEAP32[$start >> 2] | 0, HEAP32[$effEnd >> 2] | 0, HEAP32[$C >> 2] | 0, HEAP32[$C >> 2] | 0, 0, HEAP32[$LM$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0, 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0);
  _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
  $368 = HEAP32[$loss_count >> 2] | 0;
  $add404 = $368 + 1 | 0;
  $369 = HEAP32[$st$addr >> 2] | 0;
  $loss_count405 = $369 + 52 | 0;
  HEAP32[$loss_count405 >> 2] = $add404;
  STACKTOP = sp;
  return;
 }
 HEAPF32[$fade >> 2] = 1.0;
 if (!(HEAP32[$loss_count >> 2] | 0)) {
  $call132 = _celt_plc_pitch_search($decode_mem, HEAP32[$C >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0) | 0;
  HEAP32[$pitch_index >> 2] = $call132;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] = $call132;
 } else {
  HEAP32[$pitch_index >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2];
  HEAPF32[$fade >> 2] = .800000011920929;
 }
 HEAP32[$exc_length >> 2] = (HEAP32[$pitch_index >> 2] << 1 | 0) < 1024 ? HEAP32[$pitch_index >> 2] << 1 : 1024;
 $163 = HEAP32[$overlap >> 2] | 0;
 HEAP32[$saved_stack143 >> 2] = _llvm_stacksave() | 0;
 $vla144 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($163 << 2) | 0) + 15 & -16) | 0;
 $vla145 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$exc_length >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[$exc >> 2] = $_exc + 96;
 HEAP32[$window >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 60 >> 2];
 HEAP32[$c >> 2] = 0;
 do {
  HEAPF32[$S1 >> 2] = 0.0;
  HEAP32[$buf >> 2] = HEAP32[$decode_mem + (HEAP32[$c >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 1048) break;
   HEAPF32[(HEAP32[$exc >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 24 << 2) >> 2] = +HEAPF32[(HEAP32[$buf >> 2] | 0) + (1e3 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  if (!(HEAP32[$loss_count >> 2] | 0)) {
   __celt_autocorr(HEAP32[$exc >> 2] | 0, $ac, HEAP32[$window >> 2] | 0, HEAP32[$overlap >> 2] | 0, 24, 1024, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0) | 0;
   HEAPF32[$ac >> 2] = +HEAPF32[$ac >> 2] * 1.000100016593933;
   HEAP32[$i >> 2] = 1;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) > 24) break;
    $arrayidx182 = $ac + (HEAP32[$i >> 2] << 2) | 0;
    HEAPF32[$arrayidx182 >> 2] = +HEAPF32[$arrayidx182 >> 2] - +HEAPF32[$ac + (HEAP32[$i >> 2] << 2) >> 2] * 6.400000711437315e-05 * +(HEAP32[$i >> 2] | 0) * +(HEAP32[$i >> 2] | 0);
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   __celt_lpc((HEAP32[$lpc >> 2] | 0) + ((HEAP32[$c >> 2] | 0) * 24 << 2) | 0, $ac, 24);
  }
  _celt_fir_c((HEAP32[$exc >> 2] | 0) + 4096 + (0 - (HEAP32[$exc_length >> 2] | 0) << 2) | 0, (HEAP32[$lpc >> 2] | 0) + ((HEAP32[$c >> 2] | 0) * 24 << 2) | 0, $vla145, HEAP32[$exc_length >> 2] | 0, 24, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0);
  _memcpy((HEAP32[$exc >> 2] | 0) + 4096 + (0 - (HEAP32[$exc_length >> 2] | 0) << 2) | 0, $vla145 | 0, (HEAP32[$exc_length >> 2] << 2) + 0 | 0) | 0;
  HEAPF32[$E1 >> 2] = 1.0;
  HEAPF32[$E2 >> 2] = 1.0;
  HEAP32[$decay_length >> 2] = HEAP32[$exc_length >> 2] >> 1;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$decay_length >> 2] | 0)) break;
   HEAPF32[$e >> 2] = +HEAPF32[(HEAP32[$exc >> 2] | 0) + (1024 - (HEAP32[$decay_length >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
   HEAPF32[$E1 >> 2] = +HEAPF32[$E1 >> 2] + +HEAPF32[$e >> 2] * +HEAPF32[$e >> 2];
   HEAPF32[$e >> 2] = +HEAPF32[(HEAP32[$exc >> 2] | 0) + (1024 - (HEAP32[$decay_length >> 2] << 1) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
   HEAPF32[$E2 >> 2] = +HEAPF32[$E2 >> 2] + +HEAPF32[$e >> 2] * +HEAPF32[$e >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[$E1 >> 2] = +HEAPF32[$E1 >> 2] < +HEAPF32[$E2 >> 2] ? +HEAPF32[$E1 >> 2] : +HEAPF32[$E2 >> 2];
  HEAPF32[$decay150 >> 2] = +Math_sqrt(+(+HEAPF32[$E1 >> 2] / +HEAPF32[$E2 >> 2]));
  _memmove(HEAP32[$buf >> 2] | 0, (HEAP32[$buf >> 2] | 0) + (HEAP32[$N$addr >> 2] << 2) | 0, (2048 - (HEAP32[$N$addr >> 2] | 0) << 2) + 0 | 0) | 0;
  HEAP32[$extrapolation_offset >> 2] = 1024 - (HEAP32[$pitch_index >> 2] | 0);
  HEAP32[$extrapolation_len >> 2] = (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$overlap >> 2] | 0);
  HEAPF32[$attenuation >> 2] = +HEAPF32[$fade >> 2] * +HEAPF32[$decay150 >> 2];
  HEAP32[$j151 >> 2] = 0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$extrapolation_len >> 2] | 0)) break;
   if ((HEAP32[$j151 >> 2] | 0) >= (HEAP32[$pitch_index >> 2] | 0)) {
    HEAP32[$j151 >> 2] = (HEAP32[$j151 >> 2] | 0) - (HEAP32[$pitch_index >> 2] | 0);
    HEAPF32[$attenuation >> 2] = +HEAPF32[$attenuation >> 2] * +HEAPF32[$decay150 >> 2];
   }
   HEAPF32[(HEAP32[$buf >> 2] | 0) + (2048 - (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] = +HEAPF32[$attenuation >> 2] * +HEAPF32[(HEAP32[$exc >> 2] | 0) + ((HEAP32[$extrapolation_offset >> 2] | 0) + (HEAP32[$j151 >> 2] | 0) << 2) >> 2];
   HEAPF32[$tmp >> 2] = +HEAPF32[(HEAP32[$buf >> 2] | 0) + (1024 - (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$extrapolation_offset >> 2] | 0) + (HEAP32[$j151 >> 2] | 0) << 2) >> 2];
   HEAPF32[$S1 >> 2] = +HEAPF32[$S1 >> 2] + +HEAPF32[$tmp >> 2] * +HEAPF32[$tmp >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   HEAP32[$j151 >> 2] = (HEAP32[$j151 >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = 0;
  while (1) {
   $269 = HEAP32[$buf >> 2] | 0;
   if ((HEAP32[$i >> 2] | 0) >= 24) break;
   HEAPF32[$lpc_mem + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$269 + (2048 - (HEAP32[$N$addr >> 2] | 0) - 1 - (HEAP32[$i >> 2] | 0) << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  _celt_iir($269 + 8192 + (0 - (HEAP32[$N$addr >> 2] | 0) << 2) | 0, (HEAP32[$lpc >> 2] | 0) + ((HEAP32[$c >> 2] | 0) * 24 << 2) | 0, (HEAP32[$buf >> 2] | 0) + 8192 + (0 - (HEAP32[$N$addr >> 2] | 0) << 2) | 0, HEAP32[$extrapolation_len >> 2] | 0, 24, $lpc_mem, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0);
  HEAPF32[$S2 >> 2] = 0.0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$extrapolation_len >> 2] | 0)) break;
   HEAPF32[$tmp303 >> 2] = +HEAPF32[(HEAP32[$buf >> 2] | 0) + (2048 - (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
   HEAPF32[$S2 >> 2] = +HEAPF32[$S2 >> 2] + +HEAPF32[$tmp303 >> 2] * +HEAPF32[$tmp303 >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  L84 : do if (+HEAPF32[$S1 >> 2] > +HEAPF32[$S2 >> 2] * .20000000298023224) {
   if (+HEAPF32[$S1 >> 2] < +HEAPF32[$S2 >> 2]) {
    HEAPF32[$ratio >> 2] = +Math_sqrt(+((+HEAPF32[$S1 >> 2] + 1.0) / (+HEAPF32[$S2 >> 2] + 1.0)));
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$overlap >> 2] | 0)) break;
     HEAPF32[$tmp_g >> 2] = 1.0 - +HEAPF32[(HEAP32[$window >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * (1.0 - +HEAPF32[$ratio >> 2]);
     HEAPF32[(HEAP32[$buf >> 2] | 0) + (2048 - (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] = +HEAPF32[$tmp_g >> 2] * +HEAPF32[(HEAP32[$buf >> 2] | 0) + (2048 - (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
    HEAP32[$i >> 2] = HEAP32[$overlap >> 2];
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$extrapolation_len >> 2] | 0)) break L84;
     HEAPF32[(HEAP32[$buf >> 2] | 0) + (2048 - (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] = +HEAPF32[$ratio >> 2] * +HEAPF32[(HEAP32[$buf >> 2] | 0) + (2048 - (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   }
  } else {
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$extrapolation_len >> 2] | 0)) break L84;
    HEAPF32[(HEAP32[$buf >> 2] | 0) + (2048 - (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] = 0.0;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  } while (0);
  _comb_filter($vla144, (HEAP32[$buf >> 2] | 0) + 8192 | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[$overlap >> 2] | 0, -+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2], -+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2], HEAP32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2] | 0, 0, 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] | 0);
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$overlap >> 2] | 0) / 2 | 0 | 0)) break;
   HEAPF32[(HEAP32[$buf >> 2] | 0) + (2048 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = +HEAPF32[(HEAP32[$window >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[$vla144 + ((HEAP32[$overlap >> 2] | 0) - 1 - (HEAP32[$i >> 2] | 0) << 2) >> 2] + +HEAPF32[(HEAP32[$window >> 2] | 0) + ((HEAP32[$overlap >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] * +HEAPF32[$vla144 + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc399 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc399;
 } while (($inc399 | 0) < (HEAP32[$C >> 2] | 0));
 _llvm_stackrestore(HEAP32[$saved_stack143 >> 2] | 0);
 $368 = HEAP32[$loss_count >> 2] | 0;
 $add404 = $368 + 1 | 0;
 $369 = HEAP32[$st$addr >> 2] | 0;
 $loss_count405 = $369 + 52 | 0;
 HEAP32[$loss_count405 >> 2] = $add404;
 STACKTOP = sp;
 return;
}

function _silk_noise_shape_quantizer($NSQ, $signalType, $x_sc_Q10, $pulses, $xq, $sLTP_Q15, $a_Q12, $b_Q14, $AR_shp_Q13, $lag, $HarmShapeFIRPacked_Q14, $Tilt_Q14, $LF_shp_Q14, $Gain_Q16, $Lambda_Q10, $offset_Q10, $length, $shapingLPCOrder, $predictLPCOrder, $arch) {
 $NSQ = $NSQ | 0;
 $signalType = $signalType | 0;
 $x_sc_Q10 = $x_sc_Q10 | 0;
 $pulses = $pulses | 0;
 $xq = $xq | 0;
 $sLTP_Q15 = $sLTP_Q15 | 0;
 $a_Q12 = $a_Q12 | 0;
 $b_Q14 = $b_Q14 | 0;
 $AR_shp_Q13 = $AR_shp_Q13 | 0;
 $lag = $lag | 0;
 $HarmShapeFIRPacked_Q14 = $HarmShapeFIRPacked_Q14 | 0;
 $Tilt_Q14 = $Tilt_Q14 | 0;
 $LF_shp_Q14 = $LF_shp_Q14 | 0;
 $Gain_Q16 = $Gain_Q16 | 0;
 $Lambda_Q10 = $Lambda_Q10 | 0;
 $offset_Q10 = $offset_Q10 | 0;
 $length = $length | 0;
 $shapingLPCOrder = $shapingLPCOrder | 0;
 $predictLPCOrder = $predictLPCOrder | 0;
 $arch = $arch | 0;
 var $12 = 0, $140 = 0, $141 = 0, $142 = 0, $145 = 0, $AR_shp_Q13$addr = 0, $Gain_Q10 = 0, $Gain_Q16$addr = 0, $HarmShapeFIRPacked_Q14$addr = 0, $LF_shp_Q14$addr = 0, $LPC_exc_Q14 = 0, $LPC_pred_Q10 = 0, $LTP_pred_Q13 = 0, $Lambda_Q10$addr = 0, $NSQ$addr = 0, $Tilt_Q14$addr = 0, $a_Q12$addr = 0, $add107 = 0, $add139 = 0, $add313 = 0, $add335 = 0, $add357 = 0, $add5 = 0, $b_Q14$addr = 0, $cond174 = 0, $cond369 = 0, $exc_Q14 = 0, $i = 0, $lag$addr = 0, $length$addr = 0, $mul11 = 0, $mul125 = 0, $mul23 = 0, $mul307 = 0, $mul329 = 0, $mul351 = 0, $mul36 = 0, $mul49 = 0, $mul62 = 0, $mul76 = 0, $mul92 = 0, $n_AR_Q12 = 0, $n_LF_Q12 = 0, $n_LTP_Q13 = 0, $offset_Q10$addr = 0, $pred_lag_ptr = 0, $predictLPCOrder$addr = 0, $psLPC_Q14 = 0, $pulses$addr = 0, $q1_Q0 = 0, $q1_Q10 = 0, $q2_Q10 = 0, $r_Q10 = 0, $rd1_Q20 = 0, $rd2_Q20 = 0, $rdo_offset = 0, $rr_Q10 = 0, $sLF_AR_shp_Q14 = 0, $sLTP_Q15$addr = 0, $sLTP_buf_idx390 = 0, $sLTP_shp_buf_idx389 = 0, $shapingLPCOrder$addr = 0, $shp_lag_ptr = 0, $signalType$addr = 0, $tmp1 = 0, $tmp2 = 0, $x_sc_Q10$addr = 0, $xq$addr = 0, $xq_Q14 = 0, dest = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 $NSQ$addr = sp + 172 | 0;
 $signalType$addr = sp + 168 | 0;
 $x_sc_Q10$addr = sp + 164 | 0;
 $pulses$addr = sp + 160 | 0;
 $xq$addr = sp + 156 | 0;
 $sLTP_Q15$addr = sp + 152 | 0;
 $a_Q12$addr = sp + 148 | 0;
 $b_Q14$addr = sp + 144 | 0;
 $AR_shp_Q13$addr = sp + 140 | 0;
 $lag$addr = sp + 136 | 0;
 $HarmShapeFIRPacked_Q14$addr = sp + 132 | 0;
 $Tilt_Q14$addr = sp + 128 | 0;
 $LF_shp_Q14$addr = sp + 124 | 0;
 $Gain_Q16$addr = sp + 120 | 0;
 $Lambda_Q10$addr = sp + 116 | 0;
 $offset_Q10$addr = sp + 112 | 0;
 $length$addr = sp + 108 | 0;
 $shapingLPCOrder$addr = sp + 104 | 0;
 $predictLPCOrder$addr = sp + 100 | 0;
 $i = sp + 92 | 0;
 $LTP_pred_Q13 = sp + 88 | 0;
 $LPC_pred_Q10 = sp + 84 | 0;
 $n_AR_Q12 = sp + 80 | 0;
 $n_LTP_Q13 = sp + 76 | 0;
 $n_LF_Q12 = sp + 72 | 0;
 $r_Q10 = sp + 68 | 0;
 $rr_Q10 = sp + 64 | 0;
 $q1_Q0 = sp + 60 | 0;
 $q1_Q10 = sp + 56 | 0;
 $q2_Q10 = sp + 52 | 0;
 $rd1_Q20 = sp + 48 | 0;
 $rd2_Q20 = sp + 44 | 0;
 $exc_Q14 = sp + 40 | 0;
 $LPC_exc_Q14 = sp + 36 | 0;
 $xq_Q14 = sp + 32 | 0;
 $Gain_Q10 = sp + 28 | 0;
 $tmp1 = sp + 24 | 0;
 $tmp2 = sp + 20 | 0;
 $sLF_AR_shp_Q14 = sp + 16 | 0;
 $psLPC_Q14 = sp + 12 | 0;
 $shp_lag_ptr = sp + 8 | 0;
 $pred_lag_ptr = sp + 4 | 0;
 $rdo_offset = sp;
 HEAP32[$NSQ$addr >> 2] = $NSQ;
 HEAP32[$signalType$addr >> 2] = $signalType;
 HEAP32[$x_sc_Q10$addr >> 2] = $x_sc_Q10;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$xq$addr >> 2] = $xq;
 HEAP32[$sLTP_Q15$addr >> 2] = $sLTP_Q15;
 HEAP32[$a_Q12$addr >> 2] = $a_Q12;
 HEAP32[$b_Q14$addr >> 2] = $b_Q14;
 HEAP32[$AR_shp_Q13$addr >> 2] = $AR_shp_Q13;
 HEAP32[$lag$addr >> 2] = $lag;
 HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] = $HarmShapeFIRPacked_Q14;
 HEAP32[$Tilt_Q14$addr >> 2] = $Tilt_Q14;
 HEAP32[$LF_shp_Q14$addr >> 2] = $LF_shp_Q14;
 HEAP32[$Gain_Q16$addr >> 2] = $Gain_Q16;
 HEAP32[$Lambda_Q10$addr >> 2] = $Lambda_Q10;
 HEAP32[$offset_Q10$addr >> 2] = $offset_Q10;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$shapingLPCOrder$addr >> 2] = $shapingLPCOrder;
 HEAP32[$predictLPCOrder$addr >> 2] = $predictLPCOrder;
 HEAP32[sp + 96 >> 2] = $arch;
 HEAP32[$shp_lag_ptr >> 2] = (HEAP32[$NSQ$addr >> 2] | 0) + 1280 + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0) - (HEAP32[$lag$addr >> 2] | 0) + 1 << 2);
 HEAP32[$pred_lag_ptr >> 2] = (HEAP32[$sLTP_Q15$addr >> 2] | 0) + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0) - (HEAP32[$lag$addr >> 2] | 0) + 2 << 2);
 HEAP32[$Gain_Q10 >> 2] = HEAP32[$Gain_Q16$addr >> 2] >> 6;
 HEAP32[$psLPC_Q14 >> 2] = (HEAP32[$NSQ$addr >> 2] | 0) + 3840 + 60;
 HEAP32[$i >> 2] = 0;
 while (1) {
  $12 = HEAP32[$NSQ$addr >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  $add5 = 907633515 + (Math_imul(HEAP32[$12 + 4340 >> 2] | 0, 196314165) | 0) | 0;
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4340 >> 2] = $add5;
  HEAP32[$LPC_pred_Q10 >> 2] = _silk_noise_shape_quantizer_short_prediction_c(HEAP32[$psLPC_Q14 >> 2] | 0, HEAP32[$a_Q12$addr >> 2] | 0, HEAP32[$predictLPCOrder$addr >> 2] | 0) | 0;
  if ((HEAP32[$signalType$addr >> 2] | 0) == 2) {
   HEAP32[$LTP_pred_Q13 >> 2] = 2;
   $mul11 = Math_imul(HEAP32[HEAP32[$pred_lag_ptr >> 2] >> 2] >> 16, HEAP16[HEAP32[$b_Q14$addr >> 2] >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul11 + ((Math_imul(HEAP32[HEAP32[$pred_lag_ptr >> 2] >> 2] & 65535, HEAP16[HEAP32[$b_Q14$addr >> 2] >> 1] | 0) | 0) >> 16));
   $mul23 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -4 >> 2] >> 16, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 2 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul23 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -4 >> 2] & 65535, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
   $mul36 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -8 >> 2] >> 16, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 4 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul36 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -8 >> 2] & 65535, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
   $mul49 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -12 >> 2] >> 16, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 6 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul49 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -12 >> 2] & 65535, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
   $mul62 = Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -16 >> 2] >> 16, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 8 >> 1] | 0) | 0;
   HEAP32[$LTP_pred_Q13 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) + ($mul62 + ((Math_imul(HEAP32[(HEAP32[$pred_lag_ptr >> 2] | 0) + -16 >> 2] & 65535, HEAP16[(HEAP32[$b_Q14$addr >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
   HEAP32[$pred_lag_ptr >> 2] = (HEAP32[$pred_lag_ptr >> 2] | 0) + 4;
  } else HEAP32[$LTP_pred_Q13 >> 2] = 0;
  HEAP32[$n_AR_Q12 >> 2] = _silk_NSQ_noise_shape_feedback_loop_c((HEAP32[$NSQ$addr >> 2] | 0) + 4324 | 0, (HEAP32[$NSQ$addr >> 2] | 0) + 4224 | 0, HEAP32[$AR_shp_Q13$addr >> 2] | 0, HEAP32[$shapingLPCOrder$addr >> 2] | 0) | 0;
  $mul76 = Math_imul(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] >> 16, (HEAP32[$Tilt_Q14$addr >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$n_AR_Q12 >> 2] = (HEAP32[$n_AR_Q12 >> 2] | 0) + ($mul76 + ((Math_imul(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] & 65535, (HEAP32[$Tilt_Q14$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  $mul92 = Math_imul(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0) - 1 << 2) >> 2] >> 16, (HEAP32[$LF_shp_Q14$addr >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$n_LF_Q12 >> 2] = $mul92 + ((Math_imul(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0) - 1 << 2) >> 2] & 65535, (HEAP32[$LF_shp_Q14$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16);
  $add107 = (HEAP32[$n_LF_Q12 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] >> 16, HEAP32[$LF_shp_Q14$addr >> 2] >> 16) | 0) | 0;
  HEAP32[$n_LF_Q12 >> 2] = $add107 + ((Math_imul(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] & 65535, HEAP32[$LF_shp_Q14$addr >> 2] >> 16) | 0) >> 16);
  HEAP32[$tmp1 >> 2] = (HEAP32[$LPC_pred_Q10 >> 2] << 2) - (HEAP32[$n_AR_Q12 >> 2] | 0);
  HEAP32[$tmp1 >> 2] = (HEAP32[$tmp1 >> 2] | 0) - (HEAP32[$n_LF_Q12 >> 2] | 0);
  if ((HEAP32[$lag$addr >> 2] | 0) > 0) {
   $mul125 = Math_imul((HEAP32[HEAP32[$shp_lag_ptr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$shp_lag_ptr >> 2] | 0) + -8 >> 2] | 0) >> 16, (HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$n_LTP_Q13 >> 2] = $mul125 + ((Math_imul((HEAP32[HEAP32[$shp_lag_ptr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$shp_lag_ptr >> 2] | 0) + -8 >> 2] | 0) & 65535, (HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16);
   $add139 = (HEAP32[$n_LTP_Q13 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$shp_lag_ptr >> 2] | 0) + -4 >> 2] >> 16, HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] >> 16) | 0) | 0;
   HEAP32[$n_LTP_Q13 >> 2] = $add139 + ((Math_imul(HEAP32[(HEAP32[$shp_lag_ptr >> 2] | 0) + -4 >> 2] & 65535, HEAP32[$HarmShapeFIRPacked_Q14$addr >> 2] >> 16) | 0) >> 16);
   HEAP32[$n_LTP_Q13 >> 2] = HEAP32[$n_LTP_Q13 >> 2] << 1;
   HEAP32[$shp_lag_ptr >> 2] = (HEAP32[$shp_lag_ptr >> 2] | 0) + 4;
   HEAP32[$tmp2 >> 2] = (HEAP32[$LTP_pred_Q13 >> 2] | 0) - (HEAP32[$n_LTP_Q13 >> 2] | 0);
   HEAP32[$tmp1 >> 2] = (HEAP32[$tmp2 >> 2] | 0) + (HEAP32[$tmp1 >> 2] << 1);
   HEAP32[$tmp1 >> 2] = (HEAP32[$tmp1 >> 2] >> 2) + 1 >> 1;
  } else HEAP32[$tmp1 >> 2] = (HEAP32[$tmp1 >> 2] >> 1) + 1 >> 1;
  HEAP32[$r_Q10 >> 2] = (HEAP32[(HEAP32[$x_sc_Q10$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) - (HEAP32[$tmp1 >> 2] | 0);
  if ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4340 >> 2] | 0) < 0) HEAP32[$r_Q10 >> 2] = 0 - (HEAP32[$r_Q10 >> 2] | 0);
  if ((HEAP32[$r_Q10 >> 2] | 0) > 30720) $cond174 = 30720; else $cond174 = (HEAP32[$r_Q10 >> 2] | 0) < -31744 ? -31744 : HEAP32[$r_Q10 >> 2] | 0;
  HEAP32[$r_Q10 >> 2] = $cond174;
  HEAP32[$q1_Q10 >> 2] = (HEAP32[$r_Q10 >> 2] | 0) - (HEAP32[$offset_Q10$addr >> 2] | 0);
  HEAP32[$q1_Q0 >> 2] = HEAP32[$q1_Q10 >> 2] >> 10;
  do if ((HEAP32[$Lambda_Q10$addr >> 2] | 0) > 2048) {
   HEAP32[$rdo_offset >> 2] = ((HEAP32[$Lambda_Q10$addr >> 2] | 0) / 2 | 0) - 512;
   $140 = HEAP32[$q1_Q10 >> 2] | 0;
   $141 = HEAP32[$rdo_offset >> 2] | 0;
   if ((HEAP32[$q1_Q10 >> 2] | 0) > (HEAP32[$rdo_offset >> 2] | 0)) {
    HEAP32[$q1_Q0 >> 2] = $140 - $141 >> 10;
    break;
   }
   $142 = HEAP32[$q1_Q10 >> 2] | 0;
   if (($140 | 0) < (0 - $141 | 0)) {
    HEAP32[$q1_Q0 >> 2] = $142 + (HEAP32[$rdo_offset >> 2] | 0) >> 10;
    break;
   }
   if (($142 | 0) < 0) {
    HEAP32[$q1_Q0 >> 2] = -1;
    break;
   } else {
    HEAP32[$q1_Q0 >> 2] = 0;
    break;
   }
  } while (0);
  $145 = HEAP32[$q1_Q0 >> 2] | 0;
  do if ((HEAP32[$q1_Q0 >> 2] | 0) > 0) {
   HEAP32[$q1_Q10 >> 2] = ($145 << 10) - 80;
   HEAP32[$q1_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + (HEAP32[$offset_Q10$addr >> 2] | 0);
   HEAP32[$q2_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + 1024;
   HEAP32[$rd1_Q20 >> 2] = Math_imul((HEAP32[$q1_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$rd2_Q20 >> 2] = Math_imul((HEAP32[$q2_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
  } else {
   if (!$145) {
    HEAP32[$q1_Q10 >> 2] = HEAP32[$offset_Q10$addr >> 2];
    HEAP32[$q2_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + 944;
    HEAP32[$rd1_Q20 >> 2] = Math_imul((HEAP32[$q1_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
    HEAP32[$rd2_Q20 >> 2] = Math_imul((HEAP32[$q2_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
    break;
   }
   if ((HEAP32[$q1_Q0 >> 2] | 0) == -1) {
    HEAP32[$q2_Q10 >> 2] = HEAP32[$offset_Q10$addr >> 2];
    HEAP32[$q1_Q10 >> 2] = (HEAP32[$q2_Q10 >> 2] | 0) - 944;
    HEAP32[$rd1_Q20 >> 2] = Math_imul((0 - (HEAP32[$q1_Q10 >> 2] | 0) & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
    HEAP32[$rd2_Q20 >> 2] = Math_imul((HEAP32[$q2_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
    break;
   } else {
    HEAP32[$q1_Q10 >> 2] = (HEAP32[$q1_Q0 >> 2] << 10) + 80;
    HEAP32[$q1_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + (HEAP32[$offset_Q10$addr >> 2] | 0);
    HEAP32[$q2_Q10 >> 2] = (HEAP32[$q1_Q10 >> 2] | 0) + 1024;
    HEAP32[$rd1_Q20 >> 2] = Math_imul((0 - (HEAP32[$q1_Q10 >> 2] | 0) & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
    HEAP32[$rd2_Q20 >> 2] = Math_imul((0 - (HEAP32[$q2_Q10 >> 2] | 0) & 65535) << 16 >> 16, (HEAP32[$Lambda_Q10$addr >> 2] & 65535) << 16 >> 16) | 0;
    break;
   }
  } while (0);
  HEAP32[$rr_Q10 >> 2] = (HEAP32[$r_Q10 >> 2] | 0) - (HEAP32[$q1_Q10 >> 2] | 0);
  HEAP32[$rd1_Q20 >> 2] = (HEAP32[$rd1_Q20 >> 2] | 0) + (Math_imul((HEAP32[$rr_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$rr_Q10 >> 2] & 65535) << 16 >> 16) | 0);
  HEAP32[$rr_Q10 >> 2] = (HEAP32[$r_Q10 >> 2] | 0) - (HEAP32[$q2_Q10 >> 2] | 0);
  HEAP32[$rd2_Q20 >> 2] = (HEAP32[$rd2_Q20 >> 2] | 0) + (Math_imul((HEAP32[$rr_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$rr_Q10 >> 2] & 65535) << 16 >> 16) | 0);
  if ((HEAP32[$rd2_Q20 >> 2] | 0) < (HEAP32[$rd1_Q20 >> 2] | 0)) HEAP32[$q1_Q10 >> 2] = HEAP32[$q2_Q10 >> 2];
  HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] = (HEAP32[$q1_Q10 >> 2] >> 9) + 1 >> 1;
  HEAP32[$exc_Q14 >> 2] = HEAP32[$q1_Q10 >> 2] << 4;
  if ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4340 >> 2] | 0) < 0) HEAP32[$exc_Q14 >> 2] = 0 - (HEAP32[$exc_Q14 >> 2] | 0);
  HEAP32[$LPC_exc_Q14 >> 2] = (HEAP32[$exc_Q14 >> 2] | 0) + (HEAP32[$LTP_pred_Q13 >> 2] << 1);
  HEAP32[$xq_Q14 >> 2] = (HEAP32[$LPC_exc_Q14 >> 2] | 0) + (HEAP32[$LPC_pred_Q10 >> 2] << 4);
  $mul307 = Math_imul(HEAP32[$xq_Q14 >> 2] >> 16, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
  $add313 = $mul307 + ((Math_imul(HEAP32[$xq_Q14 >> 2] & 65535, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  if ((($add313 + (Math_imul(HEAP32[$xq_Q14 >> 2] | 0, (HEAP32[$Gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) > 32767) $cond369 = 32767; else {
   $mul329 = Math_imul(HEAP32[$xq_Q14 >> 2] >> 16, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
   $add335 = $mul329 + ((Math_imul(HEAP32[$xq_Q14 >> 2] & 65535, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   if ((($add335 + (Math_imul(HEAP32[$xq_Q14 >> 2] | 0, (HEAP32[$Gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1 | 0) < -32768) $cond369 = -32768; else {
    $mul351 = Math_imul(HEAP32[$xq_Q14 >> 2] >> 16, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0;
    $add357 = $mul351 + ((Math_imul(HEAP32[$xq_Q14 >> 2] & 65535, (HEAP32[$Gain_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    $cond369 = ($add357 + (Math_imul(HEAP32[$xq_Q14 >> 2] | 0, (HEAP32[$Gain_Q10 >> 2] >> 15) + 1 >> 1) | 0) >> 7) + 1 >> 1;
   }
  }
  HEAP16[(HEAP32[$xq$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $cond369;
  HEAP32[$psLPC_Q14 >> 2] = (HEAP32[$psLPC_Q14 >> 2] | 0) + 4;
  HEAP32[HEAP32[$psLPC_Q14 >> 2] >> 2] = HEAP32[$xq_Q14 >> 2];
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4324 >> 2] = (HEAP32[$xq_Q14 >> 2] | 0) - (HEAP32[(HEAP32[$x_sc_Q10$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] << 4);
  HEAP32[$sLF_AR_shp_Q14 >> 2] = (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4324 >> 2] | 0) - (HEAP32[$n_AR_Q12 >> 2] << 2);
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] = HEAP32[$sLF_AR_shp_Q14 >> 2];
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] << 2) >> 2] = (HEAP32[$sLF_AR_shp_Q14 >> 2] | 0) - (HEAP32[$n_LF_Q12 >> 2] << 2);
  HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] << 2) >> 2] = HEAP32[$LPC_exc_Q14 >> 2] << 1;
  $sLTP_shp_buf_idx389 = (HEAP32[$NSQ$addr >> 2] | 0) + 4336 | 0;
  HEAP32[$sLTP_shp_buf_idx389 >> 2] = (HEAP32[$sLTP_shp_buf_idx389 >> 2] | 0) + 1;
  $sLTP_buf_idx390 = (HEAP32[$NSQ$addr >> 2] | 0) + 4332 | 0;
  HEAP32[$sLTP_buf_idx390 >> 2] = (HEAP32[$sLTP_buf_idx390 >> 2] | 0) + 1;
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4340 >> 2] = (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4340 >> 2] | 0) + (HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 dest = $12 + 3840 | 0;
 src = (HEAP32[$NSQ$addr >> 2] | 0) + 3840 + (HEAP32[$length$addr >> 2] << 2) | 0;
 stop = dest + 64 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 STACKTOP = sp;
 return;
}

function _compute_theta($ctx, $sctx, $X, $Y, $N, $b, $B, $B0, $LM, $stereo, $fill) {
 $ctx = $ctx | 0;
 $sctx = $sctx | 0;
 $X = $X | 0;
 $Y = $Y | 0;
 $N = $N | 0;
 $b = $b | 0;
 $B = $B | 0;
 $B0 = $B0 | 0;
 $LM = $LM | 0;
 $stereo = $stereo | 0;
 $fill = $fill | 0;
 var $142 = 0, $211 = 0, $232 = 0, $239 = 0, $243 = 0, $248 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $83 = 0, $92 = 0, $B$addr = 0, $B0$addr = 0, $LM$addr = 0, $N$addr = 0, $X$addr = 0, $Y$addr = 0, $b$addr = 0, $bandE = 0, $bias = 0, $call332 = 0, $cond102 = 0, $cond134 = 0, $cond146 = 0, $cond173 = 0, $cond185 = 0, $cond219 = 0, $cond236 = 0, $cond83 = 0, $conv359 = 0, $conv49 = 0, $ctx$addr = 0, $delta = 0, $delta371 = 0, $down = 0, $ec = 0, $encode = 0, $fill$addr = 0, $fl = 0, $fl239 = 0, $fm = 0, $fs = 0, $fs201 = 0, $ft = 0, $ft202 = 0, $i = 0, $imid = 0, $imid369 = 0, $intensity = 0, $inv = 0, $iside = 0, $iside370 = 0, $itheta = 0, $itheta372 = 0, $j = 0, $m = 0, $mul119 = 0, $mul260 = 0, $mul72 = 0, $mul79 = 0, $mul89 = 0, $mul96 = 0, $offset = 0, $p0 = 0, $pulse_cap = 0, $qalloc = 0, $qalloc373 = 0, $qn = 0, $sctx$addr = 0, $stereo$addr = 0, $tell = 0, $unquantized = 0, $x = 0, $x0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 $ctx$addr = sp + 160 | 0;
 $sctx$addr = sp + 156 | 0;
 $X$addr = sp + 152 | 0;
 $Y$addr = sp + 148 | 0;
 $N$addr = sp + 144 | 0;
 $b$addr = sp + 140 | 0;
 $B$addr = sp + 136 | 0;
 $B0$addr = sp + 132 | 0;
 $LM$addr = sp + 128 | 0;
 $stereo$addr = sp + 124 | 0;
 $fill$addr = sp + 120 | 0;
 $qn = sp + 116 | 0;
 $itheta = sp + 112 | 0;
 $delta = sp + 108 | 0;
 $imid = sp + 104 | 0;
 $iside = sp + 100 | 0;
 $qalloc = sp + 96 | 0;
 $pulse_cap = sp + 92 | 0;
 $offset = sp + 88 | 0;
 $tell = sp + 84 | 0;
 $inv = sp + 80 | 0;
 $encode = sp + 76 | 0;
 $m = sp + 72 | 0;
 $i = sp + 68 | 0;
 $intensity = sp + 64 | 0;
 $ec = sp + 60 | 0;
 $bandE = sp + 56 | 0;
 $unquantized = sp + 52 | 0;
 $down = sp + 48 | 0;
 $bias = sp + 44 | 0;
 $p0 = sp + 40 | 0;
 $x = sp + 36 | 0;
 $x0 = sp + 32 | 0;
 $ft = sp + 28 | 0;
 $fs = sp + 24 | 0;
 $fs201 = sp + 20 | 0;
 $ft202 = sp + 16 | 0;
 $fl = sp + 12 | 0;
 $fl239 = sp + 8 | 0;
 $fm = sp + 4 | 0;
 $j = sp;
 HEAP32[$ctx$addr >> 2] = $ctx;
 HEAP32[$sctx$addr >> 2] = $sctx;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$Y$addr >> 2] = $Y;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$b$addr >> 2] = $b;
 HEAP32[$B$addr >> 2] = $B;
 HEAP32[$B0$addr >> 2] = $B0;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$stereo$addr >> 2] = $stereo;
 HEAP32[$fill$addr >> 2] = $fill;
 HEAP32[$itheta >> 2] = 0;
 HEAP32[$inv >> 2] = 0;
 HEAP32[$encode >> 2] = HEAP32[HEAP32[$ctx$addr >> 2] >> 2];
 HEAP32[$m >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 8 >> 2];
 HEAP32[$i >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 12 >> 2];
 HEAP32[$intensity >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 16 >> 2];
 HEAP32[$ec >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 28 >> 2];
 HEAP32[$bandE >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 36 >> 2];
 HEAP32[$pulse_cap >> 2] = (HEAP16[(HEAP32[(HEAP32[$m >> 2] | 0) + 56 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) + (HEAP32[$LM$addr >> 2] << 3);
 HEAP32[$offset >> 2] = (HEAP32[$pulse_cap >> 2] >> 1) - ((HEAP32[$stereo$addr >> 2] | 0 ? (HEAP32[$N$addr >> 2] | 0) == 2 : 0) ? 16 : 4);
 HEAP32[$qn >> 2] = _compute_qn(HEAP32[$N$addr >> 2] | 0, HEAP32[HEAP32[$b$addr >> 2] >> 2] | 0, HEAP32[$offset >> 2] | 0, HEAP32[$pulse_cap >> 2] | 0, HEAP32[$stereo$addr >> 2] | 0) | 0;
 if (HEAP32[$stereo$addr >> 2] | 0) if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$intensity >> 2] | 0)) HEAP32[$qn >> 2] = 1;
 if (HEAP32[$encode >> 2] | 0) HEAP32[$itheta >> 2] = _stereo_itheta(HEAP32[$X$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, HEAP32[$stereo$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 44 >> 2] | 0) | 0;
 HEAP32[$tell >> 2] = _ec_tell_frac(HEAP32[$ec >> 2] | 0) | 0;
 do if ((HEAP32[$qn >> 2] | 0) != 1) {
  do if (HEAP32[$encode >> 2] | 0) {
   if (HEAP32[$stereo$addr >> 2] | 0) if (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 48 >> 2] | 0) {
    HEAP32[$bias >> 2] = (((HEAP32[$itheta >> 2] | 0) > 8192 ? 32767 : -32767) | 0) / (HEAP32[$qn >> 2] | 0) | 0;
    $mul72 = Math_imul(HEAP32[$itheta >> 2] | 0, HEAP32[$qn >> 2] | 0) | 0;
    if (0 > ($mul72 + (HEAP32[$bias >> 2] | 0) >> 14 | 0)) $cond83 = 0; else {
     $mul79 = Math_imul(HEAP32[$itheta >> 2] | 0, HEAP32[$qn >> 2] | 0) | 0;
     $cond83 = $mul79 + (HEAP32[$bias >> 2] | 0) >> 14;
    }
    if (((HEAP32[$qn >> 2] | 0) - 1 | 0) < ($cond83 | 0)) $cond102 = (HEAP32[$qn >> 2] | 0) - 1 | 0; else {
     $mul89 = Math_imul(HEAP32[$itheta >> 2] | 0, HEAP32[$qn >> 2] | 0) | 0;
     if (0 > ($mul89 + (HEAP32[$bias >> 2] | 0) >> 14 | 0)) $cond102 = 0; else {
      $mul96 = Math_imul(HEAP32[$itheta >> 2] | 0, HEAP32[$qn >> 2] | 0) | 0;
      $cond102 = $mul96 + (HEAP32[$bias >> 2] | 0) >> 14;
     }
    }
    HEAP32[$down >> 2] = $cond102;
    $83 = HEAP32[$down >> 2] | 0;
    if ((HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 48 >> 2] | 0) < 0) {
     HEAP32[$itheta >> 2] = $83;
     break;
    } else {
     HEAP32[$itheta >> 2] = $83 + 1;
     break;
    }
   }
   HEAP32[$itheta >> 2] = (Math_imul(HEAP32[$itheta >> 2] | 0, HEAP32[$qn >> 2] | 0) | 0) + 8192 >> 14;
   if (!(HEAP32[$stereo$addr >> 2] | 0)) if ((HEAP32[$itheta >> 2] | 0) > 0 ? (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 56 >> 2] | 0) != 0 : 0) if ((HEAP32[$itheta >> 2] | 0) < (HEAP32[$qn >> 2] | 0)) {
    HEAP32[$unquantized >> 2] = _celt_udiv_365(HEAP32[$itheta >> 2] << 14, HEAP32[$qn >> 2] | 0) | 0;
    HEAP32[$imid >> 2] = (_bitexact_cos(HEAP32[$unquantized >> 2] & 65535) | 0) << 16 >> 16;
    HEAP32[$iside >> 2] = (_bitexact_cos(16384 - (HEAP32[$unquantized >> 2] | 0) & 65535) | 0) << 16 >> 16;
    $conv49 = ((HEAP32[$N$addr >> 2] | 0) - 1 << 7 & 65535) << 16 >> 16;
    HEAP32[$delta >> 2] = 16384 + (Math_imul($conv49, ((_bitexact_log2tan(HEAP32[$iside >> 2] | 0, HEAP32[$imid >> 2] | 0) | 0) & 65535) << 16 >> 16) | 0) >> 15;
    if ((HEAP32[$delta >> 2] | 0) > (HEAP32[HEAP32[$b$addr >> 2] >> 2] | 0)) {
     HEAP32[$itheta >> 2] = HEAP32[$qn >> 2];
     break;
    }
    if ((HEAP32[$delta >> 2] | 0) < (0 - (HEAP32[HEAP32[$b$addr >> 2] >> 2] | 0) | 0)) HEAP32[$itheta >> 2] = 0;
   }
  } while (0);
  do if ((HEAP32[$stereo$addr >> 2] | 0) != 0 & (HEAP32[$N$addr >> 2] | 0) > 2) {
   HEAP32[$p0 >> 2] = 3;
   HEAP32[$x >> 2] = HEAP32[$itheta >> 2];
   HEAP32[$x0 >> 2] = (HEAP32[$qn >> 2] | 0) / 2 | 0;
   $mul119 = Math_imul(HEAP32[$p0 >> 2] | 0, (HEAP32[$x0 >> 2] | 0) + 1 | 0) | 0;
   HEAP32[$ft >> 2] = $mul119 + (HEAP32[$x0 >> 2] | 0);
   $92 = HEAP32[$ec >> 2] | 0;
   if (HEAP32[$encode >> 2] | 0) {
    if ((HEAP32[$x >> 2] | 0) <= (HEAP32[$x0 >> 2] | 0)) $cond134 = Math_imul(HEAP32[$p0 >> 2] | 0, HEAP32[$x >> 2] | 0) | 0; else $cond134 = (HEAP32[$x >> 2] | 0) - 1 - (HEAP32[$x0 >> 2] | 0) + (Math_imul((HEAP32[$x0 >> 2] | 0) + 1 | 0, HEAP32[$p0 >> 2] | 0) | 0) | 0;
    if ((HEAP32[$x >> 2] | 0) <= (HEAP32[$x0 >> 2] | 0)) $cond146 = Math_imul(HEAP32[$p0 >> 2] | 0, (HEAP32[$x >> 2] | 0) + 1 | 0) | 0; else $cond146 = (HEAP32[$x >> 2] | 0) - (HEAP32[$x0 >> 2] | 0) + (Math_imul((HEAP32[$x0 >> 2] | 0) + 1 | 0, HEAP32[$p0 >> 2] | 0) | 0) | 0;
    _ec_encode($92, $cond134, $cond146, HEAP32[$ft >> 2] | 0);
    break;
   }
   HEAP32[$fs >> 2] = _ec_decode($92, HEAP32[$ft >> 2] | 0) | 0;
   if ((HEAP32[$fs >> 2] | 0) < (Math_imul((HEAP32[$x0 >> 2] | 0) + 1 | 0, HEAP32[$p0 >> 2] | 0) | 0)) HEAP32[$x >> 2] = (HEAP32[$fs >> 2] | 0) / (HEAP32[$p0 >> 2] | 0) | 0; else HEAP32[$x >> 2] = (HEAP32[$x0 >> 2] | 0) + 1 + ((HEAP32[$fs >> 2] | 0) - (Math_imul((HEAP32[$x0 >> 2] | 0) + 1 | 0, HEAP32[$p0 >> 2] | 0) | 0));
   if ((HEAP32[$x >> 2] | 0) <= (HEAP32[$x0 >> 2] | 0)) $cond173 = Math_imul(HEAP32[$p0 >> 2] | 0, HEAP32[$x >> 2] | 0) | 0; else $cond173 = (HEAP32[$x >> 2] | 0) - 1 - (HEAP32[$x0 >> 2] | 0) + (Math_imul((HEAP32[$x0 >> 2] | 0) + 1 | 0, HEAP32[$p0 >> 2] | 0) | 0) | 0;
   if ((HEAP32[$x >> 2] | 0) <= (HEAP32[$x0 >> 2] | 0)) $cond185 = Math_imul(HEAP32[$p0 >> 2] | 0, (HEAP32[$x >> 2] | 0) + 1 | 0) | 0; else $cond185 = (HEAP32[$x >> 2] | 0) - (HEAP32[$x0 >> 2] | 0) + (Math_imul((HEAP32[$x0 >> 2] | 0) + 1 | 0, HEAP32[$p0 >> 2] | 0) | 0) | 0;
   _ec_dec_update(HEAP32[$ec >> 2] | 0, $cond173, $cond185, HEAP32[$ft >> 2] | 0);
   HEAP32[$itheta >> 2] = HEAP32[$x >> 2];
  } else {
   if ((HEAP32[$B0$addr >> 2] | 0) > 1 | (HEAP32[$stereo$addr >> 2] | 0) != 0) {
    $142 = HEAP32[$ec >> 2] | 0;
    if (HEAP32[$encode >> 2] | 0) {
     _ec_enc_uint($142, HEAP32[$itheta >> 2] | 0, (HEAP32[$qn >> 2] | 0) + 1 | 0);
     break;
    } else {
     HEAP32[$itheta >> 2] = _ec_dec_uint($142, (HEAP32[$qn >> 2] | 0) + 1 | 0) | 0;
     break;
    }
   }
   HEAP32[$fs201 >> 2] = 1;
   HEAP32[$ft202 >> 2] = Math_imul((HEAP32[$qn >> 2] >> 1) + 1 | 0, (HEAP32[$qn >> 2] >> 1) + 1 | 0) | 0;
   if (!(HEAP32[$encode >> 2] | 0)) {
    HEAP32[$fl239 >> 2] = 0;
    HEAP32[$fm >> 2] = _ec_decode(HEAP32[$ec >> 2] | 0, HEAP32[$ft202 >> 2] | 0) | 0;
    if ((HEAP32[$fm >> 2] | 0) < ((Math_imul(HEAP32[$qn >> 2] >> 1, (HEAP32[$qn >> 2] >> 1) + 1 | 0) | 0) >> 1 | 0)) {
     HEAP32[$itheta >> 2] = ((_isqrt32((HEAP32[$fm >> 2] << 3) + 1 | 0) | 0) - 1 | 0) >>> 1;
     HEAP32[$fs201 >> 2] = (HEAP32[$itheta >> 2] | 0) + 1;
     HEAP32[$fl239 >> 2] = (Math_imul(HEAP32[$itheta >> 2] | 0, (HEAP32[$itheta >> 2] | 0) + 1 | 0) | 0) >> 1;
    } else {
     $mul260 = (HEAP32[$qn >> 2] | 0) + 1 << 1;
     HEAP32[$itheta >> 2] = ($mul260 - (_isqrt32(((HEAP32[$ft202 >> 2] | 0) - (HEAP32[$fm >> 2] | 0) - 1 << 3) + 1 | 0) | 0) | 0) >>> 1;
     HEAP32[$fs201 >> 2] = (HEAP32[$qn >> 2] | 0) + 1 - (HEAP32[$itheta >> 2] | 0);
     HEAP32[$fl239 >> 2] = (HEAP32[$ft202 >> 2] | 0) - ((Math_imul((HEAP32[$qn >> 2] | 0) + 1 - (HEAP32[$itheta >> 2] | 0) | 0, (HEAP32[$qn >> 2] | 0) + 2 - (HEAP32[$itheta >> 2] | 0) | 0) | 0) >> 1);
    }
    _ec_dec_update(HEAP32[$ec >> 2] | 0, HEAP32[$fl239 >> 2] | 0, (HEAP32[$fl239 >> 2] | 0) + (HEAP32[$fs201 >> 2] | 0) | 0, HEAP32[$ft202 >> 2] | 0);
    break;
   }
   if ((HEAP32[$itheta >> 2] | 0) <= (HEAP32[$qn >> 2] >> 1 | 0)) $cond219 = (HEAP32[$itheta >> 2] | 0) + 1 | 0; else $cond219 = (HEAP32[$qn >> 2] | 0) + 1 - (HEAP32[$itheta >> 2] | 0) | 0;
   HEAP32[$fs201 >> 2] = $cond219;
   if ((HEAP32[$itheta >> 2] | 0) <= (HEAP32[$qn >> 2] >> 1 | 0)) $cond236 = (Math_imul(HEAP32[$itheta >> 2] | 0, (HEAP32[$itheta >> 2] | 0) + 1 | 0) | 0) >> 1; else $cond236 = (HEAP32[$ft202 >> 2] | 0) - ((Math_imul((HEAP32[$qn >> 2] | 0) + 1 - (HEAP32[$itheta >> 2] | 0) | 0, (HEAP32[$qn >> 2] | 0) + 2 - (HEAP32[$itheta >> 2] | 0) | 0) | 0) >> 1) | 0;
   HEAP32[$fl >> 2] = $cond236;
   _ec_encode(HEAP32[$ec >> 2] | 0, HEAP32[$fl >> 2] | 0, (HEAP32[$fl >> 2] | 0) + (HEAP32[$fs201 >> 2] | 0) | 0, HEAP32[$ft202 >> 2] | 0);
  } while (0);
  HEAP32[$itheta >> 2] = _celt_udiv_365(HEAP32[$itheta >> 2] << 14, HEAP32[$qn >> 2] | 0) | 0;
  if ((HEAP32[$encode >> 2] | 0) != 0 & (HEAP32[$stereo$addr >> 2] | 0) != 0) if (!(HEAP32[$itheta >> 2] | 0)) {
   _intensity_stereo(HEAP32[$m >> 2] | 0, HEAP32[$X$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, HEAP32[$bandE >> 2] | 0, HEAP32[$i >> 2] | 0, HEAP32[$N$addr >> 2] | 0);
   break;
  } else {
   _stereo_split(HEAP32[$X$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0);
   break;
  }
 } else if (HEAP32[$stereo$addr >> 2] | 0) {
  if (HEAP32[$encode >> 2] | 0) {
   if ((HEAP32[$itheta >> 2] | 0) > 8192) $211 = (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 52 >> 2] | 0) != 0 ^ 1; else $211 = 0;
   HEAP32[$inv >> 2] = $211 & 1;
   L94 : do if (HEAP32[$inv >> 2] | 0) {
    HEAP32[$j >> 2] = 0;
    while (1) {
     if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break L94;
     HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = -+HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
     HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
    }
   } while (0);
   _intensity_stereo(HEAP32[$m >> 2] | 0, HEAP32[$X$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, HEAP32[$bandE >> 2] | 0, HEAP32[$i >> 2] | 0, HEAP32[$N$addr >> 2] | 0);
  }
  do if ((HEAP32[HEAP32[$b$addr >> 2] >> 2] | 0) > 16) if ((HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 32 >> 2] | 0) > 16) {
   $232 = HEAP32[$ec >> 2] | 0;
   if (HEAP32[$encode >> 2] | 0) {
    _ec_enc_bit_logp($232, HEAP32[$inv >> 2] | 0, 2);
    break;
   } else {
    HEAP32[$inv >> 2] = _ec_dec_bit_logp($232, 2) | 0;
    break;
   }
  } else label = 79; else label = 79; while (0);
  if ((label | 0) == 79) HEAP32[$inv >> 2] = 0;
  if (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 52 >> 2] | 0) HEAP32[$inv >> 2] = 0;
  HEAP32[$itheta >> 2] = 0;
 } while (0);
 $call332 = _ec_tell_frac(HEAP32[$ec >> 2] | 0) | 0;
 HEAP32[$qalloc >> 2] = $call332 - (HEAP32[$tell >> 2] | 0);
 $239 = HEAP32[$b$addr >> 2] | 0;
 HEAP32[$239 >> 2] = (HEAP32[$239 >> 2] | 0) - (HEAP32[$qalloc >> 2] | 0);
 if (!(HEAP32[$itheta >> 2] | 0)) {
  HEAP32[$imid >> 2] = 32767;
  HEAP32[$iside >> 2] = 0;
  $243 = HEAP32[$fill$addr >> 2] | 0;
  HEAP32[$243 >> 2] = HEAP32[$243 >> 2] & (1 << HEAP32[$B$addr >> 2]) - 1;
  HEAP32[$delta >> 2] = -16384;
  $255 = HEAP32[$inv >> 2] | 0;
  $256 = HEAP32[$sctx$addr >> 2] | 0;
  HEAP32[$256 >> 2] = $255;
  $257 = HEAP32[$imid >> 2] | 0;
  $258 = HEAP32[$sctx$addr >> 2] | 0;
  $imid369 = $258 + 4 | 0;
  HEAP32[$imid369 >> 2] = $257;
  $259 = HEAP32[$iside >> 2] | 0;
  $260 = HEAP32[$sctx$addr >> 2] | 0;
  $iside370 = $260 + 8 | 0;
  HEAP32[$iside370 >> 2] = $259;
  $261 = HEAP32[$delta >> 2] | 0;
  $262 = HEAP32[$sctx$addr >> 2] | 0;
  $delta371 = $262 + 12 | 0;
  HEAP32[$delta371 >> 2] = $261;
  $263 = HEAP32[$itheta >> 2] | 0;
  $264 = HEAP32[$sctx$addr >> 2] | 0;
  $itheta372 = $264 + 16 | 0;
  HEAP32[$itheta372 >> 2] = $263;
  $265 = HEAP32[$qalloc >> 2] | 0;
  $266 = HEAP32[$sctx$addr >> 2] | 0;
  $qalloc373 = $266 + 20 | 0;
  HEAP32[$qalloc373 >> 2] = $265;
  STACKTOP = sp;
  return;
 }
 if ((HEAP32[$itheta >> 2] | 0) == 16384) {
  HEAP32[$imid >> 2] = 0;
  HEAP32[$iside >> 2] = 32767;
  $248 = HEAP32[$fill$addr >> 2] | 0;
  HEAP32[$248 >> 2] = HEAP32[$248 >> 2] & (1 << HEAP32[$B$addr >> 2]) - 1 << HEAP32[$B$addr >> 2];
  HEAP32[$delta >> 2] = 16384;
  $255 = HEAP32[$inv >> 2] | 0;
  $256 = HEAP32[$sctx$addr >> 2] | 0;
  HEAP32[$256 >> 2] = $255;
  $257 = HEAP32[$imid >> 2] | 0;
  $258 = HEAP32[$sctx$addr >> 2] | 0;
  $imid369 = $258 + 4 | 0;
  HEAP32[$imid369 >> 2] = $257;
  $259 = HEAP32[$iside >> 2] | 0;
  $260 = HEAP32[$sctx$addr >> 2] | 0;
  $iside370 = $260 + 8 | 0;
  HEAP32[$iside370 >> 2] = $259;
  $261 = HEAP32[$delta >> 2] | 0;
  $262 = HEAP32[$sctx$addr >> 2] | 0;
  $delta371 = $262 + 12 | 0;
  HEAP32[$delta371 >> 2] = $261;
  $263 = HEAP32[$itheta >> 2] | 0;
  $264 = HEAP32[$sctx$addr >> 2] | 0;
  $itheta372 = $264 + 16 | 0;
  HEAP32[$itheta372 >> 2] = $263;
  $265 = HEAP32[$qalloc >> 2] | 0;
  $266 = HEAP32[$sctx$addr >> 2] | 0;
  $qalloc373 = $266 + 20 | 0;
  HEAP32[$qalloc373 >> 2] = $265;
  STACKTOP = sp;
  return;
 } else {
  HEAP32[$imid >> 2] = (_bitexact_cos(HEAP32[$itheta >> 2] & 65535) | 0) << 16 >> 16;
  HEAP32[$iside >> 2] = (_bitexact_cos(16384 - (HEAP32[$itheta >> 2] | 0) & 65535) | 0) << 16 >> 16;
  $conv359 = ((HEAP32[$N$addr >> 2] | 0) - 1 << 7 & 65535) << 16 >> 16;
  HEAP32[$delta >> 2] = 16384 + (Math_imul($conv359, ((_bitexact_log2tan(HEAP32[$iside >> 2] | 0, HEAP32[$imid >> 2] | 0) | 0) & 65535) << 16 >> 16) | 0) >> 15;
  $255 = HEAP32[$inv >> 2] | 0;
  $256 = HEAP32[$sctx$addr >> 2] | 0;
  HEAP32[$256 >> 2] = $255;
  $257 = HEAP32[$imid >> 2] | 0;
  $258 = HEAP32[$sctx$addr >> 2] | 0;
  $imid369 = $258 + 4 | 0;
  HEAP32[$imid369 >> 2] = $257;
  $259 = HEAP32[$iside >> 2] | 0;
  $260 = HEAP32[$sctx$addr >> 2] | 0;
  $iside370 = $260 + 8 | 0;
  HEAP32[$iside370 >> 2] = $259;
  $261 = HEAP32[$delta >> 2] | 0;
  $262 = HEAP32[$sctx$addr >> 2] | 0;
  $delta371 = $262 + 12 | 0;
  HEAP32[$delta371 >> 2] = $261;
  $263 = HEAP32[$itheta >> 2] | 0;
  $264 = HEAP32[$sctx$addr >> 2] | 0;
  $itheta372 = $264 + 16 | 0;
  HEAP32[$itheta372 >> 2] = $263;
  $265 = HEAP32[$qalloc >> 2] | 0;
  $266 = HEAP32[$sctx$addr >> 2] | 0;
  $qalloc373 = $266 + 20 | 0;
  HEAP32[$qalloc373 >> 2] = $265;
  STACKTOP = sp;
  return;
 }
}

function _silk_NLSF_del_dec_quant($indices, $x_Q10, $w_Q5, $pred_coef_Q8, $ec_ix, $ec_rates_Q5, $quant_step_size_Q16, $inv_quant_step_size_Q6, $mu_Q20, $order) {
 $indices = $indices | 0;
 $x_Q10 = $x_Q10 | 0;
 $w_Q5 = $w_Q5 | 0;
 $pred_coef_Q8 = $pred_coef_Q8 | 0;
 $ec_ix = $ec_ix | 0;
 $ec_rates_Q5 = $ec_rates_Q5 | 0;
 $quant_step_size_Q16 = $quant_step_size_Q16 | 0;
 $inv_quant_step_size_Q6 = $inv_quant_step_size_Q6 | 0;
 $mu_Q20 = $mu_Q20 | 0;
 $order = $order | 0;
 var $$sink = 0, $$sink1 = 0, $128 = 0, $129 = 0, $155 = 0, $200 = 0, $206 = 0, $58 = 0, $RD_Q25 = 0, $RD_max_Q25 = 0, $RD_min_Q25 = 0, $RD_tmp_Q25 = 0, $add155 = 0, $add161 = 0, $add173 = 0, $add179 = 0, $arrayidx299 = 0, $cmp17 = 0, $cmp185 = 0, $cond79 = 0, $diff_Q10 = 0, $ec_ix$addr = 0, $ec_rates_Q5$addr = 0, $i = 0, $in_Q10 = 0, $ind = 0, $ind_max_min = 0, $ind_min_max = 0, $ind_sort = 0, $ind_tmp = 0, $indices$addr = 0, $inv_quant_step_size_Q6$addr = 0, $j = 0, $max_min_Q25 = 0, $min_Q25 = 0, $min_max_Q25 = 0, $mu_Q20$addr = 0, $mul151 = 0, $mul169 = 0, $nStates = 0, $order$addr = 0, $out0_Q10 = 0, $out0_Q10_table = 0, $out1_Q10 = 0, $out1_Q10_table = 0, $pred_Q10 = 0, $pred_coef_Q8$addr = 0, $prev_out_Q10 = 0, $quant_step_size_Q16$addr = 0, $rate0_Q5 = 0, $rate1_Q5 = 0, $rates_Q5 = 0, $res_Q10 = 0, $shr = 0, $shr40 = 0, $w_Q5$addr = 0, $x_Q10$addr = 0, dest = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 432 | 0;
 $indices$addr = sp + 340 | 0;
 $x_Q10$addr = sp + 336 | 0;
 $w_Q5$addr = sp + 332 | 0;
 $pred_coef_Q8$addr = sp + 328 | 0;
 $ec_ix$addr = sp + 324 | 0;
 $ec_rates_Q5$addr = sp + 320 | 0;
 $quant_step_size_Q16$addr = sp + 316 | 0;
 $inv_quant_step_size_Q6$addr = sp + 366 | 0;
 $mu_Q20$addr = sp + 312 | 0;
 $order$addr = sp + 364 | 0;
 $i = sp + 308 | 0;
 $j = sp + 304 | 0;
 $nStates = sp + 300 | 0;
 $ind_tmp = sp + 296 | 0;
 $ind_min_max = sp + 292 | 0;
 $ind_max_min = sp + 288 | 0;
 $in_Q10 = sp + 284 | 0;
 $res_Q10 = sp + 280 | 0;
 $pred_Q10 = sp + 276 | 0;
 $diff_Q10 = sp + 272 | 0;
 $rate0_Q5 = sp + 268 | 0;
 $rate1_Q5 = sp + 264 | 0;
 $out0_Q10 = sp + 362 | 0;
 $out1_Q10 = sp + 360 | 0;
 $RD_tmp_Q25 = sp + 260 | 0;
 $min_Q25 = sp + 256 | 0;
 $min_max_Q25 = sp + 252 | 0;
 $max_min_Q25 = sp + 248 | 0;
 $ind_sort = sp + 232 | 0;
 $ind = sp + 368 | 0;
 $prev_out_Q10 = sp + 344 | 0;
 $RD_Q25 = sp + 200 | 0;
 $RD_min_Q25 = sp + 184 | 0;
 $RD_max_Q25 = sp + 168 | 0;
 $rates_Q5 = sp + 160 | 0;
 $out0_Q10_table = sp + 80 | 0;
 $out1_Q10_table = sp;
 HEAP32[$indices$addr >> 2] = $indices;
 HEAP32[$x_Q10$addr >> 2] = $x_Q10;
 HEAP32[$w_Q5$addr >> 2] = $w_Q5;
 HEAP32[$pred_coef_Q8$addr >> 2] = $pred_coef_Q8;
 HEAP32[$ec_ix$addr >> 2] = $ec_ix;
 HEAP32[$ec_rates_Q5$addr >> 2] = $ec_rates_Q5;
 HEAP32[$quant_step_size_Q16$addr >> 2] = $quant_step_size_Q16;
 HEAP16[$inv_quant_step_size_Q6$addr >> 1] = $inv_quant_step_size_Q6;
 HEAP32[$mu_Q20$addr >> 2] = $mu_Q20;
 HEAP16[$order$addr >> 1] = $order;
 HEAP32[$i >> 2] = -10;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) > 9) break;
  HEAP16[$out0_Q10 >> 1] = HEAP32[$i >> 2] << 10;
  HEAP16[$out1_Q10 >> 1] = (HEAP16[$out0_Q10 >> 1] | 0) + 1024;
  do if ((HEAP32[$i >> 2] | 0) > 0) {
   HEAP16[$out0_Q10 >> 1] = (HEAP16[$out0_Q10 >> 1] | 0) - 102;
   HEAP16[$out1_Q10 >> 1] = (HEAP16[$out1_Q10 >> 1] | 0) - 102;
  } else {
   if (!(HEAP32[$i >> 2] | 0)) {
    HEAP16[$out1_Q10 >> 1] = (HEAP16[$out1_Q10 >> 1] | 0) - 102;
    break;
   }
   $cmp17 = (HEAP32[$i >> 2] | 0) == -1;
   HEAP16[$out0_Q10 >> 1] = (HEAP16[$out0_Q10 >> 1] | 0) + 102;
   if (!$cmp17) HEAP16[$out1_Q10 >> 1] = (HEAP16[$out1_Q10 >> 1] | 0) + 102;
  } while (0);
  $shr = (Math_imul(HEAP16[$out0_Q10 >> 1] | 0, (HEAP32[$quant_step_size_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16;
  HEAP32[$out0_Q10_table + ((HEAP32[$i >> 2] | 0) + 10 << 2) >> 2] = $shr;
  $shr40 = (Math_imul(HEAP16[$out1_Q10 >> 1] | 0, (HEAP32[$quant_step_size_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16;
  HEAP32[$out1_Q10_table + ((HEAP32[$i >> 2] | 0) + 10 << 2) >> 2] = $shr40;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$nStates >> 2] = 1;
 HEAP32[$RD_Q25 >> 2] = 0;
 HEAP16[$prev_out_Q10 >> 1] = 0;
 HEAP32[$i >> 2] = (HEAP16[$order$addr >> 1] | 0) - 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < 0) break;
  HEAP32[$rates_Q5 >> 2] = (HEAP32[$ec_rates_Q5$addr >> 2] | 0) + (HEAP16[(HEAP32[$ec_ix$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0);
  HEAP32[$in_Q10 >> 2] = HEAP16[(HEAP32[$x_Q10$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1];
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$nStates >> 2] | 0)) break;
   HEAP32[$pred_Q10 >> 2] = (Math_imul(HEAPU8[(HEAP32[$pred_coef_Q8$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] | 0, HEAP16[$prev_out_Q10 + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0) >> 8;
   HEAP32[$res_Q10 >> 2] = (HEAP32[$in_Q10 >> 2] | 0) - (HEAP32[$pred_Q10 >> 2] | 0);
   HEAP32[$ind_tmp >> 2] = (Math_imul(HEAP16[$inv_quant_step_size_Q6$addr >> 1] | 0, (HEAP32[$res_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16;
   if ((HEAP32[$ind_tmp >> 2] | 0) > 9) $cond79 = 9; else $cond79 = (HEAP32[$ind_tmp >> 2] | 0) < -10 ? -10 : HEAP32[$ind_tmp >> 2] | 0;
   HEAP32[$ind_tmp >> 2] = $cond79;
   HEAP8[$ind + (HEAP32[$j >> 2] << 4) + (HEAP32[$i >> 2] | 0) >> 0] = HEAP32[$ind_tmp >> 2];
   HEAP16[$out0_Q10 >> 1] = HEAP32[$out0_Q10_table + ((HEAP32[$ind_tmp >> 2] | 0) + 10 << 2) >> 2];
   HEAP16[$out1_Q10 >> 1] = HEAP32[$out1_Q10_table + ((HEAP32[$ind_tmp >> 2] | 0) + 10 << 2) >> 2];
   HEAP16[$out0_Q10 >> 1] = (HEAP16[$out0_Q10 >> 1] | 0) + (HEAP32[$pred_Q10 >> 2] | 0);
   HEAP16[$out1_Q10 >> 1] = (HEAP16[$out1_Q10 >> 1] | 0) + (HEAP32[$pred_Q10 >> 2] | 0);
   HEAP16[$prev_out_Q10 + (HEAP32[$j >> 2] << 1) >> 1] = HEAP16[$out0_Q10 >> 1] | 0;
   HEAP16[$prev_out_Q10 + ((HEAP32[$j >> 2] | 0) + (HEAP32[$nStates >> 2] | 0) << 1) >> 1] = HEAP16[$out1_Q10 >> 1] | 0;
   $58 = HEAP32[$ind_tmp >> 2] | 0;
   do if (((HEAP32[$ind_tmp >> 2] | 0) + 1 | 0) >= 4) if (($58 + 1 | 0) == 4) {
    HEAP32[$rate0_Q5 >> 2] = HEAPU8[(HEAP32[$rates_Q5 >> 2] | 0) + ((HEAP32[$ind_tmp >> 2] | 0) + 4) >> 0];
    HEAP32[$rate1_Q5 >> 2] = 280;
    break;
   } else {
    HEAP32[$rate0_Q5 >> 2] = 108 + (((HEAP32[$ind_tmp >> 2] & 65535) << 16 >> 16) * 43 | 0);
    HEAP32[$rate1_Q5 >> 2] = (HEAP32[$rate0_Q5 >> 2] | 0) + 43;
    break;
   } else {
    if (($58 | 0) > -4) {
     HEAP32[$rate0_Q5 >> 2] = HEAPU8[(HEAP32[$rates_Q5 >> 2] | 0) + ((HEAP32[$ind_tmp >> 2] | 0) + 4) >> 0];
     HEAP32[$rate1_Q5 >> 2] = HEAPU8[(HEAP32[$rates_Q5 >> 2] | 0) + ((HEAP32[$ind_tmp >> 2] | 0) + 1 + 4) >> 0];
     break;
    }
    if ((HEAP32[$ind_tmp >> 2] | 0) == -4) {
     HEAP32[$rate0_Q5 >> 2] = 280;
     HEAP32[$rate1_Q5 >> 2] = HEAPU8[(HEAP32[$rates_Q5 >> 2] | 0) + ((HEAP32[$ind_tmp >> 2] | 0) + 1 + 4) >> 0];
     break;
    } else {
     HEAP32[$rate0_Q5 >> 2] = 108 + (Math_imul(-43, (HEAP32[$ind_tmp >> 2] & 65535) << 16 >> 16) | 0);
     HEAP32[$rate1_Q5 >> 2] = (HEAP32[$rate0_Q5 >> 2] | 0) - 43;
     break;
    }
   } while (0);
   HEAP32[$RD_tmp_Q25 >> 2] = HEAP32[$RD_Q25 + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$diff_Q10 >> 2] = (HEAP32[$in_Q10 >> 2] | 0) - (HEAP16[$out0_Q10 >> 1] | 0);
   $mul151 = Math_imul((HEAP32[$diff_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$diff_Q10 >> 2] & 65535) << 16 >> 16) | 0;
   $add155 = (HEAP32[$RD_tmp_Q25 >> 2] | 0) + (Math_imul($mul151, HEAP16[(HEAP32[$w_Q5$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) | 0;
   $add161 = $add155 + (Math_imul((HEAP32[$mu_Q20$addr >> 2] & 65535) << 16 >> 16, (HEAP32[$rate0_Q5 >> 2] & 65535) << 16 >> 16) | 0) | 0;
   HEAP32[$RD_Q25 + (HEAP32[$j >> 2] << 2) >> 2] = $add161;
   HEAP32[$diff_Q10 >> 2] = (HEAP32[$in_Q10 >> 2] | 0) - (HEAP16[$out1_Q10 >> 1] | 0);
   $mul169 = Math_imul((HEAP32[$diff_Q10 >> 2] & 65535) << 16 >> 16, (HEAP32[$diff_Q10 >> 2] & 65535) << 16 >> 16) | 0;
   $add173 = (HEAP32[$RD_tmp_Q25 >> 2] | 0) + (Math_imul($mul169, HEAP16[(HEAP32[$w_Q5$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) | 0;
   $add179 = $add173 + (Math_imul((HEAP32[$mu_Q20$addr >> 2] & 65535) << 16 >> 16, (HEAP32[$rate1_Q5 >> 2] & 65535) << 16 >> 16) | 0) | 0;
   HEAP32[$RD_Q25 + ((HEAP32[$j >> 2] | 0) + (HEAP32[$nStates >> 2] | 0) << 2) >> 2] = $add179;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  $cmp185 = (HEAP32[$nStates >> 2] | 0) <= 2;
  HEAP32[$j >> 2] = 0;
  L36 : do if ($cmp185) {
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$nStates >> 2] | 0)) break;
    HEAP8[$ind + ((HEAP32[$j >> 2] | 0) + (HEAP32[$nStates >> 2] | 0) << 4) + (HEAP32[$i >> 2] | 0) >> 0] = (HEAP8[$ind + (HEAP32[$j >> 2] << 4) + (HEAP32[$i >> 2] | 0) >> 0] | 0) + 1;
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$nStates >> 2] = HEAP32[$nStates >> 2] << 1;
   HEAP32[$j >> 2] = HEAP32[$nStates >> 2];
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= 4) break L36;
    HEAP8[$ind + (HEAP32[$j >> 2] << 4) + (HEAP32[$i >> 2] | 0) >> 0] = HEAP8[$ind + ((HEAP32[$j >> 2] | 0) - (HEAP32[$nStates >> 2] | 0) << 4) + (HEAP32[$i >> 2] | 0) >> 0] | 0;
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
  } else {
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= 4) break;
    $128 = HEAP32[$RD_Q25 + (HEAP32[$j >> 2] << 2) >> 2] | 0;
    $129 = HEAP32[$j >> 2] | 0;
    if ((HEAP32[$RD_Q25 + (HEAP32[$j >> 2] << 2) >> 2] | 0) > (HEAP32[$RD_Q25 + ((HEAP32[$j >> 2] | 0) + 4 << 2) >> 2] | 0)) {
     HEAP32[$RD_max_Q25 + ($129 << 2) >> 2] = $128;
     HEAP32[$RD_min_Q25 + (HEAP32[$j >> 2] << 2) >> 2] = HEAP32[$RD_Q25 + ((HEAP32[$j >> 2] | 0) + 4 << 2) >> 2];
     HEAP32[$RD_Q25 + (HEAP32[$j >> 2] << 2) >> 2] = HEAP32[$RD_min_Q25 + (HEAP32[$j >> 2] << 2) >> 2];
     HEAP32[$RD_Q25 + ((HEAP32[$j >> 2] | 0) + 4 << 2) >> 2] = HEAP32[$RD_max_Q25 + (HEAP32[$j >> 2] << 2) >> 2];
     HEAP16[$out0_Q10 >> 1] = HEAP16[$prev_out_Q10 + (HEAP32[$j >> 2] << 1) >> 1] | 0;
     HEAP16[$prev_out_Q10 + (HEAP32[$j >> 2] << 1) >> 1] = HEAP16[$prev_out_Q10 + ((HEAP32[$j >> 2] | 0) + 4 << 1) >> 1] | 0;
     HEAP16[$prev_out_Q10 + ((HEAP32[$j >> 2] | 0) + 4 << 1) >> 1] = HEAP16[$out0_Q10 >> 1] | 0;
     $$sink = (HEAP32[$j >> 2] | 0) + 4 | 0;
     $$sink1 = HEAP32[$j >> 2] | 0;
    } else {
     HEAP32[$RD_min_Q25 + ($129 << 2) >> 2] = $128;
     HEAP32[$RD_max_Q25 + (HEAP32[$j >> 2] << 2) >> 2] = HEAP32[$RD_Q25 + ((HEAP32[$j >> 2] | 0) + 4 << 2) >> 2];
     $$sink = HEAP32[$j >> 2] | 0;
     $$sink1 = HEAP32[$j >> 2] | 0;
    }
    HEAP32[$ind_sort + ($$sink1 << 2) >> 2] = $$sink;
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   while (1) {
    HEAP32[$min_max_Q25 >> 2] = 2147483647;
    HEAP32[$max_min_Q25 >> 2] = 0;
    HEAP32[$ind_min_max >> 2] = 0;
    HEAP32[$ind_max_min >> 2] = 0;
    HEAP32[$j >> 2] = 0;
    while (1) {
     $155 = HEAP32[$min_max_Q25 >> 2] | 0;
     if ((HEAP32[$j >> 2] | 0) >= 4) break;
     if (($155 | 0) > (HEAP32[$RD_max_Q25 + (HEAP32[$j >> 2] << 2) >> 2] | 0)) {
      HEAP32[$min_max_Q25 >> 2] = HEAP32[$RD_max_Q25 + (HEAP32[$j >> 2] << 2) >> 2];
      HEAP32[$ind_min_max >> 2] = HEAP32[$j >> 2];
     }
     if ((HEAP32[$max_min_Q25 >> 2] | 0) < (HEAP32[$RD_min_Q25 + (HEAP32[$j >> 2] << 2) >> 2] | 0)) {
      HEAP32[$max_min_Q25 >> 2] = HEAP32[$RD_min_Q25 + (HEAP32[$j >> 2] << 2) >> 2];
      HEAP32[$ind_max_min >> 2] = HEAP32[$j >> 2];
     }
     HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
    }
    if (($155 | 0) >= (HEAP32[$max_min_Q25 >> 2] | 0)) break;
    HEAP32[$ind_sort + (HEAP32[$ind_max_min >> 2] << 2) >> 2] = HEAP32[$ind_sort + (HEAP32[$ind_min_max >> 2] << 2) >> 2] ^ 4;
    HEAP32[$RD_Q25 + (HEAP32[$ind_max_min >> 2] << 2) >> 2] = HEAP32[$RD_Q25 + ((HEAP32[$ind_min_max >> 2] | 0) + 4 << 2) >> 2];
    HEAP16[$prev_out_Q10 + (HEAP32[$ind_max_min >> 2] << 1) >> 1] = HEAP16[$prev_out_Q10 + ((HEAP32[$ind_min_max >> 2] | 0) + 4 << 1) >> 1] | 0;
    HEAP32[$RD_min_Q25 + (HEAP32[$ind_max_min >> 2] << 2) >> 2] = 0;
    HEAP32[$RD_max_Q25 + (HEAP32[$ind_min_max >> 2] << 2) >> 2] = 2147483647;
    dest = $ind + (HEAP32[$ind_max_min >> 2] << 4) | 0;
    src = $ind + (HEAP32[$ind_min_max >> 2] << 4) | 0;
    stop = dest + 16 | 0;
    do {
     HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
     dest = dest + 1 | 0;
     src = src + 1 | 0;
    } while ((dest | 0) < (stop | 0));
   }
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= 4) break L36;
    $arrayidx299 = $ind + (HEAP32[$j >> 2] << 4) + (HEAP32[$i >> 2] | 0) | 0;
    HEAP8[$arrayidx299 >> 0] = (HEAP8[$arrayidx299 >> 0] | 0) + (HEAP32[$ind_sort + (HEAP32[$j >> 2] << 2) >> 2] >> 2);
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
  } while (0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 HEAP32[$ind_tmp >> 2] = 0;
 HEAP32[$min_Q25 >> 2] = 2147483647;
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= 8) break;
  if ((HEAP32[$min_Q25 >> 2] | 0) > (HEAP32[$RD_Q25 + (HEAP32[$j >> 2] << 2) >> 2] | 0)) {
   HEAP32[$min_Q25 >> 2] = HEAP32[$RD_Q25 + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$ind_tmp >> 2] = HEAP32[$j >> 2];
  }
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAP32[$j >> 2] = 0;
 while (1) {
  $200 = HEAP32[$ind_tmp >> 2] | 0;
  if ((HEAP32[$j >> 2] | 0) >= (HEAP16[$order$addr >> 1] | 0)) break;
  HEAP8[(HEAP32[$indices$addr >> 2] | 0) + (HEAP32[$j >> 2] | 0) >> 0] = HEAP8[$ind + (($200 & 3) << 4) + (HEAP32[$j >> 2] | 0) >> 0] | 0;
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 $206 = HEAP32[$indices$addr >> 2] | 0;
 HEAP8[$206 >> 0] = (HEAP8[$206 >> 0] | 0) + ($200 >> 2);
 STACKTOP = sp;
 return HEAP32[$min_Q25 >> 2] | 0;
}

function _free($mem) {
 $mem = $mem | 0;
 var $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $23 = 0, $24 = 0, $25 = 0, $27 = 0, $28 = 0, $29 = 0, $35 = 0, $36 = 0, $4 = 0, $42 = 0, $43 = 0, $44 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $53 = 0, $58 = 0, $59 = 0, $60 = 0, $63 = 0, $64 = 0, $65 = 0, $67 = 0, $70 = 0, $72 = 0, $73 = 0, $9 = 0, $F510$0 = 0, $I534$0 = 0, $K583$0 = 0, $R$1 = 0, $R$3 = 0, $R332$1 = 0, $R332$3 = 0, $RP$1 = 0, $RP360$1 = 0, $T$0 = 0, $add$ptr = 0, $add$ptr16 = 0, $add$ptr6 = 0, $add17 = 0, $add246 = 0, $add258 = 0, $add267 = 0, $add559 = 0, $and = 0, $and5 = 0, $and545 = 0, $and549 = 0, $and554 = 0, $arrayidx = 0, $arrayidx108 = 0, $arrayidx113 = 0, $arrayidx130 = 0, $arrayidx279 = 0, $arrayidx362 = 0, $arrayidx374 = 0, $arrayidx379 = 0, $arrayidx400 = 0, $arrayidx509 = 0, $arrayidx567 = 0, $arrayidx599 = 0, $arrayidx99 = 0, $bk343 = 0, $bk82 = 0, $child = 0, $child171 = 0, $child361 = 0, $child443 = 0, $dec = 0, $fd311 = 0, $fd322$pre$phiZ2D = 0, $fd347 = 0, $fd56 = 0, $fd620 = 0, $fd67$pre$phiZ2D = 0, $fd86 = 0, $head209 = 0, $head231 = 0, $p$1 = 0, $psize$1 = 0, $psize$2 = 0, $shl511 = 0, $shl546 = 0, $shl551 = 0, $shl573 = 0, $shr = 0, $shr268 = 0, $shr501 = 0, $shr535 = 0, $sp$0$i = 0, $sp$0$in$i = 0, label = 0;
 if (!$mem) return;
 $add$ptr = $mem + -8 | 0;
 $0 = HEAP32[8879] | 0;
 if ($add$ptr >>> 0 < $0 >>> 0) _abort();
 $1 = HEAP32[$mem + -4 >> 2] | 0;
 $and = $1 & 3;
 if (($and | 0) == 1) _abort();
 $and5 = $1 & -8;
 $add$ptr6 = $add$ptr + $and5 | 0;
 L10 : do if (!($1 & 1)) {
  $2 = HEAP32[$add$ptr >> 2] | 0;
  if (!$and) return;
  $add$ptr16 = $add$ptr + (0 - $2) | 0;
  $add17 = $2 + $and5 | 0;
  if ($add$ptr16 >>> 0 < $0 >>> 0) _abort();
  if ((HEAP32[8880] | 0) == ($add$ptr16 | 0)) {
   $head209 = $add$ptr6 + 4 | 0;
   $27 = HEAP32[$head209 >> 2] | 0;
   if (($27 & 3 | 0) != 3) {
    $28 = $add$ptr16;
    $p$1 = $add$ptr16;
    $psize$1 = $add17;
    break;
   }
   HEAP32[8877] = $add17;
   HEAP32[$head209 >> 2] = $27 & -2;
   HEAP32[$add$ptr16 + 4 >> 2] = $add17 | 1;
   HEAP32[$add$ptr16 + $add17 >> 2] = $add17;
   return;
  }
  $shr = $2 >>> 3;
  if ($2 >>> 0 < 256) {
   $4 = HEAP32[$add$ptr16 + 8 >> 2] | 0;
   $5 = HEAP32[$add$ptr16 + 12 >> 2] | 0;
   $arrayidx = 35540 + ($shr << 1 << 2) | 0;
   if (($4 | 0) != ($arrayidx | 0)) {
    if ($0 >>> 0 > $4 >>> 0) _abort();
    if ((HEAP32[$4 + 12 >> 2] | 0) != ($add$ptr16 | 0)) _abort();
   }
   if (($5 | 0) == ($4 | 0)) {
    HEAP32[8875] = HEAP32[8875] & ~(1 << $shr);
    $28 = $add$ptr16;
    $p$1 = $add$ptr16;
    $psize$1 = $add17;
    break;
   }
   if (($5 | 0) == ($arrayidx | 0)) $fd67$pre$phiZ2D = $5 + 8 | 0; else {
    if ($0 >>> 0 > $5 >>> 0) _abort();
    $fd56 = $5 + 8 | 0;
    if ((HEAP32[$fd56 >> 2] | 0) == ($add$ptr16 | 0)) $fd67$pre$phiZ2D = $fd56; else _abort();
   }
   HEAP32[$4 + 12 >> 2] = $5;
   HEAP32[$fd67$pre$phiZ2D >> 2] = $4;
   $28 = $add$ptr16;
   $p$1 = $add$ptr16;
   $psize$1 = $add17;
   break;
  }
  $9 = HEAP32[$add$ptr16 + 24 >> 2] | 0;
  $10 = HEAP32[$add$ptr16 + 12 >> 2] | 0;
  do if (($10 | 0) == ($add$ptr16 | 0)) {
   $child = $add$ptr16 + 16 | 0;
   $arrayidx99 = $child + 4 | 0;
   $14 = HEAP32[$arrayidx99 >> 2] | 0;
   if (!$14) {
    $15 = HEAP32[$child >> 2] | 0;
    if (!$15) {
     $R$3 = 0;
     break;
    } else {
     $R$1 = $15;
     $RP$1 = $child;
    }
   } else {
    $R$1 = $14;
    $RP$1 = $arrayidx99;
   }
   while (1) {
    $arrayidx108 = $R$1 + 20 | 0;
    $16 = HEAP32[$arrayidx108 >> 2] | 0;
    if ($16 | 0) {
     $R$1 = $16;
     $RP$1 = $arrayidx108;
     continue;
    }
    $arrayidx113 = $R$1 + 16 | 0;
    $17 = HEAP32[$arrayidx113 >> 2] | 0;
    if (!$17) break; else {
     $R$1 = $17;
     $RP$1 = $arrayidx113;
    }
   }
   if ($0 >>> 0 > $RP$1 >>> 0) _abort(); else {
    HEAP32[$RP$1 >> 2] = 0;
    $R$3 = $R$1;
    break;
   }
  } else {
   $11 = HEAP32[$add$ptr16 + 8 >> 2] | 0;
   if ($0 >>> 0 > $11 >>> 0) _abort();
   $bk82 = $11 + 12 | 0;
   if ((HEAP32[$bk82 >> 2] | 0) != ($add$ptr16 | 0)) _abort();
   $fd86 = $10 + 8 | 0;
   if ((HEAP32[$fd86 >> 2] | 0) == ($add$ptr16 | 0)) {
    HEAP32[$bk82 >> 2] = $10;
    HEAP32[$fd86 >> 2] = $11;
    $R$3 = $10;
    break;
   } else _abort();
  } while (0);
  if (!$9) {
   $28 = $add$ptr16;
   $p$1 = $add$ptr16;
   $psize$1 = $add17;
  } else {
   $18 = HEAP32[$add$ptr16 + 28 >> 2] | 0;
   $arrayidx130 = 35804 + ($18 << 2) | 0;
   do if ((HEAP32[$arrayidx130 >> 2] | 0) == ($add$ptr16 | 0)) {
    HEAP32[$arrayidx130 >> 2] = $R$3;
    if (!$R$3) {
     HEAP32[8876] = HEAP32[8876] & ~(1 << $18);
     $28 = $add$ptr16;
     $p$1 = $add$ptr16;
     $psize$1 = $add17;
     break L10;
    }
   } else if ((HEAP32[8879] | 0) >>> 0 > $9 >>> 0) _abort(); else {
    HEAP32[$9 + 16 + (((HEAP32[$9 + 16 >> 2] | 0) != ($add$ptr16 | 0) & 1) << 2) >> 2] = $R$3;
    if (!$R$3) {
     $28 = $add$ptr16;
     $p$1 = $add$ptr16;
     $psize$1 = $add17;
     break L10;
    } else break;
   } while (0);
   $23 = HEAP32[8879] | 0;
   if ($23 >>> 0 > $R$3 >>> 0) _abort();
   HEAP32[$R$3 + 24 >> 2] = $9;
   $child171 = $add$ptr16 + 16 | 0;
   $24 = HEAP32[$child171 >> 2] | 0;
   do if ($24 | 0) if ($23 >>> 0 > $24 >>> 0) _abort(); else {
    HEAP32[$R$3 + 16 >> 2] = $24;
    HEAP32[$24 + 24 >> 2] = $R$3;
    break;
   } while (0);
   $25 = HEAP32[$child171 + 4 >> 2] | 0;
   if (!$25) {
    $28 = $add$ptr16;
    $p$1 = $add$ptr16;
    $psize$1 = $add17;
   } else if ((HEAP32[8879] | 0) >>> 0 > $25 >>> 0) _abort(); else {
    HEAP32[$R$3 + 20 >> 2] = $25;
    HEAP32[$25 + 24 >> 2] = $R$3;
    $28 = $add$ptr16;
    $p$1 = $add$ptr16;
    $psize$1 = $add17;
    break;
   }
  }
 } else {
  $28 = $add$ptr;
  $p$1 = $add$ptr;
  $psize$1 = $and5;
 } while (0);
 if ($28 >>> 0 >= $add$ptr6 >>> 0) _abort();
 $head231 = $add$ptr6 + 4 | 0;
 $29 = HEAP32[$head231 >> 2] | 0;
 if (!($29 & 1)) _abort();
 if (!($29 & 2)) {
  if ((HEAP32[8881] | 0) == ($add$ptr6 | 0)) {
   $add246 = (HEAP32[8878] | 0) + $psize$1 | 0;
   HEAP32[8878] = $add246;
   HEAP32[8881] = $p$1;
   HEAP32[$p$1 + 4 >> 2] = $add246 | 1;
   if (($p$1 | 0) != (HEAP32[8880] | 0)) return;
   HEAP32[8880] = 0;
   HEAP32[8877] = 0;
   return;
  }
  if ((HEAP32[8880] | 0) == ($add$ptr6 | 0)) {
   $add258 = (HEAP32[8877] | 0) + $psize$1 | 0;
   HEAP32[8877] = $add258;
   HEAP32[8880] = $28;
   HEAP32[$p$1 + 4 >> 2] = $add258 | 1;
   HEAP32[$28 + $add258 >> 2] = $add258;
   return;
  }
  $add267 = ($29 & -8) + $psize$1 | 0;
  $shr268 = $29 >>> 3;
  L108 : do if ($29 >>> 0 < 256) {
   $35 = HEAP32[$add$ptr6 + 8 >> 2] | 0;
   $36 = HEAP32[$add$ptr6 + 12 >> 2] | 0;
   $arrayidx279 = 35540 + ($shr268 << 1 << 2) | 0;
   if (($35 | 0) != ($arrayidx279 | 0)) {
    if ((HEAP32[8879] | 0) >>> 0 > $35 >>> 0) _abort();
    if ((HEAP32[$35 + 12 >> 2] | 0) != ($add$ptr6 | 0)) _abort();
   }
   if (($36 | 0) == ($35 | 0)) {
    HEAP32[8875] = HEAP32[8875] & ~(1 << $shr268);
    break;
   }
   if (($36 | 0) == ($arrayidx279 | 0)) $fd322$pre$phiZ2D = $36 + 8 | 0; else {
    if ((HEAP32[8879] | 0) >>> 0 > $36 >>> 0) _abort();
    $fd311 = $36 + 8 | 0;
    if ((HEAP32[$fd311 >> 2] | 0) == ($add$ptr6 | 0)) $fd322$pre$phiZ2D = $fd311; else _abort();
   }
   HEAP32[$35 + 12 >> 2] = $36;
   HEAP32[$fd322$pre$phiZ2D >> 2] = $35;
  } else {
   $42 = HEAP32[$add$ptr6 + 24 >> 2] | 0;
   $43 = HEAP32[$add$ptr6 + 12 >> 2] | 0;
   do if (($43 | 0) == ($add$ptr6 | 0)) {
    $child361 = $add$ptr6 + 16 | 0;
    $arrayidx362 = $child361 + 4 | 0;
    $48 = HEAP32[$arrayidx362 >> 2] | 0;
    if (!$48) {
     $49 = HEAP32[$child361 >> 2] | 0;
     if (!$49) {
      $R332$3 = 0;
      break;
     } else {
      $R332$1 = $49;
      $RP360$1 = $child361;
     }
    } else {
     $R332$1 = $48;
     $RP360$1 = $arrayidx362;
    }
    while (1) {
     $arrayidx374 = $R332$1 + 20 | 0;
     $50 = HEAP32[$arrayidx374 >> 2] | 0;
     if ($50 | 0) {
      $R332$1 = $50;
      $RP360$1 = $arrayidx374;
      continue;
     }
     $arrayidx379 = $R332$1 + 16 | 0;
     $51 = HEAP32[$arrayidx379 >> 2] | 0;
     if (!$51) break; else {
      $R332$1 = $51;
      $RP360$1 = $arrayidx379;
     }
    }
    if ((HEAP32[8879] | 0) >>> 0 > $RP360$1 >>> 0) _abort(); else {
     HEAP32[$RP360$1 >> 2] = 0;
     $R332$3 = $R332$1;
     break;
    }
   } else {
    $44 = HEAP32[$add$ptr6 + 8 >> 2] | 0;
    if ((HEAP32[8879] | 0) >>> 0 > $44 >>> 0) _abort();
    $bk343 = $44 + 12 | 0;
    if ((HEAP32[$bk343 >> 2] | 0) != ($add$ptr6 | 0)) _abort();
    $fd347 = $43 + 8 | 0;
    if ((HEAP32[$fd347 >> 2] | 0) == ($add$ptr6 | 0)) {
     HEAP32[$bk343 >> 2] = $43;
     HEAP32[$fd347 >> 2] = $44;
     $R332$3 = $43;
     break;
    } else _abort();
   } while (0);
   if ($42 | 0) {
    $53 = HEAP32[$add$ptr6 + 28 >> 2] | 0;
    $arrayidx400 = 35804 + ($53 << 2) | 0;
    do if ((HEAP32[$arrayidx400 >> 2] | 0) == ($add$ptr6 | 0)) {
     HEAP32[$arrayidx400 >> 2] = $R332$3;
     if (!$R332$3) {
      HEAP32[8876] = HEAP32[8876] & ~(1 << $53);
      break L108;
     }
    } else if ((HEAP32[8879] | 0) >>> 0 > $42 >>> 0) _abort(); else {
     HEAP32[$42 + 16 + (((HEAP32[$42 + 16 >> 2] | 0) != ($add$ptr6 | 0) & 1) << 2) >> 2] = $R332$3;
     if (!$R332$3) break L108; else break;
    } while (0);
    $58 = HEAP32[8879] | 0;
    if ($58 >>> 0 > $R332$3 >>> 0) _abort();
    HEAP32[$R332$3 + 24 >> 2] = $42;
    $child443 = $add$ptr6 + 16 | 0;
    $59 = HEAP32[$child443 >> 2] | 0;
    do if ($59 | 0) if ($58 >>> 0 > $59 >>> 0) _abort(); else {
     HEAP32[$R332$3 + 16 >> 2] = $59;
     HEAP32[$59 + 24 >> 2] = $R332$3;
     break;
    } while (0);
    $60 = HEAP32[$child443 + 4 >> 2] | 0;
    if ($60 | 0) if ((HEAP32[8879] | 0) >>> 0 > $60 >>> 0) _abort(); else {
     HEAP32[$R332$3 + 20 >> 2] = $60;
     HEAP32[$60 + 24 >> 2] = $R332$3;
     break;
    }
   }
  } while (0);
  HEAP32[$p$1 + 4 >> 2] = $add267 | 1;
  HEAP32[$28 + $add267 >> 2] = $add267;
  if (($p$1 | 0) == (HEAP32[8880] | 0)) {
   HEAP32[8877] = $add267;
   return;
  } else $psize$2 = $add267;
 } else {
  HEAP32[$head231 >> 2] = $29 & -2;
  HEAP32[$p$1 + 4 >> 2] = $psize$1 | 1;
  HEAP32[$28 + $psize$1 >> 2] = $psize$1;
  $psize$2 = $psize$1;
 }
 $shr501 = $psize$2 >>> 3;
 if ($psize$2 >>> 0 < 256) {
  $arrayidx509 = 35540 + ($shr501 << 1 << 2) | 0;
  $63 = HEAP32[8875] | 0;
  $shl511 = 1 << $shr501;
  if (!($63 & $shl511)) {
   HEAP32[8875] = $63 | $shl511;
   $$pre$phiZ2D = $arrayidx509 + 8 | 0;
   $F510$0 = $arrayidx509;
  } else {
   $64 = $arrayidx509 + 8 | 0;
   $65 = HEAP32[$64 >> 2] | 0;
   if ((HEAP32[8879] | 0) >>> 0 > $65 >>> 0) _abort(); else {
    $$pre$phiZ2D = $64;
    $F510$0 = $65;
   }
  }
  HEAP32[$$pre$phiZ2D >> 2] = $p$1;
  HEAP32[$F510$0 + 12 >> 2] = $p$1;
  HEAP32[$p$1 + 8 >> 2] = $F510$0;
  HEAP32[$p$1 + 12 >> 2] = $arrayidx509;
  return;
 }
 $shr535 = $psize$2 >>> 8;
 if (!$shr535) $I534$0 = 0; else if ($psize$2 >>> 0 > 16777215) $I534$0 = 31; else {
  $and545 = ($shr535 + 1048320 | 0) >>> 16 & 8;
  $shl546 = $shr535 << $and545;
  $and549 = ($shl546 + 520192 | 0) >>> 16 & 4;
  $shl551 = $shl546 << $and549;
  $and554 = ($shl551 + 245760 | 0) >>> 16 & 2;
  $add559 = 14 - ($and549 | $and545 | $and554) + ($shl551 << $and554 >>> 15) | 0;
  $I534$0 = $psize$2 >>> ($add559 + 7 | 0) & 1 | $add559 << 1;
 }
 $arrayidx567 = 35804 + ($I534$0 << 2) | 0;
 HEAP32[$p$1 + 28 >> 2] = $I534$0;
 HEAP32[$p$1 + 20 >> 2] = 0;
 HEAP32[$p$1 + 16 >> 2] = 0;
 $67 = HEAP32[8876] | 0;
 $shl573 = 1 << $I534$0;
 do if (!($67 & $shl573)) {
  HEAP32[8876] = $67 | $shl573;
  HEAP32[$arrayidx567 >> 2] = $p$1;
  HEAP32[$p$1 + 24 >> 2] = $arrayidx567;
  HEAP32[$p$1 + 12 >> 2] = $p$1;
  HEAP32[$p$1 + 8 >> 2] = $p$1;
 } else {
  $K583$0 = $psize$2 << (($I534$0 | 0) == 31 ? 0 : 25 - ($I534$0 >>> 1) | 0);
  $T$0 = HEAP32[$arrayidx567 >> 2] | 0;
  while (1) {
   if ((HEAP32[$T$0 + 4 >> 2] & -8 | 0) == ($psize$2 | 0)) {
    label = 124;
    break;
   }
   $arrayidx599 = $T$0 + 16 + ($K583$0 >>> 31 << 2) | 0;
   $70 = HEAP32[$arrayidx599 >> 2] | 0;
   if (!$70) {
    label = 121;
    break;
   } else {
    $K583$0 = $K583$0 << 1;
    $T$0 = $70;
   }
  }
  if ((label | 0) == 121) if ((HEAP32[8879] | 0) >>> 0 > $arrayidx599 >>> 0) _abort(); else {
   HEAP32[$arrayidx599 >> 2] = $p$1;
   HEAP32[$p$1 + 24 >> 2] = $T$0;
   HEAP32[$p$1 + 12 >> 2] = $p$1;
   HEAP32[$p$1 + 8 >> 2] = $p$1;
   break;
  } else if ((label | 0) == 124) {
   $fd620 = $T$0 + 8 | 0;
   $72 = HEAP32[$fd620 >> 2] | 0;
   $73 = HEAP32[8879] | 0;
   if ($73 >>> 0 <= $72 >>> 0 & $73 >>> 0 <= $T$0 >>> 0) {
    HEAP32[$72 + 12 >> 2] = $p$1;
    HEAP32[$fd620 >> 2] = $p$1;
    HEAP32[$p$1 + 8 >> 2] = $72;
    HEAP32[$p$1 + 12 >> 2] = $T$0;
    HEAP32[$p$1 + 24 >> 2] = 0;
    break;
   } else _abort();
  }
 } while (0);
 $dec = (HEAP32[8883] | 0) + -1 | 0;
 HEAP32[8883] = $dec;
 if (!$dec) $sp$0$in$i = 35956; else return;
 while (1) {
  $sp$0$i = HEAP32[$sp$0$in$i >> 2] | 0;
  if (!$sp$0$i) break; else $sp$0$in$i = $sp$0$i + 8 | 0;
 }
 HEAP32[8883] = -1;
 return;
}

function _opus_custom_encoder_ctl($st, $request, $varargs) {
 $st = $st | 0;
 $request = $request | 0;
 $varargs = $varargs | 0;
 var $112 = 0, $113 = 0, $124 = 0, $125 = 0, $136 = 0, $137 = 0, $147 = 0, $148 = 0, $159 = 0, $160 = 0, $18 = 0, $19 = 0, $213 = 0, $214 = 0, $223 = 0, $224 = 0, $236 = 0, $237 = 0, $249 = 0, $250 = 0, $261 = 0, $262 = 0, $273 = 0, $274 = 0, $283 = 0, $284 = 0, $288 = 0, $33 = 0, $34 = 0, $48 = 0, $49 = 0, $6 = 0, $62 = 0, $63 = 0, $7 = 0, $74 = 0, $75 = 0, $84 = 0, $85 = 0, $94 = 0, $95 = 0, $ap = 0, $cond = 0, $i = 0, $info = 0, $info157 = 0, $oldBandE = 0, $oldLogE = 0, $oldLogE2 = 0, $request$addr = 0, $retval = 0, $st$addr = 0, $value = 0, $value108 = 0, $value14 = 0, $value141 = 0, $value171 = 0, $value180 = 0, $value189 = 0, $value193 = 0, $value25 = 0, $value37 = 0, $value48 = 0, $value5 = 0, $value52 = 0, $value56 = 0, $value70 = 0, $value81 = 0, $value92 = 0, $value97 = 0, $varet = 0, $varet110 = 0, $varet143 = 0, $varet146 = 0, $varet159 = 0, $varet16 = 0, $varet173 = 0, $varet182 = 0, $varet191 = 0, $varet195 = 0, $varet27 = 0, $varet39 = 0, $varet50 = 0, $varet54 = 0, $varet58 = 0, $varet7 = 0, $varet72 = 0, $varet83 = 0, $varet94 = 0, $varet99 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 208 | 0;
 $retval = sp + 200 | 0;
 $st$addr = sp + 196 | 0;
 $request$addr = sp + 192 | 0;
 $ap = sp + 176 | 0;
 $value = sp + 172 | 0;
 $varet = sp + 168 | 0;
 $value5 = sp + 164 | 0;
 $varet7 = sp + 160 | 0;
 $value14 = sp + 156 | 0;
 $varet16 = sp + 152 | 0;
 $value25 = sp + 148 | 0;
 $varet27 = sp + 144 | 0;
 $value37 = sp + 140 | 0;
 $varet39 = sp + 136 | 0;
 $value48 = sp + 132 | 0;
 $varet50 = sp + 128 | 0;
 $value52 = sp + 124 | 0;
 $varet54 = sp + 120 | 0;
 $value56 = sp + 116 | 0;
 $varet58 = sp + 112 | 0;
 $value70 = sp + 108 | 0;
 $varet72 = sp + 104 | 0;
 $value81 = sp + 100 | 0;
 $varet83 = sp + 96 | 0;
 $value92 = sp + 92 | 0;
 $varet94 = sp + 88 | 0;
 $value97 = sp + 84 | 0;
 $varet99 = sp + 80 | 0;
 $value108 = sp + 76 | 0;
 $varet110 = sp + 72 | 0;
 $i = sp + 68 | 0;
 $oldBandE = sp + 64 | 0;
 $oldLogE = sp + 60 | 0;
 $oldLogE2 = sp + 56 | 0;
 $value141 = sp + 52 | 0;
 $varet143 = sp + 48 | 0;
 $info = sp + 44 | 0;
 $varet146 = sp + 40 | 0;
 $info157 = sp + 36 | 0;
 $varet159 = sp + 32 | 0;
 $value171 = sp + 28 | 0;
 $varet173 = sp + 24 | 0;
 $value180 = sp + 20 | 0;
 $varet182 = sp + 16 | 0;
 $value189 = sp + 12 | 0;
 $varet191 = sp + 8 | 0;
 $value193 = sp + 4 | 0;
 $varet195 = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$request$addr >> 2] = $request;
 HEAP32[$ap >> 2] = $varargs;
 do switch (HEAP32[$request$addr >> 2] | 0) {
 case 4010:
  {
   $6 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $7 = HEAP32[$6 >> 2] | 0;
   HEAP32[$ap >> 2] = $6 + 4;
   HEAP32[$varet >> 2] = $7;
   HEAP32[$value >> 2] = HEAP32[$varet >> 2];
   if ((HEAP32[$value >> 2] | 0) < 0 | (HEAP32[$value >> 2] | 0) > 10) label = 46; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] = HEAP32[$value >> 2];
    label = 45;
   }
   break;
  }
 case 10010:
  {
   $18 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $19 = HEAP32[$18 >> 2] | 0;
   HEAP32[$ap >> 2] = $18 + 4;
   HEAP32[$varet7 >> 2] = $19;
   HEAP32[$value5 >> 2] = HEAP32[$varet7 >> 2];
   if ((HEAP32[$value5 >> 2] | 0) < 0) label = 46; else if ((HEAP32[$value5 >> 2] | 0) >= (HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] | 0)) label = 46; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 32 >> 2] = HEAP32[$value5 >> 2];
    label = 45;
   }
   break;
  }
 case 10012:
  {
   $33 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $34 = HEAP32[$33 >> 2] | 0;
   HEAP32[$ap >> 2] = $33 + 4;
   HEAP32[$varet16 >> 2] = $34;
   HEAP32[$value14 >> 2] = HEAP32[$varet16 >> 2];
   if ((HEAP32[$value14 >> 2] | 0) < 1) label = 46; else if ((HEAP32[$value14 >> 2] | 0) > (HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] | 0)) label = 46; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] = HEAP32[$value14 >> 2];
    label = 45;
   }
   break;
  }
 case 10002:
  {
   $48 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $49 = HEAP32[$48 >> 2] | 0;
   HEAP32[$ap >> 2] = $48 + 4;
   HEAP32[$varet27 >> 2] = $49;
   HEAP32[$value25 >> 2] = HEAP32[$varet27 >> 2];
   if ((HEAP32[$value25 >> 2] | 0) < 0 | (HEAP32[$value25 >> 2] | 0) > 2) label = 46; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 20 >> 2] = (HEAP32[$value25 >> 2] | 0) <= 1 & 1;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] = (HEAP32[$value25 >> 2] | 0) == 0 & 1;
    label = 45;
   }
   break;
  }
 case 4014:
  {
   $62 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $63 = HEAP32[$62 >> 2] | 0;
   HEAP32[$ap >> 2] = $62 + 4;
   HEAP32[$varet39 >> 2] = $63;
   HEAP32[$value37 >> 2] = HEAP32[$varet39 >> 2];
   if ((HEAP32[$value37 >> 2] | 0) < 0 | (HEAP32[$value37 >> 2] | 0) > 100) label = 46; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] = HEAP32[$value37 >> 2];
    label = 45;
   }
   break;
  }
 case 4020:
  {
   $74 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $75 = HEAP32[$74 >> 2] | 0;
   HEAP32[$ap >> 2] = $74 + 4;
   HEAP32[$varet50 >> 2] = $75;
   HEAP32[$value48 >> 2] = HEAP32[$varet50 >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] = HEAP32[$value48 >> 2];
   label = 45;
   break;
  }
 case 4006:
  {
   $84 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $85 = HEAP32[$84 >> 2] | 0;
   HEAP32[$ap >> 2] = $84 + 4;
   HEAP32[$varet54 >> 2] = $85;
   HEAP32[$value52 >> 2] = HEAP32[$varet54 >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] = HEAP32[$value52 >> 2];
   label = 45;
   break;
  }
 case 4002:
  {
   $94 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $95 = HEAP32[$94 >> 2] | 0;
   HEAP32[$ap >> 2] = $94 + 4;
   HEAP32[$varet58 >> 2] = $95;
   HEAP32[$value56 >> 2] = HEAP32[$varet58 >> 2];
   if ((HEAP32[$value56 >> 2] | 0) <= 500 & (HEAP32[$value56 >> 2] | 0) != -1) label = 46; else {
    if ((HEAP32[$value56 >> 2] | 0) < ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0) * 26e4 | 0)) $cond = HEAP32[$value56 >> 2] | 0; else $cond = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0) * 26e4 | 0;
    HEAP32[$value56 >> 2] = $cond;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] = HEAP32[$value56 >> 2];
    label = 45;
   }
   break;
  }
 case 10008:
  {
   $112 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $113 = HEAP32[$112 >> 2] | 0;
   HEAP32[$ap >> 2] = $112 + 4;
   HEAP32[$varet72 >> 2] = $113;
   HEAP32[$value70 >> 2] = HEAP32[$varet72 >> 2];
   if ((HEAP32[$value70 >> 2] | 0) < 1 | (HEAP32[$value70 >> 2] | 0) > 2) label = 46; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] = HEAP32[$value70 >> 2];
    label = 45;
   }
   break;
  }
 case 4036:
  {
   $124 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $125 = HEAP32[$124 >> 2] | 0;
   HEAP32[$ap >> 2] = $124 + 4;
   HEAP32[$varet83 >> 2] = $125;
   HEAP32[$value81 >> 2] = HEAP32[$varet83 >> 2];
   if ((HEAP32[$value81 >> 2] | 0) < 8 | (HEAP32[$value81 >> 2] | 0) > 24) label = 46; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] = HEAP32[$value81 >> 2];
    label = 45;
   }
   break;
  }
 case 4037:
  {
   $136 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $137 = HEAP32[$136 >> 2] | 0;
   HEAP32[$ap >> 2] = $136 + 4;
   HEAP32[$varet94 >> 2] = $137;
   HEAP32[$value92 >> 2] = HEAP32[$varet94 >> 2];
   HEAP32[HEAP32[$value92 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2];
   label = 45;
   break;
  }
 case 4046:
  {
   $147 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $148 = HEAP32[$147 >> 2] | 0;
   HEAP32[$ap >> 2] = $147 + 4;
   HEAP32[$varet99 >> 2] = $148;
   HEAP32[$value97 >> 2] = HEAP32[$varet99 >> 2];
   if ((HEAP32[$value97 >> 2] | 0) < 0 | (HEAP32[$value97 >> 2] | 0) > 1) label = 46; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2] = HEAP32[$value97 >> 2];
    label = 45;
   }
   break;
  }
 case 4047:
  {
   $159 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $160 = HEAP32[$159 >> 2] | 0;
   HEAP32[$ap >> 2] = $159 + 4;
   HEAP32[$varet110 >> 2] = $160;
   HEAP32[$value108 >> 2] = HEAP32[$varet110 >> 2];
   if (HEAP32[$value108 >> 2] | 0) {
    HEAP32[HEAP32[$value108 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 68 >> 2];
    label = 45;
   } else label = 46;
   break;
  }
 case 4028:
  {
   HEAP32[$oldBandE >> 2] = (HEAP32[$st$addr >> 2] | 0) + 244 + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0, (HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 4 >> 2] | 0) + 1024 | 0) | 0) << 2);
   HEAP32[$oldLogE >> 2] = (HEAP32[$oldBandE >> 2] | 0) + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0, HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] | 0) | 0) << 2);
   HEAP32[$oldLogE2 >> 2] = (HEAP32[$oldLogE >> 2] | 0) + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0, HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] | 0) | 0) << 2);
   _memset((HEAP32[$st$addr >> 2] | 0) + 76 | 0, 0, (_opus_custom_encoder_get_size(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0) | 0) - ((HEAP32[$st$addr >> 2] | 0) + 76 - (HEAP32[$st$addr >> 2] | 0)) | 0) | 0;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0, HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] | 0) | 0)) break;
    HEAPF32[(HEAP32[$oldLogE2 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = -28.0;
    HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = -28.0;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 216 >> 2] = 0;
   HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 84 >> 2] = 1.0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 80 >> 2] = 2;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 88 >> 2] = 256;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 96 >> 2] = 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 100 >> 2] = 0;
   label = 45;
   break;
  }
 case 10016:
  {
   $213 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $214 = HEAP32[$213 >> 2] | 0;
   HEAP32[$ap >> 2] = $213 + 4;
   HEAP32[$varet143 >> 2] = $214;
   HEAP32[$value141 >> 2] = HEAP32[$varet143 >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] = HEAP32[$value141 >> 2];
   label = 45;
   break;
  }
 case 10022:
  {
   $223 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $224 = HEAP32[$223 >> 2] | 0;
   HEAP32[$ap >> 2] = $223 + 4;
   HEAP32[$varet146 >> 2] = $224;
   HEAP32[$info >> 2] = HEAP32[$varet146 >> 2];
   if (HEAP32[$info >> 2] | 0) {
    _memcpy((HEAP32[$st$addr >> 2] | 0) + 120 | 0, HEAP32[$info >> 2] | 0, 64 | 0) | 0;
    label = 45;
   } else label = 45;
   break;
  }
 case 10028:
  {
   $236 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $237 = HEAP32[$236 >> 2] | 0;
   HEAP32[$ap >> 2] = $236 + 4;
   HEAP32[$varet159 >> 2] = $237;
   HEAP32[$info157 >> 2] = HEAP32[$varet159 >> 2];
   if (HEAP32[$info157 >> 2] | 0) {
    _memcpy((HEAP32[$st$addr >> 2] | 0) + 184 | 0, HEAP32[$info157 >> 2] | 0, 8 | 0) | 0;
    label = 45;
   } else label = 45;
   break;
  }
 case 10015:
  {
   $249 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $250 = HEAP32[$249 >> 2] | 0;
   HEAP32[$ap >> 2] = $249 + 4;
   HEAP32[$varet173 >> 2] = $250;
   HEAP32[$value171 >> 2] = HEAP32[$varet173 >> 2];
   if (!(HEAP32[$value171 >> 2] | 0)) label = 46; else {
    HEAP32[HEAP32[$value171 >> 2] >> 2] = HEAP32[HEAP32[$st$addr >> 2] >> 2];
    label = 45;
   }
   break;
  }
 case 4031:
  {
   $261 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $262 = HEAP32[$261 >> 2] | 0;
   HEAP32[$ap >> 2] = $261 + 4;
   HEAP32[$varet182 >> 2] = $262;
   HEAP32[$value180 >> 2] = HEAP32[$varet182 >> 2];
   if (!(HEAP32[$value180 >> 2] | 0)) label = 46; else {
    HEAP32[HEAP32[$value180 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2];
    label = 45;
   }
   break;
  }
 case 10024:
  {
   $273 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $274 = HEAP32[$273 >> 2] | 0;
   HEAP32[$ap >> 2] = $273 + 4;
   HEAP32[$varet191 >> 2] = $274;
   HEAP32[$value189 >> 2] = HEAP32[$varet191 >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] = HEAP32[$value189 >> 2];
   label = 45;
   break;
  }
 case 10026:
  {
   $283 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $284 = HEAP32[$283 >> 2] | 0;
   HEAP32[$ap >> 2] = $283 + 4;
   HEAP32[$varet195 >> 2] = $284;
   HEAP32[$value193 >> 2] = HEAP32[$varet195 >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 236 >> 2] = HEAP32[$value193 >> 2];
   label = 45;
   break;
  }
 default:
  {
   HEAP32[$retval >> 2] = -5;
   $288 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $288 | 0;
  }
 } while (0);
 if ((label | 0) == 45) {
  HEAP32[$retval >> 2] = 0;
  $288 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $288 | 0;
 } else if ((label | 0) == 46) {
  HEAP32[$retval >> 2] = -1;
  $288 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $288 | 0;
 }
 return 0;
}

function _compute_allocation($m, $start, $end, $offsets, $cap, $alloc_trim, $intensity, $dual_stereo, $total, $balance, $pulses, $ebits, $fine_priority, $C, $LM, $ec, $encode, $prev, $signalBandwidth) {
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $offsets = $offsets | 0;
 $cap = $cap | 0;
 $alloc_trim = $alloc_trim | 0;
 $intensity = $intensity | 0;
 $dual_stereo = $dual_stereo | 0;
 $total = $total | 0;
 $balance = $balance | 0;
 $pulses = $pulses | 0;
 $ebits = $ebits | 0;
 $fine_priority = $fine_priority | 0;
 $C = $C | 0;
 $LM = $LM | 0;
 $ec = $ec | 0;
 $encode = $encode | 0;
 $prev = $prev | 0;
 $signalBandwidth = $signalBandwidth | 0;
 var $130 = 0, $133 = 0, $137 = 0, $19 = 0, $225 = 0, $81 = 0, $C$addr = 0, $LM$addr = 0, $N = 0, $N159 = 0, $alloc_trim$addr = 0, $arrayidx80 = 0, $balance$addr = 0, $bits1j = 0, $bits2j = 0, $bitsj = 0, $cap$addr = 0, $codedBands = 0, $cond118 = 0, $cond133 = 0, $cond193 = 0, $cond206 = 0, $cond220 = 0, $cond242 = 0, $cond45 = 0, $done = 0, $dual_stereo$addr = 0, $dual_stereo_rsv = 0, $ebits$addr = 0, $ec$addr = 0, $encode$addr = 0, $end$addr = 0, $fine_priority$addr = 0, $hi = 0, $intensity$addr = 0, $intensity_rsv = 0, $j = 0, $len = 0, $lo = 0, $m$addr = 0, $mid = 0, $mul103 = 0, $mul168 = 0, $mul170 = 0, $mul174 = 0, $mul183 = 0, $mul185 = 0, $mul189 = 0, $mul55 = 0, $mul58 = 0, $mul61 = 0, $mul98 = 0, $mul99 = 0, $offsets$addr = 0, $prev$addr = 0, $psum = 0, $pulses$addr = 0, $saved_stack = 0, $shr65 = 0, $signalBandwidth$addr = 0, $skip_rsv = 0, $skip_start = 0, $start$addr = 0, $total$addr = 0, $vla = 0, $vla14 = 0, $vla15 = 0, $vla16 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 $m$addr = sp + 144 | 0;
 $start$addr = sp + 140 | 0;
 $end$addr = sp + 136 | 0;
 $offsets$addr = sp + 132 | 0;
 $cap$addr = sp + 128 | 0;
 $alloc_trim$addr = sp + 124 | 0;
 $intensity$addr = sp + 120 | 0;
 $dual_stereo$addr = sp + 116 | 0;
 $total$addr = sp + 112 | 0;
 $balance$addr = sp + 108 | 0;
 $pulses$addr = sp + 104 | 0;
 $ebits$addr = sp + 100 | 0;
 $fine_priority$addr = sp + 96 | 0;
 $C$addr = sp + 92 | 0;
 $LM$addr = sp + 88 | 0;
 $ec$addr = sp + 84 | 0;
 $encode$addr = sp + 80 | 0;
 $prev$addr = sp + 76 | 0;
 $signalBandwidth$addr = sp + 72 | 0;
 $lo = sp + 68 | 0;
 $hi = sp + 64 | 0;
 $len = sp + 60 | 0;
 $j = sp + 56 | 0;
 $codedBands = sp + 52 | 0;
 $skip_start = sp + 48 | 0;
 $skip_rsv = sp + 44 | 0;
 $intensity_rsv = sp + 40 | 0;
 $dual_stereo_rsv = sp + 36 | 0;
 $saved_stack = sp + 32 | 0;
 $done = sp + 28 | 0;
 $psum = sp + 24 | 0;
 $mid = sp + 20 | 0;
 $bitsj = sp + 16 | 0;
 $N = sp + 12 | 0;
 $bits1j = sp + 8 | 0;
 $bits2j = sp + 4 | 0;
 $N159 = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$offsets$addr >> 2] = $offsets;
 HEAP32[$cap$addr >> 2] = $cap;
 HEAP32[$alloc_trim$addr >> 2] = $alloc_trim;
 HEAP32[$intensity$addr >> 2] = $intensity;
 HEAP32[$dual_stereo$addr >> 2] = $dual_stereo;
 HEAP32[$total$addr >> 2] = $total;
 HEAP32[$balance$addr >> 2] = $balance;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$ebits$addr >> 2] = $ebits;
 HEAP32[$fine_priority$addr >> 2] = $fine_priority;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$ec$addr >> 2] = $ec;
 HEAP32[$encode$addr >> 2] = $encode;
 HEAP32[$prev$addr >> 2] = $prev;
 HEAP32[$signalBandwidth$addr >> 2] = $signalBandwidth;
 HEAP32[$total$addr >> 2] = (HEAP32[$total$addr >> 2] | 0) > 0 ? HEAP32[$total$addr >> 2] | 0 : 0;
 HEAP32[$len >> 2] = HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2];
 HEAP32[$skip_start >> 2] = HEAP32[$start$addr >> 2];
 HEAP32[$skip_rsv >> 2] = (HEAP32[$total$addr >> 2] | 0) >= 8 ? 8 : 0;
 HEAP32[$total$addr >> 2] = (HEAP32[$total$addr >> 2] | 0) - (HEAP32[$skip_rsv >> 2] | 0);
 HEAP32[$dual_stereo_rsv >> 2] = 0;
 HEAP32[$intensity_rsv >> 2] = 0;
 do if ((HEAP32[$C$addr >> 2] | 0) == 2) {
  HEAP32[$intensity_rsv >> 2] = HEAPU8[31636 + ((HEAP32[$end$addr >> 2] | 0) - (HEAP32[$start$addr >> 2] | 0)) >> 0];
  if ((HEAP32[$intensity_rsv >> 2] | 0) > (HEAP32[$total$addr >> 2] | 0)) {
   HEAP32[$intensity_rsv >> 2] = 0;
   break;
  } else {
   HEAP32[$total$addr >> 2] = (HEAP32[$total$addr >> 2] | 0) - (HEAP32[$intensity_rsv >> 2] | 0);
   HEAP32[$dual_stereo_rsv >> 2] = (HEAP32[$total$addr >> 2] | 0) >= 8 ? 8 : 0;
   HEAP32[$total$addr >> 2] = (HEAP32[$total$addr >> 2] | 0) - (HEAP32[$dual_stereo_rsv >> 2] | 0);
   break;
  }
 } while (0);
 $19 = HEAP32[$len >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($19 << 2) | 0) + 15 & -16) | 0;
 $vla14 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$len >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla15 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$len >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla16 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$len >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[$j >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  if ((HEAP32[$C$addr >> 2] << 3 | 0) > (((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0) * 3 << HEAP32[$LM$addr >> 2] << 3 >> 4 | 0)) $cond45 = HEAP32[$C$addr >> 2] << 3; else $cond45 = ((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0) * 3 << HEAP32[$LM$addr >> 2] << 3 >> 4;
  HEAP32[$vla15 + (HEAP32[$j >> 2] << 2) >> 2] = $cond45;
  $mul55 = Math_imul(HEAP32[$C$addr >> 2] | 0, (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0) | 0;
  $mul58 = Math_imul($mul55, (HEAP32[$alloc_trim$addr >> 2] | 0) - 5 - (HEAP32[$LM$addr >> 2] | 0) | 0) | 0;
  $mul61 = Math_imul($mul58, (HEAP32[$end$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) - 1 | 0) | 0;
  $shr65 = (Math_imul($mul61, 1 << (HEAP32[$LM$addr >> 2] | 0) + 3) | 0) >> 6;
  HEAP32[$vla16 + (HEAP32[$j >> 2] << 2) >> 2] = $shr65;
  if (((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) << HEAP32[$LM$addr >> 2] | 0) == 1) {
   $arrayidx80 = $vla16 + (HEAP32[$j >> 2] << 2) | 0;
   HEAP32[$arrayidx80 >> 2] = (HEAP32[$arrayidx80 >> 2] | 0) - (HEAP32[$C$addr >> 2] << 3);
  }
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAP32[$lo >> 2] = 1;
 HEAP32[$hi >> 2] = (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 48 >> 2] | 0) - 1;
 do {
  HEAP32[$done >> 2] = 0;
  HEAP32[$psum >> 2] = 0;
  HEAP32[$mid >> 2] = (HEAP32[$lo >> 2] | 0) + (HEAP32[$hi >> 2] | 0) >> 1;
  HEAP32[$j >> 2] = HEAP32[$end$addr >> 2];
  while (1) {
   $81 = HEAP32[$j >> 2] | 0;
   HEAP32[$j >> 2] = $81 + -1;
   if (($81 | 0) <= (HEAP32[$start$addr >> 2] | 0)) break;
   HEAP32[$N >> 2] = (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0);
   $mul98 = Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
   $mul99 = Math_imul(HEAP32[$mid >> 2] | 0, HEAP32[$len >> 2] | 0) | 0;
   $mul103 = Math_imul($mul98, HEAPU8[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 52 >> 2] | 0) + ($mul99 + (HEAP32[$j >> 2] | 0)) >> 0] | 0) | 0;
   HEAP32[$bitsj >> 2] = $mul103 << HEAP32[$LM$addr >> 2] >> 2;
   if ((HEAP32[$bitsj >> 2] | 0) > 0) {
    if (0 > ((HEAP32[$bitsj >> 2] | 0) + (HEAP32[$vla16 + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0)) $cond118 = 0; else $cond118 = (HEAP32[$bitsj >> 2] | 0) + (HEAP32[$vla16 + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0;
    HEAP32[$bitsj >> 2] = $cond118;
   }
   HEAP32[$bitsj >> 2] = (HEAP32[$bitsj >> 2] | 0) + (HEAP32[(HEAP32[$offsets$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0);
   if (!(HEAP32[$done >> 2] | 0 ? 1 : (HEAP32[$bitsj >> 2] | 0) >= (HEAP32[$vla15 + (HEAP32[$j >> 2] << 2) >> 2] | 0))) {
    if ((HEAP32[$bitsj >> 2] | 0) < (HEAP32[$C$addr >> 2] << 3 | 0)) continue;
    HEAP32[$psum >> 2] = (HEAP32[$psum >> 2] | 0) + (HEAP32[$C$addr >> 2] << 3);
    continue;
   }
   HEAP32[$done >> 2] = 1;
   if ((HEAP32[$bitsj >> 2] | 0) < (HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0)) $cond133 = HEAP32[$bitsj >> 2] | 0; else $cond133 = HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0;
   HEAP32[$psum >> 2] = (HEAP32[$psum >> 2] | 0) + $cond133;
  }
  $130 = HEAP32[$mid >> 2] | 0;
  if ((HEAP32[$psum >> 2] | 0) > (HEAP32[$total$addr >> 2] | 0)) HEAP32[$hi >> 2] = $130 - 1; else HEAP32[$lo >> 2] = $130 + 1;
 } while ((HEAP32[$lo >> 2] | 0) <= (HEAP32[$hi >> 2] | 0));
 $133 = HEAP32[$lo >> 2] | 0;
 HEAP32[$lo >> 2] = $133 + -1;
 HEAP32[$hi >> 2] = $133;
 HEAP32[$j >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  $137 = HEAP32[$m$addr >> 2] | 0;
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP32[$N159 >> 2] = (HEAP16[(HEAP32[$137 + 32 >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0);
  $mul168 = Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[$N159 >> 2] | 0) | 0;
  $mul170 = Math_imul(HEAP32[$lo >> 2] | 0, HEAP32[$len >> 2] | 0) | 0;
  $mul174 = Math_imul($mul168, HEAPU8[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 52 >> 2] | 0) + ($mul170 + (HEAP32[$j >> 2] | 0)) >> 0] | 0) | 0;
  HEAP32[$bits1j >> 2] = $mul174 << HEAP32[$LM$addr >> 2] >> 2;
  if ((HEAP32[$hi >> 2] | 0) >= (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 48 >> 2] | 0)) $cond193 = HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0; else {
   $mul183 = Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[$N159 >> 2] | 0) | 0;
   $mul185 = Math_imul(HEAP32[$hi >> 2] | 0, HEAP32[$len >> 2] | 0) | 0;
   $mul189 = Math_imul($mul183, HEAPU8[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 52 >> 2] | 0) + ($mul185 + (HEAP32[$j >> 2] | 0)) >> 0] | 0) | 0;
   $cond193 = $mul189 << HEAP32[$LM$addr >> 2] >> 2;
  }
  HEAP32[$bits2j >> 2] = $cond193;
  if ((HEAP32[$bits1j >> 2] | 0) > 0) {
   if (0 > ((HEAP32[$bits1j >> 2] | 0) + (HEAP32[$vla16 + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0)) $cond206 = 0; else $cond206 = (HEAP32[$bits1j >> 2] | 0) + (HEAP32[$vla16 + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0;
   HEAP32[$bits1j >> 2] = $cond206;
  }
  if ((HEAP32[$bits2j >> 2] | 0) > 0) {
   if (0 > ((HEAP32[$bits2j >> 2] | 0) + (HEAP32[$vla16 + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0)) $cond220 = 0; else $cond220 = (HEAP32[$bits2j >> 2] | 0) + (HEAP32[$vla16 + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0;
   HEAP32[$bits2j >> 2] = $cond220;
  }
  if ((HEAP32[$lo >> 2] | 0) > 0) HEAP32[$bits1j >> 2] = (HEAP32[$bits1j >> 2] | 0) + (HEAP32[(HEAP32[$offsets$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0);
  HEAP32[$bits2j >> 2] = (HEAP32[$bits2j >> 2] | 0) + (HEAP32[(HEAP32[$offsets$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0);
  if ((HEAP32[(HEAP32[$offsets$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) > 0) HEAP32[$skip_start >> 2] = HEAP32[$j >> 2];
  if (0 > ((HEAP32[$bits2j >> 2] | 0) - (HEAP32[$bits1j >> 2] | 0) | 0)) $cond242 = 0; else $cond242 = (HEAP32[$bits2j >> 2] | 0) - (HEAP32[$bits1j >> 2] | 0) | 0;
  HEAP32[$bits2j >> 2] = $cond242;
  HEAP32[$vla + (HEAP32[$j >> 2] << 2) >> 2] = HEAP32[$bits1j >> 2];
  HEAP32[$vla14 + (HEAP32[$j >> 2] << 2) >> 2] = HEAP32[$bits2j >> 2];
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAP32[$codedBands >> 2] = _interp_bits2pulses($137, HEAP32[$start$addr >> 2] | 0, HEAP32[$end$addr >> 2] | 0, HEAP32[$skip_start >> 2] | 0, $vla, $vla14, $vla15, HEAP32[$cap$addr >> 2] | 0, HEAP32[$total$addr >> 2] | 0, HEAP32[$balance$addr >> 2] | 0, HEAP32[$skip_rsv >> 2] | 0, HEAP32[$intensity$addr >> 2] | 0, HEAP32[$intensity_rsv >> 2] | 0, HEAP32[$dual_stereo$addr >> 2] | 0, HEAP32[$dual_stereo_rsv >> 2] | 0, HEAP32[$pulses$addr >> 2] | 0, HEAP32[$ebits$addr >> 2] | 0, HEAP32[$fine_priority$addr >> 2] | 0, HEAP32[$C$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, HEAP32[$ec$addr >> 2] | 0, HEAP32[$encode$addr >> 2] | 0, HEAP32[$prev$addr >> 2] | 0, HEAP32[$signalBandwidth$addr >> 2] | 0) | 0;
 $225 = HEAP32[$codedBands >> 2] | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return $225 | 0;
}

function _tf_analysis($m, $len, $isTransient, $tf_res, $lambda, $X, $N0, $LM, $tf_estimate, $tf_chan, $importance) {
 $m = $m | 0;
 $len = $len | 0;
 $isTransient = $isTransient | 0;
 $tf_res = $tf_res | 0;
 $lambda = $lambda | 0;
 $X = $X | 0;
 $N0 = $N0 | 0;
 $LM = $LM | 0;
 $tf_estimate = +$tf_estimate;
 $tf_chan = $tf_chan | 0;
 $importance = $importance | 0;
 var $$sink2 = 0, $$sink3 = 0, $$sink4 = 0, $$sink5 = 0, $$sink6 = 0, $128 = 0, $129 = 0, $187 = 0, $2 = 0, $242 = 0, $97 = 0, $B = 0, $L1 = 0, $LM$addr = 0, $N = 0, $N0$addr = 0, $X$addr = 0, $add327 = 0, $arrayidx116 = 0, $arrayidx333$sink = 0, $best_L1 = 0, $best_level = 0, $bias = 0, $cond169 = 0, $cond177 = 0, $cost0 = 0, $cost1 = 0, $curr0 = 0, $curr0263 = 0, $curr1 = 0, $curr1264 = 0, $from0 = 0, $from1 = 0, $i = 0, $importance$addr = 0, $isTransient$addr = 0, $k = 0, $lambda$addr = 0, $len$addr = 0, $m$addr = 0, $mul103 = 0, $mul151 = 0, $mul252 = 0, $mul40 = 0, $narrow = 0, $saved_stack = 0, $sel = 0, $selcost = 0, $tf_chan$addr = 0, $tf_estimate$addr = 0, $tf_res$addr = 0, $tf_select = 0, $tobool84 = 0, $vla = 0, $vla17 = 0, $vla18 = 0, $vla19 = 0, $vla7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $m$addr = sp + 128 | 0;
 $len$addr = sp + 124 | 0;
 $isTransient$addr = sp + 120 | 0;
 $tf_res$addr = sp + 116 | 0;
 $lambda$addr = sp + 112 | 0;
 $X$addr = sp + 108 | 0;
 $N0$addr = sp + 104 | 0;
 $LM$addr = sp + 100 | 0;
 $tf_estimate$addr = sp + 96 | 0;
 $tf_chan$addr = sp + 92 | 0;
 $importance$addr = sp + 88 | 0;
 $i = sp + 84 | 0;
 $cost0 = sp + 80 | 0;
 $cost1 = sp + 76 | 0;
 $sel = sp + 72 | 0;
 $selcost = sp + 64 | 0;
 $tf_select = sp + 60 | 0;
 $bias = sp + 56 | 0;
 $saved_stack = sp + 52 | 0;
 $k = sp + 48 | 0;
 $N = sp + 44 | 0;
 $narrow = sp + 40 | 0;
 $L1 = sp + 36 | 0;
 $best_L1 = sp + 32 | 0;
 $best_level = sp + 28 | 0;
 $B = sp + 24 | 0;
 $curr0 = sp + 20 | 0;
 $curr1 = sp + 16 | 0;
 $curr0263 = sp + 12 | 0;
 $curr1264 = sp + 8 | 0;
 $from0 = sp + 4 | 0;
 $from1 = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$isTransient$addr >> 2] = $isTransient;
 HEAP32[$tf_res$addr >> 2] = $tf_res;
 HEAP32[$lambda$addr >> 2] = $lambda;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N0$addr >> 2] = $N0;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAPF32[$tf_estimate$addr >> 2] = $tf_estimate;
 HEAP32[$tf_chan$addr >> 2] = $tf_chan;
 HEAP32[$importance$addr >> 2] = $importance;
 HEAP32[$tf_select >> 2] = 0;
 HEAPF32[$bias >> 2] = (-.25 > .5 - +HEAPF32[$tf_estimate$addr >> 2] ? -.25 : .5 - +HEAPF32[$tf_estimate$addr >> 2]) * .03999999910593033;
 $2 = HEAP32[$len$addr >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($2 << 2) | 0) + 15 & -16) | 0;
 $vla7 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$len$addr >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$len$addr >> 2] | 0) - 1 << 1) >> 1] | 0) << HEAP32[$LM$addr >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla17 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$len$addr >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$len$addr >> 2] | 0) - 1 << 1) >> 1] | 0) << HEAP32[$LM$addr >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla18 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$len$addr >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla19 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$len$addr >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  HEAP32[$best_level >> 2] = 0;
  HEAP32[$N >> 2] = (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) << HEAP32[$LM$addr >> 2];
  HEAP32[$narrow >> 2] = ((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) == 1 & 1;
  $mul40 = Math_imul(HEAP32[$tf_chan$addr >> 2] | 0, HEAP32[$N0$addr >> 2] | 0) | 0;
  _memcpy($vla7 | 0, (HEAP32[$X$addr >> 2] | 0) + ($mul40 + (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2]) << 2) | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
  HEAPF32[$L1 >> 2] = +_l1_metric($vla7, HEAP32[$N >> 2] | 0, HEAP32[$isTransient$addr >> 2] | 0 ? HEAP32[$LM$addr >> 2] | 0 : 0, +HEAPF32[$bias >> 2]);
  HEAPF32[$best_L1 >> 2] = +HEAPF32[$L1 >> 2];
  if (!((HEAP32[$isTransient$addr >> 2] | 0) == 0 | (HEAP32[$narrow >> 2] | 0) != 0)) {
   _memcpy($vla17 | 0, $vla7 | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
   _haar1($vla17, HEAP32[$N >> 2] >> HEAP32[$LM$addr >> 2], 1 << HEAP32[$LM$addr >> 2]);
   HEAPF32[$L1 >> 2] = +_l1_metric($vla17, HEAP32[$N >> 2] | 0, (HEAP32[$LM$addr >> 2] | 0) + 1 | 0, +HEAPF32[$bias >> 2]);
   if (+HEAPF32[$L1 >> 2] < +HEAPF32[$best_L1 >> 2]) {
    HEAPF32[$best_L1 >> 2] = +HEAPF32[$L1 >> 2];
    HEAP32[$best_level >> 2] = -1;
   }
  }
  HEAP32[$k >> 2] = 0;
  while (1) {
   $tobool84 = (HEAP32[$isTransient$addr >> 2] | 0) != 0;
   if ((HEAP32[$k >> 2] | 0) >= ((HEAP32[$LM$addr >> 2] | 0) + (((HEAP32[$isTransient$addr >> 2] | 0 ? 1 : (HEAP32[$narrow >> 2] | 0) != 0) ^ 1) & 1) | 0)) break;
   if ($tobool84) HEAP32[$B >> 2] = (HEAP32[$LM$addr >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1; else HEAP32[$B >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   _haar1($vla7, HEAP32[$N >> 2] >> HEAP32[$k >> 2], 1 << HEAP32[$k >> 2]);
   HEAPF32[$L1 >> 2] = +_l1_metric($vla7, HEAP32[$N >> 2] | 0, HEAP32[$B >> 2] | 0, +HEAPF32[$bias >> 2]);
   if (+HEAPF32[$L1 >> 2] < +HEAPF32[$best_L1 >> 2]) {
    HEAPF32[$best_L1 >> 2] = +HEAPF32[$L1 >> 2];
    HEAP32[$best_level >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   }
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  $97 = HEAP32[$best_level >> 2] | 0;
  $mul103 = Math_imul(-2, $97) | 0;
  HEAP32[$vla + (($tobool84 ? HEAP32[$i >> 2] | 0 : HEAP32[$i >> 2] | 0) << 2) >> 2] = $tobool84 ? $97 << 1 : $mul103;
  do if (HEAP32[$narrow >> 2] | 0) {
   if (HEAP32[$vla + (HEAP32[$i >> 2] << 2) >> 2] | 0) if ((HEAP32[$vla + (HEAP32[$i >> 2] << 2) >> 2] | 0) != (Math_imul(-2, HEAP32[$LM$addr >> 2] | 0) | 0)) break;
   $arrayidx116 = $vla + (HEAP32[$i >> 2] << 2) | 0;
   HEAP32[$arrayidx116 >> 2] = (HEAP32[$arrayidx116 >> 2] | 0) - 1;
  } while (0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$tf_select >> 2] = 0;
 HEAP32[$sel >> 2] = 0;
 while (1) {
  if ((HEAP32[$sel >> 2] | 0) >= 2) break;
  HEAP32[$cost0 >> 2] = Math_imul(HEAP32[HEAP32[$importance$addr >> 2] >> 2] | 0, Math_abs((HEAP32[$vla >> 2] | 0) - (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$sel >> 2] << 1) + 0) >> 0] << 1) | 0) | 0) | 0;
  $mul151 = Math_imul(HEAP32[HEAP32[$importance$addr >> 2] >> 2] | 0, Math_abs((HEAP32[$vla >> 2] | 0) - (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$sel >> 2] << 1) + 1) >> 0] << 1) | 0) | 0) | 0;
  HEAP32[$cost1 >> 2] = $mul151 + (HEAP32[$isTransient$addr >> 2] | 0 ? 0 : HEAP32[$lambda$addr >> 2] | 0);
  HEAP32[$i >> 2] = 1;
  while (1) {
   $128 = HEAP32[$cost0 >> 2] | 0;
   $129 = HEAP32[$cost1 >> 2] | 0;
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
   if (($128 | 0) < ($129 + (HEAP32[$lambda$addr >> 2] | 0) | 0)) $cond169 = HEAP32[$cost0 >> 2] | 0; else $cond169 = (HEAP32[$cost1 >> 2] | 0) + (HEAP32[$lambda$addr >> 2] | 0) | 0;
   HEAP32[$curr0 >> 2] = $cond169;
   if (((HEAP32[$cost0 >> 2] | 0) + (HEAP32[$lambda$addr >> 2] | 0) | 0) < (HEAP32[$cost1 >> 2] | 0)) $cond177 = (HEAP32[$cost0 >> 2] | 0) + (HEAP32[$lambda$addr >> 2] | 0) | 0; else $cond177 = HEAP32[$cost1 >> 2] | 0;
   HEAP32[$curr1 >> 2] = $cond177;
   HEAP32[$cost0 >> 2] = (HEAP32[$curr0 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$importance$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0, Math_abs((HEAP32[$vla + (HEAP32[$i >> 2] << 2) >> 2] | 0) - (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$sel >> 2] << 1) + 0) >> 0] << 1) | 0) | 0) | 0);
   HEAP32[$cost1 >> 2] = (HEAP32[$curr1 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$importance$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0, Math_abs((HEAP32[$vla + (HEAP32[$i >> 2] << 2) >> 2] | 0) - (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$sel >> 2] << 1) + 1) >> 0] << 1) | 0) | 0) | 0);
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$cost0 >> 2] = ($128 | 0) < ($129 | 0) ? HEAP32[$cost0 >> 2] | 0 : HEAP32[$cost1 >> 2] | 0;
  HEAP32[$selcost + (HEAP32[$sel >> 2] << 2) >> 2] = HEAP32[$cost0 >> 2];
  HEAP32[$sel >> 2] = (HEAP32[$sel >> 2] | 0) + 1;
 }
 if (HEAP32[$isTransient$addr >> 2] | 0 ? (HEAP32[$selcost + 4 >> 2] | 0) < (HEAP32[$selcost >> 2] | 0) : 0) HEAP32[$tf_select >> 2] = 1;
 HEAP32[$cost0 >> 2] = Math_imul(HEAP32[HEAP32[$importance$addr >> 2] >> 2] | 0, Math_abs((HEAP32[$vla >> 2] | 0) - (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$tf_select >> 2] << 1) + 0) >> 0] << 1) | 0) | 0) | 0;
 $mul252 = Math_imul(HEAP32[HEAP32[$importance$addr >> 2] >> 2] | 0, Math_abs((HEAP32[$vla >> 2] | 0) - (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$tf_select >> 2] << 1) + 1) >> 0] << 1) | 0) | 0) | 0;
 HEAP32[$cost1 >> 2] = $mul252 + (HEAP32[$isTransient$addr >> 2] | 0 ? 0 : HEAP32[$lambda$addr >> 2] | 0);
 HEAP32[$i >> 2] = 1;
 while (1) {
  $187 = HEAP32[$cost0 >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  HEAP32[$from0 >> 2] = $187;
  HEAP32[$from1 >> 2] = (HEAP32[$cost1 >> 2] | 0) + (HEAP32[$lambda$addr >> 2] | 0);
  if ((HEAP32[$from0 >> 2] | 0) < (HEAP32[$from1 >> 2] | 0)) {
   HEAP32[$curr0263 >> 2] = HEAP32[$from0 >> 2];
   $$sink2 = 0;
   $$sink3 = HEAP32[$i >> 2] | 0;
  } else {
   HEAP32[$curr0263 >> 2] = HEAP32[$from1 >> 2];
   $$sink2 = 1;
   $$sink3 = HEAP32[$i >> 2] | 0;
  }
  HEAP32[$vla18 + ($$sink3 << 2) >> 2] = $$sink2;
  HEAP32[$from0 >> 2] = (HEAP32[$cost0 >> 2] | 0) + (HEAP32[$lambda$addr >> 2] | 0);
  HEAP32[$from1 >> 2] = HEAP32[$cost1 >> 2];
  if ((HEAP32[$from0 >> 2] | 0) < (HEAP32[$from1 >> 2] | 0)) {
   HEAP32[$curr1264 >> 2] = HEAP32[$from0 >> 2];
   $$sink4 = 0;
   $$sink5 = HEAP32[$i >> 2] | 0;
  } else {
   HEAP32[$curr1264 >> 2] = HEAP32[$from1 >> 2];
   $$sink4 = 1;
   $$sink5 = HEAP32[$i >> 2] | 0;
  }
  HEAP32[$vla19 + ($$sink5 << 2) >> 2] = $$sink4;
  HEAP32[$cost0 >> 2] = (HEAP32[$curr0263 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$importance$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0, Math_abs((HEAP32[$vla + (HEAP32[$i >> 2] << 2) >> 2] | 0) - (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$tf_select >> 2] << 1) + 0) >> 0] << 1) | 0) | 0) | 0);
  HEAP32[$cost1 >> 2] = (HEAP32[$curr1264 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$importance$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0, Math_abs((HEAP32[$vla + (HEAP32[$i >> 2] << 2) >> 2] | 0) - (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$tf_select >> 2] << 1) + 1) >> 0] << 1) | 0) | 0) | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + ((HEAP32[$len$addr >> 2] | 0) - 1 << 2) >> 2] = ($187 | 0) < (HEAP32[$cost1 >> 2] | 0) ? 0 : 1;
 HEAP32[$i >> 2] = (HEAP32[$len$addr >> 2] | 0) - 2;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < 0) break;
  $add327 = (HEAP32[$i >> 2] | 0) + 1 | 0;
  if ((HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] | 0) == 1) {
   $$sink6 = HEAP32[$vla19 + ($add327 << 2) >> 2] | 0;
   $arrayidx333$sink = (HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
  } else {
   $$sink6 = HEAP32[$vla18 + ($add327 << 2) >> 2] | 0;
   $arrayidx333$sink = (HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
  }
  HEAP32[$arrayidx333$sink >> 2] = $$sink6;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 $242 = HEAP32[$tf_select >> 2] | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return $242 | 0;
}

function _silk_noise_shape_analysis_FLP($psEnc, $psEncCtrl, $pitch_res, $x) {
 $psEnc = $psEnc | 0;
 $psEncCtrl = $psEncCtrl | 0;
 $pitch_res = $pitch_res | 0;
 $x = $x | 0;
 var $161 = 0, $26 = 0, $35 = 0, $BWExp = 0, $HarmShapeGain = 0, $HarmShapeGain_smth332 = 0, $SNR_adj_dB = 0, $Tilt = 0, $Tilt_smth339 = 0, $arrayidx174 = 0, $arrayidx189 = 0, $arrayidx213 = 0, $arrayidx216 = 0, $auto_corr = 0, $b = 0, $call = 0.0, $call172 = 0.0, $conv160 = 0.0, $conv320 = 0.0, $conv61 = 0.0, $conv73 = 0.0, $energy_variation = 0, $flat_part = 0, $gain_add = 0, $gain_mult = 0, $k = 0, $log_energy = 0, $log_energy_prev = 0, $nSamples = 0, $nSegs = 0, $nrg = 0, $pitch_res$addr = 0, $pitch_res_ptr = 0, $psEnc$addr = 0, $psEncCtrl$addr = 0, $psShapeSt = 0, $rc = 0, $shift = 0, $slope_part = 0, $strength = 0, $warping = 0, $x$addr = 0, $x_ptr = 0, $x_windowed = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1280 | 0;
 $psEnc$addr = sp + 1264 | 0;
 $psEncCtrl$addr = sp + 1260 | 0;
 $pitch_res$addr = sp + 1256 | 0;
 $x$addr = sp + 1252 | 0;
 $psShapeSt = sp + 1248 | 0;
 $k = sp + 1244 | 0;
 $nSamples = sp + 1240 | 0;
 $nSegs = sp + 1236 | 0;
 $SNR_adj_dB = sp + 1232 | 0;
 $HarmShapeGain = sp + 1228 | 0;
 $Tilt = sp + 1224 | 0;
 $nrg = sp + 1220 | 0;
 $log_energy = sp + 1216 | 0;
 $log_energy_prev = sp + 1212 | 0;
 $energy_variation = sp + 1208 | 0;
 $BWExp = sp + 1204 | 0;
 $gain_mult = sp + 1200 | 0;
 $gain_add = sp + 1196 | 0;
 $strength = sp + 1192 | 0;
 $b = sp + 1188 | 0;
 $warping = sp + 1184 | 0;
 $x_windowed = sp + 224 | 0;
 $auto_corr = sp + 120 | 0;
 $rc = sp + 20 | 0;
 $x_ptr = sp + 16 | 0;
 $pitch_res_ptr = sp + 12 | 0;
 $shift = sp + 8 | 0;
 $slope_part = sp + 4 | 0;
 $flat_part = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$psEncCtrl$addr >> 2] = $psEncCtrl;
 HEAP32[$pitch_res$addr >> 2] = $pitch_res;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$psShapeSt >> 2] = (HEAP32[$psEnc$addr >> 2] | 0) + 7164;
 HEAP32[$x_ptr >> 2] = (HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4596 >> 2] | 0) << 2);
 HEAPF32[$SNR_adj_dB >> 2] = +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4712 >> 2] | 0) * .0078125;
 HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 696 >> 2] = +((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4692 >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4692 + 4 >> 2] | 0) | 0) * .5 * .000030517578125;
 $call = +_silk_sigmoid((+HEAPF32[$SNR_adj_dB >> 2] - 20.0) * .25);
 HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 700 >> 2] = $call;
 if (!(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4672 >> 2] | 0)) {
  HEAPF32[$b >> 2] = 1.0 - +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4528 >> 2] | 0) * .00390625;
  HEAPF32[$SNR_adj_dB >> 2] = +HEAPF32[$SNR_adj_dB >> 2] - +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 700 >> 2] * 2.0 * (+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 696 >> 2] * .5 + .5) * +HEAPF32[$b >> 2] * +HEAPF32[$b >> 2];
 }
 $26 = HEAP32[$psEnc$addr >> 2] | 0;
 if ((HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0) == 2) HEAPF32[$SNR_adj_dB >> 2] = +HEAPF32[$SNR_adj_dB >> 2] + +HEAPF32[$26 + 10056 >> 2] * 2.0; else HEAPF32[$SNR_adj_dB >> 2] = +HEAPF32[$SNR_adj_dB >> 2] + (+(HEAP32[$26 + 4712 >> 2] | 0) * -.4000000059604645 * .0078125 + 6.0) * (1.0 - +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 696 >> 2]);
 $35 = HEAP32[$psEnc$addr >> 2] | 0;
 if ((HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0) == 2) HEAP8[$35 + 4732 + 30 >> 0] = 0; else {
  HEAP32[$nSamples >> 2] = HEAP32[$35 + 4572 >> 2] << 1;
  HEAPF32[$energy_variation >> 2] = 0.0;
  HEAPF32[$log_energy_prev >> 2] = 0.0;
  HEAP32[$pitch_res_ptr >> 2] = HEAP32[$pitch_res$addr >> 2];
  HEAP32[$nSegs >> 2] = (((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] & 65535) << 16 >> 16) * 5 | 0) / 2 | 0;
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nSegs >> 2] | 0)) break;
   $conv61 = +(HEAP32[$nSamples >> 2] | 0);
   HEAPF32[$nrg >> 2] = $conv61 + +_silk_energy_FLP(HEAP32[$pitch_res_ptr >> 2] | 0, HEAP32[$nSamples >> 2] | 0);
   HEAPF32[$log_energy >> 2] = +_silk_log2(+HEAPF32[$nrg >> 2]);
   if ((HEAP32[$k >> 2] | 0) > 0) {
    $conv73 = +Math_abs(+(+HEAPF32[$log_energy >> 2] - +HEAPF32[$log_energy_prev >> 2]));
    HEAPF32[$energy_variation >> 2] = +HEAPF32[$energy_variation >> 2] + $conv73;
   }
   HEAPF32[$log_energy_prev >> 2] = +HEAPF32[$log_energy >> 2];
   HEAP32[$pitch_res_ptr >> 2] = (HEAP32[$pitch_res_ptr >> 2] | 0) + (HEAP32[$nSamples >> 2] << 2);
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 30 >> 0] = +HEAPF32[$energy_variation >> 2] > +((HEAP32[$nSegs >> 2] | 0) - 1 | 0) * .6000000238418579 ? 0 : 1;
 }
 HEAPF32[$strength >> 2] = +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 704 >> 2] * 1.0000000474974513e-03;
 HEAPF32[$BWExp >> 2] = .9399999976158142 / (+HEAPF32[$strength >> 2] * +HEAPF32[$strength >> 2] + 1.0);
 HEAPF32[$warping >> 2] = +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4668 >> 2] | 0) / 65536.0 + +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 700 >> 2] * .009999999776482582;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  HEAP32[$flat_part >> 2] = (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) * 3;
  HEAP32[$slope_part >> 2] = ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4600 >> 2] | 0) - (HEAP32[$flat_part >> 2] | 0) | 0) / 2 | 0;
  _silk_apply_sine_window_FLP($x_windowed, HEAP32[$x_ptr >> 2] | 0, 1, HEAP32[$slope_part >> 2] | 0);
  HEAP32[$shift >> 2] = HEAP32[$slope_part >> 2];
  _memcpy($x_windowed + (HEAP32[$shift >> 2] << 2) | 0, (HEAP32[$x_ptr >> 2] | 0) + (HEAP32[$shift >> 2] << 2) | 0, HEAP32[$flat_part >> 2] << 2 | 0) | 0;
  HEAP32[$shift >> 2] = (HEAP32[$shift >> 2] | 0) + (HEAP32[$flat_part >> 2] | 0);
  _silk_apply_sine_window_FLP($x_windowed + (HEAP32[$shift >> 2] << 2) | 0, (HEAP32[$x_ptr >> 2] | 0) + (HEAP32[$shift >> 2] << 2) | 0, 2, HEAP32[$slope_part >> 2] | 0);
  HEAP32[$x_ptr >> 2] = (HEAP32[$x_ptr >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] << 2);
  if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4668 >> 2] | 0) > 0) _silk_warped_autocorrelation_FLP($auto_corr, $x_windowed, +HEAPF32[$warping >> 2], HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4600 >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4632 >> 2] | 0); else _silk_autocorrelation_FLP($auto_corr, $x_windowed, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4600 >> 2] | 0, (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4632 >> 2] | 0) + 1 | 0);
  HEAPF32[$auto_corr >> 2] = +HEAPF32[$auto_corr >> 2] + (+HEAPF32[$auto_corr >> 2] * 2.9999999242136255e-05 + 1.0);
  HEAPF32[$nrg >> 2] = +_silk_schur_FLP($rc, $auto_corr, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4632 >> 2] | 0);
  _silk_k2a_FLP((HEAP32[$psEncCtrl$addr >> 2] | 0) + 244 + ((HEAP32[$k >> 2] | 0) * 24 << 2) | 0, $rc, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4632 >> 2] | 0);
  $conv160 = +Math_sqrt(+(+HEAPF32[$nrg >> 2]));
  HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = $conv160;
  if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4668 >> 2] | 0) > 0) {
   $call172 = +_warped_gain((HEAP32[$psEncCtrl$addr >> 2] | 0) + 244 + ((HEAP32[$k >> 2] | 0) * 24 << 2) | 0, +HEAPF32[$warping >> 2], HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4632 >> 2] | 0);
   $arrayidx174 = (HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) | 0;
   HEAPF32[$arrayidx174 >> 2] = +HEAPF32[$arrayidx174 >> 2] * $call172;
  }
  _silk_bwexpander_FLP((HEAP32[$psEncCtrl$addr >> 2] | 0) + 244 + ((HEAP32[$k >> 2] | 0) * 24 << 2) | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4632 >> 2] | 0, +HEAPF32[$BWExp >> 2]);
  $arrayidx189 = (HEAP32[$psEncCtrl$addr >> 2] | 0) + 244 + ((HEAP32[$k >> 2] | 0) * 24 << 2) | 0;
  if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4668 >> 2] | 0) > 0) _warped_true2monic_coefs($arrayidx189, +HEAPF32[$warping >> 2], 3.999000072479248, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4632 >> 2] | 0); else _limit_coefs($arrayidx189, 3.999000072479248, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4632 >> 2] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAPF32[$gain_mult >> 2] = +Math_pow(2.0, +(+HEAPF32[$SNR_adj_dB >> 2] * -.1599999964237213));
 HEAPF32[$gain_add >> 2] = +Math_pow(2.0, .3199999928474426);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  $arrayidx213 = (HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) | 0;
  HEAPF32[$arrayidx213 >> 2] = +HEAPF32[$arrayidx213 >> 2] * +HEAPF32[$gain_mult >> 2];
  $arrayidx216 = (HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) | 0;
  HEAPF32[$arrayidx216 >> 2] = +HEAPF32[$arrayidx216 >> 2] + +HEAPF32[$gain_add >> 2];
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAPF32[$strength >> 2] = ((+(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4692 >> 2] | 0) * .000030517578125 - 1.0) * .5 + 1.0) * 4.0;
 HEAPF32[$strength >> 2] = +HEAPF32[$strength >> 2] * (+(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4528 >> 2] | 0) * .00390625);
 if ((HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0) == 2) {
  HEAP32[$k >> 2] = 0;
  while (1) {
   $161 = HEAP32[$psEnc$addr >> 2] | 0;
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
   HEAPF32[$b >> 2] = .20000000298023224 / +(HEAP32[$161 + 4572 >> 2] | 0) + 3.0 / +(HEAP32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 228 + (HEAP32[$k >> 2] << 2) >> 2] | 0);
   HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 628 + (HEAP32[$k >> 2] << 2) >> 2] = +HEAPF32[$b >> 2] + -1.0;
   HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 644 + (HEAP32[$k >> 2] << 2) >> 2] = 1.0 - +HEAPF32[$b >> 2] - +HEAPF32[$b >> 2] * +HEAPF32[$strength >> 2];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAPF32[$Tilt >> 2] = -.25 - +(HEAP32[$161 + 4528 >> 2] | 0) * .26249998807907104 * .00390625;
 } else {
  HEAPF32[$b >> 2] = 1.2999999523162842 / +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0);
  HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 628 >> 2] = +HEAPF32[$b >> 2] + -1.0;
  HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 644 >> 2] = 1.0 - +HEAPF32[$b >> 2] - +HEAPF32[$b >> 2] * +HEAPF32[$strength >> 2] * .6000000238418579;
  HEAP32[$k >> 2] = 1;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
   HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 628 + (HEAP32[$k >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 628 >> 2];
   HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 644 + (HEAP32[$k >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 644 >> 2];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAPF32[$Tilt >> 2] = -.25;
 }
 if ((HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0) == 2) {
  HEAPF32[$HarmShapeGain >> 2] = .30000001192092896;
  HEAPF32[$HarmShapeGain >> 2] = +HEAPF32[$HarmShapeGain >> 2] + (1.0 - (1.0 - +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 700 >> 2]) * +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 696 >> 2]) * .20000000298023224;
  $conv320 = +Math_sqrt(+(+HEAPF32[(HEAP32[$psEnc$addr >> 2] | 0) + 10056 >> 2]));
  HEAPF32[$HarmShapeGain >> 2] = +HEAPF32[$HarmShapeGain >> 2] * $conv320;
 } else HEAPF32[$HarmShapeGain >> 2] = 0.0;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  $HarmShapeGain_smth332 = (HEAP32[$psShapeSt >> 2] | 0) + 4 | 0;
  HEAPF32[$HarmShapeGain_smth332 >> 2] = +HEAPF32[$HarmShapeGain_smth332 >> 2] + (+HEAPF32[$HarmShapeGain >> 2] - +HEAPF32[(HEAP32[$psShapeSt >> 2] | 0) + 4 >> 2]) * .4000000059604645;
  HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 676 + (HEAP32[$k >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$psShapeSt >> 2] | 0) + 4 >> 2];
  $Tilt_smth339 = (HEAP32[$psShapeSt >> 2] | 0) + 8 | 0;
  HEAPF32[$Tilt_smth339 >> 2] = +HEAPF32[$Tilt_smth339 >> 2] + (+HEAPF32[$Tilt >> 2] - +HEAPF32[(HEAP32[$psShapeSt >> 2] | 0) + 8 >> 2]) * .4000000059604645;
  HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 660 + (HEAP32[$k >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$psShapeSt >> 2] | 0) + 8 >> 2];
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_VAD_GetSA_Q8_c($psEncC, $pIn) {
 $psEncC = $psEncC | 0;
 $pIn = $pIn | 0;
 var $$sink = 0, $$sink1 = 0, $194 = 0, $49 = 0, $70 = 0, $71 = 0, $95 = 0, $98 = 0, $HPstateTmp = 0, $NrgToNoiseRatio_Q8 = 0, $SA_Q15 = 0, $SNR_Q7 = 0, $X_offset = 0, $Xnrg = 0, $add13 = 0, $add314 = 0, $and163 = 0, $arrayidx43 = 0, $b = 0, $call254 = 0, $call324 = 0, $cond = 0, $cond102 = 0, $cond102$sink = 0, $dec_subframe_length = 0, $dec_subframe_offset = 0, $decimated_framelength = 0, $decimated_framelength1 = 0, $decimated_framelength2 = 0, $div140$sink = 0, $i = 0, $input_tilt = 0, $mul160 = 0, $mul174 = 0, $mul217 = 0, $mul243 = 0, $mul271 = 0, $mul303 = 0, $pIn$addr = 0, $pSNR_dB_Q7 = 0, $psEncC$addr = 0, $psSilk_VAD = 0, $ret = 0, $s = 0, $saved_stack = 0, $shl206 = 0, $shr157 = 0, $smooth_coef_Q16 = 0, $speech_nrg = 0, $sumSquared = 0, $vla = 0, $x_tmp = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $psEncC$addr = sp + 132 | 0;
 $pIn$addr = sp + 128 | 0;
 $SA_Q15 = sp + 124 | 0;
 $pSNR_dB_Q7 = sp + 120 | 0;
 $input_tilt = sp + 116 | 0;
 $decimated_framelength1 = sp + 112 | 0;
 $decimated_framelength2 = sp + 108 | 0;
 $decimated_framelength = sp + 104 | 0;
 $dec_subframe_length = sp + 100 | 0;
 $dec_subframe_offset = sp + 96 | 0;
 $SNR_Q7 = sp + 92 | 0;
 $i = sp + 88 | 0;
 $b = sp + 84 | 0;
 $s = sp + 80 | 0;
 $sumSquared = sp + 76 | 0;
 $smooth_coef_Q16 = sp + 72 | 0;
 $HPstateTmp = sp + 136 | 0;
 $Xnrg = sp + 56 | 0;
 $NrgToNoiseRatio_Q8 = sp + 40 | 0;
 $speech_nrg = sp + 36 | 0;
 $x_tmp = sp + 32 | 0;
 $X_offset = sp + 16 | 0;
 $ret = sp + 8 | 0;
 $psSilk_VAD = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$pIn$addr >> 2] = $pIn;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$psSilk_VAD >> 2] = (HEAP32[$psEncC$addr >> 2] | 0) + 32;
 HEAP32[$decimated_framelength1 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] >> 1;
 HEAP32[$decimated_framelength2 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] >> 2;
 HEAP32[$decimated_framelength >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] >> 3;
 HEAP32[$X_offset >> 2] = 0;
 HEAP32[$X_offset + 4 >> 2] = (HEAP32[$decimated_framelength >> 2] | 0) + (HEAP32[$decimated_framelength2 >> 2] | 0);
 HEAP32[$X_offset + 8 >> 2] = (HEAP32[$X_offset + 4 >> 2] | 0) + (HEAP32[$decimated_framelength >> 2] | 0);
 HEAP32[$X_offset + 12 >> 2] = (HEAP32[$X_offset + 8 >> 2] | 0) + (HEAP32[$decimated_framelength2 >> 2] | 0);
 $add13 = (HEAP32[$X_offset + 12 >> 2] | 0) + (HEAP32[$decimated_framelength1 >> 2] | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add13 << 1) | 0) + 15 & -16) | 0;
 _silk_ana_filt_bank_1(HEAP32[$pIn$addr >> 2] | 0, HEAP32[$psSilk_VAD >> 2] | 0, $vla, $vla + (HEAP32[$X_offset + 12 >> 2] << 1) | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0);
 _silk_ana_filt_bank_1($vla, (HEAP32[$psSilk_VAD >> 2] | 0) + 8 | 0, $vla, $vla + (HEAP32[$X_offset + 8 >> 2] << 1) | 0, HEAP32[$decimated_framelength1 >> 2] | 0);
 _silk_ana_filt_bank_1($vla, (HEAP32[$psSilk_VAD >> 2] | 0) + 16 | 0, $vla, $vla + (HEAP32[$X_offset + 4 >> 2] << 1) | 0, HEAP32[$decimated_framelength2 >> 2] | 0);
 HEAP16[$vla + ((HEAP32[$decimated_framelength >> 2] | 0) - 1 << 1) >> 1] = HEAP16[$vla + ((HEAP32[$decimated_framelength >> 2] | 0) - 1 << 1) >> 1] >> 1;
 HEAP16[$HPstateTmp >> 1] = HEAP16[$vla + ((HEAP32[$decimated_framelength >> 2] | 0) - 1 << 1) >> 1] | 0;
 HEAP32[$i >> 2] = (HEAP32[$decimated_framelength >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) <= 0) break;
  HEAP16[$vla + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] = HEAP16[$vla + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] >> 1;
  $arrayidx43 = $vla + (HEAP32[$i >> 2] << 1) | 0;
  HEAP16[$arrayidx43 >> 1] = (HEAP16[$arrayidx43 >> 1] | 0) - (HEAP16[$vla + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 HEAP16[$vla >> 1] = (HEAP16[$vla >> 1] | 0) - (HEAP16[(HEAP32[$psSilk_VAD >> 2] | 0) + 56 >> 1] | 0);
 HEAP16[(HEAP32[$psSilk_VAD >> 2] | 0) + 56 >> 1] = HEAP16[$HPstateTmp >> 1] | 0;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  $49 = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0;
  HEAP32[$decimated_framelength >> 2] = $49 >> (_silk_min_int_451(4 - (HEAP32[$b >> 2] | 0) | 0, 3) | 0);
  HEAP32[$dec_subframe_length >> 2] = HEAP32[$decimated_framelength >> 2] >> 2;
  HEAP32[$dec_subframe_offset >> 2] = 0;
  HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] = HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 24 + (HEAP32[$b >> 2] << 2) >> 2];
  HEAP32[$s >> 2] = 0;
  while (1) {
   if ((HEAP32[$s >> 2] | 0) >= 4) break;
   HEAP32[$sumSquared >> 2] = 0;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$dec_subframe_length >> 2] | 0)) break;
    HEAP32[$x_tmp >> 2] = HEAP16[$vla + ((HEAP32[$X_offset + (HEAP32[$b >> 2] << 2) >> 2] | 0) + (HEAP32[$i >> 2] | 0) + (HEAP32[$dec_subframe_offset >> 2] | 0) << 1) >> 1] >> 3;
    HEAP32[$sumSquared >> 2] = (HEAP32[$sumSquared >> 2] | 0) + (Math_imul((HEAP32[$x_tmp >> 2] & 65535) << 16 >> 16, (HEAP32[$x_tmp >> 2] & 65535) << 16 >> 16) | 0);
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   $70 = HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0;
   $71 = HEAP32[$sumSquared >> 2] | 0;
   if ((HEAP32[$s >> 2] | 0) < 3) {
    if ($70 + $71 & -2147483648 | 0) $cond = 2147483647; else $cond = (HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0) + (HEAP32[$sumSquared >> 2] | 0) | 0;
    $$sink = HEAP32[$b >> 2] | 0;
    $cond102$sink = $cond;
   } else {
    if ($70 + ($71 >> 1) & -2147483648 | 0) $cond102 = 2147483647; else $cond102 = (HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0) + (HEAP32[$sumSquared >> 2] >> 1) | 0;
    $$sink = HEAP32[$b >> 2] | 0;
    $cond102$sink = $cond102;
   }
   HEAP32[$Xnrg + ($$sink << 2) >> 2] = $cond102$sink;
   HEAP32[$dec_subframe_offset >> 2] = (HEAP32[$dec_subframe_offset >> 2] | 0) + (HEAP32[$dec_subframe_length >> 2] | 0);
   HEAP32[$s >> 2] = (HEAP32[$s >> 2] | 0) + 1;
  }
  HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 24 + (HEAP32[$b >> 2] << 2) >> 2] = HEAP32[$sumSquared >> 2];
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 _silk_VAD_GetNoiseLevels($Xnrg, HEAP32[$psSilk_VAD >> 2] | 0);
 HEAP32[$sumSquared >> 2] = 0;
 HEAP32[$input_tilt >> 2] = 0;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  HEAP32[$speech_nrg >> 2] = (HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] | 0);
  $95 = HEAP32[$b >> 2] | 0;
  if ((HEAP32[$speech_nrg >> 2] | 0) > 0) {
   $98 = HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0;
   if (!(HEAP32[$Xnrg + ($95 << 2) >> 2] & -8388608)) {
    $$sink1 = HEAP32[$b >> 2] | 0;
    $div140$sink = ($98 << 8 | 0) / ((HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] | 0) + 1 | 0) | 0;
   } else {
    $$sink1 = HEAP32[$b >> 2] | 0;
    $div140$sink = ($98 | 0) / ((HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] >> 8) + 1 | 0) | 0;
   }
   HEAP32[$NrgToNoiseRatio_Q8 + ($$sink1 << 2) >> 2] = $div140$sink;
   HEAP32[$SNR_Q7 >> 2] = (_silk_lin2log(HEAP32[$NrgToNoiseRatio_Q8 + (HEAP32[$b >> 2] << 2) >> 2] | 0) | 0) - 1024;
   HEAP32[$sumSquared >> 2] = (HEAP32[$sumSquared >> 2] | 0) + (Math_imul((HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0);
   if ((HEAP32[$speech_nrg >> 2] | 0) < 1048576) {
    $shr157 = (_silk_SQRT_APPROX_454(HEAP32[$speech_nrg >> 2] | 0) | 0) << 6 >> 16;
    $mul160 = Math_imul($shr157, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0;
    $and163 = (_silk_SQRT_APPROX_454(HEAP32[$speech_nrg >> 2] | 0) | 0) << 6 & 65535;
    HEAP32[$SNR_Q7 >> 2] = $mul160 + ((Math_imul($and163, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0) >> 16);
   }
   $mul174 = Math_imul(HEAP32[20724 + (HEAP32[$b >> 2] << 2) >> 2] >> 16, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$input_tilt >> 2] = (HEAP32[$input_tilt >> 2] | 0) + ($mul174 + ((Math_imul(HEAP32[20724 + (HEAP32[$b >> 2] << 2) >> 2] & 65535, (HEAP32[$SNR_Q7 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  } else HEAP32[$NrgToNoiseRatio_Q8 + ($95 << 2) >> 2] = 256;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 HEAP32[$sumSquared >> 2] = (HEAP32[$sumSquared >> 2] | 0) / 4 | 0;
 HEAP32[$pSNR_dB_Q7 >> 2] = ((_silk_SQRT_APPROX_454(HEAP32[$sumSquared >> 2] | 0) | 0) * 3 & 65535) << 16 >> 16;
 HEAP32[$SA_Q15 >> 2] = _silk_sigm_Q15(0 + (((HEAP32[$pSNR_dB_Q7 >> 2] & 65535) << 16 >> 16) * 45e3 >> 16) - 128 | 0) | 0;
 $shl206 = (_silk_sigm_Q15(HEAP32[$input_tilt >> 2] | 0) | 0) - 16384 << 1;
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4708 >> 2] = $shl206;
 HEAP32[$speech_nrg >> 2] = 0;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  $mul217 = Math_imul((HEAP32[$b >> 2] | 0) + 1 | 0, (HEAP32[$Xnrg + (HEAP32[$b >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] | 0) >> 4) | 0;
  HEAP32[$speech_nrg >> 2] = (HEAP32[$speech_nrg >> 2] | 0) + $mul217;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0) == ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 20 | 0)) HEAP32[$speech_nrg >> 2] = HEAP32[$speech_nrg >> 2] >> 1;
 if ((HEAP32[$speech_nrg >> 2] | 0) <= 0) HEAP32[$SA_Q15 >> 2] = HEAP32[$SA_Q15 >> 2] >> 1; else if ((HEAP32[$speech_nrg >> 2] | 0) < 16384) {
  HEAP32[$speech_nrg >> 2] = HEAP32[$speech_nrg >> 2] << 16;
  HEAP32[$speech_nrg >> 2] = _silk_SQRT_APPROX_454(HEAP32[$speech_nrg >> 2] | 0) | 0;
  $mul243 = Math_imul(32768 + (HEAP32[$speech_nrg >> 2] | 0) >> 16, (HEAP32[$SA_Q15 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$SA_Q15 >> 2] = $mul243 + ((Math_imul(32768 + (HEAP32[$speech_nrg >> 2] | 0) & 65535, (HEAP32[$SA_Q15 >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 }
 $call254 = _silk_min_int_451(HEAP32[$SA_Q15 >> 2] >> 7, 255) | 0;
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4528 >> 2] = $call254;
 $mul271 = Math_imul(HEAP32[$SA_Q15 >> 2] >> 16, (HEAP32[$SA_Q15 >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$smooth_coef_Q16 >> 2] = 0 + (($mul271 + ((Math_imul(HEAP32[$SA_Q15 >> 2] & 65535, (HEAP32[$SA_Q15 >> 2] & 65535) << 16 >> 16) | 0) >> 16) & 65535) << 16 >> 16 << 12 >> 16);
 if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0) == ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 10 | 0)) HEAP32[$smooth_coef_Q16 >> 2] = HEAP32[$smooth_coef_Q16 >> 2] >> 1;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  $mul303 = Math_imul((HEAP32[$NrgToNoiseRatio_Q8 + (HEAP32[$b >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] | 0) >> 16, (HEAP32[$smooth_coef_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add314 = (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] | 0) + ($mul303 + ((Math_imul((HEAP32[$NrgToNoiseRatio_Q8 + (HEAP32[$b >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] | 0) & 65535, (HEAP32[$smooth_coef_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] = $add314;
  HEAP32[$SNR_Q7 >> 2] = ((_silk_lin2log(HEAP32[(HEAP32[$psSilk_VAD >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] | 0) | 0) - 1024 | 0) * 3;
  $call324 = _silk_sigm_Q15((HEAP32[$SNR_Q7 >> 2] | 0) - 2048 >> 4) | 0;
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4692 + (HEAP32[$b >> 2] << 2) >> 2] = $call324;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 $194 = HEAP32[$ret >> 2] | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return $194 | 0;
}

function _quant_partition($ctx, $X, $N, $b, $B, $lowband, $LM, $gain, $fill) {
 $ctx = $ctx | 0;
 $X = $X | 0;
 $N = $N | 0;
 $b = $b | 0;
 $B = $B | 0;
 $lowband = $lowband | 0;
 $LM = $LM | 0;
 $gain = +$gain;
 $fill = $fill | 0;
 var $$sink = 0, $$sink3 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0.0, $209 = 0.0, $223 = 0, $52 = 0, $63 = 0, $68 = 0, $82 = 0, $B$addr = 0, $B0 = 0, $K = 0, $LM$addr = 0, $N$addr = 0, $X$addr = 0, $Y = 0, $b$addr = 0, $cache = 0, $call107 = 0, $call114 = 0, $call130 = 0, $call174 = 0, $call186 = 0, $cm = 0, $cm_mask = 0, $cmp169 = 0, $cond = 0, $cond65 = 0, $cond81 = 0, $ctx$addr = 0, $curr_bits = 0, $delta = 0, $ec = 0, $encode = 0, $fill$addr = 0, $gain$addr = 0, $i = 0, $imid = 0, $iside = 0, $itheta = 0, $j = 0, $lowband$addr = 0, $m = 0, $mbits = 0, $mid = 0, $mul = 0, $next_lowband2 = 0, $q = 0, $qalloc = 0, $rebalance = 0, $remaining_bits = 0, $remaining_bits143 = 0, $remaining_bits146 = 0, $sbits = 0, $sctx = 0, $side = 0, $spread = 0, $tmp = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 $ctx$addr = sp + 160 | 0;
 $X$addr = sp + 156 | 0;
 $N$addr = sp + 152 | 0;
 $b$addr = sp + 148 | 0;
 $B$addr = sp + 144 | 0;
 $lowband$addr = sp + 140 | 0;
 $LM$addr = sp + 136 | 0;
 $gain$addr = sp + 132 | 0;
 $fill$addr = sp + 128 | 0;
 $cache = sp + 124 | 0;
 $q = sp + 120 | 0;
 $curr_bits = sp + 116 | 0;
 $imid = sp + 112 | 0;
 $iside = sp + 108 | 0;
 $B0 = sp + 104 | 0;
 $mid = sp + 100 | 0;
 $side = sp + 96 | 0;
 $cm = sp + 92 | 0;
 $Y = sp + 88 | 0;
 $encode = sp + 84 | 0;
 $m = sp + 80 | 0;
 $i = sp + 76 | 0;
 $spread = sp + 72 | 0;
 $ec = sp + 68 | 0;
 $mbits = sp + 64 | 0;
 $sbits = sp + 60 | 0;
 $delta = sp + 56 | 0;
 $itheta = sp + 52 | 0;
 $qalloc = sp + 48 | 0;
 $sctx = sp + 24 | 0;
 $next_lowband2 = sp + 20 | 0;
 $rebalance = sp + 16 | 0;
 $K = sp + 12 | 0;
 $j = sp + 8 | 0;
 $cm_mask = sp + 4 | 0;
 $tmp = sp;
 HEAP32[$ctx$addr >> 2] = $ctx;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$b$addr >> 2] = $b;
 HEAP32[$B$addr >> 2] = $B;
 HEAP32[$lowband$addr >> 2] = $lowband;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAPF32[$gain$addr >> 2] = $gain;
 HEAP32[$fill$addr >> 2] = $fill;
 HEAP32[$imid >> 2] = 0;
 HEAP32[$iside >> 2] = 0;
 HEAP32[$B0 >> 2] = HEAP32[$B$addr >> 2];
 HEAPF32[$mid >> 2] = 0.0;
 HEAPF32[$side >> 2] = 0.0;
 HEAP32[$cm >> 2] = 0;
 HEAP32[$Y >> 2] = 0;
 HEAP32[$encode >> 2] = HEAP32[HEAP32[$ctx$addr >> 2] >> 2];
 HEAP32[$m >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 8 >> 2];
 HEAP32[$i >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 12 >> 2];
 HEAP32[$spread >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 20 >> 2];
 HEAP32[$ec >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 28 >> 2];
 $mul = Math_imul((HEAP32[$LM$addr >> 2] | 0) + 1 | 0, HEAP32[(HEAP32[$m >> 2] | 0) + 8 >> 2] | 0) | 0;
 HEAP32[$cache >> 2] = (HEAP32[(HEAP32[$m >> 2] | 0) + 92 + 8 >> 2] | 0) + (HEAP16[(HEAP32[(HEAP32[$m >> 2] | 0) + 92 + 4 >> 2] | 0) + ($mul + (HEAP32[$i >> 2] | 0) << 1) >> 1] | 0);
 if ((HEAP32[$LM$addr >> 2] | 0) != -1) if ((HEAP32[$N$addr >> 2] | 0) > 2 ? (HEAP32[$b$addr >> 2] | 0) > ((HEAPU8[(HEAP32[$cache >> 2] | 0) + (HEAPU8[HEAP32[$cache >> 2] >> 0] | 0) >> 0] | 0) + 12 | 0) : 0) {
  HEAP32[$next_lowband2 >> 2] = 0;
  HEAP32[$N$addr >> 2] = HEAP32[$N$addr >> 2] >> 1;
  HEAP32[$Y >> 2] = (HEAP32[$X$addr >> 2] | 0) + (HEAP32[$N$addr >> 2] << 2);
  HEAP32[$LM$addr >> 2] = (HEAP32[$LM$addr >> 2] | 0) - 1;
  if ((HEAP32[$B$addr >> 2] | 0) == 1) HEAP32[$fill$addr >> 2] = HEAP32[$fill$addr >> 2] & 1 | HEAP32[$fill$addr >> 2] << 1;
  HEAP32[$B$addr >> 2] = (HEAP32[$B$addr >> 2] | 0) + 1 >> 1;
  _compute_theta(HEAP32[$ctx$addr >> 2] | 0, $sctx, HEAP32[$X$addr >> 2] | 0, HEAP32[$Y >> 2] | 0, HEAP32[$N$addr >> 2] | 0, $b$addr, HEAP32[$B$addr >> 2] | 0, HEAP32[$B0 >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, 0, $fill$addr);
  HEAP32[$imid >> 2] = HEAP32[$sctx + 4 >> 2];
  HEAP32[$iside >> 2] = HEAP32[$sctx + 8 >> 2];
  HEAP32[$delta >> 2] = HEAP32[$sctx + 12 >> 2];
  HEAP32[$itheta >> 2] = HEAP32[$sctx + 16 >> 2];
  HEAP32[$qalloc >> 2] = HEAP32[$sctx + 20 >> 2];
  HEAPF32[$mid >> 2] = +(HEAP32[$imid >> 2] | 0) * .000030517578125;
  HEAPF32[$side >> 2] = +(HEAP32[$iside >> 2] | 0) * .000030517578125;
  do if ((HEAP32[$B0 >> 2] | 0) > 1) if (HEAP32[$itheta >> 2] & 16383 | 0) {
   $52 = HEAP32[$delta >> 2] | 0;
   if ((HEAP32[$itheta >> 2] | 0) > 8192) {
    HEAP32[$delta >> 2] = (HEAP32[$delta >> 2] | 0) - ($52 >> 4 - (HEAP32[$LM$addr >> 2] | 0));
    break;
   }
   if (0 < ($52 + (HEAP32[$N$addr >> 2] << 3 >> 5 - (HEAP32[$LM$addr >> 2] | 0)) | 0)) $cond = 0; else $cond = (HEAP32[$delta >> 2] | 0) + (HEAP32[$N$addr >> 2] << 3 >> 5 - (HEAP32[$LM$addr >> 2] | 0)) | 0;
   HEAP32[$delta >> 2] = $cond;
  } while (0);
  $63 = HEAP32[$b$addr >> 2] | 0;
  if ((HEAP32[$b$addr >> 2] | 0) < (((HEAP32[$b$addr >> 2] | 0) - (HEAP32[$delta >> 2] | 0) | 0) / 2 | 0 | 0)) $cond65 = $63; else $cond65 = ($63 - (HEAP32[$delta >> 2] | 0) | 0) / 2 | 0;
  if (0 > ($cond65 | 0)) $cond81 = 0; else {
   $68 = HEAP32[$b$addr >> 2] | 0;
   if ((HEAP32[$b$addr >> 2] | 0) < (((HEAP32[$b$addr >> 2] | 0) - (HEAP32[$delta >> 2] | 0) | 0) / 2 | 0 | 0)) $cond81 = $68; else $cond81 = ($68 - (HEAP32[$delta >> 2] | 0) | 0) / 2 | 0;
  }
  HEAP32[$mbits >> 2] = $cond81;
  HEAP32[$sbits >> 2] = (HEAP32[$b$addr >> 2] | 0) - (HEAP32[$mbits >> 2] | 0);
  $remaining_bits = (HEAP32[$ctx$addr >> 2] | 0) + 32 | 0;
  HEAP32[$remaining_bits >> 2] = (HEAP32[$remaining_bits >> 2] | 0) - (HEAP32[$qalloc >> 2] | 0);
  if (HEAP32[$lowband$addr >> 2] | 0) HEAP32[$next_lowband2 >> 2] = (HEAP32[$lowband$addr >> 2] | 0) + (HEAP32[$N$addr >> 2] << 2);
  HEAP32[$rebalance >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 32 >> 2];
  $82 = HEAP32[$ctx$addr >> 2] | 0;
  if ((HEAP32[$mbits >> 2] | 0) >= (HEAP32[$sbits >> 2] | 0)) {
   HEAP32[$cm >> 2] = _quant_partition($82, HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$mbits >> 2] | 0, HEAP32[$B$addr >> 2] | 0, HEAP32[$lowband$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, +HEAPF32[$gain$addr >> 2] * +HEAPF32[$mid >> 2], HEAP32[$fill$addr >> 2] | 0) | 0;
   HEAP32[$rebalance >> 2] = (HEAP32[$mbits >> 2] | 0) - ((HEAP32[$rebalance >> 2] | 0) - (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 32 >> 2] | 0));
   if ((HEAP32[$rebalance >> 2] | 0) > 24 & (HEAP32[$itheta >> 2] | 0) != 0) HEAP32[$sbits >> 2] = (HEAP32[$sbits >> 2] | 0) + ((HEAP32[$rebalance >> 2] | 0) - 24);
   $call107 = _quant_partition(HEAP32[$ctx$addr >> 2] | 0, HEAP32[$Y >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$sbits >> 2] | 0, HEAP32[$B$addr >> 2] | 0, HEAP32[$next_lowband2 >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, +HEAPF32[$gain$addr >> 2] * +HEAPF32[$side >> 2], HEAP32[$fill$addr >> 2] >> HEAP32[$B$addr >> 2]) | 0;
   HEAP32[$cm >> 2] = HEAP32[$cm >> 2] | $call107 << (HEAP32[$B0 >> 2] >> 1);
   $223 = HEAP32[$cm >> 2] | 0;
   STACKTOP = sp;
   return $223 | 0;
  } else {
   $call114 = _quant_partition($82, HEAP32[$Y >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$sbits >> 2] | 0, HEAP32[$B$addr >> 2] | 0, HEAP32[$next_lowband2 >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, +HEAPF32[$gain$addr >> 2] * +HEAPF32[$side >> 2], HEAP32[$fill$addr >> 2] >> HEAP32[$B$addr >> 2]) | 0;
   HEAP32[$cm >> 2] = $call114 << (HEAP32[$B0 >> 2] >> 1);
   HEAP32[$rebalance >> 2] = (HEAP32[$sbits >> 2] | 0) - ((HEAP32[$rebalance >> 2] | 0) - (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 32 >> 2] | 0));
   if ((HEAP32[$rebalance >> 2] | 0) > 24 & (HEAP32[$itheta >> 2] | 0) != 16384) HEAP32[$mbits >> 2] = (HEAP32[$mbits >> 2] | 0) + ((HEAP32[$rebalance >> 2] | 0) - 24);
   $call130 = _quant_partition(HEAP32[$ctx$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$mbits >> 2] | 0, HEAP32[$B$addr >> 2] | 0, HEAP32[$lowband$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, +HEAPF32[$gain$addr >> 2] * +HEAPF32[$mid >> 2], HEAP32[$fill$addr >> 2] | 0) | 0;
   HEAP32[$cm >> 2] = HEAP32[$cm >> 2] | $call130;
   $223 = HEAP32[$cm >> 2] | 0;
   STACKTOP = sp;
   return $223 | 0;
  }
 }
 HEAP32[$q >> 2] = _bits2pulses(HEAP32[$m >> 2] | 0, HEAP32[$i >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, HEAP32[$b$addr >> 2] | 0) | 0;
 HEAP32[$curr_bits >> 2] = _pulses2bits(HEAP32[$m >> 2] | 0, HEAP32[$i >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, HEAP32[$q >> 2] | 0) | 0;
 $$sink = HEAP32[$ctx$addr >> 2] | 0;
 $$sink3 = HEAP32[$curr_bits >> 2] | 0;
 while (1) {
  $remaining_bits146 = $$sink + 32 | 0;
  HEAP32[$remaining_bits146 >> 2] = (HEAP32[$remaining_bits146 >> 2] | 0) - $$sink3;
  if (!((HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 32 >> 2] | 0) < 0 ? (HEAP32[$q >> 2] | 0) > 0 : 0)) break;
  $remaining_bits143 = (HEAP32[$ctx$addr >> 2] | 0) + 32 | 0;
  HEAP32[$remaining_bits143 >> 2] = (HEAP32[$remaining_bits143 >> 2] | 0) + (HEAP32[$curr_bits >> 2] | 0);
  HEAP32[$q >> 2] = (HEAP32[$q >> 2] | 0) + -1;
  HEAP32[$curr_bits >> 2] = _pulses2bits(HEAP32[$m >> 2] | 0, HEAP32[$i >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, HEAP32[$q >> 2] | 0) | 0;
  $$sink = HEAP32[$ctx$addr >> 2] | 0;
  $$sink3 = HEAP32[$curr_bits >> 2] | 0;
 }
 if (HEAP32[$q >> 2] | 0) {
  HEAP32[$K >> 2] = _get_pulses(HEAP32[$q >> 2] | 0) | 0;
  $171 = HEAP32[$X$addr >> 2] | 0;
  $172 = HEAP32[$N$addr >> 2] | 0;
  $173 = HEAP32[$K >> 2] | 0;
  $174 = HEAP32[$spread >> 2] | 0;
  $175 = HEAP32[$B$addr >> 2] | 0;
  $176 = HEAP32[$ec >> 2] | 0;
  $177 = +HEAPF32[$gain$addr >> 2];
  if (HEAP32[$encode >> 2] | 0) {
   HEAP32[$cm >> 2] = _alg_quant($171, $172, $173, $174, $175, $176, $177, HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 4 >> 2] | 0, HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 44 >> 2] | 0) | 0;
   $223 = HEAP32[$cm >> 2] | 0;
   STACKTOP = sp;
   return $223 | 0;
  } else {
   HEAP32[$cm >> 2] = _alg_unquant($171, $172, $173, $174, $175, $176, $177) | 0;
   $223 = HEAP32[$cm >> 2] | 0;
   STACKTOP = sp;
   return $223 | 0;
  }
 }
 if (!(HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 4 >> 2] | 0)) {
  $223 = HEAP32[$cm >> 2] | 0;
  STACKTOP = sp;
  return $223 | 0;
 }
 HEAP32[$cm_mask >> 2] = (1 << HEAP32[$B$addr >> 2]) - 1;
 HEAP32[$fill$addr >> 2] = HEAP32[$fill$addr >> 2] & HEAP32[$cm_mask >> 2];
 if (!(HEAP32[$fill$addr >> 2] | 0)) {
  _memset(HEAP32[$X$addr >> 2] | 0, 0, HEAP32[$N$addr >> 2] << 2 | 0) | 0;
  $223 = HEAP32[$cm >> 2] | 0;
  STACKTOP = sp;
  return $223 | 0;
 }
 $cmp169 = (HEAP32[$lowband$addr >> 2] | 0) == 0;
 HEAP32[$j >> 2] = 0;
 if ($cmp169) {
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
   $call174 = _celt_lcg_rand(HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 40 >> 2] | 0) | 0;
   HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 40 >> 2] = $call174;
   HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +(HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 40 >> 2] >> 20 | 0);
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$cm >> 2] = HEAP32[$cm_mask >> 2];
 } else {
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
   $call186 = _celt_lcg_rand(HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 40 >> 2] | 0) | 0;
   HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 40 >> 2] = $call186;
   HEAPF32[$tmp >> 2] = .00390625;
   $209 = +HEAPF32[$tmp >> 2];
   HEAPF32[$tmp >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 40 >> 2] & 32768 | 0 ? $209 : -$209;
   HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$lowband$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] + +HEAPF32[$tmp >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$cm >> 2] = HEAP32[$fill$addr >> 2];
 }
 _renormalise_vector(HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, +HEAPF32[$gain$addr >> 2], HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 44 >> 2] | 0);
 $223 = HEAP32[$cm >> 2] | 0;
 STACKTOP = sp;
 return $223 | 0;
}

function _silk_nsq_del_dec_scale_states($psEncC, $NSQ, $psDelDec, $x16, $x_sc_Q10, $sLTP, $sLTP_Q15, $subfr, $nStatesDelayedDecision, $LTP_scale_Q14, $Gains_Q16, $pitchL, $signal_type, $decisionDelay) {
 $psEncC = $psEncC | 0;
 $NSQ = $NSQ | 0;
 $psDelDec = $psDelDec | 0;
 $x16 = $x16 | 0;
 $x_sc_Q10 = $x_sc_Q10 | 0;
 $sLTP = $sLTP | 0;
 $sLTP_Q15 = $sLTP_Q15 | 0;
 $subfr = $subfr | 0;
 $nStatesDelayedDecision = $nStatesDelayedDecision | 0;
 $LTP_scale_Q14 = $LTP_scale_Q14 | 0;
 $Gains_Q16 = $Gains_Q16 | 0;
 $pitchL = $pitchL | 0;
 $signal_type = $signal_type | 0;
 $decisionDelay = $decisionDelay | 0;
 var $Gains_Q16$addr = 0, $LTP_scale_Q14$addr = 0, $NSQ$addr = 0, $add122 = 0, $add128 = 0, $add149 = 0, $add15 = 0, $add155 = 0, $add167 = 0, $add173 = 0, $add191 = 0, $add198 = 0, $add22 = 0, $add220 = 0, $add227 = 0, $add249 = 0, $add256 = 0, $add271 = 0, $add278 = 0, $add52 = 0, $add83 = 0, $add90 = 0, $cond = 0, $decisionDelay$addr = 0, $gain_adj_Q16 = 0, $i = 0, $inv_gain_Q26 = 0, $inv_gain_Q31 = 0, $k = 0, $lag = 0, $mul = 0, $mul115 = 0, $mul142 = 0, $mul160 = 0, $mul183 = 0, $mul212 = 0, $mul241 = 0, $mul263 = 0, $mul30 = 0, $mul46 = 0, $mul75 = 0, $nStatesDelayedDecision$addr = 0, $pitchL$addr = 0, $psDD = 0, $psDelDec$addr = 0, $psEncC$addr = 0, $sLTP$addr = 0, $sLTP_Q15$addr = 0, $signal_type$addr = 0, $subfr$addr = 0, $x16$addr = 0, $x_sc_Q10$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $psEncC$addr = sp + 80 | 0;
 $NSQ$addr = sp + 76 | 0;
 $psDelDec$addr = sp + 72 | 0;
 $x16$addr = sp + 68 | 0;
 $x_sc_Q10$addr = sp + 64 | 0;
 $sLTP$addr = sp + 60 | 0;
 $sLTP_Q15$addr = sp + 56 | 0;
 $subfr$addr = sp + 52 | 0;
 $nStatesDelayedDecision$addr = sp + 48 | 0;
 $LTP_scale_Q14$addr = sp + 44 | 0;
 $Gains_Q16$addr = sp + 40 | 0;
 $pitchL$addr = sp + 36 | 0;
 $signal_type$addr = sp + 32 | 0;
 $decisionDelay$addr = sp + 28 | 0;
 $i = sp + 24 | 0;
 $k = sp + 20 | 0;
 $lag = sp + 16 | 0;
 $gain_adj_Q16 = sp + 12 | 0;
 $inv_gain_Q31 = sp + 8 | 0;
 $inv_gain_Q26 = sp + 4 | 0;
 $psDD = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$NSQ$addr >> 2] = $NSQ;
 HEAP32[$psDelDec$addr >> 2] = $psDelDec;
 HEAP32[$x16$addr >> 2] = $x16;
 HEAP32[$x_sc_Q10$addr >> 2] = $x_sc_Q10;
 HEAP32[$sLTP$addr >> 2] = $sLTP;
 HEAP32[$sLTP_Q15$addr >> 2] = $sLTP_Q15;
 HEAP32[$subfr$addr >> 2] = $subfr;
 HEAP32[$nStatesDelayedDecision$addr >> 2] = $nStatesDelayedDecision;
 HEAP32[$LTP_scale_Q14$addr >> 2] = $LTP_scale_Q14;
 HEAP32[$Gains_Q16$addr >> 2] = $Gains_Q16;
 HEAP32[$pitchL$addr >> 2] = $pitchL;
 HEAP32[$signal_type$addr >> 2] = $signal_type;
 HEAP32[$decisionDelay$addr >> 2] = $decisionDelay;
 HEAP32[$lag >> 2] = HEAP32[(HEAP32[$pitchL$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2];
 if ((HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2] | 0) > 1) $cond = HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2] | 0; else $cond = 1;
 HEAP32[$inv_gain_Q31 >> 2] = _silk_INVERSE32_varQ_425($cond, 47) | 0;
 HEAP32[$inv_gain_Q26 >> 2] = (HEAP32[$inv_gain_Q31 >> 2] >> 4) + 1 >> 1;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0)) break;
  $mul = Math_imul(HEAP16[(HEAP32[$x16$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] >> 16, (HEAP32[$inv_gain_Q26 >> 2] & 65535) << 16 >> 16) | 0;
  $add15 = $mul + ((Math_imul(HEAP16[(HEAP32[$x16$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] & 65535, (HEAP32[$inv_gain_Q26 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add22 = $add15 + (Math_imul(HEAP16[(HEAP32[$x16$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, (HEAP32[$inv_gain_Q26 >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[(HEAP32[$x_sc_Q10$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $add22;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L8 : do if (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4348 >> 2] | 0) {
  if (!(HEAP32[$subfr$addr >> 2] | 0)) {
   $mul30 = Math_imul(HEAP32[$inv_gain_Q31 >> 2] >> 16, (HEAP32[$LTP_scale_Q14$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$inv_gain_Q31 >> 2] = $mul30 + ((Math_imul(HEAP32[$inv_gain_Q31 >> 2] & 65535, (HEAP32[$LTP_scale_Q14$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16) << 2;
  }
  HEAP32[$i >> 2] = (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0) - (HEAP32[$lag >> 2] | 0) - 2;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0)) break L8;
   $mul46 = Math_imul(HEAP32[$inv_gain_Q31 >> 2] >> 16, HEAP16[(HEAP32[$sLTP$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
   $add52 = $mul46 + ((Math_imul(HEAP32[$inv_gain_Q31 >> 2] & 65535, HEAP16[(HEAP32[$sLTP$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) >> 16) | 0;
   HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $add52;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 if ((HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2] | 0) == (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4344 >> 2] | 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$gain_adj_Q16 >> 2] = _silk_DIV32_varQ_426(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4344 >> 2] | 0, HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2] | 0, 16) | 0;
 HEAP32[$i >> 2] = (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0) - (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0);
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0)) break;
  $mul75 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
  $add83 = $mul75 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add90 = $add83 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 2) >> 2] = $add90;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L24 : do if ((HEAP32[$signal_type$addr >> 2] | 0) == 2) if (!(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4348 >> 2] | 0)) {
  HEAP32[$i >> 2] = (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0) - (HEAP32[$lag >> 2] | 0) - 2;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0) - (HEAP32[$decisionDelay$addr >> 2] | 0) | 0)) break L24;
   $mul115 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
   $add122 = $mul115 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   $add128 = $add122 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
   HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $add128;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nStatesDelayedDecision$addr >> 2] | 0)) break;
  HEAP32[$psDD >> 2] = (HEAP32[$psDelDec$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 1300 | 0);
  $mul142 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] & 65535) << 16 >> 16) | 0;
  $add149 = $mul142 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add155 = $add149 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[(HEAP32[$psDD >> 2] | 0) + 1280 >> 2] = $add155;
  $mul160 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1284 >> 2] & 65535) << 16 >> 16) | 0;
  $add167 = $mul160 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1284 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add173 = $add167 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1284 >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[(HEAP32[$psDD >> 2] | 0) + 1284 >> 2] = $add173;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 16) break;
   $mul183 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$psDD >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
   $add191 = $mul183 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$psDD >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   $add198 = $add191 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$psDD >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
   HEAP32[(HEAP32[$psDD >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $add198;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 24) break;
   $mul212 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
   $add220 = $mul212 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   $add227 = $add220 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1184 + (HEAP32[$i >> 2] << 2) >> 2] = $add227;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 40) break;
   $mul241 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 864 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
   $add249 = $mul241 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 864 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   $add256 = $add249 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 864 + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 864 + (HEAP32[$i >> 2] << 2) >> 2] = $add256;
   $mul263 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
   $add271 = $mul263 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   $add278 = $add271 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
   HEAP32[(HEAP32[$psDD >> 2] | 0) + 1024 + (HEAP32[$i >> 2] << 2) >> 2] = $add278;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4344 >> 2] = HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2];
 STACKTOP = sp;
 return;
}

function _silk_burg_modified_FLP($A, $x, $minInvGain, $subfr_length, $nb_subfr, $D) {
 $A = $A | 0;
 $x = $x | 0;
 $minInvGain = +$minInvGain;
 $subfr_length = $subfr_length | 0;
 $nb_subfr = $nb_subfr | 0;
 $D = $D | 0;
 var $230 = 0.0, $A$addr = 0, $Af = 0, $Atmp = 0, $C0 = 0, $CAb = 0, $CAf = 0, $C_first_row = 0, $C_last_row = 0, $D$addr = 0, $add$ptr233 = 0, $add16 = 0.0, $arrayidx = 0, $arrayidx202 = 0, $arrayidx207 = 0, $arrayidx42 = 0, $arrayidx52 = 0, $arrayidx78 = 0, $arrayidx86 = 0, $call234 = 0.0, $call6 = 0.0, $conv263 = 0.0, $invGain = 0, $k = 0, $minInvGain$addr = 0, $n = 0, $nb_subfr$addr = 0, $nrg_b = 0, $nrg_f = 0, $num = 0, $rc = 0, $reached_max_gain = 0, $s = 0, $subfr_length$addr = 0, $tmp1 = 0, $tmp2 = 0, $x$addr = 0, $x_ptr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1104 | 0;
 $A$addr = sp + 1088 | 0;
 $x$addr = sp + 1084 | 0;
 $minInvGain$addr = sp + 1080 | 0;
 $subfr_length$addr = sp + 1076 | 0;
 $nb_subfr$addr = sp + 1072 | 0;
 $D$addr = sp + 1068 | 0;
 $k = sp + 1064 | 0;
 $n = sp + 1060 | 0;
 $s = sp + 1056 | 0;
 $reached_max_gain = sp + 1052 | 0;
 $C0 = sp + 1040 | 0;
 $invGain = sp + 1032 | 0;
 $num = sp + 1024 | 0;
 $nrg_f = sp + 1016 | 0;
 $nrg_b = sp + 1008 | 0;
 $rc = sp + 1e3 | 0;
 $Atmp = sp + 992 | 0;
 $tmp1 = sp + 984 | 0;
 $tmp2 = sp + 976 | 0;
 $x_ptr = sp + 1048 | 0;
 $C_first_row = sp + 784 | 0;
 $C_last_row = sp + 592 | 0;
 $CAf = sp + 392 | 0;
 $CAb = sp + 192 | 0;
 $Af = sp;
 HEAP32[$A$addr >> 2] = $A;
 HEAP32[$x$addr >> 2] = $x;
 HEAPF32[$minInvGain$addr >> 2] = $minInvGain;
 HEAP32[$subfr_length$addr >> 2] = $subfr_length;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$D$addr >> 2] = $D;
 HEAPF64[$C0 >> 3] = +_silk_energy_FLP(HEAP32[$x$addr >> 2] | 0, Math_imul(HEAP32[$nb_subfr$addr >> 2] | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0);
 _memset($C_first_row | 0, 0, 192) | 0;
 HEAP32[$s >> 2] = 0;
 while (1) {
  if ((HEAP32[$s >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  HEAP32[$x_ptr >> 2] = (HEAP32[$x$addr >> 2] | 0) + ((Math_imul(HEAP32[$s >> 2] | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2);
  HEAP32[$n >> 2] = 1;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= ((HEAP32[$D$addr >> 2] | 0) + 1 | 0)) break;
   $call6 = +_silk_inner_product_FLP(HEAP32[$x_ptr >> 2] | 0, (HEAP32[$x_ptr >> 2] | 0) + (HEAP32[$n >> 2] << 2) | 0, (HEAP32[$subfr_length$addr >> 2] | 0) - (HEAP32[$n >> 2] | 0) | 0);
   $arrayidx = $C_first_row + ((HEAP32[$n >> 2] | 0) - 1 << 3) | 0;
   HEAPF64[$arrayidx >> 3] = +HEAPF64[$arrayidx >> 3] + $call6;
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
  HEAP32[$s >> 2] = (HEAP32[$s >> 2] | 0) + 1;
 }
 _memcpy($C_last_row | 0, $C_first_row | 0, 192) | 0;
 $add16 = +HEAPF64[$C0 >> 3] + +HEAPF64[$C0 >> 3] * 9.999999747378752e-06 + 9.999999717180685e-10;
 HEAPF64[$CAf >> 3] = $add16;
 HEAPF64[$CAb >> 3] = $add16;
 HEAPF64[$invGain >> 3] = 1.0;
 HEAP32[$reached_max_gain >> 2] = 0;
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$D$addr >> 2] | 0)) break;
  HEAP32[$s >> 2] = 0;
  while (1) {
   if ((HEAP32[$s >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
   HEAP32[$x_ptr >> 2] = (HEAP32[$x$addr >> 2] | 0) + ((Math_imul(HEAP32[$s >> 2] | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2);
   HEAPF64[$tmp1 >> 3] = +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2];
   HEAPF64[$tmp2 >> 3] = +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + ((HEAP32[$subfr_length$addr >> 2] | 0) - (HEAP32[$n >> 2] | 0) - 1 << 2) >> 2];
   HEAP32[$k >> 2] = 0;
   while (1) {
    if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$n >> 2] | 0)) break;
    $arrayidx42 = $C_first_row + (HEAP32[$k >> 2] << 3) | 0;
    HEAPF64[$arrayidx42 >> 3] = +HEAPF64[$arrayidx42 >> 3] - +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1 << 2) >> 2];
    $arrayidx52 = $C_last_row + (HEAP32[$k >> 2] << 3) | 0;
    HEAPF64[$arrayidx52 >> 3] = +HEAPF64[$arrayidx52 >> 3] - +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + ((HEAP32[$subfr_length$addr >> 2] | 0) - (HEAP32[$n >> 2] | 0) - 1 << 2) >> 2] * +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + ((HEAP32[$subfr_length$addr >> 2] | 0) - (HEAP32[$n >> 2] | 0) + (HEAP32[$k >> 2] | 0) << 2) >> 2];
    HEAPF64[$Atmp >> 3] = +HEAPF64[$Af + (HEAP32[$k >> 2] << 3) >> 3];
    HEAPF64[$tmp1 >> 3] = +HEAPF64[$tmp1 >> 3] + +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1 << 2) >> 2] * +HEAPF64[$Atmp >> 3];
    HEAPF64[$tmp2 >> 3] = +HEAPF64[$tmp2 >> 3] + +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + ((HEAP32[$subfr_length$addr >> 2] | 0) - (HEAP32[$n >> 2] | 0) + (HEAP32[$k >> 2] | 0) << 2) >> 2] * +HEAPF64[$Atmp >> 3];
    HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   }
   HEAP32[$k >> 2] = 0;
   while (1) {
    if ((HEAP32[$k >> 2] | 0) > (HEAP32[$n >> 2] | 0)) break;
    $arrayidx78 = $CAf + (HEAP32[$k >> 2] << 3) | 0;
    HEAPF64[$arrayidx78 >> 3] = +HEAPF64[$arrayidx78 >> 3] - +HEAPF64[$tmp1 >> 3] * +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) << 2) >> 2];
    $arrayidx86 = $CAb + (HEAP32[$k >> 2] << 3) | 0;
    HEAPF64[$arrayidx86 >> 3] = +HEAPF64[$arrayidx86 >> 3] - +HEAPF64[$tmp2 >> 3] * +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + ((HEAP32[$subfr_length$addr >> 2] | 0) - (HEAP32[$n >> 2] | 0) + (HEAP32[$k >> 2] | 0) - 1 << 2) >> 2];
    HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   }
   HEAP32[$s >> 2] = (HEAP32[$s >> 2] | 0) + 1;
  }
  HEAPF64[$tmp1 >> 3] = +HEAPF64[$C_first_row + (HEAP32[$n >> 2] << 3) >> 3];
  HEAPF64[$tmp2 >> 3] = +HEAPF64[$C_last_row + (HEAP32[$n >> 2] << 3) >> 3];
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$n >> 2] | 0)) break;
   HEAPF64[$Atmp >> 3] = +HEAPF64[$Af + (HEAP32[$k >> 2] << 3) >> 3];
   HEAPF64[$tmp1 >> 3] = +HEAPF64[$tmp1 >> 3] + +HEAPF64[$C_last_row + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1 << 3) >> 3] * +HEAPF64[$Atmp >> 3];
   HEAPF64[$tmp2 >> 3] = +HEAPF64[$tmp2 >> 3] + +HEAPF64[$C_first_row + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1 << 3) >> 3] * +HEAPF64[$Atmp >> 3];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAPF64[$CAf + ((HEAP32[$n >> 2] | 0) + 1 << 3) >> 3] = +HEAPF64[$tmp1 >> 3];
  HEAPF64[$CAb + ((HEAP32[$n >> 2] | 0) + 1 << 3) >> 3] = +HEAPF64[$tmp2 >> 3];
  HEAPF64[$num >> 3] = +HEAPF64[$CAb + ((HEAP32[$n >> 2] | 0) + 1 << 3) >> 3];
  HEAPF64[$nrg_b >> 3] = +HEAPF64[$CAb >> 3];
  HEAPF64[$nrg_f >> 3] = +HEAPF64[$CAf >> 3];
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$n >> 2] | 0)) break;
   HEAPF64[$Atmp >> 3] = +HEAPF64[$Af + (HEAP32[$k >> 2] << 3) >> 3];
   HEAPF64[$num >> 3] = +HEAPF64[$num >> 3] + +HEAPF64[$CAb + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) << 3) >> 3] * +HEAPF64[$Atmp >> 3];
   HEAPF64[$nrg_b >> 3] = +HEAPF64[$nrg_b >> 3] + +HEAPF64[$CAb + ((HEAP32[$k >> 2] | 0) + 1 << 3) >> 3] * +HEAPF64[$Atmp >> 3];
   HEAPF64[$nrg_f >> 3] = +HEAPF64[$nrg_f >> 3] + +HEAPF64[$CAf + ((HEAP32[$k >> 2] | 0) + 1 << 3) >> 3] * +HEAPF64[$Atmp >> 3];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAPF64[$rc >> 3] = +HEAPF64[$num >> 3] * -2.0 / (+HEAPF64[$nrg_f >> 3] + +HEAPF64[$nrg_b >> 3]);
  HEAPF64[$tmp1 >> 3] = +HEAPF64[$invGain >> 3] * (1.0 - +HEAPF64[$rc >> 3] * +HEAPF64[$rc >> 3]);
  if (+HEAPF64[$tmp1 >> 3] <= +HEAPF32[$minInvGain$addr >> 2]) {
   HEAPF64[$rc >> 3] = +Math_sqrt(+(1.0 - +HEAPF32[$minInvGain$addr >> 2] / +HEAPF64[$invGain >> 3]));
   if (+HEAPF64[$num >> 3] > 0.0) HEAPF64[$rc >> 3] = -+HEAPF64[$rc >> 3];
   HEAPF64[$invGain >> 3] = +HEAPF32[$minInvGain$addr >> 2];
   HEAP32[$reached_max_gain >> 2] = 1;
  } else HEAPF64[$invGain >> 3] = +HEAPF64[$tmp1 >> 3];
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= ((HEAP32[$n >> 2] | 0) + 1 >> 1 | 0)) break;
   HEAPF64[$tmp1 >> 3] = +HEAPF64[$Af + (HEAP32[$k >> 2] << 3) >> 3];
   HEAPF64[$tmp2 >> 3] = +HEAPF64[$Af + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1 << 3) >> 3];
   HEAPF64[$Af + (HEAP32[$k >> 2] << 3) >> 3] = +HEAPF64[$tmp1 >> 3] + +HEAPF64[$rc >> 3] * +HEAPF64[$tmp2 >> 3];
   HEAPF64[$Af + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1 << 3) >> 3] = +HEAPF64[$tmp2 >> 3] + +HEAPF64[$rc >> 3] * +HEAPF64[$tmp1 >> 3];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAPF64[$Af + (HEAP32[$n >> 2] << 3) >> 3] = +HEAPF64[$rc >> 3];
  if (HEAP32[$reached_max_gain >> 2] | 0) {
   label = 33;
   break;
  }
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) > ((HEAP32[$n >> 2] | 0) + 1 | 0)) break;
   HEAPF64[$tmp1 >> 3] = +HEAPF64[$CAf + (HEAP32[$k >> 2] << 3) >> 3];
   $arrayidx202 = $CAf + (HEAP32[$k >> 2] << 3) | 0;
   HEAPF64[$arrayidx202 >> 3] = +HEAPF64[$arrayidx202 >> 3] + +HEAPF64[$rc >> 3] * +HEAPF64[$CAb + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) + 1 << 3) >> 3];
   $arrayidx207 = $CAb + ((HEAP32[$n >> 2] | 0) - (HEAP32[$k >> 2] | 0) + 1 << 3) | 0;
   HEAPF64[$arrayidx207 >> 3] = +HEAPF64[$arrayidx207 >> 3] + +HEAPF64[$rc >> 3] * +HEAPF64[$tmp1 >> 3];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 L48 : do if ((label | 0) == 33) {
  HEAP32[$k >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$D$addr >> 2] | 0)) break L48;
   HEAPF64[$Af + (HEAP32[$k >> 2] << 3) >> 3] = 0.0;
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
 } while (0);
 if (!(HEAP32[$reached_max_gain >> 2] | 0)) {
  HEAPF64[$nrg_f >> 3] = +HEAPF64[$CAf >> 3];
  HEAPF64[$tmp1 >> 3] = 1.0;
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$D$addr >> 2] | 0)) break;
   HEAPF64[$Atmp >> 3] = +HEAPF64[$Af + (HEAP32[$k >> 2] << 3) >> 3];
   HEAPF64[$nrg_f >> 3] = +HEAPF64[$nrg_f >> 3] + +HEAPF64[$CAf + ((HEAP32[$k >> 2] | 0) + 1 << 3) >> 3] * +HEAPF64[$Atmp >> 3];
   HEAPF64[$tmp1 >> 3] = +HEAPF64[$tmp1 >> 3] + +HEAPF64[$Atmp >> 3] * +HEAPF64[$Atmp >> 3];
   HEAPF32[(HEAP32[$A$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = -+HEAPF64[$Atmp >> 3];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAPF64[$nrg_f >> 3] = +HEAPF64[$nrg_f >> 3] - +HEAPF64[$C0 >> 3] * 9.999999747378752e-06 * +HEAPF64[$tmp1 >> 3];
  $230 = +HEAPF64[$nrg_f >> 3];
  $conv263 = $230;
  STACKTOP = sp;
  return +$conv263;
 }
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$D$addr >> 2] | 0)) break;
  HEAPF32[(HEAP32[$A$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = -+HEAPF64[$Af + (HEAP32[$k >> 2] << 3) >> 3];
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$s >> 2] = 0;
 while (1) {
  if ((HEAP32[$s >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  $add$ptr233 = (HEAP32[$x$addr >> 2] | 0) + ((Math_imul(HEAP32[$s >> 2] | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) | 0;
  $call234 = +_silk_energy_FLP($add$ptr233, HEAP32[$D$addr >> 2] | 0);
  HEAPF64[$C0 >> 3] = +HEAPF64[$C0 >> 3] - $call234;
  HEAP32[$s >> 2] = (HEAP32[$s >> 2] | 0) + 1;
 }
 HEAPF64[$nrg_f >> 3] = +HEAPF64[$C0 >> 3] * +HEAPF64[$invGain >> 3];
 $230 = +HEAPF64[$nrg_f >> 3];
 $conv263 = $230;
 STACKTOP = sp;
 return +$conv263;
}

function _run_prefilter($st, $in, $prefilter_mem, $CC, $N, $prefilter_tapset, $pitch, $gain, $qgain, $enabled, $nbAvailableBytes, $analysis) {
 $st = $st | 0;
 $in = $in | 0;
 $prefilter_mem = $prefilter_mem | 0;
 $CC = $CC | 0;
 $N = $N | 0;
 $prefilter_tapset = $prefilter_tapset | 0;
 $pitch = $pitch | 0;
 $gain = $gain | 0;
 $qgain = $qgain | 0;
 $enabled = $enabled | 0;
 $nbAvailableBytes = $nbAvailableBytes | 0;
 $analysis = $analysis | 0;
 var $224 = 0, $CC$addr = 0, $N$addr = 0, $add$ptr140 = 0, $add$ptr143 = 0, $add$ptr162 = 0, $add$ptr17 = 0, $add$ptr178 = 0, $add$ptr194 = 0, $add$ptr197 = 0, $add$ptr218 = 0, $analysis$addr = 0, $c = 0, $cond122 = 0, $cond136 = 0, $enabled$addr = 0, $gain$addr = 0, $gain1 = 0, $in$addr = 0, $inc = 0, $inc272 = 0, $mode = 0, $mul = 0, $mul63 = 0, $nbAvailableBytes$addr = 0, $offset = 0, $overlap = 0, $pf_on = 0, $pf_threshold = 0, $pitch$addr = 0, $pitch_index = 0, $pre = 0, $prefilter_mem$addr = 0, $prefilter_tapset$addr = 0, $qg = 0, $qgain$addr = 0, $saved_stack = 0, $saved_stack33 = 0, $shr = 0, $st$addr = 0, $vla = 0, $vla34 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $st$addr = sp + 96 | 0;
 $in$addr = sp + 92 | 0;
 $prefilter_mem$addr = sp + 88 | 0;
 $CC$addr = sp + 84 | 0;
 $N$addr = sp + 80 | 0;
 $prefilter_tapset$addr = sp + 76 | 0;
 $pitch$addr = sp + 72 | 0;
 $gain$addr = sp + 68 | 0;
 $qgain$addr = sp + 64 | 0;
 $enabled$addr = sp + 60 | 0;
 $nbAvailableBytes$addr = sp + 56 | 0;
 $analysis$addr = sp + 52 | 0;
 $c = sp + 48 | 0;
 $pre = sp + 40 | 0;
 $mode = sp + 36 | 0;
 $pitch_index = sp + 32 | 0;
 $gain1 = sp + 28 | 0;
 $pf_threshold = sp + 24 | 0;
 $pf_on = sp + 20 | 0;
 $qg = sp + 16 | 0;
 $overlap = sp + 12 | 0;
 $saved_stack = sp + 8 | 0;
 $saved_stack33 = sp + 4 | 0;
 $offset = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$prefilter_mem$addr >> 2] = $prefilter_mem;
 HEAP32[$CC$addr >> 2] = $CC;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$prefilter_tapset$addr >> 2] = $prefilter_tapset;
 HEAP32[$pitch$addr >> 2] = $pitch;
 HEAP32[$gain$addr >> 2] = $gain;
 HEAP32[$qgain$addr >> 2] = $qgain;
 HEAP32[$enabled$addr >> 2] = $enabled;
 HEAP32[$nbAvailableBytes$addr >> 2] = $nbAvailableBytes;
 HEAP32[$analysis$addr >> 2] = $analysis;
 HEAP32[$mode >> 2] = HEAP32[HEAP32[$st$addr >> 2] >> 2];
 HEAP32[$overlap >> 2] = HEAP32[(HEAP32[$mode >> 2] | 0) + 4 >> 2];
 $mul = Math_imul(HEAP32[$CC$addr >> 2] | 0, (HEAP32[$N$addr >> 2] | 0) + 1024 | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($mul << 2) | 0) + 15 & -16) | 0;
 HEAP32[$pre >> 2] = $vla;
 HEAP32[$pre + 4 >> 2] = $vla + ((HEAP32[$N$addr >> 2] | 0) + 1024 << 2);
 HEAP32[$c >> 2] = 0;
 do {
  _memcpy(HEAP32[$pre + (HEAP32[$c >> 2] << 2) >> 2] | 0, (HEAP32[$prefilter_mem$addr >> 2] | 0) + (HEAP32[$c >> 2] << 10 << 2) | 0, 4096 | 0) | 0;
  $add$ptr17 = (HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$overlap >> 2] | 0) | 0) | 0) << 2) | 0;
  _memcpy((HEAP32[$pre + (HEAP32[$c >> 2] << 2) >> 2] | 0) + 4096 | 0, $add$ptr17 + (HEAP32[$overlap >> 2] << 2) | 0, (HEAP32[$N$addr >> 2] << 2) + 0 | 0) | 0;
  $inc = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc;
 } while (($inc | 0) < (HEAP32[$CC$addr >> 2] | 0));
 if (HEAP32[$enabled$addr >> 2] | 0) {
  $shr = 1024 + (HEAP32[$N$addr >> 2] | 0) >> 1;
  HEAP32[$saved_stack33 >> 2] = _llvm_stacksave() | 0;
  $vla34 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * ($shr << 2) | 0) + 15 & -16) | 0;
  _pitch_downsample($pre, $vla34, 1024 + (HEAP32[$N$addr >> 2] | 0) | 0, HEAP32[$CC$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
  _pitch_search($vla34 + 2048 | 0, $vla34, HEAP32[$N$addr >> 2] | 0, 979, $pitch_index, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
  HEAP32[$pitch_index >> 2] = 1024 - (HEAP32[$pitch_index >> 2] | 0);
  HEAPF32[$gain1 >> 2] = +_remove_doubling($vla34, 1024, 15, HEAP32[$N$addr >> 2] | 0, $pitch_index, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] | 0, +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2], HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
  if ((HEAP32[$pitch_index >> 2] | 0) > 1022) HEAP32[$pitch_index >> 2] = 1022;
  HEAPF32[$gain1 >> 2] = +HEAPF32[$gain1 >> 2] * .699999988079071;
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] | 0) > 2) HEAPF32[$gain1 >> 2] = +HEAPF32[$gain1 >> 2] * .5;
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] | 0) > 4) HEAPF32[$gain1 >> 2] = +HEAPF32[$gain1 >> 2] * .5;
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] | 0) > 8) HEAPF32[$gain1 >> 2] = 0.0;
  _llvm_stackrestore(HEAP32[$saved_stack33 >> 2] | 0);
 } else {
  HEAPF32[$gain1 >> 2] = 0.0;
  HEAP32[$pitch_index >> 2] = 15;
 }
 if (HEAP32[HEAP32[$analysis$addr >> 2] >> 2] | 0) HEAPF32[$gain1 >> 2] = +HEAPF32[$gain1 >> 2] * +HEAPF32[(HEAP32[$analysis$addr >> 2] | 0) + 40 >> 2];
 HEAPF32[$pf_threshold >> 2] = .20000000298023224;
 $mul63 = (Math_abs((HEAP32[$pitch_index >> 2] | 0) - (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] | 0) | 0) | 0) * 10 | 0;
 if (($mul63 | 0) > (HEAP32[$pitch_index >> 2] | 0)) HEAPF32[$pf_threshold >> 2] = +HEAPF32[$pf_threshold >> 2] + .20000000298023224;
 if ((HEAP32[$nbAvailableBytes$addr >> 2] | 0) < 25) HEAPF32[$pf_threshold >> 2] = +HEAPF32[$pf_threshold >> 2] + .10000000149011612;
 if ((HEAP32[$nbAvailableBytes$addr >> 2] | 0) < 35) HEAPF32[$pf_threshold >> 2] = +HEAPF32[$pf_threshold >> 2] + .10000000149011612;
 if (+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] > .4000000059604645) HEAPF32[$pf_threshold >> 2] = +HEAPF32[$pf_threshold >> 2] - .10000000149011612;
 if (+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] > .550000011920929) HEAPF32[$pf_threshold >> 2] = +HEAPF32[$pf_threshold >> 2] - .10000000149011612;
 HEAPF32[$pf_threshold >> 2] = +HEAPF32[$pf_threshold >> 2] > .20000000298023224 ? +HEAPF32[$pf_threshold >> 2] : .20000000298023224;
 if (+HEAPF32[$gain1 >> 2] < +HEAPF32[$pf_threshold >> 2]) {
  HEAPF32[$gain1 >> 2] = 0.0;
  HEAP32[$pf_on >> 2] = 0;
  HEAP32[$qg >> 2] = 0;
 } else {
  if (+Math_abs(+(+HEAPF32[$gain1 >> 2] - +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2])) < .10000000149011612) HEAPF32[$gain1 >> 2] = +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2];
  HEAP32[$qg >> 2] = ~~+Math_floor(+(+HEAPF32[$gain1 >> 2] * 32.0 / 3.0 + .5)) - 1;
  if (0 > ((7 < (HEAP32[$qg >> 2] | 0) ? 7 : HEAP32[$qg >> 2] | 0) | 0)) $cond122 = 0; else $cond122 = 7 < (HEAP32[$qg >> 2] | 0) ? 7 : HEAP32[$qg >> 2] | 0;
  HEAP32[$qg >> 2] = $cond122;
  HEAPF32[$gain1 >> 2] = +((HEAP32[$qg >> 2] | 0) + 1 | 0) * .09375;
  HEAP32[$pf_on >> 2] = 1;
 }
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$offset >> 2] = (HEAP32[(HEAP32[$mode >> 2] | 0) + 44 >> 2] | 0) - (HEAP32[$overlap >> 2] | 0);
  if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] | 0) > 15) $cond136 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] | 0; else $cond136 = 15;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] = $cond136;
  $add$ptr140 = (HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$overlap >> 2] | 0) | 0) | 0) << 2) | 0;
  $add$ptr143 = (HEAP32[$st$addr >> 2] | 0) + 244 + ((Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$overlap >> 2] | 0) | 0) << 2) | 0;
  _memcpy($add$ptr140 | 0, $add$ptr143 | 0, (HEAP32[$overlap >> 2] << 2) + 0 | 0) | 0;
  if (HEAP32[$offset >> 2] | 0) {
   $add$ptr162 = (HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$overlap >> 2] | 0) | 0) | 0) << 2) | 0;
   _comb_filter($add$ptr162 + (HEAP32[$overlap >> 2] << 2) | 0, (HEAP32[$pre + (HEAP32[$c >> 2] << 2) >> 2] | 0) + 4096 | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] | 0, HEAP32[$offset >> 2] | 0, -+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2], -+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2], HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, 0, 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
  }
  $add$ptr178 = (HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$overlap >> 2] | 0) | 0) | 0) << 2) | 0;
  _comb_filter($add$ptr178 + (HEAP32[$overlap >> 2] << 2) + (HEAP32[$offset >> 2] << 2) | 0, (HEAP32[$pre + (HEAP32[$c >> 2] << 2) >> 2] | 0) + 4096 + (HEAP32[$offset >> 2] << 2) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 104 >> 2] | 0, HEAP32[$pitch_index >> 2] | 0, (HEAP32[$N$addr >> 2] | 0) - (HEAP32[$offset >> 2] | 0) | 0, -+HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2], -+HEAPF32[$gain1 >> 2], HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[$prefilter_tapset$addr >> 2] | 0, HEAP32[(HEAP32[$mode >> 2] | 0) + 60 >> 2] | 0, HEAP32[$overlap >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] | 0);
  $add$ptr194 = (HEAP32[$st$addr >> 2] | 0) + 244 + ((Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$overlap >> 2] | 0) | 0) << 2) | 0;
  $add$ptr197 = (HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, (HEAP32[$N$addr >> 2] | 0) + (HEAP32[$overlap >> 2] | 0) | 0) | 0) << 2) | 0;
  _memcpy($add$ptr194 | 0, $add$ptr197 + (HEAP32[$N$addr >> 2] << 2) | 0, (HEAP32[$overlap >> 2] << 2) + 0 | 0) | 0;
  $add$ptr218 = (HEAP32[$prefilter_mem$addr >> 2] | 0) + (HEAP32[$c >> 2] << 10 << 2) | 0;
  if ((HEAP32[$N$addr >> 2] | 0) > 1024) _memcpy($add$ptr218 | 0, (HEAP32[$pre + (HEAP32[$c >> 2] << 2) >> 2] | 0) + (HEAP32[$N$addr >> 2] << 2) | 0, 4096 | 0) | 0; else {
   _memmove($add$ptr218 | 0, (HEAP32[$prefilter_mem$addr >> 2] | 0) + (HEAP32[$c >> 2] << 10 << 2) + (HEAP32[$N$addr >> 2] << 2) | 0, (1024 - (HEAP32[$N$addr >> 2] | 0) << 2) + 0 | 0) | 0;
   _memcpy((HEAP32[$prefilter_mem$addr >> 2] | 0) + (HEAP32[$c >> 2] << 10 << 2) + 4096 + (0 - (HEAP32[$N$addr >> 2] | 0) << 2) | 0, (HEAP32[$pre + (HEAP32[$c >> 2] << 2) >> 2] | 0) + 4096 | 0, (HEAP32[$N$addr >> 2] << 2) + 0 | 0) | 0;
  }
  $inc272 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc272;
 } while (($inc272 | 0) < (HEAP32[$CC$addr >> 2] | 0));
 HEAPF32[HEAP32[$gain$addr >> 2] >> 2] = +HEAPF32[$gain1 >> 2];
 HEAP32[HEAP32[$pitch$addr >> 2] >> 2] = HEAP32[$pitch_index >> 2];
 HEAP32[HEAP32[$qgain$addr >> 2] >> 2] = HEAP32[$qg >> 2];
 $224 = HEAP32[$pf_on >> 2] | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return $224 | 0;
}

function _opus_packet_parse_impl($data, $len, $self_delimited, $out_toc, $frames, $size, $payload_offset, $packet_offset) {
 $data = $data | 0;
 $len = $len | 0;
 $self_delimited = $self_delimited | 0;
 $out_toc = $out_toc | 0;
 $frames = $frames | 0;
 $size = $size | 0;
 $payload_offset = $payload_offset | 0;
 $packet_offset = $packet_offset | 0;
 var $153 = 0, $31 = 0, $40 = 0, $5 = 0, $bytes = 0, $cbr = 0, $ch = 0, $count = 0, $data$addr = 0, $data0 = 0, $frames$addr = 0, $framesize = 0, $i = 0, $last_size = 0, $len$addr = 0, $mul141 = 0, $mul99 = 0, $out_toc$addr = 0, $p = 0, $packet_offset$addr = 0, $pad = 0, $payload_offset$addr = 0, $retval = 0, $self_delimited$addr = 0, $size$addr = 0, $tmp = 0, $toc = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $retval = sp + 72 | 0;
 $data$addr = sp + 68 | 0;
 $len$addr = sp + 64 | 0;
 $self_delimited$addr = sp + 60 | 0;
 $out_toc$addr = sp + 56 | 0;
 $frames$addr = sp + 52 | 0;
 $size$addr = sp + 48 | 0;
 $payload_offset$addr = sp + 44 | 0;
 $packet_offset$addr = sp + 40 | 0;
 $i = sp + 36 | 0;
 $bytes = sp + 32 | 0;
 $count = sp + 28 | 0;
 $cbr = sp + 24 | 0;
 $ch = sp + 77 | 0;
 $toc = sp + 76 | 0;
 $framesize = sp + 20 | 0;
 $last_size = sp + 16 | 0;
 $pad = sp + 12 | 0;
 $data0 = sp + 8 | 0;
 $p = sp + 4 | 0;
 $tmp = sp;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$self_delimited$addr >> 2] = $self_delimited;
 HEAP32[$out_toc$addr >> 2] = $out_toc;
 HEAP32[$frames$addr >> 2] = $frames;
 HEAP32[$size$addr >> 2] = $size;
 HEAP32[$payload_offset$addr >> 2] = $payload_offset;
 HEAP32[$packet_offset$addr >> 2] = $packet_offset;
 HEAP32[$pad >> 2] = 0;
 HEAP32[$data0 >> 2] = HEAP32[$data$addr >> 2];
 if ((HEAP32[$size$addr >> 2] | 0) == 0 | (HEAP32[$len$addr >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = -1;
  $153 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $153 | 0;
 }
 if (!(HEAP32[$len$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = -4;
  $153 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $153 | 0;
 }
 HEAP32[$framesize >> 2] = _opus_packet_get_samples_per_frame(HEAP32[$data$addr >> 2] | 0, 48e3) | 0;
 HEAP32[$cbr >> 2] = 0;
 $5 = HEAP32[$data$addr >> 2] | 0;
 HEAP32[$data$addr >> 2] = $5 + 1;
 HEAP8[$toc >> 0] = HEAP8[$5 >> 0] | 0;
 HEAP32[$len$addr >> 2] = (HEAP32[$len$addr >> 2] | 0) + -1;
 HEAP32[$last_size >> 2] = HEAP32[$len$addr >> 2];
 L9 : do switch (HEAPU8[$toc >> 0] & 3 | 0) {
 case 0:
  {
   HEAP32[$count >> 2] = 1;
   break;
  }
 case 1:
  {
   HEAP32[$count >> 2] = 2;
   HEAP32[$cbr >> 2] = 1;
   if (!(HEAP32[$self_delimited$addr >> 2] | 0)) {
    if (!(HEAP32[$len$addr >> 2] & 1)) {
     HEAP32[$last_size >> 2] = (HEAP32[$len$addr >> 2] | 0) / 2 | 0;
     HEAP16[HEAP32[$size$addr >> 2] >> 1] = HEAP32[$last_size >> 2];
     break L9;
    }
    HEAP32[$retval >> 2] = -4;
    $153 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $153 | 0;
   }
   break;
  }
 case 2:
  {
   HEAP32[$count >> 2] = 2;
   HEAP32[$bytes >> 2] = _parse_size(HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0, HEAP32[$size$addr >> 2] | 0) | 0;
   HEAP32[$len$addr >> 2] = (HEAP32[$len$addr >> 2] | 0) - (HEAP32[$bytes >> 2] | 0);
   if ((HEAP16[HEAP32[$size$addr >> 2] >> 1] | 0) >= 0) if ((HEAP16[HEAP32[$size$addr >> 2] >> 1] | 0) <= (HEAP32[$len$addr >> 2] | 0)) {
    HEAP32[$data$addr >> 2] = (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$bytes >> 2] | 0);
    HEAP32[$last_size >> 2] = (HEAP32[$len$addr >> 2] | 0) - (HEAP16[HEAP32[$size$addr >> 2] >> 1] | 0);
    break L9;
   }
   HEAP32[$retval >> 2] = -4;
   $153 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $153 | 0;
  }
 default:
  {
   if ((HEAP32[$len$addr >> 2] | 0) < 1) {
    HEAP32[$retval >> 2] = -4;
    $153 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $153 | 0;
   }
   $31 = HEAP32[$data$addr >> 2] | 0;
   HEAP32[$data$addr >> 2] = $31 + 1;
   HEAP8[$ch >> 0] = HEAP8[$31 >> 0] | 0;
   HEAP32[$count >> 2] = HEAPU8[$ch >> 0] & 63;
   if ((HEAP32[$count >> 2] | 0) > 0) if ((Math_imul(HEAP32[$framesize >> 2] | 0, HEAP32[$count >> 2] | 0) | 0) <= 5760) {
    HEAP32[$len$addr >> 2] = (HEAP32[$len$addr >> 2] | 0) + -1;
    L18 : do if (HEAPU8[$ch >> 0] & 64 | 0) {
     while (1) {
      if ((HEAP32[$len$addr >> 2] | 0) <= 0) break;
      $40 = HEAP32[$data$addr >> 2] | 0;
      HEAP32[$data$addr >> 2] = $40 + 1;
      HEAP32[$p >> 2] = HEAPU8[$40 >> 0];
      HEAP32[$len$addr >> 2] = (HEAP32[$len$addr >> 2] | 0) + -1;
      HEAP32[$tmp >> 2] = (HEAP32[$p >> 2] | 0) == 255 ? 254 : HEAP32[$p >> 2] | 0;
      HEAP32[$len$addr >> 2] = (HEAP32[$len$addr >> 2] | 0) - (HEAP32[$tmp >> 2] | 0);
      HEAP32[$pad >> 2] = (HEAP32[$pad >> 2] | 0) + (HEAP32[$tmp >> 2] | 0);
      if ((HEAP32[$p >> 2] | 0) != 255) break L18;
     }
     HEAP32[$retval >> 2] = -4;
     $153 = HEAP32[$retval >> 2] | 0;
     STACKTOP = sp;
     return $153 | 0;
    } while (0);
    if ((HEAP32[$len$addr >> 2] | 0) < 0) {
     HEAP32[$retval >> 2] = -4;
     $153 = HEAP32[$retval >> 2] | 0;
     STACKTOP = sp;
     return $153 | 0;
    }
    HEAP32[$cbr >> 2] = ((HEAPU8[$ch >> 0] & 128 | 0) != 0 ^ 1) & 1;
    if (HEAP32[$cbr >> 2] | 0) {
     if (HEAP32[$self_delimited$addr >> 2] | 0) break L9;
     HEAP32[$last_size >> 2] = (HEAP32[$len$addr >> 2] | 0) / (HEAP32[$count >> 2] | 0) | 0;
     $mul99 = Math_imul(HEAP32[$last_size >> 2] | 0, HEAP32[$count >> 2] | 0) | 0;
     if (($mul99 | 0) != (HEAP32[$len$addr >> 2] | 0)) {
      HEAP32[$retval >> 2] = -4;
      $153 = HEAP32[$retval >> 2] | 0;
      STACKTOP = sp;
      return $153 | 0;
     }
     HEAP32[$i >> 2] = 0;
     while (1) {
      if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$count >> 2] | 0) - 1 | 0)) break L9;
      HEAP16[(HEAP32[$size$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = HEAP32[$last_size >> 2];
      HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
     }
    }
    HEAP32[$last_size >> 2] = HEAP32[$len$addr >> 2];
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$count >> 2] | 0) - 1 | 0)) break;
     HEAP32[$bytes >> 2] = _parse_size(HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0, (HEAP32[$size$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) | 0) | 0;
     HEAP32[$len$addr >> 2] = (HEAP32[$len$addr >> 2] | 0) - (HEAP32[$bytes >> 2] | 0);
     if ((HEAP16[(HEAP32[$size$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) < 0) {
      label = 31;
      break;
     }
     if ((HEAP16[(HEAP32[$size$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) > (HEAP32[$len$addr >> 2] | 0)) {
      label = 31;
      break;
     }
     HEAP32[$data$addr >> 2] = (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$bytes >> 2] | 0);
     HEAP32[$last_size >> 2] = (HEAP32[$last_size >> 2] | 0) - ((HEAP32[$bytes >> 2] | 0) + (HEAP16[(HEAP32[$size$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0));
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
    if ((label | 0) == 31) {
     HEAP32[$retval >> 2] = -4;
     $153 = HEAP32[$retval >> 2] | 0;
     STACKTOP = sp;
     return $153 | 0;
    }
    if ((HEAP32[$last_size >> 2] | 0) >= 0) break L9;
    HEAP32[$retval >> 2] = -4;
    $153 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $153 | 0;
   }
   HEAP32[$retval >> 2] = -4;
   $153 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $153 | 0;
  }
 } while (0);
 L67 : do if (HEAP32[$self_delimited$addr >> 2] | 0) {
  HEAP32[$bytes >> 2] = _parse_size(HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0, (HEAP32[$size$addr >> 2] | 0) + (HEAP32[$count >> 2] << 1) + -2 | 0) | 0;
  HEAP32[$len$addr >> 2] = (HEAP32[$len$addr >> 2] | 0) - (HEAP32[$bytes >> 2] | 0);
  if ((HEAP16[(HEAP32[$size$addr >> 2] | 0) + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] | 0) >= 0) if ((HEAP16[(HEAP32[$size$addr >> 2] | 0) + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] | 0) <= (HEAP32[$len$addr >> 2] | 0)) {
   HEAP32[$data$addr >> 2] = (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$bytes >> 2] | 0);
   if (!(HEAP32[$cbr >> 2] | 0)) {
    if (((HEAP32[$bytes >> 2] | 0) + (HEAP16[(HEAP32[$size$addr >> 2] | 0) + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) <= (HEAP32[$last_size >> 2] | 0)) break;
    HEAP32[$retval >> 2] = -4;
    $153 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $153 | 0;
   }
   $mul141 = Math_imul(HEAP16[(HEAP32[$size$addr >> 2] | 0) + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] | 0, HEAP32[$count >> 2] | 0) | 0;
   if (($mul141 | 0) > (HEAP32[$len$addr >> 2] | 0)) {
    HEAP32[$retval >> 2] = -4;
    $153 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $153 | 0;
   }
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$count >> 2] | 0) - 1 | 0)) break L67;
    HEAP16[(HEAP32[$size$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = HEAP16[(HEAP32[$size$addr >> 2] | 0) + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] | 0;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  }
  HEAP32[$retval >> 2] = -4;
  $153 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $153 | 0;
 } else {
  if ((HEAP32[$last_size >> 2] | 0) <= 1275) {
   HEAP16[(HEAP32[$size$addr >> 2] | 0) + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] = HEAP32[$last_size >> 2];
   break;
  }
  HEAP32[$retval >> 2] = -4;
  $153 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $153 | 0;
 } while (0);
 if (HEAP32[$payload_offset$addr >> 2] | 0) HEAP32[HEAP32[$payload_offset$addr >> 2] >> 2] = (HEAP32[$data$addr >> 2] | 0) - (HEAP32[$data0 >> 2] | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$count >> 2] | 0)) break;
  if (HEAP32[$frames$addr >> 2] | 0) HEAP32[(HEAP32[$frames$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$data$addr >> 2];
  HEAP32[$data$addr >> 2] = (HEAP32[$data$addr >> 2] | 0) + (HEAP16[(HEAP32[$size$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if (HEAP32[$packet_offset$addr >> 2] | 0) HEAP32[HEAP32[$packet_offset$addr >> 2] >> 2] = (HEAP32[$pad >> 2] | 0) + ((HEAP32[$data$addr >> 2] | 0) - (HEAP32[$data0 >> 2] | 0));
 if (HEAP32[$out_toc$addr >> 2] | 0) HEAP8[HEAP32[$out_toc$addr >> 2] >> 0] = HEAP8[$toc >> 0] | 0;
 HEAP32[$retval >> 2] = HEAP32[$count >> 2];
 $153 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $153 | 0;
}

function _tonality_get_info($tonal, $info_out, $len) {
 $tonal = $tonal | 0;
 $info_out = $info_out | 0;
 $len = $len | 0;
 var $$sink1 = 0, $191 = 0, $29 = 0.0, $57 = 0, $cond = 0.0, $cond123 = 0.0, $cond137 = 0.0, $cond165 = 0.0, $cond173 = 0.0, $cond198 = 0, $cond218 = 0.0, $cond230 = 0.0, $cond243 = 0.0, $cond253 = 0.0, $cond52 = 0.0, $curr_lookahead = 0, $dec202 = 0, $i = 0, $inc = 0, $inc21 = 0, $inc87 = 0, $inc97 = 0, $info_out$addr = 0, $len$addr = 0, $mpos = 0, $pmax = 0, $pmin = 0, $pos = 0, $pos0 = 0, $pos_vad = 0, $prob_avg = 0, $prob_count = 0, $prob_max = 0, $prob_min = 0, $read_pos277$sink2 = 0, $read_pos284 = 0, $read_subframe275 = 0, $tonal$addr = 0, $tonality_avg = 0, $tonality_count = 0, $tonality_max = 0, $vad_prob = 0, $vpos = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $tonal$addr = sp + 76 | 0;
 $info_out$addr = sp + 72 | 0;
 $len$addr = sp + 68 | 0;
 $pos = sp + 64 | 0;
 $curr_lookahead = sp + 60 | 0;
 $tonality_max = sp + 56 | 0;
 $tonality_avg = sp + 52 | 0;
 $tonality_count = sp + 48 | 0;
 $i = sp + 44 | 0;
 $pos0 = sp + 40 | 0;
 $prob_avg = sp + 36 | 0;
 $prob_count = sp + 32 | 0;
 $prob_min = sp + 28 | 0;
 $prob_max = sp + 24 | 0;
 $vad_prob = sp + 20 | 0;
 $mpos = sp + 16 | 0;
 $vpos = sp + 12 | 0;
 $pos_vad = sp + 8 | 0;
 $pmin = sp + 4 | 0;
 $pmax = sp;
 HEAP32[$tonal$addr >> 2] = $tonal;
 HEAP32[$info_out$addr >> 2] = $info_out;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$pos >> 2] = HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7448 >> 2];
 HEAP32[$curr_lookahead >> 2] = (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7444 >> 2] | 0) - (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7448 >> 2] | 0);
 if ((HEAP32[$curr_lookahead >> 2] | 0) < 0) HEAP32[$curr_lookahead >> 2] = (HEAP32[$curr_lookahead >> 2] | 0) + 100;
 if ((HEAP32[$len$addr >> 2] | 0) > ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 8 >> 2] | 0) / 50 | 0 | 0)) if ((HEAP32[$pos >> 2] | 0) != (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7444 >> 2] | 0)) {
  $inc = (HEAP32[$pos >> 2] | 0) + 1 | 0;
  HEAP32[$pos >> 2] = $inc;
  HEAP32[$pos >> 2] = (HEAP32[$pos >> 2] | 0) == 100 ? 0 : $inc;
 }
 if ((HEAP32[$pos >> 2] | 0) == (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7444 >> 2] | 0)) HEAP32[$pos >> 2] = (HEAP32[$pos >> 2] | 0) + -1;
 if ((HEAP32[$pos >> 2] | 0) < 0) HEAP32[$pos >> 2] = 99;
 HEAP32[$pos0 >> 2] = HEAP32[$pos >> 2];
 _memcpy(HEAP32[$info_out$addr >> 2] | 0, (HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$pos >> 2] << 6) | 0, 64 | 0) | 0;
 $29 = +HEAPF32[(HEAP32[$info_out$addr >> 2] | 0) + 4 >> 2];
 HEAPF32[$tonality_avg >> 2] = $29;
 HEAPF32[$tonality_max >> 2] = $29;
 HEAP32[$tonality_count >> 2] = 1;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 3) break;
  $inc21 = (HEAP32[$pos >> 2] | 0) + 1 | 0;
  HEAP32[$pos >> 2] = $inc21;
  HEAP32[$pos >> 2] = (HEAP32[$pos >> 2] | 0) == 100 ? 0 : $inc21;
  if ((HEAP32[$pos >> 2] | 0) == (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7444 >> 2] | 0)) break;
  if (+HEAPF32[$tonality_max >> 2] > +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$pos >> 2] << 6) + 4 >> 2]) $cond = +HEAPF32[$tonality_max >> 2]; else $cond = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$pos >> 2] << 6) + 4 >> 2];
  HEAPF32[$tonality_max >> 2] = $cond;
  HEAPF32[$tonality_avg >> 2] = +HEAPF32[$tonality_avg >> 2] + +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$pos >> 2] << 6) + 4 >> 2];
  HEAP32[$tonality_count >> 2] = (HEAP32[$tonality_count >> 2] | 0) + 1;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if (+HEAPF32[$tonality_avg >> 2] / +(HEAP32[$tonality_count >> 2] | 0) > +HEAPF32[$tonality_max >> 2] - .20000000298023224) $cond52 = +HEAPF32[$tonality_avg >> 2] / +(HEAP32[$tonality_count >> 2] | 0); else $cond52 = +HEAPF32[$tonality_max >> 2] - .20000000298023224;
 HEAPF32[(HEAP32[$info_out$addr >> 2] | 0) + 4 >> 2] = $cond52;
 $57 = HEAP32[$pos0 >> 2] | 0;
 HEAP32[$vpos >> 2] = $57;
 HEAP32[$mpos >> 2] = $57;
 if ((HEAP32[$curr_lookahead >> 2] | 0) > 15) {
  HEAP32[$mpos >> 2] = (HEAP32[$mpos >> 2] | 0) + 5;
  if ((HEAP32[$mpos >> 2] | 0) >= 100) HEAP32[$mpos >> 2] = (HEAP32[$mpos >> 2] | 0) - 100;
  HEAP32[$vpos >> 2] = (HEAP32[$vpos >> 2] | 0) + 1;
  if ((HEAP32[$vpos >> 2] | 0) >= 100) HEAP32[$vpos >> 2] = (HEAP32[$vpos >> 2] | 0) - 100;
 }
 HEAPF32[$prob_min >> 2] = 1.0;
 HEAPF32[$prob_max >> 2] = 0.0;
 HEAPF32[$vad_prob >> 2] = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$vpos >> 2] << 6) + 36 >> 2];
 HEAPF32[$prob_count >> 2] = .10000000149011612 > +HEAPF32[$vad_prob >> 2] ? .10000000149011612 : +HEAPF32[$vad_prob >> 2];
 HEAPF32[$prob_avg >> 2] = (.10000000149011612 > +HEAPF32[$vad_prob >> 2] ? .10000000149011612 : +HEAPF32[$vad_prob >> 2]) * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$mpos >> 2] << 6) + 20 >> 2];
 while (1) {
  $inc87 = (HEAP32[$mpos >> 2] | 0) + 1 | 0;
  HEAP32[$mpos >> 2] = $inc87;
  HEAP32[$mpos >> 2] = (HEAP32[$mpos >> 2] | 0) == 100 ? 0 : $inc87;
  if ((HEAP32[$mpos >> 2] | 0) == (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7444 >> 2] | 0)) break;
  $inc97 = (HEAP32[$vpos >> 2] | 0) + 1 | 0;
  HEAP32[$vpos >> 2] = $inc97;
  HEAP32[$vpos >> 2] = (HEAP32[$vpos >> 2] | 0) == 100 ? 0 : $inc97;
  if ((HEAP32[$vpos >> 2] | 0) == (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7444 >> 2] | 0)) break;
  HEAPF32[$pos_vad >> 2] = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$vpos >> 2] << 6) + 36 >> 2];
  if ((+HEAPF32[$prob_avg >> 2] - (+HEAPF32[$vad_prob >> 2] - +HEAPF32[$pos_vad >> 2]) * 10.0) / +HEAPF32[$prob_count >> 2] < +HEAPF32[$prob_min >> 2]) $cond123 = (+HEAPF32[$prob_avg >> 2] - (+HEAPF32[$vad_prob >> 2] - +HEAPF32[$pos_vad >> 2]) * 10.0) / +HEAPF32[$prob_count >> 2]; else $cond123 = +HEAPF32[$prob_min >> 2];
  HEAPF32[$prob_min >> 2] = $cond123;
  if ((+HEAPF32[$prob_avg >> 2] + (+HEAPF32[$vad_prob >> 2] - +HEAPF32[$pos_vad >> 2]) * 10.0) / +HEAPF32[$prob_count >> 2] > +HEAPF32[$prob_max >> 2]) $cond137 = (+HEAPF32[$prob_avg >> 2] + (+HEAPF32[$vad_prob >> 2] - +HEAPF32[$pos_vad >> 2]) * 10.0) / +HEAPF32[$prob_count >> 2]; else $cond137 = +HEAPF32[$prob_max >> 2];
  HEAPF32[$prob_max >> 2] = $cond137;
  HEAPF32[$prob_count >> 2] = +HEAPF32[$prob_count >> 2] + (.10000000149011612 > +HEAPF32[$pos_vad >> 2] ? .10000000149011612 : +HEAPF32[$pos_vad >> 2]);
  HEAPF32[$prob_avg >> 2] = +HEAPF32[$prob_avg >> 2] + (.10000000149011612 > +HEAPF32[$pos_vad >> 2] ? .10000000149011612 : +HEAPF32[$pos_vad >> 2]) * +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$mpos >> 2] << 6) + 20 >> 2];
 }
 HEAPF32[(HEAP32[$info_out$addr >> 2] | 0) + 20 >> 2] = +HEAPF32[$prob_avg >> 2] / +HEAPF32[$prob_count >> 2];
 if (+HEAPF32[$prob_avg >> 2] / +HEAPF32[$prob_count >> 2] < +HEAPF32[$prob_min >> 2]) $cond165 = +HEAPF32[$prob_avg >> 2] / +HEAPF32[$prob_count >> 2]; else $cond165 = +HEAPF32[$prob_min >> 2];
 HEAPF32[$prob_min >> 2] = $cond165;
 if (+HEAPF32[$prob_avg >> 2] / +HEAPF32[$prob_count >> 2] > +HEAPF32[$prob_max >> 2]) $cond173 = +HEAPF32[$prob_avg >> 2] / +HEAPF32[$prob_count >> 2]; else $cond173 = +HEAPF32[$prob_max >> 2];
 HEAPF32[$prob_max >> 2] = $cond173;
 HEAPF32[$prob_min >> 2] = +HEAPF32[$prob_min >> 2] > 0.0 ? +HEAPF32[$prob_min >> 2] : 0.0;
 HEAPF32[$prob_max >> 2] = +HEAPF32[$prob_max >> 2] < 1.0 ? +HEAPF32[$prob_max >> 2] : 1.0;
 if ((HEAP32[$curr_lookahead >> 2] | 0) < 10) {
  HEAPF32[$pmin >> 2] = +HEAPF32[$prob_min >> 2];
  HEAPF32[$pmax >> 2] = +HEAPF32[$prob_max >> 2];
  HEAP32[$pos >> 2] = HEAP32[$pos0 >> 2];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if (((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) - 1 | 0) < 15) $cond198 = (HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7436 >> 2] | 0) - 1 | 0; else $cond198 = 15;
   if ((HEAP32[$i >> 2] | 0) >= ($cond198 | 0)) break;
   $dec202 = (HEAP32[$pos >> 2] | 0) + -1 | 0;
   HEAP32[$pos >> 2] = $dec202;
   HEAP32[$pos >> 2] = (HEAP32[$pos >> 2] | 0) < 0 ? 99 : $dec202;
   if (+HEAPF32[$pmin >> 2] < +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$pos >> 2] << 6) + 20 >> 2]) $cond218 = +HEAPF32[$pmin >> 2]; else $cond218 = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$pos >> 2] << 6) + 20 >> 2];
   HEAPF32[$pmin >> 2] = $cond218;
   if (+HEAPF32[$pmax >> 2] > +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$pos >> 2] << 6) + 20 >> 2]) $cond230 = +HEAPF32[$pmax >> 2]; else $cond230 = +HEAPF32[(HEAP32[$tonal$addr >> 2] | 0) + 7600 + (HEAP32[$pos >> 2] << 6) + 20 >> 2];
   HEAPF32[$pmax >> 2] = $cond230;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  if (0.0 > +HEAPF32[$pmin >> 2] - +HEAPF32[$vad_prob >> 2] * .10000000149011612) $cond243 = 0.0; else $cond243 = +HEAPF32[$pmin >> 2] - +HEAPF32[$vad_prob >> 2] * .10000000149011612;
  HEAPF32[$pmin >> 2] = $cond243;
  if (1.0 < +HEAPF32[$pmax >> 2] + +HEAPF32[$vad_prob >> 2] * .10000000149011612) $cond253 = 1.0; else $cond253 = +HEAPF32[$pmax >> 2] + +HEAPF32[$vad_prob >> 2] * .10000000149011612;
  HEAPF32[$pmax >> 2] = $cond253;
  HEAPF32[$prob_min >> 2] = +HEAPF32[$prob_min >> 2] + (1.0 - +(HEAP32[$curr_lookahead >> 2] | 0) * .10000000149011612) * (+HEAPF32[$pmin >> 2] - +HEAPF32[$prob_min >> 2]);
  HEAPF32[$prob_max >> 2] = +HEAPF32[$prob_max >> 2] + (1.0 - +(HEAP32[$curr_lookahead >> 2] | 0) * .10000000149011612) * (+HEAPF32[$pmax >> 2] - +HEAPF32[$prob_max >> 2]);
 }
 HEAPF32[(HEAP32[$info_out$addr >> 2] | 0) + 24 >> 2] = +HEAPF32[$prob_min >> 2];
 HEAPF32[(HEAP32[$info_out$addr >> 2] | 0) + 28 >> 2] = +HEAPF32[$prob_max >> 2];
 $$sink1 = (HEAP32[$len$addr >> 2] | 0) / ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 8 >> 2] | 0) / 400 | 0 | 0) | 0;
 $read_pos277$sink2 = (HEAP32[$tonal$addr >> 2] | 0) + 7452 | 0;
 while (1) {
  HEAP32[$read_pos277$sink2 >> 2] = (HEAP32[$read_pos277$sink2 >> 2] | 0) + $$sink1;
  $191 = HEAP32[$tonal$addr >> 2] | 0;
  if ((HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 7452 >> 2] | 0) < 8) break;
  $read_subframe275 = $191 + 7452 | 0;
  HEAP32[$read_subframe275 >> 2] = (HEAP32[$read_subframe275 >> 2] | 0) - 8;
  $$sink1 = 1;
  $read_pos277$sink2 = (HEAP32[$tonal$addr >> 2] | 0) + 7448 | 0;
 }
 if ((HEAP32[$191 + 7448 >> 2] | 0) < 100) {
  STACKTOP = sp;
  return;
 }
 $read_pos284 = (HEAP32[$tonal$addr >> 2] | 0) + 7448 | 0;
 HEAP32[$read_pos284 >> 2] = (HEAP32[$read_pos284 >> 2] | 0) - 100;
 STACKTOP = sp;
 return;
}

function _quant_coarse_energy($m, $start, $end, $effEnd, $eBands, $oldEBands, $budget, $error, $enc, $C, $LM, $nbAvailableBytes, $force_intra, $delayedIntra, $two_pass, $loss_rate, $lfe) {
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $effEnd = $effEnd | 0;
 $eBands = $eBands | 0;
 $oldEBands = $oldEBands | 0;
 $budget = $budget | 0;
 $error = $error | 0;
 $enc = $enc | 0;
 $C = $C | 0;
 $LM = $LM | 0;
 $nbAvailableBytes = $nbAvailableBytes | 0;
 $force_intra = $force_intra | 0;
 $delayedIntra = $delayedIntra | 0;
 $two_pass = $two_pass | 0;
 $loss_rate = $loss_rate | 0;
 $lfe = $lfe | 0;
 var $11 = 0, $135 = 0, $68 = 0, $C$addr = 0, $LM$addr = 0, $badness1 = 0, $badness2 = 0, $budget$addr = 0, $call53 = 0, $call80 = 0, $cond = 0.0, $delayedIntra$addr = 0, $eBands$addr = 0, $effEnd$addr = 0, $enc$addr = 0, $enc_intra_state = 0, $enc_start_state = 0, $end$addr = 0, $error$addr = 0, $force_intra$addr = 0, $intra = 0, $intra_bias = 0, $intra_buf = 0, $lfe$addr = 0, $loss_rate$addr = 0, $m$addr = 0, $max_decay = 0, $mul103 = 0, $mul113 = 0, $mul122 = 0, $mul33 = 0, $mul39 = 0, $mul94 = 0, $nbAvailableBytes$addr = 0, $new_distortion = 0, $nintra_bytes = 0, $nstart_bytes = 0, $oldEBands$addr = 0, $save_bytes = 0, $saved_stack = 0, $saved_stack59 = 0, $start$addr = 0, $sub54 = 0, $tell = 0, $tell_intra = 0, $two_pass$addr = 0, $vla = 0, $vla36 = 0, $vla36$alloca_mul = 0, $vla60 = 0, dest = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 $m$addr = sp + 216 | 0;
 $start$addr = sp + 212 | 0;
 $end$addr = sp + 208 | 0;
 $effEnd$addr = sp + 204 | 0;
 $eBands$addr = sp + 200 | 0;
 $oldEBands$addr = sp + 196 | 0;
 $budget$addr = sp + 192 | 0;
 $error$addr = sp + 188 | 0;
 $enc$addr = sp + 184 | 0;
 $C$addr = sp + 180 | 0;
 $LM$addr = sp + 176 | 0;
 $nbAvailableBytes$addr = sp + 172 | 0;
 $force_intra$addr = sp + 168 | 0;
 $delayedIntra$addr = sp + 164 | 0;
 $two_pass$addr = sp + 160 | 0;
 $loss_rate$addr = sp + 156 | 0;
 $lfe$addr = sp + 152 | 0;
 $intra = sp + 148 | 0;
 $max_decay = sp + 144 | 0;
 $enc_start_state = sp + 96 | 0;
 $tell = sp + 92 | 0;
 $badness1 = sp + 88 | 0;
 $intra_bias = sp + 84 | 0;
 $new_distortion = sp + 80 | 0;
 $saved_stack = sp + 76 | 0;
 $intra_buf = sp + 72 | 0;
 $enc_intra_state = sp + 24 | 0;
 $tell_intra = sp + 20 | 0;
 $nstart_bytes = sp + 16 | 0;
 $nintra_bytes = sp + 12 | 0;
 $save_bytes = sp + 8 | 0;
 $badness2 = sp + 4 | 0;
 $saved_stack59 = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$effEnd$addr >> 2] = $effEnd;
 HEAP32[$eBands$addr >> 2] = $eBands;
 HEAP32[$oldEBands$addr >> 2] = $oldEBands;
 HEAP32[$budget$addr >> 2] = $budget;
 HEAP32[$error$addr >> 2] = $error;
 HEAP32[$enc$addr >> 2] = $enc;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$nbAvailableBytes$addr >> 2] = $nbAvailableBytes;
 HEAP32[$force_intra$addr >> 2] = $force_intra;
 HEAP32[$delayedIntra$addr >> 2] = $delayedIntra;
 HEAP32[$two_pass$addr >> 2] = $two_pass;
 HEAP32[$loss_rate$addr >> 2] = $loss_rate;
 HEAP32[$lfe$addr >> 2] = $lfe;
 HEAP32[$badness1 >> 2] = 0;
 if (HEAP32[$force_intra$addr >> 2] | 0) $11 = 1; else if (HEAP32[$two_pass$addr >> 2] | 0) $11 = 0; else if (+HEAPF32[HEAP32[$delayedIntra$addr >> 2] >> 2] > +(Math_imul(HEAP32[$C$addr >> 2] << 1, (HEAP32[$end$addr >> 2] | 0) - (HEAP32[$start$addr >> 2] | 0) | 0) | 0)) $11 = (HEAP32[$nbAvailableBytes$addr >> 2] | 0) > (Math_imul((HEAP32[$end$addr >> 2] | 0) - (HEAP32[$start$addr >> 2] | 0) | 0, HEAP32[$C$addr >> 2] | 0) | 0); else $11 = 0;
 HEAP32[$intra >> 2] = $11 & 1;
 HEAP32[$intra_bias >> 2] = ~~(+((HEAP32[$budget$addr >> 2] | 0) >>> 0) * +HEAPF32[HEAP32[$delayedIntra$addr >> 2] >> 2] * +(HEAP32[$loss_rate$addr >> 2] | 0) / +(HEAP32[$C$addr >> 2] << 9 | 0));
 HEAPF32[$new_distortion >> 2] = +_loss_distortion(HEAP32[$eBands$addr >> 2] | 0, HEAP32[$oldEBands$addr >> 2] | 0, HEAP32[$start$addr >> 2] | 0, HEAP32[$effEnd$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$C$addr >> 2] | 0);
 HEAP32[$tell >> 2] = _ec_tell_123(HEAP32[$enc$addr >> 2] | 0) | 0;
 if (((HEAP32[$tell >> 2] | 0) + 3 | 0) >>> 0 > (HEAP32[$budget$addr >> 2] | 0) >>> 0) {
  HEAP32[$intra >> 2] = 0;
  HEAP32[$two_pass$addr >> 2] = 0;
 }
 HEAPF32[$max_decay >> 2] = 16.0;
 if (((HEAP32[$end$addr >> 2] | 0) - (HEAP32[$start$addr >> 2] | 0) | 0) > 10) {
  if (+HEAPF32[$max_decay >> 2] < +(HEAP32[$nbAvailableBytes$addr >> 2] | 0) * .125) $cond = +HEAPF32[$max_decay >> 2]; else $cond = +(HEAP32[$nbAvailableBytes$addr >> 2] | 0) * .125;
  HEAPF32[$max_decay >> 2] = $cond;
 }
 if (HEAP32[$lfe$addr >> 2] | 0) HEAPF32[$max_decay >> 2] = 3.0;
 dest = $enc_start_state;
 src = HEAP32[$enc$addr >> 2] | 0;
 stop = dest + 48 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 $mul33 = Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($mul33 << 2) | 0) + 15 & -16) | 0;
 $vla36$alloca_mul = (Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2;
 $vla36 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $vla36$alloca_mul | 0) + 15 & -16) | 0;
 $mul39 = (Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2;
 _memcpy($vla | 0, HEAP32[$oldEBands$addr >> 2] | 0, $mul39 + 0 | 0) | 0;
 if ((HEAP32[$two_pass$addr >> 2] | 0) != 0 | (HEAP32[$intra >> 2] | 0) != 0) HEAP32[$badness1 >> 2] = _quant_coarse_energy_impl(HEAP32[$m$addr >> 2] | 0, HEAP32[$start$addr >> 2] | 0, HEAP32[$end$addr >> 2] | 0, HEAP32[$eBands$addr >> 2] | 0, $vla, HEAP32[$budget$addr >> 2] | 0, HEAP32[$tell >> 2] | 0, 31297 + ((HEAP32[$LM$addr >> 2] | 0) * 84 | 0) + 42 | 0, $vla36, HEAP32[$enc$addr >> 2] | 0, HEAP32[$C$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, 1, +HEAPF32[$max_decay >> 2], HEAP32[$lfe$addr >> 2] | 0) | 0;
 if (HEAP32[$intra >> 2] | 0) {
  $mul113 = (Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2;
  _memcpy(HEAP32[$oldEBands$addr >> 2] | 0, $vla | 0, $mul113 + 0 | 0) | 0;
  $mul122 = (Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2;
  _memcpy(HEAP32[$error$addr >> 2] | 0, $vla36 | 0, $mul122 + 0 | 0) | 0;
 } else {
  HEAP32[$tell_intra >> 2] = _ec_tell_frac(HEAP32[$enc$addr >> 2] | 0) | 0;
  dest = $enc_intra_state;
  src = HEAP32[$enc$addr >> 2] | 0;
  stop = dest + 48 | 0;
  do {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  } while ((dest | 0) < (stop | 0));
  HEAP32[$nstart_bytes >> 2] = _ec_range_bytes($enc_start_state) | 0;
  HEAP32[$nintra_bytes >> 2] = _ec_range_bytes($enc_intra_state) | 0;
  $call53 = _ec_get_buffer($enc_intra_state) | 0;
  HEAP32[$intra_buf >> 2] = $call53 + (HEAP32[$nstart_bytes >> 2] | 0);
  $sub54 = (HEAP32[$nintra_bytes >> 2] | 0) - (HEAP32[$nstart_bytes >> 2] | 0) | 0;
  HEAP32[$save_bytes >> 2] = $sub54;
  HEAP32[$save_bytes >> 2] = (HEAP32[$save_bytes >> 2] | 0) == 0 ? 1 : $sub54;
  $68 = HEAP32[$save_bytes >> 2] | 0;
  HEAP32[$saved_stack59 >> 2] = _llvm_stacksave() | 0;
  $vla60 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * $68 | 0) + 15 & -16) | 0;
  _memcpy($vla60 | 0, HEAP32[$intra_buf >> 2] | 0, (HEAP32[$nintra_bytes >> 2] | 0) - (HEAP32[$nstart_bytes >> 2] | 0) + 0 | 0) | 0;
  dest = HEAP32[$enc$addr >> 2] | 0;
  src = $enc_start_state;
  stop = dest + 48 | 0;
  do {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  } while ((dest | 0) < (stop | 0));
  HEAP32[$badness2 >> 2] = _quant_coarse_energy_impl(HEAP32[$m$addr >> 2] | 0, HEAP32[$start$addr >> 2] | 0, HEAP32[$end$addr >> 2] | 0, HEAP32[$eBands$addr >> 2] | 0, HEAP32[$oldEBands$addr >> 2] | 0, HEAP32[$budget$addr >> 2] | 0, HEAP32[$tell >> 2] | 0, 31297 + ((HEAP32[$LM$addr >> 2] | 0) * 84 | 0) + ((HEAP32[$intra >> 2] | 0) * 42 | 0) | 0, HEAP32[$error$addr >> 2] | 0, HEAP32[$enc$addr >> 2] | 0, HEAP32[$C$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, 0, +HEAPF32[$max_decay >> 2], HEAP32[$lfe$addr >> 2] | 0) | 0;
  do if (HEAP32[$two_pass$addr >> 2] | 0) {
   if ((HEAP32[$badness1 >> 2] | 0) >= (HEAP32[$badness2 >> 2] | 0)) {
    if ((HEAP32[$badness1 >> 2] | 0) != (HEAP32[$badness2 >> 2] | 0)) break;
    $call80 = _ec_tell_frac(HEAP32[$enc$addr >> 2] | 0) | 0;
    if (($call80 + (HEAP32[$intra_bias >> 2] | 0) | 0) <= (HEAP32[$tell_intra >> 2] | 0)) break;
   }
   dest = HEAP32[$enc$addr >> 2] | 0;
   src = $enc_intra_state;
   stop = dest + 48 | 0;
   do {
    HEAP32[dest >> 2] = HEAP32[src >> 2];
    dest = dest + 4 | 0;
    src = src + 4 | 0;
   } while ((dest | 0) < (stop | 0));
   _memcpy(HEAP32[$intra_buf >> 2] | 0, $vla60 | 0, (HEAP32[$nintra_bytes >> 2] | 0) - (HEAP32[$nstart_bytes >> 2] | 0) + 0 | 0) | 0;
   $mul94 = (Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2;
   _memcpy(HEAP32[$oldEBands$addr >> 2] | 0, $vla | 0, $mul94 + 0 | 0) | 0;
   $mul103 = (Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2;
   _memcpy(HEAP32[$error$addr >> 2] | 0, $vla36 | 0, $mul103 + 0 | 0) | 0;
   HEAP32[$intra >> 2] = 1;
  } while (0);
  _llvm_stackrestore(HEAP32[$saved_stack59 >> 2] | 0);
 }
 if (HEAP32[$intra >> 2] | 0) {
  HEAPF32[HEAP32[$delayedIntra$addr >> 2] >> 2] = +HEAPF32[$new_distortion >> 2];
  $135 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($135 | 0);
  STACKTOP = sp;
  return;
 } else {
  HEAPF32[HEAP32[$delayedIntra$addr >> 2] >> 2] = +HEAPF32[15e3 + (HEAP32[$LM$addr >> 2] << 2) >> 2] * +HEAPF32[15e3 + (HEAP32[$LM$addr >> 2] << 2) >> 2] * +HEAPF32[HEAP32[$delayedIntra$addr >> 2] >> 2] + +HEAPF32[$new_distortion >> 2];
  $135 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($135 | 0);
  STACKTOP = sp;
  return;
 }
}

function _quant_band_stereo($ctx, $X, $Y, $N, $b, $B, $lowband, $LM, $lowband_out, $lowband_scratch, $fill) {
 $ctx = $ctx | 0;
 $X = $X | 0;
 $Y = $Y | 0;
 $N = $N | 0;
 $b = $b | 0;
 $B = $B | 0;
 $lowband = $lowband | 0;
 $LM = $LM | 0;
 $lowband_out = $lowband_out | 0;
 $lowband_scratch = $lowband_scratch | 0;
 $fill = $fill | 0;
 var $116 = 0, $121 = 0, $132 = 0, $206 = 0, $B$addr = 0, $LM$addr = 0, $N$addr = 0, $X$addr = 0, $Y$addr = 0, $b$addr = 0, $c = 0, $call130 = 0, $call146 = 0, $cm = 0, $cond109 = 0, $cond93 = 0, $ctx$addr = 0, $delta = 0, $ec = 0, $encode = 0, $fill$addr = 0, $imid = 0, $inv = 0, $iside = 0, $itheta = 0, $j = 0, $lowband$addr = 0, $lowband_out$addr = 0, $lowband_scratch$addr = 0, $mbits = 0, $mid = 0, $orig_fill = 0, $qalloc = 0, $rebalance = 0, $remaining_bits = 0, $remaining_bits111 = 0, $retval = 0, $sbits = 0, $sctx = 0, $side = 0, $sign = 0, $tmp = 0, $x2 = 0, $y2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 $retval = sp + 152 | 0;
 $ctx$addr = sp + 148 | 0;
 $X$addr = sp + 144 | 0;
 $Y$addr = sp + 140 | 0;
 $N$addr = sp + 136 | 0;
 $b$addr = sp + 132 | 0;
 $B$addr = sp + 128 | 0;
 $lowband$addr = sp + 124 | 0;
 $LM$addr = sp + 120 | 0;
 $lowband_out$addr = sp + 116 | 0;
 $lowband_scratch$addr = sp + 112 | 0;
 $fill$addr = sp + 108 | 0;
 $imid = sp + 104 | 0;
 $iside = sp + 100 | 0;
 $inv = sp + 96 | 0;
 $mid = sp + 92 | 0;
 $side = sp + 88 | 0;
 $cm = sp + 84 | 0;
 $mbits = sp + 80 | 0;
 $sbits = sp + 76 | 0;
 $delta = sp + 72 | 0;
 $itheta = sp + 68 | 0;
 $qalloc = sp + 64 | 0;
 $sctx = sp + 40 | 0;
 $orig_fill = sp + 36 | 0;
 $encode = sp + 32 | 0;
 $ec = sp + 28 | 0;
 $c = sp + 24 | 0;
 $sign = sp + 20 | 0;
 $x2 = sp + 16 | 0;
 $y2 = sp + 12 | 0;
 $tmp = sp + 8 | 0;
 $rebalance = sp + 4 | 0;
 $j = sp;
 HEAP32[$ctx$addr >> 2] = $ctx;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$Y$addr >> 2] = $Y;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$b$addr >> 2] = $b;
 HEAP32[$B$addr >> 2] = $B;
 HEAP32[$lowband$addr >> 2] = $lowband;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$lowband_out$addr >> 2] = $lowband_out;
 HEAP32[$lowband_scratch$addr >> 2] = $lowband_scratch;
 HEAP32[$fill$addr >> 2] = $fill;
 HEAP32[$imid >> 2] = 0;
 HEAP32[$iside >> 2] = 0;
 HEAP32[$inv >> 2] = 0;
 HEAPF32[$mid >> 2] = 0.0;
 HEAPF32[$side >> 2] = 0.0;
 HEAP32[$cm >> 2] = 0;
 HEAP32[$encode >> 2] = HEAP32[HEAP32[$ctx$addr >> 2] >> 2];
 HEAP32[$ec >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 28 >> 2];
 if ((HEAP32[$N$addr >> 2] | 0) == 1) {
  HEAP32[$retval >> 2] = _quant_band_n1(HEAP32[$ctx$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, HEAP32[$b$addr >> 2] | 0, HEAP32[$lowband_out$addr >> 2] | 0) | 0;
  $206 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $206 | 0;
 }
 HEAP32[$orig_fill >> 2] = HEAP32[$fill$addr >> 2];
 _compute_theta(HEAP32[$ctx$addr >> 2] | 0, $sctx, HEAP32[$X$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, $b$addr, HEAP32[$B$addr >> 2] | 0, HEAP32[$B$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, 1, $fill$addr);
 HEAP32[$inv >> 2] = HEAP32[$sctx >> 2];
 HEAP32[$imid >> 2] = HEAP32[$sctx + 4 >> 2];
 HEAP32[$iside >> 2] = HEAP32[$sctx + 8 >> 2];
 HEAP32[$delta >> 2] = HEAP32[$sctx + 12 >> 2];
 HEAP32[$itheta >> 2] = HEAP32[$sctx + 16 >> 2];
 HEAP32[$qalloc >> 2] = HEAP32[$sctx + 20 >> 2];
 HEAPF32[$mid >> 2] = +(HEAP32[$imid >> 2] | 0) * .000030517578125;
 HEAPF32[$side >> 2] = +(HEAP32[$iside >> 2] | 0) * .000030517578125;
 do if ((HEAP32[$N$addr >> 2] | 0) == 2) {
  HEAP32[$sign >> 2] = 0;
  HEAP32[$mbits >> 2] = HEAP32[$b$addr >> 2];
  HEAP32[$sbits >> 2] = 0;
  HEAP32[$sbits >> 2] = (HEAP32[$itheta >> 2] | 0) != 0 & (HEAP32[$itheta >> 2] | 0) != 16384 ? 8 : 0;
  HEAP32[$mbits >> 2] = (HEAP32[$mbits >> 2] | 0) - (HEAP32[$sbits >> 2] | 0);
  HEAP32[$c >> 2] = (HEAP32[$itheta >> 2] | 0) > 8192 & 1;
  $remaining_bits = (HEAP32[$ctx$addr >> 2] | 0) + 32 | 0;
  HEAP32[$remaining_bits >> 2] = (HEAP32[$remaining_bits >> 2] | 0) - ((HEAP32[$qalloc >> 2] | 0) + (HEAP32[$sbits >> 2] | 0));
  HEAP32[$x2 >> 2] = HEAP32[$c >> 2] | 0 ? HEAP32[$Y$addr >> 2] | 0 : HEAP32[$X$addr >> 2] | 0;
  HEAP32[$y2 >> 2] = HEAP32[$c >> 2] | 0 ? HEAP32[$X$addr >> 2] | 0 : HEAP32[$Y$addr >> 2] | 0;
  do if (HEAP32[$sbits >> 2] | 0) if (HEAP32[$encode >> 2] | 0) {
   HEAP32[$sign >> 2] = +HEAPF32[HEAP32[$x2 >> 2] >> 2] * +HEAPF32[(HEAP32[$y2 >> 2] | 0) + 4 >> 2] - +HEAPF32[(HEAP32[$x2 >> 2] | 0) + 4 >> 2] * +HEAPF32[HEAP32[$y2 >> 2] >> 2] < 0.0 & 1;
   _ec_enc_bits(HEAP32[$ec >> 2] | 0, HEAP32[$sign >> 2] | 0, 1);
   break;
  } else {
   HEAP32[$sign >> 2] = _ec_dec_bits(HEAP32[$ec >> 2] | 0, 1) | 0;
   break;
  } while (0);
  HEAP32[$sign >> 2] = 1 - (HEAP32[$sign >> 2] << 1);
  HEAP32[$cm >> 2] = _quant_band(HEAP32[$ctx$addr >> 2] | 0, HEAP32[$x2 >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$mbits >> 2] | 0, HEAP32[$B$addr >> 2] | 0, HEAP32[$lowband$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, HEAP32[$lowband_out$addr >> 2] | 0, 1.0, HEAP32[$lowband_scratch$addr >> 2] | 0, HEAP32[$orig_fill >> 2] | 0) | 0;
  HEAPF32[HEAP32[$y2 >> 2] >> 2] = +(0 - (HEAP32[$sign >> 2] | 0) | 0) * +HEAPF32[(HEAP32[$x2 >> 2] | 0) + 4 >> 2];
  HEAPF32[(HEAP32[$y2 >> 2] | 0) + 4 >> 2] = +(HEAP32[$sign >> 2] | 0) * +HEAPF32[HEAP32[$x2 >> 2] >> 2];
  if (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 4 >> 2] | 0) {
   HEAPF32[HEAP32[$X$addr >> 2] >> 2] = +HEAPF32[$mid >> 2] * +HEAPF32[HEAP32[$X$addr >> 2] >> 2];
   HEAPF32[(HEAP32[$X$addr >> 2] | 0) + 4 >> 2] = +HEAPF32[$mid >> 2] * +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + 4 >> 2];
   HEAPF32[HEAP32[$Y$addr >> 2] >> 2] = +HEAPF32[$side >> 2] * +HEAPF32[HEAP32[$Y$addr >> 2] >> 2];
   HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + 4 >> 2] = +HEAPF32[$side >> 2] * +HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + 4 >> 2];
   HEAPF32[$tmp >> 2] = +HEAPF32[HEAP32[$X$addr >> 2] >> 2];
   HEAPF32[HEAP32[$X$addr >> 2] >> 2] = +HEAPF32[$tmp >> 2] - +HEAPF32[HEAP32[$Y$addr >> 2] >> 2];
   HEAPF32[HEAP32[$Y$addr >> 2] >> 2] = +HEAPF32[$tmp >> 2] + +HEAPF32[HEAP32[$Y$addr >> 2] >> 2];
   HEAPF32[$tmp >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + 4 >> 2];
   HEAPF32[(HEAP32[$X$addr >> 2] | 0) + 4 >> 2] = +HEAPF32[$tmp >> 2] - +HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + 4 >> 2];
   HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + 4 >> 2] = +HEAPF32[$tmp >> 2] + +HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + 4 >> 2];
  }
 } else {
  $116 = HEAP32[$b$addr >> 2] | 0;
  if ((HEAP32[$b$addr >> 2] | 0) < (((HEAP32[$b$addr >> 2] | 0) - (HEAP32[$delta >> 2] | 0) | 0) / 2 | 0 | 0)) $cond93 = $116; else $cond93 = ($116 - (HEAP32[$delta >> 2] | 0) | 0) / 2 | 0;
  if (0 > ($cond93 | 0)) $cond109 = 0; else {
   $121 = HEAP32[$b$addr >> 2] | 0;
   if ((HEAP32[$b$addr >> 2] | 0) < (((HEAP32[$b$addr >> 2] | 0) - (HEAP32[$delta >> 2] | 0) | 0) / 2 | 0 | 0)) $cond109 = $121; else $cond109 = ($121 - (HEAP32[$delta >> 2] | 0) | 0) / 2 | 0;
  }
  HEAP32[$mbits >> 2] = $cond109;
  HEAP32[$sbits >> 2] = (HEAP32[$b$addr >> 2] | 0) - (HEAP32[$mbits >> 2] | 0);
  $remaining_bits111 = (HEAP32[$ctx$addr >> 2] | 0) + 32 | 0;
  HEAP32[$remaining_bits111 >> 2] = (HEAP32[$remaining_bits111 >> 2] | 0) - (HEAP32[$qalloc >> 2] | 0);
  HEAP32[$rebalance >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 32 >> 2];
  $132 = HEAP32[$ctx$addr >> 2] | 0;
  if ((HEAP32[$mbits >> 2] | 0) >= (HEAP32[$sbits >> 2] | 0)) {
   HEAP32[$cm >> 2] = _quant_band($132, HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$mbits >> 2] | 0, HEAP32[$B$addr >> 2] | 0, HEAP32[$lowband$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, HEAP32[$lowband_out$addr >> 2] | 0, 1.0, HEAP32[$lowband_scratch$addr >> 2] | 0, HEAP32[$fill$addr >> 2] | 0) | 0;
   HEAP32[$rebalance >> 2] = (HEAP32[$mbits >> 2] | 0) - ((HEAP32[$rebalance >> 2] | 0) - (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 32 >> 2] | 0));
   if ((HEAP32[$rebalance >> 2] | 0) > 24 & (HEAP32[$itheta >> 2] | 0) != 0) HEAP32[$sbits >> 2] = (HEAP32[$sbits >> 2] | 0) + ((HEAP32[$rebalance >> 2] | 0) - 24);
   $call130 = _quant_band(HEAP32[$ctx$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$sbits >> 2] | 0, HEAP32[$B$addr >> 2] | 0, 0, HEAP32[$LM$addr >> 2] | 0, 0, +HEAPF32[$side >> 2], 0, HEAP32[$fill$addr >> 2] >> HEAP32[$B$addr >> 2]) | 0;
   HEAP32[$cm >> 2] = HEAP32[$cm >> 2] | $call130;
   break;
  } else {
   HEAP32[$cm >> 2] = _quant_band($132, HEAP32[$Y$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$sbits >> 2] | 0, HEAP32[$B$addr >> 2] | 0, 0, HEAP32[$LM$addr >> 2] | 0, 0, +HEAPF32[$side >> 2], 0, HEAP32[$fill$addr >> 2] >> HEAP32[$B$addr >> 2]) | 0;
   HEAP32[$rebalance >> 2] = (HEAP32[$sbits >> 2] | 0) - ((HEAP32[$rebalance >> 2] | 0) - (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 32 >> 2] | 0));
   if ((HEAP32[$rebalance >> 2] | 0) > 24 & (HEAP32[$itheta >> 2] | 0) != 16384) HEAP32[$mbits >> 2] = (HEAP32[$mbits >> 2] | 0) + ((HEAP32[$rebalance >> 2] | 0) - 24);
   $call146 = _quant_band(HEAP32[$ctx$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$mbits >> 2] | 0, HEAP32[$B$addr >> 2] | 0, HEAP32[$lowband$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, HEAP32[$lowband_out$addr >> 2] | 0, 1.0, HEAP32[$lowband_scratch$addr >> 2] | 0, HEAP32[$fill$addr >> 2] | 0) | 0;
   HEAP32[$cm >> 2] = HEAP32[$cm >> 2] | $call146;
   break;
  }
 } while (0);
 L32 : do if (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 4 >> 2] | 0) {
  if ((HEAP32[$N$addr >> 2] | 0) != 2) _stereo_merge(HEAP32[$X$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, +HEAPF32[$mid >> 2], HEAP32[$N$addr >> 2] | 0, HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 44 >> 2] | 0);
  if (HEAP32[$inv >> 2] | 0) {
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break L32;
    HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = -+HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
  }
 } while (0);
 HEAP32[$retval >> 2] = HEAP32[$cm >> 2];
 $206 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $206 | 0;
}

function _compute_vbr($mode, $analysis, $base_target, $LM, $bitrate, $lastCodedBands, $C, $intensity, $constrained_vbr, $stereo_saving, $tot_boost, $tf_estimate, $pitch_change, $maxDepth, $lfe, $has_surround_mask, $surround_masking, $temporal_vbr) {
 $mode = $mode | 0;
 $analysis = $analysis | 0;
 $base_target = $base_target | 0;
 $LM = $LM | 0;
 $bitrate = $bitrate | 0;
 $lastCodedBands = $lastCodedBands | 0;
 $C = $C | 0;
 $intensity = $intensity | 0;
 $constrained_vbr = $constrained_vbr | 0;
 $stereo_saving = +$stereo_saving;
 $tot_boost = $tot_boost | 0;
 $tf_estimate = +$tf_estimate;
 $pitch_change = $pitch_change | 0;
 $maxDepth = +$maxDepth;
 $lfe = $lfe | 0;
 $has_surround_mask = $has_surround_mask | 0;
 $surround_masking = +$surround_masking;
 $temporal_vbr = +$temporal_vbr;
 var $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $C$addr = 0, $LM$addr = 0, $amount = 0, $analysis$addr = 0, $base_target$addr = 0, $bins = 0, $bitrate$addr = 0, $cmp192 = 0, $coded_bands = 0, $coded_bins = 0, $coded_stereo_bands = 0, $coded_stereo_dof = 0, $cond121 = 0, $cond182 = 0, $cond198 = 0, $cond88 = 0.0, $constrained_vbr$addr = 0, $conv129 = 0.0, $eBands = 0, $floor_depth = 0, $has_surround_mask$addr = 0, $intensity$addr = 0, $lastCodedBands$addr = 0, $lfe$addr = 0, $maxDepth$addr = 0, $max_frac = 0, $mode$addr = 0, $mul191 = 0, $mul195 = 0, $nbEBands = 0, $pitch_change$addr = 0, $shl59$sink = 0, $stereo_saving$addr = 0, $sub58$sink = 0.0, $surround_masking$addr = 0, $surround_target = 0, $target = 0, $temporal_vbr$addr = 0, $tf_calibration = 0, $tf_estimate$addr = 0, $tonal = 0, $tonal_target = 0, $tot_boost$addr = 0, $tvbr_factor = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $mode$addr = sp + 132 | 0;
 $analysis$addr = sp + 128 | 0;
 $base_target$addr = sp + 124 | 0;
 $LM$addr = sp + 120 | 0;
 $bitrate$addr = sp + 116 | 0;
 $lastCodedBands$addr = sp + 112 | 0;
 $C$addr = sp + 108 | 0;
 $intensity$addr = sp + 104 | 0;
 $constrained_vbr$addr = sp + 100 | 0;
 $stereo_saving$addr = sp + 96 | 0;
 $tot_boost$addr = sp + 92 | 0;
 $tf_estimate$addr = sp + 88 | 0;
 $pitch_change$addr = sp + 84 | 0;
 $maxDepth$addr = sp + 80 | 0;
 $lfe$addr = sp + 76 | 0;
 $has_surround_mask$addr = sp + 72 | 0;
 $surround_masking$addr = sp + 68 | 0;
 $temporal_vbr$addr = sp + 64 | 0;
 $target = sp + 60 | 0;
 $coded_bins = sp + 56 | 0;
 $coded_bands = sp + 52 | 0;
 $tf_calibration = sp + 48 | 0;
 $nbEBands = sp + 44 | 0;
 $eBands = sp + 40 | 0;
 $coded_stereo_bands = sp + 36 | 0;
 $coded_stereo_dof = sp + 32 | 0;
 $max_frac = sp + 28 | 0;
 $tonal_target = sp + 24 | 0;
 $tonal = sp + 20 | 0;
 $surround_target = sp + 16 | 0;
 $floor_depth = sp + 12 | 0;
 $bins = sp + 8 | 0;
 $amount = sp + 4 | 0;
 $tvbr_factor = sp;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$analysis$addr >> 2] = $analysis;
 HEAP32[$base_target$addr >> 2] = $base_target;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$bitrate$addr >> 2] = $bitrate;
 HEAP32[$lastCodedBands$addr >> 2] = $lastCodedBands;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$intensity$addr >> 2] = $intensity;
 HEAP32[$constrained_vbr$addr >> 2] = $constrained_vbr;
 HEAPF32[$stereo_saving$addr >> 2] = $stereo_saving;
 HEAP32[$tot_boost$addr >> 2] = $tot_boost;
 HEAPF32[$tf_estimate$addr >> 2] = $tf_estimate;
 HEAP32[$pitch_change$addr >> 2] = $pitch_change;
 HEAPF32[$maxDepth$addr >> 2] = $maxDepth;
 HEAP32[$lfe$addr >> 2] = $lfe;
 HEAP32[$has_surround_mask$addr >> 2] = $has_surround_mask;
 HEAPF32[$surround_masking$addr >> 2] = $surround_masking;
 HEAPF32[$temporal_vbr$addr >> 2] = $temporal_vbr;
 HEAP32[$nbEBands >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 8 >> 2];
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$coded_bands >> 2] = HEAP32[$lastCodedBands$addr >> 2] | 0 ? HEAP32[$lastCodedBands$addr >> 2] | 0 : HEAP32[$nbEBands >> 2] | 0;
 HEAP32[$coded_bins >> 2] = HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$coded_bands >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2];
 if ((HEAP32[$C$addr >> 2] | 0) == 2) HEAP32[$coded_bins >> 2] = (HEAP32[$coded_bins >> 2] | 0) + (HEAP16[(HEAP32[$eBands >> 2] | 0) + (((HEAP32[$intensity$addr >> 2] | 0) < (HEAP32[$coded_bands >> 2] | 0) ? HEAP32[$intensity$addr >> 2] | 0 : HEAP32[$coded_bands >> 2] | 0) << 1) >> 1] << HEAP32[$LM$addr >> 2]);
 HEAP32[$target >> 2] = HEAP32[$base_target$addr >> 2];
 if (HEAP32[HEAP32[$analysis$addr >> 2] >> 2] | 0) if (+HEAPF32[(HEAP32[$analysis$addr >> 2] | 0) + 16 >> 2] < .4) HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) - ~~(+(HEAP32[$coded_bins >> 2] << 3 | 0) * (.4000000059604645 - +HEAPF32[(HEAP32[$analysis$addr >> 2] | 0) + 16 >> 2]));
 if ((HEAP32[$C$addr >> 2] | 0) == 2) {
  HEAP32[$coded_stereo_bands >> 2] = (HEAP32[$intensity$addr >> 2] | 0) < (HEAP32[$coded_bands >> 2] | 0) ? HEAP32[$intensity$addr >> 2] | 0 : HEAP32[$coded_bands >> 2] | 0;
  HEAP32[$coded_stereo_dof >> 2] = (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$coded_stereo_bands >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2]) - (HEAP32[$coded_stereo_bands >> 2] | 0);
  HEAPF32[$max_frac >> 2] = +(HEAP32[$coded_stereo_dof >> 2] | 0) * .800000011920929 / +(HEAP32[$coded_bins >> 2] | 0);
  HEAPF32[$stereo_saving$addr >> 2] = +HEAPF32[$stereo_saving$addr >> 2] < 1.0 ? +HEAPF32[$stereo_saving$addr >> 2] : 1.0;
  if (+HEAPF32[$max_frac >> 2] * +(HEAP32[$target >> 2] | 0) < (+HEAPF32[$stereo_saving$addr >> 2] - .10000000149011612) * +(HEAP32[$coded_stereo_dof >> 2] << 3 | 0)) {
   $shl59$sink = HEAP32[$target >> 2] | 0;
   $sub58$sink = +HEAPF32[$max_frac >> 2];
  } else {
   $shl59$sink = HEAP32[$coded_stereo_dof >> 2] << 3;
   $sub58$sink = +HEAPF32[$stereo_saving$addr >> 2] - .10000000149011612;
  }
  HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) - ~~($sub58$sink * +($shl59$sink | 0));
 }
 HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) + ((HEAP32[$tot_boost$addr >> 2] | 0) - (19 << HEAP32[$LM$addr >> 2]));
 HEAPF32[$tf_calibration >> 2] = .04399999976158142;
 HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) + ~~((+HEAPF32[$tf_estimate$addr >> 2] - +HEAPF32[$tf_calibration >> 2]) * +(HEAP32[$target >> 2] | 0));
 if (!(HEAP32[$lfe$addr >> 2] | 0 ? 1 : (HEAP32[HEAP32[$analysis$addr >> 2] >> 2] | 0) == 0)) {
  if (0.0 > +HEAPF32[(HEAP32[$analysis$addr >> 2] | 0) + 4 >> 2] - .15000000596046448) $cond88 = 0.0; else $cond88 = +HEAPF32[(HEAP32[$analysis$addr >> 2] | 0) + 4 >> 2] - .15000000596046448;
  HEAPF32[$tonal >> 2] = $cond88 - .11999999731779099;
  HEAP32[$tonal_target >> 2] = (HEAP32[$target >> 2] | 0) + ~~(+(HEAP32[$coded_bins >> 2] << 3 | 0) * 1.2000000476837158 * +HEAPF32[$tonal >> 2]);
  if (HEAP32[$pitch_change$addr >> 2] | 0) HEAP32[$tonal_target >> 2] = (HEAP32[$tonal_target >> 2] | 0) + ~~(+(HEAP32[$coded_bins >> 2] << 3 | 0) * .800000011920929);
  HEAP32[$target >> 2] = HEAP32[$tonal_target >> 2];
 }
 if (!((HEAP32[$has_surround_mask$addr >> 2] | 0) == 0 | (HEAP32[$lfe$addr >> 2] | 0) != 0)) {
  HEAP32[$surround_target >> 2] = (HEAP32[$target >> 2] | 0) + ~~(+HEAPF32[$surround_masking$addr >> 2] * +(HEAP32[$coded_bins >> 2] << 3 | 0));
  if (((HEAP32[$target >> 2] | 0) / 4 | 0 | 0) > (HEAP32[$surround_target >> 2] | 0)) $cond121 = (HEAP32[$target >> 2] | 0) / 4 | 0; else $cond121 = HEAP32[$surround_target >> 2] | 0;
  HEAP32[$target >> 2] = $cond121;
 }
 HEAP32[$bins >> 2] = HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$nbEBands >> 2] | 0) - 2 << 1) >> 1] << HEAP32[$LM$addr >> 2];
 $conv129 = +((Math_imul(HEAP32[$C$addr >> 2] | 0, HEAP32[$bins >> 2] | 0) | 0) << 3 | 0);
 HEAP32[$floor_depth >> 2] = ~~($conv129 * +HEAPF32[$maxDepth$addr >> 2]);
 HEAP32[$floor_depth >> 2] = (HEAP32[$floor_depth >> 2] | 0) > (HEAP32[$target >> 2] >> 2 | 0) ? HEAP32[$floor_depth >> 2] | 0 : HEAP32[$target >> 2] >> 2;
 HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) < (HEAP32[$floor_depth >> 2] | 0) ? HEAP32[$target >> 2] | 0 : HEAP32[$floor_depth >> 2] | 0;
 if (((HEAP32[$has_surround_mask$addr >> 2] | 0) == 0 | (HEAP32[$lfe$addr >> 2] | 0) != 0) & (HEAP32[$constrained_vbr$addr >> 2] | 0) != 0) HEAP32[$target >> 2] = (HEAP32[$base_target$addr >> 2] | 0) + ~~(+((HEAP32[$target >> 2] | 0) - (HEAP32[$base_target$addr >> 2] | 0) | 0) * .6700000166893005);
 if (!((HEAP32[$has_surround_mask$addr >> 2] | 0) == 0 & +HEAPF32[$tf_estimate$addr >> 2] < .20000000298023224)) {
  $114 = HEAP32[$base_target$addr >> 2] | 0;
  $mul191 = $114 << 1;
  $115 = HEAP32[$target >> 2] | 0;
  $cmp192 = ($mul191 | 0) < ($115 | 0);
  $116 = HEAP32[$base_target$addr >> 2] | 0;
  $mul195 = $116 << 1;
  $117 = HEAP32[$target >> 2] | 0;
  $cond198 = $cmp192 ? $mul195 : $117;
  HEAP32[$target >> 2] = $cond198;
  $118 = HEAP32[$target >> 2] | 0;
  STACKTOP = sp;
  return $118 | 0;
 }
 if (0 > ((32e3 < (96e3 - (HEAP32[$bitrate$addr >> 2] | 0) | 0) ? 32e3 : 96e3 - (HEAP32[$bitrate$addr >> 2] | 0) | 0) | 0)) $cond182 = 0; else $cond182 = 32e3 < (96e3 - (HEAP32[$bitrate$addr >> 2] | 0) | 0) ? 32e3 : 96e3 - (HEAP32[$bitrate$addr >> 2] | 0) | 0;
 HEAPF32[$amount >> 2] = +($cond182 | 0) * 3.099999958067201e-06;
 HEAPF32[$tvbr_factor >> 2] = +HEAPF32[$temporal_vbr$addr >> 2] * +HEAPF32[$amount >> 2];
 HEAP32[$target >> 2] = (HEAP32[$target >> 2] | 0) + ~~(+HEAPF32[$tvbr_factor >> 2] * +(HEAP32[$target >> 2] | 0));
 $114 = HEAP32[$base_target$addr >> 2] | 0;
 $mul191 = $114 << 1;
 $115 = HEAP32[$target >> 2] | 0;
 $cmp192 = ($mul191 | 0) < ($115 | 0);
 $116 = HEAP32[$base_target$addr >> 2] | 0;
 $mul195 = $116 << 1;
 $117 = HEAP32[$target >> 2] | 0;
 $cond198 = $cmp192 ? $mul195 : $117;
 HEAP32[$target >> 2] = $cond198;
 $118 = HEAP32[$target >> 2] | 0;
 STACKTOP = sp;
 return $118 | 0;
}

function _opus_repacketizer_out_range_impl($rp, $begin, $end, $data, $maxlen, $self_delimited, $pad) {
 $rp = $rp | 0;
 $begin = $begin | 0;
 $end = $end | 0;
 $data = $data | 0;
 $maxlen = $maxlen | 0;
 $self_delimited = $self_delimited | 0;
 $pad = $pad | 0;
 var $100 = 0, $102 = 0, $112 = 0, $116 = 0, $157 = 0, $159 = 0, $25 = 0, $38 = 0, $48 = 0, $74 = 0, $89 = 0, $91 = 0, $add147 = 0, $arrayidx167 = 0, $begin$addr = 0, $call = 0, $call196 = 0, $cond = 0, $conv138 = 0, $conv141 = 0, $conv157 = 0, $conv159 = 0, $conv183 = 0, $conv25 = 0, $conv38 = 0, $conv48 = 0, $conv71 = 0, $count = 0, $data$addr = 0, $end$addr = 0, $frames = 0, $i = 0, $len = 0, $maxlen$addr = 0, $nb_255s = 0, $pad$addr = 0, $pad_amount = 0, $ptr = 0, $retval = 0, $rp$addr = 0, $sdlen = 0, $self_delimited$addr = 0, $tot_size = 0, $vbr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $retval = sp + 68 | 0;
 $rp$addr = sp + 64 | 0;
 $begin$addr = sp + 60 | 0;
 $end$addr = sp + 56 | 0;
 $data$addr = sp + 52 | 0;
 $maxlen$addr = sp + 48 | 0;
 $self_delimited$addr = sp + 44 | 0;
 $pad$addr = sp + 40 | 0;
 $i = sp + 36 | 0;
 $count = sp + 32 | 0;
 $tot_size = sp + 28 | 0;
 $len = sp + 24 | 0;
 $frames = sp + 20 | 0;
 $ptr = sp + 16 | 0;
 $vbr = sp + 12 | 0;
 $pad_amount = sp + 8 | 0;
 $nb_255s = sp + 4 | 0;
 $sdlen = sp;
 HEAP32[$rp$addr >> 2] = $rp;
 HEAP32[$begin$addr >> 2] = $begin;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$maxlen$addr >> 2] = $maxlen;
 HEAP32[$self_delimited$addr >> 2] = $self_delimited;
 HEAP32[$pad$addr >> 2] = $pad;
 if ((HEAP32[$begin$addr >> 2] | 0) >= 0) if ((HEAP32[$begin$addr >> 2] | 0) < (HEAP32[$end$addr >> 2] | 0)) if ((HEAP32[$end$addr >> 2] | 0) <= (HEAP32[(HEAP32[$rp$addr >> 2] | 0) + 4 >> 2] | 0)) {
  HEAP32[$count >> 2] = (HEAP32[$end$addr >> 2] | 0) - (HEAP32[$begin$addr >> 2] | 0);
  HEAP32[$len >> 2] = (HEAP32[$rp$addr >> 2] | 0) + 200 + (HEAP32[$begin$addr >> 2] << 1);
  HEAP32[$frames >> 2] = (HEAP32[$rp$addr >> 2] | 0) + 8 + (HEAP32[$begin$addr >> 2] << 2);
  if (HEAP32[$self_delimited$addr >> 2] | 0) HEAP32[$tot_size >> 2] = 1 + ((HEAP16[(HEAP32[$len >> 2] | 0) + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] | 0) >= 252 & 1); else HEAP32[$tot_size >> 2] = 0;
  HEAP32[$ptr >> 2] = HEAP32[$data$addr >> 2];
  do if ((HEAP32[$count >> 2] | 0) == 1) {
   HEAP32[$tot_size >> 2] = (HEAP32[$tot_size >> 2] | 0) + ((HEAP16[HEAP32[$len >> 2] >> 1] | 0) + 1);
   if ((HEAP32[$tot_size >> 2] | 0) <= (HEAP32[$maxlen$addr >> 2] | 0)) {
    $conv25 = HEAPU8[HEAP32[$rp$addr >> 2] >> 0] & 252;
    $25 = HEAP32[$ptr >> 2] | 0;
    HEAP32[$ptr >> 2] = $25 + 1;
    HEAP8[$25 >> 0] = $conv25;
    break;
   }
   HEAP32[$retval >> 2] = -2;
   $159 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $159 | 0;
  } else if ((HEAP32[$count >> 2] | 0) == 2) {
   $conv38 = HEAP16[HEAP32[$len >> 2] >> 1] | 0;
   if ((HEAP16[(HEAP32[$len >> 2] | 0) + 2 >> 1] | 0) == (HEAP16[HEAP32[$len >> 2] >> 1] | 0)) {
    HEAP32[$tot_size >> 2] = (HEAP32[$tot_size >> 2] | 0) + (($conv38 << 1) + 1);
    if ((HEAP32[$tot_size >> 2] | 0) <= (HEAP32[$maxlen$addr >> 2] | 0)) {
     $conv48 = (HEAPU8[HEAP32[$rp$addr >> 2] >> 0] & 252 | 1) & 255;
     $38 = HEAP32[$ptr >> 2] | 0;
     HEAP32[$ptr >> 2] = $38 + 1;
     HEAP8[$38 >> 0] = $conv48;
     break;
    }
    HEAP32[$retval >> 2] = -2;
    $159 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $159 | 0;
   } else {
    HEAP32[$tot_size >> 2] = (HEAP32[$tot_size >> 2] | 0) + ($conv38 + (HEAP16[(HEAP32[$len >> 2] | 0) + 2 >> 1] | 0) + 2 + ((HEAP16[HEAP32[$len >> 2] >> 1] | 0) >= 252 & 1));
    if ((HEAP32[$tot_size >> 2] | 0) <= (HEAP32[$maxlen$addr >> 2] | 0)) {
     $conv71 = (HEAPU8[HEAP32[$rp$addr >> 2] >> 0] & 252 | 2) & 255;
     $48 = HEAP32[$ptr >> 2] | 0;
     HEAP32[$ptr >> 2] = $48 + 1;
     HEAP8[$48 >> 0] = $conv71;
     $call = _encode_size(HEAP16[HEAP32[$len >> 2] >> 1] | 0, HEAP32[$ptr >> 2] | 0) | 0;
     HEAP32[$ptr >> 2] = (HEAP32[$ptr >> 2] | 0) + $call;
     break;
    }
    HEAP32[$retval >> 2] = -2;
    $159 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $159 | 0;
   }
  } while (0);
  if ((HEAP32[$count >> 2] | 0) > 2) label = 23; else if (HEAP32[$pad$addr >> 2] | 0) if ((HEAP32[$tot_size >> 2] | 0) < (HEAP32[$maxlen$addr >> 2] | 0)) label = 23;
  L32 : do if ((label | 0) == 23) {
   HEAP32[$pad_amount >> 2] = 0;
   HEAP32[$ptr >> 2] = HEAP32[$data$addr >> 2];
   if (HEAP32[$self_delimited$addr >> 2] | 0) HEAP32[$tot_size >> 2] = 1 + ((HEAP16[(HEAP32[$len >> 2] | 0) + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] | 0) >= 252 & 1); else HEAP32[$tot_size >> 2] = 0;
   HEAP32[$vbr >> 2] = 0;
   HEAP32[$i >> 2] = 1;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$count >> 2] | 0)) break;
    if ((HEAP16[(HEAP32[$len >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) != (HEAP16[HEAP32[$len >> 2] >> 1] | 0)) {
     label = 29;
     break;
    }
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   if ((label | 0) == 29) HEAP32[$vbr >> 2] = 1;
   do if (HEAP32[$vbr >> 2] | 0) {
    HEAP32[$tot_size >> 2] = (HEAP32[$tot_size >> 2] | 0) + 2;
    HEAP32[$i >> 2] = 0;
    while (1) {
     $74 = HEAP32[$len >> 2] | 0;
     if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$count >> 2] | 0) - 1 | 0)) break;
     HEAP32[$tot_size >> 2] = (HEAP32[$tot_size >> 2] | 0) + (1 + ((HEAP16[$74 + (HEAP32[$i >> 2] << 1) >> 1] | 0) >= 252 & 1) + (HEAP16[(HEAP32[$len >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0));
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
    HEAP32[$tot_size >> 2] = (HEAP32[$tot_size >> 2] | 0) + (HEAP16[$74 + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] | 0);
    if ((HEAP32[$tot_size >> 2] | 0) <= (HEAP32[$maxlen$addr >> 2] | 0)) {
     $conv138 = (HEAPU8[HEAP32[$rp$addr >> 2] >> 0] & 252 | 3) & 255;
     $89 = HEAP32[$ptr >> 2] | 0;
     HEAP32[$ptr >> 2] = $89 + 1;
     HEAP8[$89 >> 0] = $conv138;
     $conv141 = (HEAP32[$count >> 2] | 128) & 255;
     $91 = HEAP32[$ptr >> 2] | 0;
     HEAP32[$ptr >> 2] = $91 + 1;
     HEAP8[$91 >> 0] = $conv141;
     break;
    }
    HEAP32[$retval >> 2] = -2;
    $159 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $159 | 0;
   } else {
    $add147 = (Math_imul(HEAP32[$count >> 2] | 0, HEAP16[HEAP32[$len >> 2] >> 1] | 0) | 0) + 2 | 0;
    HEAP32[$tot_size >> 2] = (HEAP32[$tot_size >> 2] | 0) + $add147;
    if ((HEAP32[$tot_size >> 2] | 0) <= (HEAP32[$maxlen$addr >> 2] | 0)) {
     $conv157 = (HEAPU8[HEAP32[$rp$addr >> 2] >> 0] & 252 | 3) & 255;
     $100 = HEAP32[$ptr >> 2] | 0;
     HEAP32[$ptr >> 2] = $100 + 1;
     HEAP8[$100 >> 0] = $conv157;
     $conv159 = HEAP32[$count >> 2] & 255;
     $102 = HEAP32[$ptr >> 2] | 0;
     HEAP32[$ptr >> 2] = $102 + 1;
     HEAP8[$102 >> 0] = $conv159;
     break;
    }
    HEAP32[$retval >> 2] = -2;
    $159 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $159 | 0;
   } while (0);
   if (HEAP32[$pad$addr >> 2] | 0) $cond = (HEAP32[$maxlen$addr >> 2] | 0) - (HEAP32[$tot_size >> 2] | 0) | 0; else $cond = 0;
   HEAP32[$pad_amount >> 2] = $cond;
   if (HEAP32[$pad_amount >> 2] | 0) {
    $arrayidx167 = (HEAP32[$data$addr >> 2] | 0) + 1 | 0;
    HEAP8[$arrayidx167 >> 0] = HEAPU8[$arrayidx167 >> 0] | 64;
    HEAP32[$nb_255s >> 2] = ((HEAP32[$pad_amount >> 2] | 0) - 1 | 0) / 255 | 0;
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nb_255s >> 2] | 0)) break;
     $112 = HEAP32[$ptr >> 2] | 0;
     HEAP32[$ptr >> 2] = $112 + 1;
     HEAP8[$112 >> 0] = -1;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
    $conv183 = (HEAP32[$pad_amount >> 2] | 0) - ((HEAP32[$nb_255s >> 2] | 0) * 255 | 0) - 1 & 255;
    $116 = HEAP32[$ptr >> 2] | 0;
    HEAP32[$ptr >> 2] = $116 + 1;
    HEAP8[$116 >> 0] = $conv183;
    HEAP32[$tot_size >> 2] = (HEAP32[$tot_size >> 2] | 0) + (HEAP32[$pad_amount >> 2] | 0);
   }
   if (HEAP32[$vbr >> 2] | 0) {
    HEAP32[$i >> 2] = 0;
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$count >> 2] | 0) - 1 | 0)) break L32;
     $call196 = _encode_size(HEAP16[(HEAP32[$len >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, HEAP32[$ptr >> 2] | 0) | 0;
     HEAP32[$ptr >> 2] = (HEAP32[$ptr >> 2] | 0) + $call196;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   }
  } while (0);
  if (HEAP32[$self_delimited$addr >> 2] | 0) {
   HEAP32[$sdlen >> 2] = _encode_size(HEAP16[(HEAP32[$len >> 2] | 0) + ((HEAP32[$count >> 2] | 0) - 1 << 1) >> 1] | 0, HEAP32[$ptr >> 2] | 0) | 0;
   HEAP32[$ptr >> 2] = (HEAP32[$ptr >> 2] | 0) + (HEAP32[$sdlen >> 2] | 0);
  }
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$count >> 2] | 0)) break;
   _memmove(HEAP32[$ptr >> 2] | 0, HEAP32[(HEAP32[$frames >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0, (HEAP16[(HEAP32[$len >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) + 0 | 0) | 0;
   HEAP32[$ptr >> 2] = (HEAP32[$ptr >> 2] | 0) + (HEAP16[(HEAP32[$len >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0);
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  L83 : do if (HEAP32[$pad$addr >> 2] | 0) while (1) {
   if ((HEAP32[$ptr >> 2] | 0) >>> 0 >= ((HEAP32[$data$addr >> 2] | 0) + (HEAP32[$maxlen$addr >> 2] | 0) | 0) >>> 0) break L83;
   $157 = HEAP32[$ptr >> 2] | 0;
   HEAP32[$ptr >> 2] = $157 + 1;
   HEAP8[$157 >> 0] = 0;
  } while (0);
  HEAP32[$retval >> 2] = HEAP32[$tot_size >> 2];
  $159 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $159 | 0;
 }
 HEAP32[$retval >> 2] = -1;
 $159 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $159 | 0;
}

function _kf_bfly5($Fout, $fstride, $st, $m, $N, $mm) {
 $Fout = $Fout | 0;
 $fstride = $fstride | 0;
 $st = $st | 0;
 $m = $m | 0;
 $N = $N | 0;
 $mm = $mm | 0;
 var $27 = 0, $Fout$addr = 0, $Fout0 = 0, $Fout1 = 0, $Fout2 = 0, $Fout3 = 0, $Fout4 = 0, $Fout_beg = 0, $N$addr = 0, $arrayidx = 0, $arrayidx4 = 0, $fstride$addr = 0, $i = 0, $m$addr = 0, $mm$addr = 0, $mul111 = 0.0, $mul126 = 0.0, $mul21 = 0.0, $mul33 = 0.0, $mul47 = 0.0, $mul62 = 0.0, $mul79 = 0.0, $mul94 = 0.0, $scratch = 0, $st$addr = 0, $tw = 0, $u = 0, $ya = 0, $yb = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 $Fout$addr = sp + 184 | 0;
 $fstride$addr = sp + 180 | 0;
 $st$addr = sp + 176 | 0;
 $m$addr = sp + 172 | 0;
 $N$addr = sp + 168 | 0;
 $mm$addr = sp + 164 | 0;
 $Fout0 = sp + 160 | 0;
 $Fout1 = sp + 156 | 0;
 $Fout2 = sp + 152 | 0;
 $Fout3 = sp + 148 | 0;
 $Fout4 = sp + 144 | 0;
 $i = sp + 140 | 0;
 $u = sp + 136 | 0;
 $scratch = sp + 32 | 0;
 $tw = sp + 24 | 0;
 $ya = sp + 16 | 0;
 $yb = sp + 8 | 0;
 $Fout_beg = sp;
 HEAP32[$Fout$addr >> 2] = $Fout;
 HEAP32[$fstride$addr >> 2] = $fstride;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$mm$addr >> 2] = $mm;
 HEAP32[$Fout_beg >> 2] = HEAP32[$Fout$addr >> 2];
 $arrayidx = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] | 0) + ((Math_imul(HEAP32[$fstride$addr >> 2] | 0, HEAP32[$m$addr >> 2] | 0) | 0) << 3) | 0;
 HEAP32[$ya >> 2] = HEAP32[$arrayidx >> 2];
 HEAP32[$ya + 4 >> 2] = HEAP32[$arrayidx + 4 >> 2];
 $arrayidx4 = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] | 0) + ((Math_imul(HEAP32[$fstride$addr >> 2] << 1, HEAP32[$m$addr >> 2] | 0) | 0) << 3) | 0;
 HEAP32[$yb >> 2] = HEAP32[$arrayidx4 >> 2];
 HEAP32[$yb + 4 >> 2] = HEAP32[$arrayidx4 + 4 >> 2];
 HEAP32[$tw >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAP32[$Fout$addr >> 2] = (HEAP32[$Fout_beg >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$mm$addr >> 2] | 0) | 0) << 3);
  HEAP32[$Fout0 >> 2] = HEAP32[$Fout$addr >> 2];
  HEAP32[$Fout1 >> 2] = (HEAP32[$Fout0 >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3);
  HEAP32[$Fout2 >> 2] = (HEAP32[$Fout0 >> 2] | 0) + (HEAP32[$m$addr >> 2] << 1 << 3);
  HEAP32[$Fout3 >> 2] = (HEAP32[$Fout0 >> 2] | 0) + ((HEAP32[$m$addr >> 2] | 0) * 3 << 3);
  HEAP32[$Fout4 >> 2] = (HEAP32[$Fout0 >> 2] | 0) + (HEAP32[$m$addr >> 2] << 2 << 3);
  HEAP32[$u >> 2] = 0;
  while (1) {
   if ((HEAP32[$u >> 2] | 0) >= (HEAP32[$m$addr >> 2] | 0)) break;
   $27 = HEAP32[$Fout0 >> 2] | 0;
   HEAP32[$scratch >> 2] = HEAP32[$27 >> 2];
   HEAP32[$scratch + 4 >> 2] = HEAP32[$27 + 4 >> 2];
   $mul21 = +HEAPF32[HEAP32[$Fout1 >> 2] >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] | 0, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) >> 2];
   HEAPF32[$scratch + 8 >> 2] = $mul21 - +HEAPF32[(HEAP32[$Fout1 >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] | 0, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) + 4 >> 2];
   $mul33 = +HEAPF32[HEAP32[$Fout1 >> 2] >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] | 0, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) + 4 >> 2];
   HEAPF32[$scratch + 8 + 4 >> 2] = $mul33 + +HEAPF32[(HEAP32[$Fout1 >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] | 0, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) >> 2];
   $mul47 = +HEAPF32[HEAP32[$Fout2 >> 2] >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] << 1, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) >> 2];
   HEAPF32[$scratch + 16 >> 2] = $mul47 - +HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] << 1, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) + 4 >> 2];
   $mul62 = +HEAPF32[HEAP32[$Fout2 >> 2] >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] << 1, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) + 4 >> 2];
   HEAPF32[$scratch + 16 + 4 >> 2] = $mul62 + +HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] << 1, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) >> 2];
   $mul79 = +HEAPF32[HEAP32[$Fout3 >> 2] >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul((HEAP32[$u >> 2] | 0) * 3 | 0, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) >> 2];
   HEAPF32[$scratch + 24 >> 2] = $mul79 - +HEAPF32[(HEAP32[$Fout3 >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul((HEAP32[$u >> 2] | 0) * 3 | 0, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) + 4 >> 2];
   $mul94 = +HEAPF32[HEAP32[$Fout3 >> 2] >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul((HEAP32[$u >> 2] | 0) * 3 | 0, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) + 4 >> 2];
   HEAPF32[$scratch + 24 + 4 >> 2] = $mul94 + +HEAPF32[(HEAP32[$Fout3 >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul((HEAP32[$u >> 2] | 0) * 3 | 0, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) >> 2];
   $mul111 = +HEAPF32[HEAP32[$Fout4 >> 2] >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] << 2, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) >> 2];
   HEAPF32[$scratch + 32 >> 2] = $mul111 - +HEAPF32[(HEAP32[$Fout4 >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] << 2, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) + 4 >> 2];
   $mul126 = +HEAPF32[HEAP32[$Fout4 >> 2] >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] << 2, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) + 4 >> 2];
   HEAPF32[$scratch + 32 + 4 >> 2] = $mul126 + +HEAPF32[(HEAP32[$Fout4 >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$tw >> 2] | 0) + ((Math_imul(HEAP32[$u >> 2] << 2, HEAP32[$fstride$addr >> 2] | 0) | 0) << 3) >> 2];
   HEAPF32[$scratch + 56 >> 2] = +HEAPF32[$scratch + 8 >> 2] + +HEAPF32[$scratch + 32 >> 2];
   HEAPF32[$scratch + 56 + 4 >> 2] = +HEAPF32[$scratch + 8 + 4 >> 2] + +HEAPF32[$scratch + 32 + 4 >> 2];
   HEAPF32[$scratch + 80 >> 2] = +HEAPF32[$scratch + 8 >> 2] - +HEAPF32[$scratch + 32 >> 2];
   HEAPF32[$scratch + 80 + 4 >> 2] = +HEAPF32[$scratch + 8 + 4 >> 2] - +HEAPF32[$scratch + 32 + 4 >> 2];
   HEAPF32[$scratch + 64 >> 2] = +HEAPF32[$scratch + 16 >> 2] + +HEAPF32[$scratch + 24 >> 2];
   HEAPF32[$scratch + 64 + 4 >> 2] = +HEAPF32[$scratch + 16 + 4 >> 2] + +HEAPF32[$scratch + 24 + 4 >> 2];
   HEAPF32[$scratch + 72 >> 2] = +HEAPF32[$scratch + 16 >> 2] - +HEAPF32[$scratch + 24 >> 2];
   HEAPF32[$scratch + 72 + 4 >> 2] = +HEAPF32[$scratch + 16 + 4 >> 2] - +HEAPF32[$scratch + 24 + 4 >> 2];
   HEAPF32[HEAP32[$Fout0 >> 2] >> 2] = +HEAPF32[HEAP32[$Fout0 >> 2] >> 2] + (+HEAPF32[$scratch + 56 >> 2] + +HEAPF32[$scratch + 64 >> 2]);
   HEAPF32[(HEAP32[$Fout0 >> 2] | 0) + 4 >> 2] = +HEAPF32[(HEAP32[$Fout0 >> 2] | 0) + 4 >> 2] + (+HEAPF32[$scratch + 56 + 4 >> 2] + +HEAPF32[$scratch + 64 + 4 >> 2]);
   HEAPF32[$scratch + 40 >> 2] = +HEAPF32[$scratch >> 2] + (+HEAPF32[$scratch + 56 >> 2] * +HEAPF32[$ya >> 2] + +HEAPF32[$scratch + 64 >> 2] * +HEAPF32[$yb >> 2]);
   HEAPF32[$scratch + 40 + 4 >> 2] = +HEAPF32[$scratch + 4 >> 2] + (+HEAPF32[$scratch + 56 + 4 >> 2] * +HEAPF32[$ya >> 2] + +HEAPF32[$scratch + 64 + 4 >> 2] * +HEAPF32[$yb >> 2]);
   HEAPF32[$scratch + 48 >> 2] = +HEAPF32[$scratch + 80 + 4 >> 2] * +HEAPF32[$ya + 4 >> 2] + +HEAPF32[$scratch + 72 + 4 >> 2] * +HEAPF32[$yb + 4 >> 2];
   HEAPF32[$scratch + 48 + 4 >> 2] = -(+HEAPF32[$scratch + 80 >> 2] * +HEAPF32[$ya + 4 >> 2] + +HEAPF32[$scratch + 72 >> 2] * +HEAPF32[$yb + 4 >> 2]);
   HEAPF32[HEAP32[$Fout1 >> 2] >> 2] = +HEAPF32[$scratch + 40 >> 2] - +HEAPF32[$scratch + 48 >> 2];
   HEAPF32[(HEAP32[$Fout1 >> 2] | 0) + 4 >> 2] = +HEAPF32[$scratch + 40 + 4 >> 2] - +HEAPF32[$scratch + 48 + 4 >> 2];
   HEAPF32[HEAP32[$Fout4 >> 2] >> 2] = +HEAPF32[$scratch + 40 >> 2] + +HEAPF32[$scratch + 48 >> 2];
   HEAPF32[(HEAP32[$Fout4 >> 2] | 0) + 4 >> 2] = +HEAPF32[$scratch + 40 + 4 >> 2] + +HEAPF32[$scratch + 48 + 4 >> 2];
   HEAPF32[$scratch + 88 >> 2] = +HEAPF32[$scratch >> 2] + (+HEAPF32[$scratch + 56 >> 2] * +HEAPF32[$yb >> 2] + +HEAPF32[$scratch + 64 >> 2] * +HEAPF32[$ya >> 2]);
   HEAPF32[$scratch + 88 + 4 >> 2] = +HEAPF32[$scratch + 4 >> 2] + (+HEAPF32[$scratch + 56 + 4 >> 2] * +HEAPF32[$yb >> 2] + +HEAPF32[$scratch + 64 + 4 >> 2] * +HEAPF32[$ya >> 2]);
   HEAPF32[$scratch + 96 >> 2] = +HEAPF32[$scratch + 72 + 4 >> 2] * +HEAPF32[$ya + 4 >> 2] - +HEAPF32[$scratch + 80 + 4 >> 2] * +HEAPF32[$yb + 4 >> 2];
   HEAPF32[$scratch + 96 + 4 >> 2] = +HEAPF32[$scratch + 80 >> 2] * +HEAPF32[$yb + 4 >> 2] - +HEAPF32[$scratch + 72 >> 2] * +HEAPF32[$ya + 4 >> 2];
   HEAPF32[HEAP32[$Fout2 >> 2] >> 2] = +HEAPF32[$scratch + 88 >> 2] + +HEAPF32[$scratch + 96 >> 2];
   HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 4 >> 2] = +HEAPF32[$scratch + 88 + 4 >> 2] + +HEAPF32[$scratch + 96 + 4 >> 2];
   HEAPF32[HEAP32[$Fout3 >> 2] >> 2] = +HEAPF32[$scratch + 88 >> 2] - +HEAPF32[$scratch + 96 >> 2];
   HEAPF32[(HEAP32[$Fout3 >> 2] | 0) + 4 >> 2] = +HEAPF32[$scratch + 88 + 4 >> 2] - +HEAPF32[$scratch + 96 + 4 >> 2];
   HEAP32[$Fout0 >> 2] = (HEAP32[$Fout0 >> 2] | 0) + 8;
   HEAP32[$Fout1 >> 2] = (HEAP32[$Fout1 >> 2] | 0) + 8;
   HEAP32[$Fout2 >> 2] = (HEAP32[$Fout2 >> 2] | 0) + 8;
   HEAP32[$Fout3 >> 2] = (HEAP32[$Fout3 >> 2] | 0) + 8;
   HEAP32[$Fout4 >> 2] = (HEAP32[$Fout4 >> 2] | 0) + 8;
   HEAP32[$u >> 2] = (HEAP32[$u >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_NLSF_stabilize($NLSF_Q15, $NDeltaMin_Q15, $L) {
 $NLSF_Q15 = $NLSF_Q15 | 0;
 $NDeltaMin_Q15 = $NDeltaMin_Q15 | 0;
 $L = $L | 0;
 var $158 = 0, $44 = 0, $55 = 0, $7 = 0, $I = 0, $L$addr = 0, $NDeltaMin_Q15$addr = 0, $NLSF_Q15$addr = 0, $add89 = 0, $arrayidx205$sink = 0, $center_freq_Q15 = 0, $cond188 = 0, $cond256 = 0, $conv204$sink = 0, $conv219 = 0, $conv226 = 0, $conv260 = 0, $conv272 = 0, $conv290 = 0, $diff_Q15 = 0, $i = 0, $k = 0, $loops = 0, $max_center_Q15 = 0, $min_center_Q15 = 0, $min_diff_Q15 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $NLSF_Q15$addr = sp + 40 | 0;
 $NDeltaMin_Q15$addr = sp + 36 | 0;
 $L$addr = sp + 32 | 0;
 $i = sp + 28 | 0;
 $I = sp + 24 | 0;
 $k = sp + 20 | 0;
 $loops = sp + 16 | 0;
 $center_freq_Q15 = sp + 44 | 0;
 $diff_Q15 = sp + 12 | 0;
 $min_diff_Q15 = sp + 8 | 0;
 $min_center_Q15 = sp + 4 | 0;
 $max_center_Q15 = sp;
 HEAP32[$NLSF_Q15$addr >> 2] = $NLSF_Q15;
 HEAP32[$NDeltaMin_Q15$addr >> 2] = $NDeltaMin_Q15;
 HEAP32[$L$addr >> 2] = $L;
 HEAP32[$I >> 2] = 0;
 HEAP32[$loops >> 2] = 0;
 while (1) {
  if ((HEAP32[$loops >> 2] | 0) >= 20) break;
  HEAP32[$min_diff_Q15 >> 2] = (HEAP16[HEAP32[$NLSF_Q15$addr >> 2] >> 1] | 0) - (HEAP16[HEAP32[$NDeltaMin_Q15$addr >> 2] >> 1] | 0);
  HEAP32[$I >> 2] = 0;
  HEAP32[$i >> 2] = 1;
  while (1) {
   $7 = HEAP32[$NLSF_Q15$addr >> 2] | 0;
   if ((HEAP32[$i >> 2] | 0) > ((HEAP32[$L$addr >> 2] | 0) - 1 | 0)) break;
   HEAP32[$diff_Q15 >> 2] = (HEAP16[$7 + (HEAP32[$i >> 2] << 1) >> 1] | 0) - ((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0));
   if ((HEAP32[$diff_Q15 >> 2] | 0) < (HEAP32[$min_diff_Q15 >> 2] | 0)) {
    HEAP32[$min_diff_Q15 >> 2] = HEAP32[$diff_Q15 >> 2];
    HEAP32[$I >> 2] = HEAP32[$i >> 2];
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$diff_Q15 >> 2] = 32768 - ((HEAP16[$7 + ((HEAP32[$L$addr >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + (HEAP32[$L$addr >> 2] << 1) >> 1] | 0));
  if ((HEAP32[$diff_Q15 >> 2] | 0) < (HEAP32[$min_diff_Q15 >> 2] | 0)) {
   HEAP32[$min_diff_Q15 >> 2] = HEAP32[$diff_Q15 >> 2];
   HEAP32[$I >> 2] = HEAP32[$L$addr >> 2];
  }
  if ((HEAP32[$min_diff_Q15 >> 2] | 0) >= 0) {
   label = 45;
   break;
  }
  if (!(HEAP32[$I >> 2] | 0)) HEAP16[HEAP32[$NLSF_Q15$addr >> 2] >> 1] = HEAP16[HEAP32[$NDeltaMin_Q15$addr >> 2] >> 1] | 0; else {
   if ((HEAP32[$I >> 2] | 0) == (HEAP32[$L$addr >> 2] | 0)) {
    $arrayidx205$sink = (HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$L$addr >> 2] | 0) - 1 << 1) | 0;
    $conv204$sink = 32768 - (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + (HEAP32[$L$addr >> 2] << 1) >> 1] | 0) & 65535;
   } else {
    HEAP32[$min_center_Q15 >> 2] = 0;
    HEAP32[$k >> 2] = 0;
    while (1) {
     $44 = HEAP32[$NDeltaMin_Q15$addr >> 2] | 0;
     if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$I >> 2] | 0)) break;
     HEAP32[$min_center_Q15 >> 2] = (HEAP32[$min_center_Q15 >> 2] | 0) + (HEAP16[$44 + (HEAP32[$k >> 2] << 1) >> 1] | 0);
     HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
    }
    HEAP32[$min_center_Q15 >> 2] = (HEAP32[$min_center_Q15 >> 2] | 0) + (HEAP16[$44 + (HEAP32[$I >> 2] << 1) >> 1] >> 1);
    HEAP32[$max_center_Q15 >> 2] = 32768;
    HEAP32[$k >> 2] = HEAP32[$L$addr >> 2];
    while (1) {
     $55 = HEAP32[$NDeltaMin_Q15$addr >> 2] | 0;
     if ((HEAP32[$k >> 2] | 0) <= (HEAP32[$I >> 2] | 0)) break;
     HEAP32[$max_center_Q15 >> 2] = (HEAP32[$max_center_Q15 >> 2] | 0) - (HEAP16[$55 + (HEAP32[$k >> 2] << 1) >> 1] | 0);
     HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + -1;
    }
    HEAP32[$max_center_Q15 >> 2] = (HEAP32[$max_center_Q15 >> 2] | 0) - (HEAP16[$55 + (HEAP32[$I >> 2] << 1) >> 1] >> 1);
    $add89 = ((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) >> 1) + ((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) & 1) | 0;
    do if ((HEAP32[$min_center_Q15 >> 2] | 0) > (HEAP32[$max_center_Q15 >> 2] | 0)) {
     if (($add89 | 0) > (HEAP32[$min_center_Q15 >> 2] | 0)) {
      $cond188 = HEAP32[$min_center_Q15 >> 2] | 0;
      break;
     }
     if ((((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) >> 1) + ((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) & 1) | 0) < (HEAP32[$max_center_Q15 >> 2] | 0)) {
      $cond188 = HEAP32[$max_center_Q15 >> 2] | 0;
      break;
     } else {
      $cond188 = ((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) >> 1) + ((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) & 1) | 0;
      break;
     }
    } else {
     if (($add89 | 0) > (HEAP32[$max_center_Q15 >> 2] | 0)) {
      $cond188 = HEAP32[$max_center_Q15 >> 2] | 0;
      break;
     }
     if ((((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) >> 1) + ((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) & 1) | 0) < (HEAP32[$min_center_Q15 >> 2] | 0)) {
      $cond188 = HEAP32[$min_center_Q15 >> 2] | 0;
      break;
     } else {
      $cond188 = ((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) >> 1) + ((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) & 1) | 0;
      break;
     }
    } while (0);
    HEAP16[$center_freq_Q15 >> 1] = $cond188;
    HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] = (HEAP16[$center_freq_Q15 >> 1] | 0) - (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] >> 1);
    $arrayidx205$sink = (HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) | 0;
    $conv204$sink = (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$I >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + (HEAP32[$I >> 2] << 1) >> 1] | 0) & 65535;
   }
   HEAP16[$arrayidx205$sink >> 1] = $conv204$sink;
  }
  HEAP32[$loops >> 2] = (HEAP32[$loops >> 2] | 0) + 1;
 }
 if ((label | 0) == 45) {
  STACKTOP = sp;
  return;
 }
 if ((HEAP32[$loops >> 2] | 0) != 20) {
  STACKTOP = sp;
  return;
 }
 _silk_insertion_sort_increasing_all_values_int16(HEAP32[$NLSF_Q15$addr >> 2] | 0, HEAP32[$L$addr >> 2] | 0);
 $conv219 = (_silk_max_int_495(HEAP16[HEAP32[$NLSF_Q15$addr >> 2] >> 1] | 0, HEAP16[HEAP32[$NDeltaMin_Q15$addr >> 2] >> 1] | 0) | 0) & 65535;
 HEAP16[HEAP32[$NLSF_Q15$addr >> 2] >> 1] = $conv219;
 HEAP32[$i >> 2] = 1;
 while (1) {
  $158 = HEAP32[$NLSF_Q15$addr >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$L$addr >> 2] | 0)) break;
  $conv226 = HEAP16[$158 + (HEAP32[$i >> 2] << 1) >> 1] | 0;
  if (((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) > 32767) $cond256 = 32767; else if (((HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) < -32768) $cond256 = -32768; else $cond256 = (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
  $conv260 = (_silk_max_int_495($conv226, ($cond256 & 65535) << 16 >> 16) | 0) & 65535;
  HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $conv260;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 $conv272 = (_silk_min_int_496(HEAP16[$158 + ((HEAP32[$L$addr >> 2] | 0) - 1 << 1) >> 1] | 0, 32768 - (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + (HEAP32[$L$addr >> 2] << 1) >> 1] | 0) | 0) | 0) & 65535;
 HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$L$addr >> 2] | 0) - 1 << 1) >> 1] = $conv272;
 HEAP32[$i >> 2] = (HEAP32[$L$addr >> 2] | 0) - 2;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < 0) break;
  $conv290 = (_silk_min_int_496(HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, (HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$NDeltaMin_Q15$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) | 0) | 0) & 65535;
  HEAP16[(HEAP32[$NLSF_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $conv290;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return;
}

function _silk_encode_pulses($psRangeEnc, $signalType, $quantOffsetType, $pulses, $frame_length) {
 $psRangeEnc = $psRangeEnc | 0;
 $signalType = $signalType | 0;
 $quantOffsetType = $quantOffsetType | 0;
 $pulses = $pulses | 0;
 $frame_length = $frame_length | 0;
 var $103 = 0, $132 = 0, $74 = 0, $95 = 0, $RateLevelIndex = 0, $abs_pulses_ptr = 0, $abs_q = 0, $arrayidx95 = 0, $bit = 0, $call82 = 0, $call87 = 0, $call92 = 0, $cdf_ptr = 0, $conv213 = 0, $conv23 = 0, $conv41 = 0, $conv59 = 0, $conv9 = 0, $frame_length$addr = 0, $i = 0, $iter = 0, $j = 0, $k = 0, $minSumBits_Q5 = 0, $mul1 = 0, $nBits_ptr = 0, $nLS = 0, $psRangeEnc$addr = 0, $pulses$addr = 0, $pulses_comb = 0, $pulses_ptr = 0, $quantOffsetType$addr = 0, $saved_stack = 0, $scale_down = 0, $signalType$addr = 0, $sumBits_Q5 = 0, $vla = 0, $vla70 = 0, $vla71 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $psRangeEnc$addr = sp + 116 | 0;
 $signalType$addr = sp + 112 | 0;
 $quantOffsetType$addr = sp + 108 | 0;
 $pulses$addr = sp + 104 | 0;
 $frame_length$addr = sp + 100 | 0;
 $i = sp + 96 | 0;
 $k = sp + 92 | 0;
 $j = sp + 88 | 0;
 $iter = sp + 84 | 0;
 $bit = sp + 80 | 0;
 $nLS = sp + 76 | 0;
 $scale_down = sp + 72 | 0;
 $RateLevelIndex = sp + 68 | 0;
 $abs_q = sp + 64 | 0;
 $minSumBits_Q5 = sp + 60 | 0;
 $sumBits_Q5 = sp + 56 | 0;
 $pulses_comb = sp + 24 | 0;
 $abs_pulses_ptr = sp + 16 | 0;
 $pulses_ptr = sp + 12 | 0;
 $cdf_ptr = sp + 8 | 0;
 $nBits_ptr = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$psRangeEnc$addr >> 2] = $psRangeEnc;
 HEAP32[$signalType$addr >> 2] = $signalType;
 HEAP32[$quantOffsetType$addr >> 2] = $quantOffsetType;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$frame_length$addr >> 2] = $frame_length;
 HEAP32[$RateLevelIndex >> 2] = 0;
 HEAP32[$pulses_comb >> 2] = 0;
 HEAP32[$pulses_comb + 4 >> 2] = 0;
 HEAP32[$pulses_comb + 8 >> 2] = 0;
 HEAP32[$pulses_comb + 12 >> 2] = 0;
 HEAP32[$pulses_comb + 16 >> 2] = 0;
 HEAP32[$pulses_comb + 20 >> 2] = 0;
 HEAP32[$pulses_comb + 24 >> 2] = 0;
 HEAP32[$pulses_comb + 28 >> 2] = 0;
 HEAP32[$iter >> 2] = HEAP32[$frame_length$addr >> 2] >> 4;
 if ((HEAP32[$iter >> 2] << 4 | 0) < (HEAP32[$frame_length$addr >> 2] | 0)) {
  HEAP32[$iter >> 2] = (HEAP32[$iter >> 2] | 0) + 1;
  dest = (HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$frame_length$addr >> 2] | 0) | 0;
  stop = dest + 16 | 0;
  do {
   HEAP8[dest >> 0] = 0;
   dest = dest + 1 | 0;
  } while ((dest | 0) < (stop | 0));
 }
 $mul1 = HEAP32[$iter >> 2] << 4;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($mul1 << 2) | 0) + 15 & -16) | 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$iter >> 2] << 4 | 0)) break;
  $conv9 = HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 0) >> 0] | 0;
  HEAP32[$vla + ((HEAP32[$i >> 2] | 0) + 0 << 2) >> 2] = (HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 0) >> 0] | 0) > 0 ? $conv9 : 0 - $conv9 | 0;
  $conv23 = HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1) >> 0] | 0;
  HEAP32[$vla + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] = (HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1) >> 0] | 0) > 0 ? $conv23 : 0 - $conv23 | 0;
  $conv41 = HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2) >> 0] | 0;
  HEAP32[$vla + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2] = (HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2) >> 0] | 0) > 0 ? $conv41 : 0 - $conv41 | 0;
  $conv59 = HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3) >> 0] | 0;
  HEAP32[$vla + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2] = (HEAP8[(HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3) >> 0] | 0) > 0 ? $conv59 : 0 - $conv59 | 0;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
 }
 $vla70 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$iter >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla71 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$iter >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[$abs_pulses_ptr >> 2] = $vla;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$iter >> 2] | 0)) break;
  HEAP32[$vla71 + (HEAP32[$i >> 2] << 2) >> 2] = 0;
  L11 : while (1) {
   HEAP32[$scale_down >> 2] = _combine_and_check($pulses_comb, HEAP32[$abs_pulses_ptr >> 2] | 0, HEAPU8[32378] | 0, 8) | 0;
   $call82 = _combine_and_check($pulses_comb, $pulses_comb, HEAPU8[32379] | 0, 4) | 0;
   HEAP32[$scale_down >> 2] = (HEAP32[$scale_down >> 2] | 0) + $call82;
   $call87 = _combine_and_check($pulses_comb, $pulses_comb, HEAPU8[32380] | 0, 2) | 0;
   HEAP32[$scale_down >> 2] = (HEAP32[$scale_down >> 2] | 0) + $call87;
   $call92 = _combine_and_check($vla70 + (HEAP32[$i >> 2] << 2) | 0, $pulses_comb, HEAPU8[32381] | 0, 1) | 0;
   HEAP32[$scale_down >> 2] = (HEAP32[$scale_down >> 2] | 0) + $call92;
   if (!(HEAP32[$scale_down >> 2] | 0)) break;
   $arrayidx95 = $vla71 + (HEAP32[$i >> 2] << 2) | 0;
   HEAP32[$arrayidx95 >> 2] = (HEAP32[$arrayidx95 >> 2] | 0) + 1;
   HEAP32[$k >> 2] = 0;
   while (1) {
    if ((HEAP32[$k >> 2] | 0) >= 16) continue L11;
    HEAP32[(HEAP32[$abs_pulses_ptr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = HEAP32[(HEAP32[$abs_pulses_ptr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] >> 1;
    HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   }
  }
  HEAP32[$abs_pulses_ptr >> 2] = (HEAP32[$abs_pulses_ptr >> 2] | 0) + 64;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$minSumBits_Q5 >> 2] = 2147483647;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= 9) break;
  HEAP32[$nBits_ptr >> 2] = 32562 + ((HEAP32[$k >> 2] | 0) * 18 | 0);
  HEAP32[$sumBits_Q5 >> 2] = HEAPU8[32742 + ((HEAP32[$signalType$addr >> 2] >> 1) * 9 | 0) + (HEAP32[$k >> 2] | 0) >> 0];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$iter >> 2] | 0)) break;
   $74 = HEAP32[$nBits_ptr >> 2] | 0;
   if ((HEAP32[$vla71 + (HEAP32[$i >> 2] << 2) >> 2] | 0) > 0) HEAP32[$sumBits_Q5 >> 2] = (HEAP32[$sumBits_Q5 >> 2] | 0) + (HEAPU8[$74 + 17 >> 0] | 0); else HEAP32[$sumBits_Q5 >> 2] = (HEAP32[$sumBits_Q5 >> 2] | 0) + (HEAPU8[$74 + (HEAP32[$vla70 + (HEAP32[$i >> 2] << 2) >> 2] | 0) >> 0] | 0);
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  if ((HEAP32[$sumBits_Q5 >> 2] | 0) < (HEAP32[$minSumBits_Q5 >> 2] | 0)) {
   HEAP32[$minSumBits_Q5 >> 2] = HEAP32[$sumBits_Q5 >> 2];
   HEAP32[$RateLevelIndex >> 2] = HEAP32[$k >> 2];
  }
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$RateLevelIndex >> 2] | 0, 32724 + ((HEAP32[$signalType$addr >> 2] >> 1) * 9 | 0) | 0, 8);
 HEAP32[$cdf_ptr >> 2] = 32382 + ((HEAP32[$RateLevelIndex >> 2] | 0) * 18 | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$iter >> 2] | 0)) break;
  $95 = HEAP32[$psRangeEnc$addr >> 2] | 0;
  if (!(HEAP32[$vla71 + (HEAP32[$i >> 2] << 2) >> 2] | 0)) _ec_enc_icdf($95, HEAP32[$vla70 + (HEAP32[$i >> 2] << 2) >> 2] | 0, HEAP32[$cdf_ptr >> 2] | 0, 8); else {
   _ec_enc_icdf($95, 17, HEAP32[$cdf_ptr >> 2] | 0, 8);
   HEAP32[$k >> 2] = 0;
   while (1) {
    $103 = HEAP32[$psRangeEnc$addr >> 2] | 0;
    if ((HEAP32[$k >> 2] | 0) >= ((HEAP32[$vla71 + (HEAP32[$i >> 2] << 2) >> 2] | 0) - 1 | 0)) break;
    _ec_enc_icdf($103, 17, 32544, 8);
    HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   }
   _ec_enc_icdf($103, HEAP32[$vla70 + (HEAP32[$i >> 2] << 2) >> 2] | 0, 32544, 8);
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$iter >> 2] | 0)) break;
  if ((HEAP32[$vla70 + (HEAP32[$i >> 2] << 2) >> 2] | 0) > 0) _silk_shell_encoder(HEAP32[$psRangeEnc$addr >> 2] | 0, $vla + (HEAP32[$i >> 2] << 4 << 2) | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$iter >> 2] | 0)) break;
  L56 : do if ((HEAP32[$vla71 + (HEAP32[$i >> 2] << 2) >> 2] | 0) > 0) {
   HEAP32[$pulses_ptr >> 2] = (HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 4);
   HEAP32[$nLS >> 2] = (HEAP32[$vla71 + (HEAP32[$i >> 2] << 2) >> 2] | 0) - 1;
   HEAP32[$k >> 2] = 0;
   while (1) {
    if ((HEAP32[$k >> 2] | 0) >= 16) break L56;
    $conv213 = HEAP8[(HEAP32[$pulses_ptr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0;
    HEAP32[$abs_q >> 2] = (((HEAP8[(HEAP32[$pulses_ptr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) > 0 ? $conv213 : 0 - $conv213 | 0) & 255) << 24 >> 24;
    HEAP32[$j >> 2] = HEAP32[$nLS >> 2];
    while (1) {
     $132 = HEAP32[$abs_q >> 2] | 0;
     if ((HEAP32[$j >> 2] | 0) <= 0) break;
     HEAP32[$bit >> 2] = $132 >> HEAP32[$j >> 2] & 1;
     _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$bit >> 2] | 0, 32216, 8);
     HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + -1;
    }
    HEAP32[$bit >> 2] = $132 & 1;
    _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$bit >> 2] | 0, 32216, 8);
    HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   }
  } while (0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _silk_encode_signs(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pulses$addr >> 2] | 0, HEAP32[$frame_length$addr >> 2] | 0, HEAP32[$signalType$addr >> 2] | 0, HEAP32[$quantOffsetType$addr >> 2] | 0, $vla70);
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _opus_decode_native($st, $data, $len, $pcm, $frame_size, $decode_fec, $self_delimited, $packet_offset, $soft_clip) {
 $st = $st | 0;
 $data = $data | 0;
 $len = $len | 0;
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $decode_fec = $decode_fec | 0;
 $self_delimited = $self_delimited | 0;
 $packet_offset = $packet_offset | 0;
 $soft_clip = $soft_clip | 0;
 var $127 = 0, $18 = 0, $add$ptr = 0, $add$ptr65 = 0, $add$ptr96 = 0, $count = 0, $data$addr = 0, $decode_fec$addr = 0, $duration_copy = 0, $frame_size$addr = 0, $i = 0, $len$addr = 0, $mul80 = 0, $nb_samples = 0, $offset = 0, $packet_bandwidth = 0, $packet_frame_size = 0, $packet_mode = 0, $packet_offset$addr = 0, $packet_stream_channels = 0, $pcm$addr = 0, $pcm_count = 0, $ret = 0, $ret40 = 0, $ret91 = 0, $retval = 0, $self_delimited$addr = 0, $size = 0, $soft_clip$addr = 0, $st$addr = 0, $toc = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 208 | 0;
 $retval = sp + 88 | 0;
 $st$addr = sp + 84 | 0;
 $data$addr = sp + 80 | 0;
 $len$addr = sp + 76 | 0;
 $pcm$addr = sp + 72 | 0;
 $frame_size$addr = sp + 68 | 0;
 $decode_fec$addr = sp + 64 | 0;
 $self_delimited$addr = sp + 60 | 0;
 $packet_offset$addr = sp + 56 | 0;
 $soft_clip$addr = sp + 52 | 0;
 $i = sp + 48 | 0;
 $nb_samples = sp + 44 | 0;
 $count = sp + 40 | 0;
 $offset = sp + 36 | 0;
 $toc = sp + 192 | 0;
 $packet_frame_size = sp + 32 | 0;
 $packet_bandwidth = sp + 28 | 0;
 $packet_mode = sp + 24 | 0;
 $packet_stream_channels = sp + 20 | 0;
 $size = sp + 96 | 0;
 $pcm_count = sp + 16 | 0;
 $ret = sp + 12 | 0;
 $duration_copy = sp + 8 | 0;
 $ret40 = sp + 4 | 0;
 $ret91 = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$decode_fec$addr >> 2] = $decode_fec;
 HEAP32[$self_delimited$addr >> 2] = $self_delimited;
 HEAP32[$packet_offset$addr >> 2] = $packet_offset;
 HEAP32[$soft_clip$addr >> 2] = $soft_clip;
 if ((HEAP32[$decode_fec$addr >> 2] | 0) < 0 | (HEAP32[$decode_fec$addr >> 2] | 0) > 1) {
  HEAP32[$retval >> 2] = -1;
  $127 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $127 | 0;
 }
 if ((HEAP32[$decode_fec$addr >> 2] | 0) != 0 | (HEAP32[$len$addr >> 2] | 0) == 0 | (HEAP32[$data$addr >> 2] | 0) == 0) if ((HEAP32[$frame_size$addr >> 2] | 0) % ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0) / 400 | 0 | 0) | 0 | 0) {
  HEAP32[$retval >> 2] = -1;
  $127 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $127 | 0;
 }
 if ((HEAP32[$len$addr >> 2] | 0) == 0 | (HEAP32[$data$addr >> 2] | 0) == 0) {
  HEAP32[$pcm_count >> 2] = 0;
  while (1) {
   $add$ptr = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[$pcm_count >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) | 0;
   HEAP32[$ret >> 2] = _opus_decode_frame(HEAP32[$st$addr >> 2] | 0, 0, 0, $add$ptr, (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$pcm_count >> 2] | 0) | 0, 0) | 0;
   $18 = HEAP32[$ret >> 2] | 0;
   if ((HEAP32[$ret >> 2] | 0) < 0) {
    label = 9;
    break;
   }
   HEAP32[$pcm_count >> 2] = (HEAP32[$pcm_count >> 2] | 0) + $18;
   if ((HEAP32[$pcm_count >> 2] | 0) >= (HEAP32[$frame_size$addr >> 2] | 0)) {
    label = 11;
    break;
   }
  }
  if ((label | 0) == 9) {
   HEAP32[$retval >> 2] = $18;
   $127 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $127 | 0;
  } else if ((label | 0) == 11) {
   __opus_false() | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] = HEAP32[$pcm_count >> 2];
   HEAP32[$retval >> 2] = HEAP32[$pcm_count >> 2];
   $127 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $127 | 0;
  }
 }
 if ((HEAP32[$len$addr >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = -1;
  $127 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $127 | 0;
 }
 HEAP32[$packet_mode >> 2] = _opus_packet_get_mode(HEAP32[$data$addr >> 2] | 0) | 0;
 HEAP32[$packet_bandwidth >> 2] = _opus_packet_get_bandwidth(HEAP32[$data$addr >> 2] | 0) | 0;
 HEAP32[$packet_frame_size >> 2] = _opus_packet_get_samples_per_frame(HEAP32[$data$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] | 0) | 0;
 HEAP32[$packet_stream_channels >> 2] = _opus_packet_get_nb_channels(HEAP32[$data$addr >> 2] | 0) | 0;
 HEAP32[$count >> 2] = _opus_packet_parse_impl(HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0, HEAP32[$self_delimited$addr >> 2] | 0, $toc, 0, $size, $offset, HEAP32[$packet_offset$addr >> 2] | 0) | 0;
 if ((HEAP32[$count >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = HEAP32[$count >> 2];
  $127 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $127 | 0;
 }
 HEAP32[$data$addr >> 2] = (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$offset >> 2] | 0);
 if (HEAP32[$decode_fec$addr >> 2] | 0) {
  if (!((HEAP32[$packet_mode >> 2] | 0) == 1002 ? 1 : (HEAP32[$frame_size$addr >> 2] | 0) < (HEAP32[$packet_frame_size >> 2] | 0))) if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] | 0) != 1002) {
   HEAP32[$duration_copy >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2];
   if ((HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$packet_frame_size >> 2] | 0) | 0) {
    HEAP32[$ret40 >> 2] = _opus_decode_native(HEAP32[$st$addr >> 2] | 0, 0, 0, HEAP32[$pcm$addr >> 2] | 0, (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$packet_frame_size >> 2] | 0) | 0, 0, 0, 0, HEAP32[$soft_clip$addr >> 2] | 0) | 0;
    if ((HEAP32[$ret40 >> 2] | 0) < 0) {
     HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] = HEAP32[$duration_copy >> 2];
     HEAP32[$retval >> 2] = HEAP32[$ret40 >> 2];
     $127 = HEAP32[$retval >> 2] | 0;
     STACKTOP = sp;
     return $127 | 0;
    }
   }
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] = HEAP32[$packet_mode >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] = HEAP32[$packet_bandwidth >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] = HEAP32[$packet_frame_size >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] = HEAP32[$packet_stream_channels >> 2];
   $add$ptr65 = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$packet_frame_size >> 2] | 0) | 0) | 0) << 2) | 0;
   HEAP32[$ret40 >> 2] = _opus_decode_frame(HEAP32[$st$addr >> 2] | 0, HEAP32[$data$addr >> 2] | 0, HEAP16[$size >> 1] | 0, $add$ptr65, HEAP32[$packet_frame_size >> 2] | 0, 1) | 0;
   if ((HEAP32[$ret40 >> 2] | 0) < 0) {
    HEAP32[$retval >> 2] = HEAP32[$ret40 >> 2];
    $127 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $127 | 0;
   } else {
    __opus_false() | 0;
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] = HEAP32[$frame_size$addr >> 2];
    HEAP32[$retval >> 2] = HEAP32[$frame_size$addr >> 2];
    $127 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $127 | 0;
   }
  }
  HEAP32[$retval >> 2] = _opus_decode_native(HEAP32[$st$addr >> 2] | 0, 0, 0, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, 0, 0, 0, HEAP32[$soft_clip$addr >> 2] | 0) | 0;
  $127 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $127 | 0;
 }
 $mul80 = Math_imul(HEAP32[$count >> 2] | 0, HEAP32[$packet_frame_size >> 2] | 0) | 0;
 if (($mul80 | 0) > (HEAP32[$frame_size$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = -2;
  $127 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $127 | 0;
 }
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] = HEAP32[$packet_mode >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] = HEAP32[$packet_bandwidth >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] = HEAP32[$packet_frame_size >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] = HEAP32[$packet_stream_channels >> 2];
 HEAP32[$nb_samples >> 2] = 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$count >> 2] | 0)) break;
  $add$ptr96 = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[$nb_samples >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) | 0;
  HEAP32[$ret91 >> 2] = _opus_decode_frame(HEAP32[$st$addr >> 2] | 0, HEAP32[$data$addr >> 2] | 0, HEAP16[$size + (HEAP32[$i >> 2] << 1) >> 1] | 0, $add$ptr96, (HEAP32[$frame_size$addr >> 2] | 0) - (HEAP32[$nb_samples >> 2] | 0) | 0, 0) | 0;
  if ((HEAP32[$ret91 >> 2] | 0) < 0) {
   label = 31;
   break;
  }
  HEAP32[$data$addr >> 2] = (HEAP32[$data$addr >> 2] | 0) + (HEAP16[$size + (HEAP32[$i >> 2] << 1) >> 1] | 0);
  HEAP32[$nb_samples >> 2] = (HEAP32[$nb_samples >> 2] | 0) + (HEAP32[$ret91 >> 2] | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((label | 0) == 31) {
  HEAP32[$retval >> 2] = HEAP32[$ret91 >> 2];
  $127 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $127 | 0;
 }
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] = HEAP32[$nb_samples >> 2];
 __opus_false() | 0;
 if (HEAP32[$soft_clip$addr >> 2] | 0) _opus_pcm_soft_clip(HEAP32[$pcm$addr >> 2] | 0, HEAP32[$nb_samples >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 76 | 0); else {
  HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 76 + 4 >> 2] = 0.0;
  HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 76 >> 2] = 0.0;
 }
 HEAP32[$retval >> 2] = HEAP32[$nb_samples >> 2];
 $127 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $127 | 0;
}

function _silk_nsq_scale_states($psEncC, $NSQ, $x16, $x_sc_Q10, $sLTP, $sLTP_Q15, $subfr, $LTP_scale_Q14, $Gains_Q16, $pitchL, $signal_type) {
 $psEncC = $psEncC | 0;
 $NSQ = $NSQ | 0;
 $x16 = $x16 | 0;
 $x_sc_Q10 = $x_sc_Q10 | 0;
 $sLTP = $sLTP | 0;
 $sLTP_Q15 = $sLTP_Q15 | 0;
 $subfr = $subfr | 0;
 $LTP_scale_Q14 = $LTP_scale_Q14 | 0;
 $Gains_Q16 = $Gains_Q16 | 0;
 $pitchL = $pitchL | 0;
 $signal_type = $signal_type | 0;
 var $Gains_Q16$addr = 0, $LTP_scale_Q14$addr = 0, $NSQ$addr = 0, $add121 = 0, $add127 = 0, $add143 = 0, $add149 = 0, $add15 = 0, $add161 = 0, $add167 = 0, $add185 = 0, $add192 = 0, $add214 = 0, $add22 = 0, $add221 = 0, $add52 = 0, $add83 = 0, $add90 = 0, $cond = 0, $gain_adj_Q16 = 0, $i = 0, $inv_gain_Q26 = 0, $inv_gain_Q31 = 0, $lag = 0, $mul = 0, $mul114 = 0, $mul136 = 0, $mul154 = 0, $mul177 = 0, $mul206 = 0, $mul30 = 0, $mul46 = 0, $mul75 = 0, $pitchL$addr = 0, $psEncC$addr = 0, $sLTP$addr = 0, $sLTP_Q15$addr = 0, $signal_type$addr = 0, $subfr$addr = 0, $x16$addr = 0, $x_sc_Q10$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $psEncC$addr = sp + 60 | 0;
 $NSQ$addr = sp + 56 | 0;
 $x16$addr = sp + 52 | 0;
 $x_sc_Q10$addr = sp + 48 | 0;
 $sLTP$addr = sp + 44 | 0;
 $sLTP_Q15$addr = sp + 40 | 0;
 $subfr$addr = sp + 36 | 0;
 $LTP_scale_Q14$addr = sp + 32 | 0;
 $Gains_Q16$addr = sp + 28 | 0;
 $pitchL$addr = sp + 24 | 0;
 $signal_type$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $lag = sp + 12 | 0;
 $gain_adj_Q16 = sp + 8 | 0;
 $inv_gain_Q31 = sp + 4 | 0;
 $inv_gain_Q26 = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$NSQ$addr >> 2] = $NSQ;
 HEAP32[$x16$addr >> 2] = $x16;
 HEAP32[$x_sc_Q10$addr >> 2] = $x_sc_Q10;
 HEAP32[$sLTP$addr >> 2] = $sLTP;
 HEAP32[$sLTP_Q15$addr >> 2] = $sLTP_Q15;
 HEAP32[$subfr$addr >> 2] = $subfr;
 HEAP32[$LTP_scale_Q14$addr >> 2] = $LTP_scale_Q14;
 HEAP32[$Gains_Q16$addr >> 2] = $Gains_Q16;
 HEAP32[$pitchL$addr >> 2] = $pitchL;
 HEAP32[$signal_type$addr >> 2] = $signal_type;
 HEAP32[$lag >> 2] = HEAP32[(HEAP32[$pitchL$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2];
 if ((HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2] | 0) > 1) $cond = HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2] | 0; else $cond = 1;
 HEAP32[$inv_gain_Q31 >> 2] = _silk_INVERSE32_varQ($cond, 47) | 0;
 HEAP32[$inv_gain_Q26 >> 2] = (HEAP32[$inv_gain_Q31 >> 2] >> 4) + 1 >> 1;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0)) break;
  $mul = Math_imul(HEAP16[(HEAP32[$x16$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] >> 16, (HEAP32[$inv_gain_Q26 >> 2] & 65535) << 16 >> 16) | 0;
  $add15 = $mul + ((Math_imul(HEAP16[(HEAP32[$x16$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] & 65535, (HEAP32[$inv_gain_Q26 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add22 = $add15 + (Math_imul(HEAP16[(HEAP32[$x16$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, (HEAP32[$inv_gain_Q26 >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[(HEAP32[$x_sc_Q10$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $add22;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L8 : do if (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4348 >> 2] | 0) {
  if (!(HEAP32[$subfr$addr >> 2] | 0)) {
   $mul30 = Math_imul(HEAP32[$inv_gain_Q31 >> 2] >> 16, (HEAP32[$LTP_scale_Q14$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[$inv_gain_Q31 >> 2] = $mul30 + ((Math_imul(HEAP32[$inv_gain_Q31 >> 2] & 65535, (HEAP32[$LTP_scale_Q14$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16) << 2;
  }
  HEAP32[$i >> 2] = (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0) - (HEAP32[$lag >> 2] | 0) - 2;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0)) break L8;
   $mul46 = Math_imul(HEAP32[$inv_gain_Q31 >> 2] >> 16, HEAP16[(HEAP32[$sLTP$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
   $add52 = $mul46 + ((Math_imul(HEAP32[$inv_gain_Q31 >> 2] & 65535, HEAP16[(HEAP32[$sLTP$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) >> 16) | 0;
   HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $add52;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 if ((HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2] | 0) == (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4344 >> 2] | 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$gain_adj_Q16 >> 2] = _silk_DIV32_varQ_419(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4344 >> 2] | 0, HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2] | 0, 16) | 0;
 HEAP32[$i >> 2] = (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0) - (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0);
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] | 0)) break;
  $mul75 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
  $add83 = $mul75 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add90 = $add83 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[$i >> 2] << 2) >> 2] = $add90;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L24 : do if ((HEAP32[$signal_type$addr >> 2] | 0) == 2) if (!(HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4348 >> 2] | 0)) {
  HEAP32[$i >> 2] = (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0) - (HEAP32[$lag >> 2] | 0) - 2;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] | 0)) break L24;
   $mul114 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
   $add121 = $mul114 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   $add127 = $add121 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
   HEAP32[(HEAP32[$sLTP_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $add127;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 $mul136 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] & 65535) << 16 >> 16) | 0;
 $add143 = $mul136 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
 $add149 = $add143 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] >> 15) + 1 >> 1) | 0) | 0;
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4320 >> 2] = $add149;
 $mul154 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4324 >> 2] & 65535) << 16 >> 16) | 0;
 $add161 = $mul154 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4324 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
 $add167 = $add161 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4324 >> 2] >> 15) + 1 >> 1) | 0) | 0;
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4324 >> 2] = $add167;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 16) break;
  $mul177 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 3840 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
  $add185 = $mul177 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 3840 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add192 = $add185 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 3840 + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 3840 + (HEAP32[$i >> 2] << 2) >> 2] = $add192;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 24) break;
  $mul206 = Math_imul(HEAP32[$gain_adj_Q16 >> 2] >> 16, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4224 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
  $add214 = $mul206 + ((Math_imul(HEAP32[$gain_adj_Q16 >> 2] & 65535, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4224 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add221 = $add214 + (Math_imul(HEAP32[$gain_adj_Q16 >> 2] | 0, (HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4224 + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4224 + (HEAP32[$i >> 2] << 2) >> 2] = $add221;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4344 >> 2] = HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$subfr$addr >> 2] << 2) >> 2];
 STACKTOP = sp;
 return;
}

function _remove_doubling($x, $maxperiod, $minperiod, $N, $T0_, $prev_period, $prev_gain, $arch) {
 $x = $x | 0;
 $maxperiod = $maxperiod | 0;
 $minperiod = $minperiod | 0;
 $N = $N | 0;
 $T0_ = $T0_ | 0;
 $prev_period = $prev_period | 0;
 $prev_gain = +$prev_gain;
 $arch = $arch | 0;
 var $15 = 0, $156 = 0.0, $157 = 0, $3 = 0, $65 = 0, $N$addr = 0, $T = 0, $T0 = 0, $T0_$addr = 0, $T1 = 0, $T1b = 0, $add = 0, $arch$addr = 0, $best_xy = 0, $best_yy = 0, $call = 0.0, $call138 = 0.0, $cond109 = 0.0, $cond84 = 0.0, $cond96 = 0.0, $cont = 0, $g = 0, $g0 = 0, $g1 = 0, $i = 0, $k = 0, $maxperiod$addr = 0, $minperiod$addr = 0, $minperiod0 = 0, $mul42 = 0, $mul69 = 0, $offset = 0, $pg = 0, $prev_gain$addr = 0, $prev_period$addr = 0, $saved_stack = 0, $thresh = 0, $vla = 0, $x$addr = 0, $xcorr = 0, $xx = 0, $xy = 0, $xy2 = 0, $yy = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $x$addr = sp + 124 | 0;
 $maxperiod$addr = sp + 120 | 0;
 $minperiod$addr = sp + 116 | 0;
 $N$addr = sp + 112 | 0;
 $T0_$addr = sp + 108 | 0;
 $prev_period$addr = sp + 104 | 0;
 $prev_gain$addr = sp + 100 | 0;
 $arch$addr = sp + 96 | 0;
 $k = sp + 92 | 0;
 $i = sp + 88 | 0;
 $T = sp + 84 | 0;
 $T0 = sp + 80 | 0;
 $g = sp + 76 | 0;
 $g0 = sp + 72 | 0;
 $pg = sp + 68 | 0;
 $xy = sp + 64 | 0;
 $xx = sp + 60 | 0;
 $yy = sp + 56 | 0;
 $xy2 = sp + 52 | 0;
 $xcorr = sp + 40 | 0;
 $best_xy = sp + 36 | 0;
 $best_yy = sp + 32 | 0;
 $offset = sp + 28 | 0;
 $minperiod0 = sp + 24 | 0;
 $saved_stack = sp + 20 | 0;
 $T1 = sp + 16 | 0;
 $T1b = sp + 12 | 0;
 $g1 = sp + 8 | 0;
 $cont = sp + 4 | 0;
 $thresh = sp;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$maxperiod$addr >> 2] = $maxperiod;
 HEAP32[$minperiod$addr >> 2] = $minperiod;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$T0_$addr >> 2] = $T0_;
 HEAP32[$prev_period$addr >> 2] = $prev_period;
 HEAPF32[$prev_gain$addr >> 2] = $prev_gain;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$minperiod0 >> 2] = HEAP32[$minperiod$addr >> 2];
 HEAP32[$maxperiod$addr >> 2] = (HEAP32[$maxperiod$addr >> 2] | 0) / 2 | 0;
 HEAP32[$minperiod$addr >> 2] = (HEAP32[$minperiod$addr >> 2] | 0) / 2 | 0;
 $3 = HEAP32[$T0_$addr >> 2] | 0;
 HEAP32[$3 >> 2] = (HEAP32[$3 >> 2] | 0) / 2 | 0;
 HEAP32[$prev_period$addr >> 2] = (HEAP32[$prev_period$addr >> 2] | 0) / 2 | 0;
 HEAP32[$N$addr >> 2] = (HEAP32[$N$addr >> 2] | 0) / 2 | 0;
 HEAP32[$x$addr >> 2] = (HEAP32[$x$addr >> 2] | 0) + (HEAP32[$maxperiod$addr >> 2] << 2);
 if ((HEAP32[HEAP32[$T0_$addr >> 2] >> 2] | 0) >= (HEAP32[$maxperiod$addr >> 2] | 0)) HEAP32[HEAP32[$T0_$addr >> 2] >> 2] = (HEAP32[$maxperiod$addr >> 2] | 0) - 1;
 $15 = HEAP32[HEAP32[$T0_$addr >> 2] >> 2] | 0;
 HEAP32[$T0 >> 2] = $15;
 HEAP32[$T >> 2] = $15;
 $add = (HEAP32[$maxperiod$addr >> 2] | 0) + 1 | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add << 2) | 0) + 15 & -16) | 0;
 FUNCTION_TABLE_viiiiii[HEAP32[_DUAL_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$x$addr >> 2] | 0, HEAP32[$x$addr >> 2] | 0, (HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[$T0 >> 2] | 0) << 2) | 0, HEAP32[$N$addr >> 2] | 0, $xx, $xy);
 HEAPF32[$vla >> 2] = +HEAPF32[$xx >> 2];
 HEAPF32[$yy >> 2] = +HEAPF32[$xx >> 2];
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) > (HEAP32[$maxperiod$addr >> 2] | 0)) break;
  HEAPF32[$yy >> 2] = +HEAPF32[$yy >> 2] + +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[$i >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$N$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$N$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 2) >> 2];
  HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = 0.0 > +HEAPF32[$yy >> 2] ? 0.0 : +HEAPF32[$yy >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[$yy >> 2] = +HEAPF32[$vla + (HEAP32[$T0 >> 2] << 2) >> 2];
 HEAPF32[$best_xy >> 2] = +HEAPF32[$xy >> 2];
 HEAPF32[$best_yy >> 2] = +HEAPF32[$yy >> 2];
 $call = +_compute_pitch_gain(+HEAPF32[$xy >> 2], +HEAPF32[$xx >> 2], +HEAPF32[$yy >> 2]);
 HEAPF32[$g0 >> 2] = $call;
 HEAPF32[$g >> 2] = $call;
 HEAP32[$k >> 2] = 2;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) > 15) break;
  HEAPF32[$cont >> 2] = 0.0;
  HEAP32[$T1 >> 2] = _celt_udiv_110((HEAP32[$T0 >> 2] << 1) + (HEAP32[$k >> 2] | 0) | 0, HEAP32[$k >> 2] << 1) | 0;
  if ((HEAP32[$T1 >> 2] | 0) < (HEAP32[$minperiod$addr >> 2] | 0)) break;
  do if ((HEAP32[$k >> 2] | 0) == 2) {
   $65 = HEAP32[$T0 >> 2] | 0;
   if (((HEAP32[$T1 >> 2] | 0) + (HEAP32[$T0 >> 2] | 0) | 0) > (HEAP32[$maxperiod$addr >> 2] | 0)) {
    HEAP32[$T1b >> 2] = $65;
    break;
   } else {
    HEAP32[$T1b >> 2] = $65 + (HEAP32[$T1 >> 2] | 0);
    break;
   }
  } else {
   $mul42 = Math_imul(HEAP32[14836 + (HEAP32[$k >> 2] << 2) >> 2] << 1, HEAP32[$T0 >> 2] | 0) | 0;
   HEAP32[$T1b >> 2] = _celt_udiv_110($mul42 + (HEAP32[$k >> 2] | 0) | 0, HEAP32[$k >> 2] << 1) | 0;
  } while (0);
  FUNCTION_TABLE_viiiiii[HEAP32[_DUAL_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$x$addr >> 2] | 0, (HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[$T1 >> 2] | 0) << 2) | 0, (HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[$T1b >> 2] | 0) << 2) | 0, HEAP32[$N$addr >> 2] | 0, $xy, $xy2);
  HEAPF32[$xy >> 2] = (+HEAPF32[$xy >> 2] + +HEAPF32[$xy2 >> 2]) * .5;
  HEAPF32[$yy >> 2] = (+HEAPF32[$vla + (HEAP32[$T1 >> 2] << 2) >> 2] + +HEAPF32[$vla + (HEAP32[$T1b >> 2] << 2) >> 2]) * .5;
  HEAPF32[$g1 >> 2] = +_compute_pitch_gain(+HEAPF32[$xy >> 2], +HEAPF32[$xx >> 2], +HEAPF32[$yy >> 2]);
  do if ((Math_abs((HEAP32[$T1 >> 2] | 0) - (HEAP32[$prev_period$addr >> 2] | 0) | 0) | 0) <= 1) HEAPF32[$cont >> 2] = +HEAPF32[$prev_gain$addr >> 2]; else {
   if ((Math_abs((HEAP32[$T1 >> 2] | 0) - (HEAP32[$prev_period$addr >> 2] | 0) | 0) | 0) <= 2) {
    $mul69 = Math_imul((HEAP32[$k >> 2] | 0) * 5 | 0, HEAP32[$k >> 2] | 0) | 0;
    if (($mul69 | 0) < (HEAP32[$T0 >> 2] | 0)) {
     HEAPF32[$cont >> 2] = +HEAPF32[$prev_gain$addr >> 2] * .5;
     break;
    }
   }
   HEAPF32[$cont >> 2] = 0.0;
  } while (0);
  if (.30000001192092896 > +HEAPF32[$g0 >> 2] * .699999988079071 - +HEAPF32[$cont >> 2]) $cond84 = .30000001192092896; else $cond84 = +HEAPF32[$g0 >> 2] * .699999988079071 - +HEAPF32[$cont >> 2];
  HEAPF32[$thresh >> 2] = $cond84;
  if ((HEAP32[$T1 >> 2] | 0) < ((HEAP32[$minperiod$addr >> 2] | 0) * 3 | 0)) {
   if (.4000000059604645 > +HEAPF32[$g0 >> 2] * .8500000238418579 - +HEAPF32[$cont >> 2]) $cond96 = .4000000059604645; else $cond96 = +HEAPF32[$g0 >> 2] * .8500000238418579 - +HEAPF32[$cont >> 2];
   HEAPF32[$thresh >> 2] = $cond96;
  } else if ((HEAP32[$T1 >> 2] | 0) < (HEAP32[$minperiod$addr >> 2] << 1 | 0)) {
   if (.5 > +HEAPF32[$g0 >> 2] * .8999999761581421 - +HEAPF32[$cont >> 2]) $cond109 = .5; else $cond109 = +HEAPF32[$g0 >> 2] * .8999999761581421 - +HEAPF32[$cont >> 2];
   HEAPF32[$thresh >> 2] = $cond109;
  }
  if (+HEAPF32[$g1 >> 2] > +HEAPF32[$thresh >> 2]) {
   HEAPF32[$best_xy >> 2] = +HEAPF32[$xy >> 2];
   HEAPF32[$best_yy >> 2] = +HEAPF32[$yy >> 2];
   HEAP32[$T >> 2] = HEAP32[$T1 >> 2];
   HEAPF32[$g >> 2] = +HEAPF32[$g1 >> 2];
  }
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAPF32[$best_xy >> 2] = 0.0 > +HEAPF32[$best_xy >> 2] ? 0.0 : +HEAPF32[$best_xy >> 2];
 if (+HEAPF32[$best_yy >> 2] <= +HEAPF32[$best_xy >> 2]) HEAPF32[$pg >> 2] = 1.0; else HEAPF32[$pg >> 2] = +HEAPF32[$best_xy >> 2] / (+HEAPF32[$best_yy >> 2] + 1.0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= 3) break;
  $call138 = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$x$addr >> 2] | 0, (HEAP32[$x$addr >> 2] | 0) + (0 - ((HEAP32[$T >> 2] | 0) + (HEAP32[$k >> 2] | 0) - 1) << 2) | 0, HEAP32[$N$addr >> 2] | 0);
  HEAPF32[$xcorr + (HEAP32[$k >> 2] << 2) >> 2] = $call138;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 do if (+HEAPF32[$xcorr + 8 >> 2] - +HEAPF32[$xcorr >> 2] > (+HEAPF32[$xcorr + 4 >> 2] - +HEAPF32[$xcorr >> 2]) * .699999988079071) HEAP32[$offset >> 2] = 1; else if (+HEAPF32[$xcorr >> 2] - +HEAPF32[$xcorr + 8 >> 2] > (+HEAPF32[$xcorr + 4 >> 2] - +HEAPF32[$xcorr + 8 >> 2]) * .699999988079071) {
  HEAP32[$offset >> 2] = -1;
  break;
 } else {
  HEAP32[$offset >> 2] = 0;
  break;
 } while (0);
 if (+HEAPF32[$pg >> 2] > +HEAPF32[$g >> 2]) HEAPF32[$pg >> 2] = +HEAPF32[$g >> 2];
 HEAP32[HEAP32[$T0_$addr >> 2] >> 2] = (HEAP32[$T >> 2] << 1) + (HEAP32[$offset >> 2] | 0);
 if ((HEAP32[HEAP32[$T0_$addr >> 2] >> 2] | 0) >= (HEAP32[$minperiod0 >> 2] | 0)) {
  $156 = +HEAPF32[$pg >> 2];
  $157 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($157 | 0);
  STACKTOP = sp;
  return +$156;
 }
 HEAP32[HEAP32[$T0_$addr >> 2] >> 2] = HEAP32[$minperiod0 >> 2];
 $156 = +HEAPF32[$pg >> 2];
 $157 = HEAP32[$saved_stack >> 2] | 0;
 _llvm_stackrestore($157 | 0);
 STACKTOP = sp;
 return +$156;
}

function _silk_encode_indices($psEncC, $psRangeEnc, $FrameIndex, $encode_LBRR, $condCoding) {
 $psEncC = $psEncC | 0;
 $psRangeEnc = $psRangeEnc | 0;
 $FrameIndex = $FrameIndex | 0;
 $encode_LBRR = $encode_LBRR | 0;
 $condCoding = $condCoding | 0;
 var $1 = 0, $10 = 0, $12 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $23 = 0, $24 = 0, $61 = 0, $9 = 0, $FrameIndex$addr = 0, $Seed = 0, $condCoding$addr = 0, $conv11 = 0, $conv168 = 0, $conv170 = 0, $delta_lagIndex = 0, $ec_ix = 0, $ec_prevSignalType169 = 0, $encode_LBRR$addr = 0, $encode_absolute_lagIndex = 0, $i = 0, $k = 0, $pitch_high_bits = 0, $pitch_low_bits = 0, $pred_Q8 = 0, $psEncC$addr = 0, $psIndices = 0, $psRangeEnc$addr = 0, $signalType167 = 0, $typeOffset = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $psEncC$addr = sp + 48 | 0;
 $psRangeEnc$addr = sp + 44 | 0;
 $FrameIndex$addr = sp + 40 | 0;
 $encode_LBRR$addr = sp + 36 | 0;
 $condCoding$addr = sp + 32 | 0;
 $i = sp + 28 | 0;
 $k = sp + 24 | 0;
 $typeOffset = sp + 20 | 0;
 $encode_absolute_lagIndex = sp + 16 | 0;
 $delta_lagIndex = sp + 12 | 0;
 $ec_ix = sp + 56 | 0;
 $pred_Q8 = sp + 88 | 0;
 $psIndices = sp + 8 | 0;
 $pitch_high_bits = sp + 4 | 0;
 $pitch_low_bits = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$psRangeEnc$addr >> 2] = $psRangeEnc;
 HEAP32[$FrameIndex$addr >> 2] = $FrameIndex;
 HEAP32[$encode_LBRR$addr >> 2] = $encode_LBRR;
 HEAP32[$condCoding$addr >> 2] = $condCoding;
 $1 = HEAP32[$psEncC$addr >> 2] | 0;
 if (HEAP32[$encode_LBRR$addr >> 2] | 0) HEAP32[$psIndices >> 2] = $1 + 6096 + ((HEAP32[$FrameIndex$addr >> 2] | 0) * 36 | 0); else HEAP32[$psIndices >> 2] = $1 + 4732;
 HEAP32[$typeOffset >> 2] = (HEAP8[(HEAP32[$psIndices >> 2] | 0) + 29 >> 0] << 1) + (HEAP8[(HEAP32[$psIndices >> 2] | 0) + 30 >> 0] | 0);
 $9 = HEAP32[$psRangeEnc$addr >> 2] | 0;
 $10 = HEAP32[$typeOffset >> 2] | 0;
 if ((HEAP32[$encode_LBRR$addr >> 2] | 0) != 0 | (HEAP32[$typeOffset >> 2] | 0) >= 2) _ec_enc_icdf($9, $10 - 2 | 0, 32221, 8); else _ec_enc_icdf($9, $10, 32225, 8);
 $12 = HEAP32[$psRangeEnc$addr >> 2] | 0;
 $conv11 = HEAP8[HEAP32[$psIndices >> 2] >> 0] | 0;
 if ((HEAP32[$condCoding$addr >> 2] | 0) == 2) _ec_enc_icdf($12, $conv11, 31684, 8); else {
  _ec_enc_icdf($12, $conv11 >> 3, 31660 + (HEAP8[(HEAP32[$psIndices >> 2] | 0) + 29 >> 0] << 3) | 0, 8);
  _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[HEAP32[$psIndices >> 2] >> 0] & 7, 32250, 8);
 }
 HEAP32[$i >> 2] = 1;
 while (1) {
  $23 = HEAP32[$psRangeEnc$addr >> 2] | 0;
  $24 = HEAP32[$psIndices >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  _ec_enc_icdf($23, HEAP8[$24 + (HEAP32[$i >> 2] | 0) >> 0] | 0, 31684, 8);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _ec_enc_icdf($23, HEAP8[$24 + 8 >> 0] | 0, (HEAP32[(HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4688 >> 2] | 0) + 16 >> 2] | 0) + (Math_imul(HEAP8[(HEAP32[$psIndices >> 2] | 0) + 29 >> 0] >> 1, HEAP16[HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4688 >> 2] >> 1] | 0) | 0) | 0, 8);
 _silk_NLSF_unpack($ec_ix, $pred_Q8, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4688 >> 2] | 0, HEAP8[(HEAP32[$psIndices >> 2] | 0) + 8 >> 0] | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP16[(HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4688 >> 2] | 0) + 2 >> 1] | 0)) break;
  do if ((HEAP8[(HEAP32[$psIndices >> 2] | 0) + 8 + ((HEAP32[$i >> 2] | 0) + 1) >> 0] | 0) >= 4) {
   _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, 8, (HEAP32[(HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4688 >> 2] | 0) + 28 >> 2] | 0) + (HEAP16[$ec_ix + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0, 8);
   _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, (HEAP8[(HEAP32[$psIndices >> 2] | 0) + 8 + ((HEAP32[$i >> 2] | 0) + 1) >> 0] | 0) - 4 | 0, 32258, 8);
  } else {
   $61 = HEAP32[$psRangeEnc$addr >> 2] | 0;
   if ((HEAP8[(HEAP32[$psIndices >> 2] | 0) + 8 + ((HEAP32[$i >> 2] | 0) + 1) >> 0] | 0) <= -4) {
    _ec_enc_icdf($61, 0, (HEAP32[(HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4688 >> 2] | 0) + 28 >> 2] | 0) + (HEAP16[$ec_ix + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0, 8);
    _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, 0 - (HEAP8[(HEAP32[$psIndices >> 2] | 0) + 8 + ((HEAP32[$i >> 2] | 0) + 1) >> 0] | 0) - 4 | 0, 32258, 8);
    break;
   } else {
    _ec_enc_icdf($61, (HEAP8[(HEAP32[$psIndices >> 2] | 0) + 8 + ((HEAP32[$i >> 2] | 0) + 1) >> 0] | 0) + 4 | 0, (HEAP32[(HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4688 >> 2] | 0) + 28 >> 2] | 0) + (HEAP16[$ec_ix + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0, 8);
    break;
   }
  } while (0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0) == 4) _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psIndices >> 2] | 0) + 31 >> 0] | 0, 32227, 8);
 if ((HEAP8[(HEAP32[$psIndices >> 2] | 0) + 29 >> 0] | 0) != 2) {
  $141 = HEAP32[$psIndices >> 2] | 0;
  $signalType167 = $141 + 29 | 0;
  $142 = HEAP8[$signalType167 >> 0] | 0;
  $conv168 = $142 << 24 >> 24;
  $143 = HEAP32[$psEncC$addr >> 2] | 0;
  $ec_prevSignalType169 = $143 + 5764 | 0;
  HEAP32[$ec_prevSignalType169 >> 2] = $conv168;
  $144 = HEAP32[$psRangeEnc$addr >> 2] | 0;
  $145 = HEAP32[$psIndices >> 2] | 0;
  $Seed = $145 + 34 | 0;
  $146 = HEAP8[$Seed >> 0] | 0;
  $conv170 = $146 << 24 >> 24;
  _ec_enc_icdf($144, $conv170, 32235, 8);
  STACKTOP = sp;
  return;
 }
 HEAP32[$encode_absolute_lagIndex >> 2] = 1;
 if ((HEAP32[$condCoding$addr >> 2] | 0) == 2) if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 5764 >> 2] | 0) == 2) {
  HEAP32[$delta_lagIndex >> 2] = (HEAP16[(HEAP32[$psIndices >> 2] | 0) + 26 >> 1] | 0) - (HEAP16[(HEAP32[$psEncC$addr >> 2] | 0) + 5768 >> 1] | 0);
  if ((HEAP32[$delta_lagIndex >> 2] | 0) < -8 | (HEAP32[$delta_lagIndex >> 2] | 0) > 11) HEAP32[$delta_lagIndex >> 2] = 0; else {
   HEAP32[$delta_lagIndex >> 2] = (HEAP32[$delta_lagIndex >> 2] | 0) + 9;
   HEAP32[$encode_absolute_lagIndex >> 2] = 0;
  }
  _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$delta_lagIndex >> 2] | 0, 32297, 8);
 }
 if (HEAP32[$encode_absolute_lagIndex >> 2] | 0) {
  HEAP32[$pitch_high_bits >> 2] = (HEAP16[(HEAP32[$psIndices >> 2] | 0) + 26 >> 1] | 0) / (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] >> 1 | 0) | 0;
  HEAP32[$pitch_low_bits >> 2] = (HEAP16[(HEAP32[$psIndices >> 2] | 0) + 26 >> 1] | 0) - (Math_imul((HEAP32[$pitch_high_bits >> 2] & 65535) << 16 >> 16, (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] >> 1 & 65535) << 16 >> 16) | 0);
  _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pitch_high_bits >> 2] | 0, 32265, 8);
  _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pitch_low_bits >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4680 >> 2] | 0, 8);
 }
 HEAP16[(HEAP32[$psEncC$addr >> 2] | 0) + 5768 >> 1] = HEAP16[(HEAP32[$psIndices >> 2] | 0) + 26 >> 1] | 0;
 _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psIndices >> 2] | 0) + 28 >> 0] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4684 >> 2] | 0, 8);
 _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psIndices >> 2] | 0) + 32 >> 0] | 0, 31725, 8);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psIndices >> 2] | 0) + 4 + (HEAP32[$k >> 2] | 0) >> 0] | 0, HEAP32[15056 + (HEAP8[(HEAP32[$psIndices >> 2] | 0) + 32 >> 0] << 2) >> 2] | 0, 8);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 if (HEAP32[$condCoding$addr >> 2] | 0) {
  $141 = HEAP32[$psIndices >> 2] | 0;
  $signalType167 = $141 + 29 | 0;
  $142 = HEAP8[$signalType167 >> 0] | 0;
  $conv168 = $142 << 24 >> 24;
  $143 = HEAP32[$psEncC$addr >> 2] | 0;
  $ec_prevSignalType169 = $143 + 5764 | 0;
  HEAP32[$ec_prevSignalType169 >> 2] = $conv168;
  $144 = HEAP32[$psRangeEnc$addr >> 2] | 0;
  $145 = HEAP32[$psIndices >> 2] | 0;
  $Seed = $145 + 34 | 0;
  $146 = HEAP8[$Seed >> 0] | 0;
  $conv170 = $146 << 24 >> 24;
  _ec_enc_icdf($144, $conv170, 32235, 8);
  STACKTOP = sp;
  return;
 }
 _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$psIndices >> 2] | 0) + 33 >> 0] | 0, 32218, 8);
 $141 = HEAP32[$psIndices >> 2] | 0;
 $signalType167 = $141 + 29 | 0;
 $142 = HEAP8[$signalType167 >> 0] | 0;
 $conv168 = $142 << 24 >> 24;
 $143 = HEAP32[$psEncC$addr >> 2] | 0;
 $ec_prevSignalType169 = $143 + 5764 | 0;
 HEAP32[$ec_prevSignalType169 >> 2] = $conv168;
 $144 = HEAP32[$psRangeEnc$addr >> 2] | 0;
 $145 = HEAP32[$psIndices >> 2] | 0;
 $Seed = $145 + 34 | 0;
 $146 = HEAP8[$Seed >> 0] | 0;
 $conv170 = $146 << 24 >> 24;
 _ec_enc_icdf($144, $conv170, 32235, 8);
 STACKTOP = sp;
 return;
}

function _silk_VQ_WMat_EC_c($ind, $res_nrg_Q15, $rate_dist_Q8, $gain_Q7, $XX_Q17, $xX_Q17, $cb_Q7, $cb_gain_Q7, $cl_Q5, $subfr_len, $max_gain_Q7, $L) {
 $ind = $ind | 0;
 $res_nrg_Q15 = $res_nrg_Q15 | 0;
 $rate_dist_Q8 = $rate_dist_Q8 | 0;
 $gain_Q7 = $gain_Q7 | 0;
 $XX_Q17 = $XX_Q17 | 0;
 $xX_Q17 = $xX_Q17 | 0;
 $cb_Q7 = $cb_Q7 | 0;
 $cb_gain_Q7 = $cb_gain_Q7 | 0;
 $cl_Q5 = $cl_Q5 | 0;
 $subfr_len = $subfr_len | 0;
 $max_gain_Q7 = $max_gain_Q7 | 0;
 $L = $L | 0;
 var $L$addr = 0, $XX_Q17$addr = 0, $bits_res_Q8 = 0, $bits_tot_Q8 = 0, $cb_Q7$addr = 0, $cb_gain_Q7$addr = 0, $cb_row_Q7 = 0, $cl_Q5$addr = 0, $cond = 0, $conv173 = 0, $gain_Q7$addr = 0, $gain_tmp_Q7 = 0, $ind$addr = 0, $k = 0, $max_gain_Q7$addr = 0, $mul116 = 0, $mul141 = 0, $mul161 = 0, $mul52 = 0, $mul86 = 0, $neg_xX_Q24 = 0, $penalty = 0, $rate_dist_Q8$addr = 0, $res_nrg_Q15$addr = 0, $subfr_len$addr = 0, $sum1_Q15 = 0, $sum2_Q24 = 0, $xX_Q17$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $ind$addr = sp + 96 | 0;
 $res_nrg_Q15$addr = sp + 92 | 0;
 $rate_dist_Q8$addr = sp + 88 | 0;
 $gain_Q7$addr = sp + 84 | 0;
 $XX_Q17$addr = sp + 80 | 0;
 $xX_Q17$addr = sp + 76 | 0;
 $cb_Q7$addr = sp + 72 | 0;
 $cb_gain_Q7$addr = sp + 68 | 0;
 $cl_Q5$addr = sp + 64 | 0;
 $subfr_len$addr = sp + 60 | 0;
 $max_gain_Q7$addr = sp + 56 | 0;
 $L$addr = sp + 52 | 0;
 $k = sp + 48 | 0;
 $gain_tmp_Q7 = sp + 44 | 0;
 $cb_row_Q7 = sp + 40 | 0;
 $neg_xX_Q24 = sp + 20 | 0;
 $sum1_Q15 = sp + 16 | 0;
 $sum2_Q24 = sp + 12 | 0;
 $bits_res_Q8 = sp + 8 | 0;
 $bits_tot_Q8 = sp + 4 | 0;
 $penalty = sp;
 HEAP32[$ind$addr >> 2] = $ind;
 HEAP32[$res_nrg_Q15$addr >> 2] = $res_nrg_Q15;
 HEAP32[$rate_dist_Q8$addr >> 2] = $rate_dist_Q8;
 HEAP32[$gain_Q7$addr >> 2] = $gain_Q7;
 HEAP32[$XX_Q17$addr >> 2] = $XX_Q17;
 HEAP32[$xX_Q17$addr >> 2] = $xX_Q17;
 HEAP32[$cb_Q7$addr >> 2] = $cb_Q7;
 HEAP32[$cb_gain_Q7$addr >> 2] = $cb_gain_Q7;
 HEAP32[$cl_Q5$addr >> 2] = $cl_Q5;
 HEAP32[$subfr_len$addr >> 2] = $subfr_len;
 HEAP32[$max_gain_Q7$addr >> 2] = $max_gain_Q7;
 HEAP32[$L$addr >> 2] = $L;
 HEAP32[$neg_xX_Q24 >> 2] = 0 - (HEAP32[HEAP32[$xX_Q17$addr >> 2] >> 2] << 7);
 HEAP32[$neg_xX_Q24 + 4 >> 2] = 0 - (HEAP32[(HEAP32[$xX_Q17$addr >> 2] | 0) + 4 >> 2] << 7);
 HEAP32[$neg_xX_Q24 + 8 >> 2] = 0 - (HEAP32[(HEAP32[$xX_Q17$addr >> 2] | 0) + 8 >> 2] << 7);
 HEAP32[$neg_xX_Q24 + 12 >> 2] = 0 - (HEAP32[(HEAP32[$xX_Q17$addr >> 2] | 0) + 12 >> 2] << 7);
 HEAP32[$neg_xX_Q24 + 16 >> 2] = 0 - (HEAP32[(HEAP32[$xX_Q17$addr >> 2] | 0) + 16 >> 2] << 7);
 HEAP32[HEAP32[$rate_dist_Q8$addr >> 2] >> 2] = 2147483647;
 HEAP32[HEAP32[$res_nrg_Q15$addr >> 2] >> 2] = 2147483647;
 HEAP32[$cb_row_Q7 >> 2] = HEAP32[$cb_Q7$addr >> 2];
 HEAP8[HEAP32[$ind$addr >> 2] >> 0] = 0;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$L$addr >> 2] | 0)) break;
  HEAP32[$gain_tmp_Q7 >> 2] = HEAPU8[(HEAP32[$cb_gain_Q7$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0];
  HEAP32[$sum1_Q15 >> 2] = 32801;
  if (((HEAP32[$gain_tmp_Q7 >> 2] | 0) - (HEAP32[$max_gain_Q7$addr >> 2] | 0) | 0) > 0) $cond = (HEAP32[$gain_tmp_Q7 >> 2] | 0) - (HEAP32[$max_gain_Q7$addr >> 2] | 0) | 0; else $cond = 0;
  HEAP32[$penalty >> 2] = $cond << 11;
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$neg_xX_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 4 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 1 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 8 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 2 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 12 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 3 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 16 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 4 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = HEAP32[$sum2_Q24 >> 2] << 1;
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[HEAP32[$XX_Q17$addr >> 2] >> 2] | 0, HEAP8[HEAP32[$cb_row_Q7 >> 2] >> 0] | 0) | 0);
  $mul52 = Math_imul(HEAP32[$sum2_Q24 >> 2] >> 16, HEAP8[HEAP32[$cb_row_Q7 >> 2] >> 0] << 16 >> 16) | 0;
  HEAP32[$sum1_Q15 >> 2] = (HEAP32[$sum1_Q15 >> 2] | 0) + ($mul52 + ((Math_imul(HEAP32[$sum2_Q24 >> 2] & 65535, HEAP8[HEAP32[$cb_row_Q7 >> 2] >> 0] << 16 >> 16) | 0) >> 16));
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$neg_xX_Q24 + 4 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 28 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 2 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 32 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 3 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 36 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 4 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = HEAP32[$sum2_Q24 >> 2] << 1;
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 24 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 1 >> 0] | 0) | 0);
  $mul86 = Math_imul(HEAP32[$sum2_Q24 >> 2] >> 16, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 1 >> 0] << 16 >> 16) | 0;
  HEAP32[$sum1_Q15 >> 2] = (HEAP32[$sum1_Q15 >> 2] | 0) + ($mul86 + ((Math_imul(HEAP32[$sum2_Q24 >> 2] & 65535, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 1 >> 0] << 16 >> 16) | 0) >> 16));
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$neg_xX_Q24 + 8 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 52 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 3 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 56 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 4 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = HEAP32[$sum2_Q24 >> 2] << 1;
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 48 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 2 >> 0] | 0) | 0);
  $mul116 = Math_imul(HEAP32[$sum2_Q24 >> 2] >> 16, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 2 >> 0] << 16 >> 16) | 0;
  HEAP32[$sum1_Q15 >> 2] = (HEAP32[$sum1_Q15 >> 2] | 0) + ($mul116 + ((Math_imul(HEAP32[$sum2_Q24 >> 2] & 65535, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 2 >> 0] << 16 >> 16) | 0) >> 16));
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$neg_xX_Q24 + 12 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 76 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 4 >> 0] | 0) | 0);
  HEAP32[$sum2_Q24 >> 2] = HEAP32[$sum2_Q24 >> 2] << 1;
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 72 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 3 >> 0] | 0) | 0);
  $mul141 = Math_imul(HEAP32[$sum2_Q24 >> 2] >> 16, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 3 >> 0] << 16 >> 16) | 0;
  HEAP32[$sum1_Q15 >> 2] = (HEAP32[$sum1_Q15 >> 2] | 0) + ($mul141 + ((Math_imul(HEAP32[$sum2_Q24 >> 2] & 65535, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 3 >> 0] << 16 >> 16) | 0) >> 16));
  HEAP32[$sum2_Q24 >> 2] = HEAP32[$neg_xX_Q24 + 16 >> 2] << 1;
  HEAP32[$sum2_Q24 >> 2] = (HEAP32[$sum2_Q24 >> 2] | 0) + (Math_imul(HEAP32[(HEAP32[$XX_Q17$addr >> 2] | 0) + 96 >> 2] | 0, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 4 >> 0] | 0) | 0);
  $mul161 = Math_imul(HEAP32[$sum2_Q24 >> 2] >> 16, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 4 >> 0] << 16 >> 16) | 0;
  HEAP32[$sum1_Q15 >> 2] = (HEAP32[$sum1_Q15 >> 2] | 0) + ($mul161 + ((Math_imul(HEAP32[$sum2_Q24 >> 2] & 65535, HEAP8[(HEAP32[$cb_row_Q7 >> 2] | 0) + 4 >> 0] << 16 >> 16) | 0) >> 16));
  if ((HEAP32[$sum1_Q15 >> 2] | 0) >= 0) {
   $conv173 = (HEAP32[$subfr_len$addr >> 2] & 65535) << 16 >> 16;
   HEAP32[$bits_res_Q8 >> 2] = Math_imul($conv173, ((_silk_lin2log((HEAP32[$sum1_Q15 >> 2] | 0) + (HEAP32[$penalty >> 2] | 0) | 0) | 0) - 1920 & 65535) << 16 >> 16) | 0;
   HEAP32[$bits_tot_Q8 >> 2] = (HEAP32[$bits_res_Q8 >> 2] | 0) + (HEAPU8[(HEAP32[$cl_Q5$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] << 2);
   if ((HEAP32[$bits_tot_Q8 >> 2] | 0) <= (HEAP32[HEAP32[$rate_dist_Q8$addr >> 2] >> 2] | 0)) {
    HEAP32[HEAP32[$rate_dist_Q8$addr >> 2] >> 2] = HEAP32[$bits_tot_Q8 >> 2];
    HEAP32[HEAP32[$res_nrg_Q15$addr >> 2] >> 2] = (HEAP32[$sum1_Q15 >> 2] | 0) + (HEAP32[$penalty >> 2] | 0);
    HEAP8[HEAP32[$ind$addr >> 2] >> 0] = HEAP32[$k >> 2];
    HEAP32[HEAP32[$gain_Q7$addr >> 2] >> 2] = HEAP32[$gain_tmp_Q7 >> 2];
   }
  }
  HEAP32[$cb_row_Q7 >> 2] = (HEAP32[$cb_row_Q7 >> 2] | 0) + 5;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _clt_mdct_forward_c($l, $in, $out, $window, $overlap, $shift, $stride, $arch) {
 $l = $l | 0;
 $in = $in | 0;
 $out = $out | 0;
 $window = $window | 0;
 $overlap = $overlap | 0;
 $shift = $shift | 0;
 $stride = $stride | 0;
 $arch = $arch | 0;
 var $107 = 0, $109 = 0, $16 = 0, $39 = 0, $49 = 0, $62 = 0.0, $63 = 0, $65 = 0.0, $66 = 0, $81 = 0, $91 = 0, $N = 0, $N2 = 0, $N4 = 0, $add23 = 0.0, $add59 = 0.0, $add64 = 0.0, $arrayidx97 = 0, $fp = 0, $i = 0, $im = 0, $in$addr = 0, $l$addr = 0, $out$addr = 0, $overlap$addr = 0, $re = 0, $saved_stack = 0, $scale = 0, $shift$addr = 0, $shr = 0, $st = 0, $stride$addr = 0, $sub27 = 0.0, $t = 0, $t0 = 0, $t1 = 0, $t104 = 0, $trig = 0, $vla = 0, $vla5 = 0, $window$addr = 0, $wp1 = 0, $wp2 = 0, $xp1 = 0, $xp2 = 0, $yc = 0, $yi = 0, $yi110 = 0, $yp = 0, $yp1 = 0, $yp2 = 0, $yp73 = 0, $yr = 0, $yr109 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 $l$addr = sp + 144 | 0;
 $in$addr = sp + 140 | 0;
 $out$addr = sp + 136 | 0;
 $window$addr = sp + 132 | 0;
 $overlap$addr = sp + 128 | 0;
 $shift$addr = sp + 124 | 0;
 $stride$addr = sp + 120 | 0;
 $i = sp + 112 | 0;
 $N = sp + 108 | 0;
 $N2 = sp + 104 | 0;
 $N4 = sp + 100 | 0;
 $st = sp + 96 | 0;
 $trig = sp + 92 | 0;
 $scale = sp + 88 | 0;
 $saved_stack = sp + 84 | 0;
 $xp1 = sp + 80 | 0;
 $xp2 = sp + 76 | 0;
 $yp = sp + 72 | 0;
 $wp1 = sp + 68 | 0;
 $wp2 = sp + 64 | 0;
 $yp73 = sp + 60 | 0;
 $t = sp + 56 | 0;
 $yc = sp + 48 | 0;
 $t0 = sp + 44 | 0;
 $t1 = sp + 40 | 0;
 $re = sp + 36 | 0;
 $im = sp + 32 | 0;
 $yr = sp + 28 | 0;
 $yi = sp + 24 | 0;
 $fp = sp + 20 | 0;
 $yp1 = sp + 16 | 0;
 $yp2 = sp + 12 | 0;
 $t104 = sp + 8 | 0;
 $yr109 = sp + 4 | 0;
 $yi110 = sp;
 HEAP32[$l$addr >> 2] = $l;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$window$addr >> 2] = $window;
 HEAP32[$overlap$addr >> 2] = $overlap;
 HEAP32[$shift$addr >> 2] = $shift;
 HEAP32[$stride$addr >> 2] = $stride;
 HEAP32[sp + 116 >> 2] = $arch;
 HEAP32[$st >> 2] = HEAP32[(HEAP32[$l$addr >> 2] | 0) + 8 + (HEAP32[$shift$addr >> 2] << 2) >> 2];
 HEAPF32[$scale >> 2] = +HEAPF32[(HEAP32[$st >> 2] | 0) + 4 >> 2];
 HEAP32[$N >> 2] = HEAP32[HEAP32[$l$addr >> 2] >> 2];
 HEAP32[$trig >> 2] = HEAP32[(HEAP32[$l$addr >> 2] | 0) + 24 >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  $shr = HEAP32[$N >> 2] >> 1;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$shift$addr >> 2] | 0)) break;
  HEAP32[$N >> 2] = $shr;
  HEAP32[$trig >> 2] = (HEAP32[$trig >> 2] | 0) + (HEAP32[$N >> 2] << 2);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$N2 >> 2] = $shr;
 HEAP32[$N4 >> 2] = HEAP32[$N >> 2] >> 2;
 $16 = HEAP32[$N2 >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($16 << 2) | 0) + 15 & -16) | 0;
 $vla5 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$N4 >> 2] << 3) | 0) + 15 & -16) | 0;
 HEAP32[$xp1 >> 2] = (HEAP32[$in$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] >> 1 << 2);
 HEAP32[$xp2 >> 2] = (HEAP32[$in$addr >> 2] | 0) + (HEAP32[$N2 >> 2] << 2) + -4 + (HEAP32[$overlap$addr >> 2] >> 1 << 2);
 HEAP32[$yp >> 2] = $vla;
 HEAP32[$wp1 >> 2] = (HEAP32[$window$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] >> 1 << 2);
 HEAP32[$wp2 >> 2] = (HEAP32[$window$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] >> 1 << 2) + -4;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$overlap$addr >> 2] | 0) + 3 >> 2 | 0)) break;
  $add23 = +HEAPF32[HEAP32[$wp2 >> 2] >> 2] * +HEAPF32[(HEAP32[$xp1 >> 2] | 0) + (HEAP32[$N2 >> 2] << 2) >> 2] + +HEAPF32[HEAP32[$wp1 >> 2] >> 2] * +HEAPF32[HEAP32[$xp2 >> 2] >> 2];
  $39 = HEAP32[$yp >> 2] | 0;
  HEAP32[$yp >> 2] = $39 + 4;
  HEAPF32[$39 >> 2] = $add23;
  $sub27 = +HEAPF32[HEAP32[$wp1 >> 2] >> 2] * +HEAPF32[HEAP32[$xp1 >> 2] >> 2] - +HEAPF32[HEAP32[$wp2 >> 2] >> 2] * +HEAPF32[(HEAP32[$xp2 >> 2] | 0) + (0 - (HEAP32[$N2 >> 2] | 0) << 2) >> 2];
  $49 = HEAP32[$yp >> 2] | 0;
  HEAP32[$yp >> 2] = $49 + 4;
  HEAPF32[$49 >> 2] = $sub27;
  HEAP32[$xp1 >> 2] = (HEAP32[$xp1 >> 2] | 0) + 8;
  HEAP32[$xp2 >> 2] = (HEAP32[$xp2 >> 2] | 0) + -8;
  HEAP32[$wp1 >> 2] = (HEAP32[$wp1 >> 2] | 0) + 8;
  HEAP32[$wp2 >> 2] = (HEAP32[$wp2 >> 2] | 0) + -8;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$wp1 >> 2] = HEAP32[$window$addr >> 2];
 HEAP32[$wp2 >> 2] = (HEAP32[$window$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] << 2) + -4;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$N4 >> 2] | 0) - ((HEAP32[$overlap$addr >> 2] | 0) + 3 >> 2) | 0)) break;
  $62 = +HEAPF32[HEAP32[$xp2 >> 2] >> 2];
  $63 = HEAP32[$yp >> 2] | 0;
  HEAP32[$yp >> 2] = $63 + 4;
  HEAPF32[$63 >> 2] = $62;
  $65 = +HEAPF32[HEAP32[$xp1 >> 2] >> 2];
  $66 = HEAP32[$yp >> 2] | 0;
  HEAP32[$yp >> 2] = $66 + 4;
  HEAPF32[$66 >> 2] = $65;
  HEAP32[$xp1 >> 2] = (HEAP32[$xp1 >> 2] | 0) + 8;
  HEAP32[$xp2 >> 2] = (HEAP32[$xp2 >> 2] | 0) + -8;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N4 >> 2] | 0)) break;
  $add59 = -(+HEAPF32[HEAP32[$wp1 >> 2] >> 2] * +HEAPF32[(HEAP32[$xp1 >> 2] | 0) + (0 - (HEAP32[$N2 >> 2] | 0) << 2) >> 2]) + +HEAPF32[HEAP32[$wp2 >> 2] >> 2] * +HEAPF32[HEAP32[$xp2 >> 2] >> 2];
  $81 = HEAP32[$yp >> 2] | 0;
  HEAP32[$yp >> 2] = $81 + 4;
  HEAPF32[$81 >> 2] = $add59;
  $add64 = +HEAPF32[HEAP32[$wp2 >> 2] >> 2] * +HEAPF32[HEAP32[$xp1 >> 2] >> 2] + +HEAPF32[HEAP32[$wp1 >> 2] >> 2] * +HEAPF32[(HEAP32[$xp2 >> 2] | 0) + (HEAP32[$N2 >> 2] << 2) >> 2];
  $91 = HEAP32[$yp >> 2] | 0;
  HEAP32[$yp >> 2] = $91 + 4;
  HEAPF32[$91 >> 2] = $add64;
  HEAP32[$xp1 >> 2] = (HEAP32[$xp1 >> 2] | 0) + 8;
  HEAP32[$xp2 >> 2] = (HEAP32[$xp2 >> 2] | 0) + -8;
  HEAP32[$wp1 >> 2] = (HEAP32[$wp1 >> 2] | 0) + 8;
  HEAP32[$wp2 >> 2] = (HEAP32[$wp2 >> 2] | 0) + -8;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$yp73 >> 2] = $vla;
 HEAP32[$t >> 2] = HEAP32[$trig >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N4 >> 2] | 0)) break;
  HEAPF32[$t0 >> 2] = +HEAPF32[(HEAP32[$t >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$t1 >> 2] = +HEAPF32[(HEAP32[$t >> 2] | 0) + ((HEAP32[$N4 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
  $107 = HEAP32[$yp73 >> 2] | 0;
  HEAP32[$yp73 >> 2] = $107 + 4;
  HEAPF32[$re >> 2] = +HEAPF32[$107 >> 2];
  $109 = HEAP32[$yp73 >> 2] | 0;
  HEAP32[$yp73 >> 2] = $109 + 4;
  HEAPF32[$im >> 2] = +HEAPF32[$109 >> 2];
  HEAPF32[$yr >> 2] = +HEAPF32[$re >> 2] * +HEAPF32[$t0 >> 2] - +HEAPF32[$im >> 2] * +HEAPF32[$t1 >> 2];
  HEAPF32[$yi >> 2] = +HEAPF32[$im >> 2] * +HEAPF32[$t0 >> 2] + +HEAPF32[$re >> 2] * +HEAPF32[$t1 >> 2];
  HEAPF32[$yc >> 2] = +HEAPF32[$yr >> 2];
  HEAPF32[$yc + 4 >> 2] = +HEAPF32[$yi >> 2];
  HEAPF32[$yc >> 2] = +HEAPF32[$scale >> 2] * +HEAPF32[$yc >> 2];
  HEAPF32[$yc + 4 >> 2] = +HEAPF32[$scale >> 2] * +HEAPF32[$yc + 4 >> 2];
  $arrayidx97 = $vla5 + (HEAP16[(HEAP32[(HEAP32[$st >> 2] | 0) + 44 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << 3) | 0;
  HEAP32[$arrayidx97 >> 2] = HEAP32[$yc >> 2];
  HEAP32[$arrayidx97 + 4 >> 2] = HEAP32[$yc + 4 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _opus_fft_impl(HEAP32[$st >> 2] | 0, $vla5);
 HEAP32[$fp >> 2] = $vla5;
 HEAP32[$yp1 >> 2] = HEAP32[$out$addr >> 2];
 HEAP32[$yp2 >> 2] = (HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$stride$addr >> 2] | 0, (HEAP32[$N2 >> 2] | 0) - 1 | 0) | 0) << 2);
 HEAP32[$t104 >> 2] = HEAP32[$trig >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N4 >> 2] | 0)) break;
  HEAPF32[$yr109 >> 2] = +HEAPF32[(HEAP32[$fp >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$t104 >> 2] | 0) + ((HEAP32[$N4 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] - +HEAPF32[HEAP32[$fp >> 2] >> 2] * +HEAPF32[(HEAP32[$t104 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$yi110 >> 2] = +HEAPF32[HEAP32[$fp >> 2] >> 2] * +HEAPF32[(HEAP32[$t104 >> 2] | 0) + ((HEAP32[$N4 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2] + +HEAPF32[(HEAP32[$fp >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$t104 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[HEAP32[$yp1 >> 2] >> 2] = +HEAPF32[$yr109 >> 2];
  HEAPF32[HEAP32[$yp2 >> 2] >> 2] = +HEAPF32[$yi110 >> 2];
  HEAP32[$fp >> 2] = (HEAP32[$fp >> 2] | 0) + 8;
  HEAP32[$yp1 >> 2] = (HEAP32[$yp1 >> 2] | 0) + (HEAP32[$stride$addr >> 2] << 1 << 2);
  HEAP32[$yp2 >> 2] = (HEAP32[$yp2 >> 2] | 0) + (0 - (HEAP32[$stride$addr >> 2] << 1) << 2);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_decode_indices($psDec, $psRangeDec, $FrameIndex, $decode_LBRR, $condCoding) {
 $psDec = $psDec | 0;
 $psRangeDec = $psRangeDec | 0;
 $FrameIndex = $FrameIndex | 0;
 $decode_LBRR = $decode_LBRR | 0;
 $condCoding = $condCoding | 0;
 var $$sink = 0, $$sink1 = 0, $$sink2 = 0, $$sink3 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $22 = 0, $FrameIndex$addr = 0, $Ix = 0, $Seed = 0, $call181 = 0, $call69 = 0, $call74 = 0, $condCoding$addr = 0, $conv126 = 0, $conv129 = 0, $conv134 = 0, $conv145 = 0, $conv148 = 0, $conv16 = 0, $conv160 = 0, $conv170 = 0, $conv179 = 0, $conv182 = 0, $conv22 = 0, $conv33 = 0, $conv45 = 0, $conv8 = 0, $conv92 = 0, $decode_LBRR$addr = 0, $decode_absolute_lagIndex = 0, $delta_lagIndex = 0, $ec_ix = 0, $ec_prevSignalType180 = 0, $i = 0, $indices177 = 0, $indices183 = 0, $indices23 = 0, $k = 0, $lagIndex136 = 0, $pred_Q8 = 0, $psDec$addr = 0, $psRangeDec$addr = 0, $signalType178 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $psDec$addr = sp + 36 | 0;
 $psRangeDec$addr = sp + 32 | 0;
 $FrameIndex$addr = sp + 28 | 0;
 $decode_LBRR$addr = sp + 24 | 0;
 $condCoding$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $k = sp + 12 | 0;
 $Ix = sp + 8 | 0;
 $decode_absolute_lagIndex = sp + 4 | 0;
 $delta_lagIndex = sp;
 $ec_ix = sp + 40 | 0;
 $pred_Q8 = sp + 72 | 0;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$psRangeDec$addr >> 2] = $psRangeDec;
 HEAP32[$FrameIndex$addr >> 2] = $FrameIndex;
 HEAP32[$decode_LBRR$addr >> 2] = $decode_LBRR;
 HEAP32[$condCoding$addr >> 2] = $condCoding;
 if (HEAP32[$decode_LBRR$addr >> 2] | 0) label = 3; else if (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2404 + (HEAP32[$FrameIndex$addr >> 2] << 2) >> 2] | 0) label = 3; else HEAP32[$Ix >> 2] = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32225, 8) | 0;
 if ((label | 0) == 3) HEAP32[$Ix >> 2] = (_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32221, 8) | 0) + 2;
 HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] = HEAP32[$Ix >> 2] >> 1;
 HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 30 >> 0] = HEAP32[$Ix >> 2] & 1;
 $11 = HEAP32[$psRangeDec$addr >> 2] | 0;
 if ((HEAP32[$condCoding$addr >> 2] | 0) == 2) {
  $conv8 = (_ec_dec_icdf($11, 31684, 8) | 0) & 255;
  HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 >> 0] = $conv8;
 } else {
  $conv16 = (_ec_dec_icdf($11, 31660 + (HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] << 3) | 0, 8) | 0) << 3 & 255;
  HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 >> 0] = $conv16;
  $conv22 = ((_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32250, 8) | 0) & 255) << 24 >> 24;
  $indices23 = (HEAP32[$psDec$addr >> 2] | 0) + 2736 | 0;
  HEAP8[$indices23 >> 0] = (HEAP8[$indices23 >> 0] | 0) + $conv22;
 }
 HEAP32[$i >> 2] = 1;
 while (1) {
  $22 = HEAP32[$psRangeDec$addr >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0)) break;
  $conv33 = (_ec_dec_icdf($22, 31684, 8) | 0) & 255;
  HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + (HEAP32[$i >> 2] | 0) >> 0] = $conv33;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 $conv45 = (_ec_dec_icdf($22, (HEAP32[(HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2732 >> 2] | 0) + 16 >> 2] | 0) + (Math_imul(HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] >> 1, HEAP16[HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2732 >> 2] >> 1] | 0) | 0) | 0, 8) | 0) & 255;
 HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 8 >> 0] = $conv45;
 _silk_NLSF_unpack($ec_ix, $pred_Q8, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2732 >> 2] | 0, HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 8 >> 0] | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP16[(HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2732 >> 2] | 0) + 2 >> 1] | 0)) break;
  HEAP32[$Ix >> 2] = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, (HEAP32[(HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2732 >> 2] | 0) + 28 >> 2] | 0) + (HEAP16[$ec_ix + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0, 8) | 0;
  if (!(HEAP32[$Ix >> 2] | 0)) {
   $call69 = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32258, 8) | 0;
   HEAP32[$Ix >> 2] = (HEAP32[$Ix >> 2] | 0) - $call69;
  } else if ((HEAP32[$Ix >> 2] | 0) == 8) {
   $call74 = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32258, 8) | 0;
   HEAP32[$Ix >> 2] = (HEAP32[$Ix >> 2] | 0) + $call74;
  }
  HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 8 + ((HEAP32[$i >> 2] | 0) + 1) >> 0] = (HEAP32[$Ix >> 2] | 0) - 4;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) == 4) {
  $conv92 = (_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32227, 8) | 0) & 255;
  $$sink = $conv92;
  $$sink1 = HEAP32[$psDec$addr >> 2] | 0;
 } else {
  $$sink = 4;
  $$sink1 = HEAP32[$psDec$addr >> 2] | 0;
 }
 HEAP8[$$sink1 + 2736 + 31 >> 0] = $$sink;
 if ((HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] | 0) != 2) {
  $109 = HEAP32[$psDec$addr >> 2] | 0;
  $indices177 = $109 + 2736 | 0;
  $signalType178 = $indices177 + 29 | 0;
  $110 = HEAP8[$signalType178 >> 0] | 0;
  $conv179 = $110 << 24 >> 24;
  $111 = HEAP32[$psDec$addr >> 2] | 0;
  $ec_prevSignalType180 = $111 + 2396 | 0;
  HEAP32[$ec_prevSignalType180 >> 2] = $conv179;
  $112 = HEAP32[$psRangeDec$addr >> 2] | 0;
  $call181 = _ec_dec_icdf($112, 32235, 8) | 0;
  $conv182 = $call181 & 255;
  $113 = HEAP32[$psDec$addr >> 2] | 0;
  $indices183 = $113 + 2736 | 0;
  $Seed = $indices183 + 34 | 0;
  HEAP8[$Seed >> 0] = $conv182;
  STACKTOP = sp;
  return;
 }
 HEAP32[$decode_absolute_lagIndex >> 2] = 1;
 if ((HEAP32[$condCoding$addr >> 2] | 0) == 2) if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2396 >> 2] | 0) == 2) {
  HEAP32[$delta_lagIndex >> 2] = ((_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32297, 8) | 0) & 65535) << 16 >> 16;
  if ((HEAP32[$delta_lagIndex >> 2] | 0) > 0) {
   HEAP32[$delta_lagIndex >> 2] = (HEAP32[$delta_lagIndex >> 2] | 0) - 9;
   HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 26 >> 1] = (HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2400 >> 1] | 0) + (HEAP32[$delta_lagIndex >> 2] | 0);
   HEAP32[$decode_absolute_lagIndex >> 2] = 0;
  }
 }
 if (HEAP32[$decode_absolute_lagIndex >> 2] | 0) {
  $conv126 = ((_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32265, 8) | 0) & 65535) << 16 >> 16;
  $conv129 = (Math_imul($conv126, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] >> 1) | 0) & 65535;
  HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 26 >> 1] = $conv129;
  $conv134 = ((_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2380 >> 2] | 0, 8) | 0) & 65535) << 16 >> 16;
  $lagIndex136 = (HEAP32[$psDec$addr >> 2] | 0) + 2736 + 26 | 0;
  HEAP16[$lagIndex136 >> 1] = (HEAP16[$lagIndex136 >> 1] | 0) + $conv134;
 }
 HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2400 >> 1] = HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 26 >> 1] | 0;
 $conv145 = (_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2384 >> 2] | 0, 8) | 0) & 255;
 HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 28 >> 0] = $conv145;
 $conv148 = (_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 31725, 8) | 0) & 255;
 HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 32 >> 0] = $conv148;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0)) break;
  $conv160 = (_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[15056 + (HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 32 >> 0] << 2) >> 2] | 0, 8) | 0) & 255;
  HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 4 + (HEAP32[$k >> 2] | 0) >> 0] = $conv160;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 if (!(HEAP32[$condCoding$addr >> 2] | 0)) {
  $conv170 = (_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32218, 8) | 0) & 255;
  $$sink2 = $conv170;
  $$sink3 = HEAP32[$psDec$addr >> 2] | 0;
 } else {
  $$sink2 = 0;
  $$sink3 = HEAP32[$psDec$addr >> 2] | 0;
 }
 HEAP8[$$sink3 + 2736 + 33 >> 0] = $$sink2;
 $109 = HEAP32[$psDec$addr >> 2] | 0;
 $indices177 = $109 + 2736 | 0;
 $signalType178 = $indices177 + 29 | 0;
 $110 = HEAP8[$signalType178 >> 0] | 0;
 $conv179 = $110 << 24 >> 24;
 $111 = HEAP32[$psDec$addr >> 2] | 0;
 $ec_prevSignalType180 = $111 + 2396 | 0;
 HEAP32[$ec_prevSignalType180 >> 2] = $conv179;
 $112 = HEAP32[$psRangeDec$addr >> 2] | 0;
 $call181 = _ec_dec_icdf($112, 32235, 8) | 0;
 $conv182 = $call181 & 255;
 $113 = HEAP32[$psDec$addr >> 2] | 0;
 $indices183 = $113 + 2736 | 0;
 $Seed = $indices183 + 34 | 0;
 HEAP8[$Seed >> 0] = $conv182;
 STACKTOP = sp;
 return;
}

function _opus_pcm_soft_clip($_x, $N, $C, $declip_mem) {
 $_x = $_x | 0;
 $N = $N | 0;
 $C = $C | 0;
 $declip_mem = $declip_mem | 0;
 var $110 = 0.0, $113 = 0, $130 = 0.0, $34 = 0.0, $39 = 0.0, $70 = 0, $79 = 0.0, $90 = 0.0, $C$addr = 0, $N$addr = 0, $_x$addr = 0, $a = 0, $add = 0.0, $add142 = 0.0, $arrayidx162 = 0, $c = 0, $cond = 0.0, $cond173 = 0.0, $cond189 = 0.0, $cond19 = 0.0, $conv97 = 0.0, $curr = 0, $declip_mem$addr = 0, $delta = 0, $end = 0, $i = 0, $maxval = 0, $mul138 = 0.0, $mul38 = 0.0, $offset = 0, $peak_pos = 0, $special = 0, $start = 0, $x = 0, $x0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $_x$addr = sp + 64 | 0;
 $N$addr = sp + 60 | 0;
 $C$addr = sp + 56 | 0;
 $declip_mem$addr = sp + 52 | 0;
 $c = sp + 48 | 0;
 $i = sp + 44 | 0;
 $x = sp + 40 | 0;
 $a = sp + 36 | 0;
 $x0 = sp + 32 | 0;
 $curr = sp + 28 | 0;
 $start = sp + 24 | 0;
 $end = sp + 20 | 0;
 $maxval = sp + 16 | 0;
 $special = sp + 12 | 0;
 $peak_pos = sp + 8 | 0;
 $delta = sp + 4 | 0;
 $offset = sp;
 HEAP32[$_x$addr >> 2] = $_x;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$declip_mem$addr >> 2] = $declip_mem;
 if (!((((HEAP32[$C$addr >> 2] | 0) < 1 | (HEAP32[$N$addr >> 2] | 0) < 1) ^ 1) & (HEAP32[$_x$addr >> 2] | 0) != 0 & (HEAP32[$declip_mem$addr >> 2] | 0) != 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$N$addr >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0)) break;
  if (2.0 < +HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $cond = 2.0; else $cond = +HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  if (-2.0 > $cond) $cond19 = -2.0; else if (2.0 < +HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $cond19 = 2.0; else $cond19 = +HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $cond19;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$c >> 2] = 0;
 while (1) {
  if ((HEAP32[$c >> 2] | 0) >= (HEAP32[$C$addr >> 2] | 0)) break;
  HEAP32[$x >> 2] = (HEAP32[$_x$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2);
  HEAPF32[$a >> 2] = +HEAPF32[(HEAP32[$declip_mem$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
   $34 = +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
   if ($34 * +HEAPF32[$a >> 2] >= 0.0) break;
   $39 = +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
   $mul38 = +HEAPF32[$a >> 2] * +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
   $add = $39 + $mul38 * +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] = $add;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$curr >> 2] = 0;
  HEAPF32[$x0 >> 2] = +HEAPF32[HEAP32[$x >> 2] >> 2];
  do {
   HEAP32[$special >> 2] = 0;
   HEAP32[$i >> 2] = HEAP32[$curr >> 2];
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
    if (+HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] > 1.0) break;
    if (+HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] < -1.0) break;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   if ((HEAP32[$i >> 2] | 0) == (HEAP32[$N$addr >> 2] | 0)) {
    label = 23;
    break;
   }
   HEAP32[$peak_pos >> 2] = HEAP32[$i >> 2];
   $70 = HEAP32[$i >> 2] | 0;
   HEAP32[$end >> 2] = $70;
   HEAP32[$start >> 2] = $70;
   HEAPF32[$maxval >> 2] = +Math_abs(+(+HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2]));
   while (1) {
    if ((HEAP32[$start >> 2] | 0) <= 0) break;
    $79 = +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
    if (!($79 * +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul((HEAP32[$start >> 2] | 0) - 1 | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] >= 0.0)) break;
    HEAP32[$start >> 2] = (HEAP32[$start >> 2] | 0) + -1;
   }
   while (1) {
    if ((HEAP32[$end >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
    $90 = +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
    if (!($90 * +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$end >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] >= 0.0)) break;
    $conv97 = +Math_abs(+(+HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$end >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2]));
    if ($conv97 > +HEAPF32[$maxval >> 2]) {
     HEAPF32[$maxval >> 2] = +Math_abs(+(+HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$end >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2]));
     HEAP32[$peak_pos >> 2] = HEAP32[$end >> 2];
    }
    HEAP32[$end >> 2] = (HEAP32[$end >> 2] | 0) + 1;
   }
   if (!(HEAP32[$start >> 2] | 0)) {
    $110 = +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
    $113 = $110 * +HEAPF32[HEAP32[$x >> 2] >> 2] >= 0.0;
   } else $113 = 0;
   HEAP32[$special >> 2] = $113 & 1;
   HEAPF32[$a >> 2] = (+HEAPF32[$maxval >> 2] - 1.0) / (+HEAPF32[$maxval >> 2] * +HEAPF32[$maxval >> 2]);
   HEAPF32[$a >> 2] = +HEAPF32[$a >> 2] + +HEAPF32[$a >> 2] * 2.399999914359796e-07;
   if (+HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] > 0.0) HEAPF32[$a >> 2] = -+HEAPF32[$a >> 2];
   HEAP32[$i >> 2] = HEAP32[$start >> 2];
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end >> 2] | 0)) break;
    $130 = +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
    $mul138 = +HEAPF32[$a >> 2] * +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
    $add142 = $130 + $mul138 * +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
    HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] = $add142;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   L54 : do if ((HEAP32[$special >> 2] | 0) != 0 & (HEAP32[$peak_pos >> 2] | 0) >= 2) {
    HEAPF32[$offset >> 2] = +HEAPF32[$x0 >> 2] - +HEAPF32[HEAP32[$x >> 2] >> 2];
    HEAPF32[$delta >> 2] = +HEAPF32[$offset >> 2] / +(HEAP32[$peak_pos >> 2] | 0);
    HEAP32[$i >> 2] = HEAP32[$curr >> 2];
    while (1) {
     if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$peak_pos >> 2] | 0)) break L54;
     HEAPF32[$offset >> 2] = +HEAPF32[$offset >> 2] - +HEAPF32[$delta >> 2];
     $arrayidx162 = (HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) | 0;
     HEAPF32[$arrayidx162 >> 2] = +HEAPF32[$arrayidx162 >> 2] + +HEAPF32[$offset >> 2];
     if (1.0 < +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2]) $cond173 = 1.0; else $cond173 = +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
     if (-1.0 > $cond173) $cond189 = -1.0; else if (1.0 < +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2]) $cond189 = 1.0; else $cond189 = +HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2];
     HEAPF32[(HEAP32[$x >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] = $cond189;
     HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
    }
   } while (0);
   HEAP32[$curr >> 2] = HEAP32[$end >> 2];
  } while ((HEAP32[$curr >> 2] | 0) != (HEAP32[$N$addr >> 2] | 0));
  if ((label | 0) == 23) {
   label = 0;
   HEAPF32[$a >> 2] = 0.0;
  }
  HEAPF32[(HEAP32[$declip_mem$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2) >> 2] = +HEAPF32[$a >> 2];
  HEAP32[$c >> 2] = (HEAP32[$c >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _celt_synthesis($mode, $X, $out_syn, $oldBandE, $start, $effEnd, $C, $CC, $isTransient, $LM, $downsample, $silence, $arch) {
 $mode = $mode | 0;
 $X = $X | 0;
 $out_syn = $out_syn | 0;
 $oldBandE = $oldBandE | 0;
 $start = $start | 0;
 $effEnd = $effEnd | 0;
 $C = $C | 0;
 $CC = $CC | 0;
 $isTransient = $isTransient | 0;
 $LM = $LM | 0;
 $downsample = $downsample | 0;
 $silence = $silence | 0;
 $arch = $arch | 0;
 var $7 = 0, $B = 0, $C$addr = 0, $CC$addr = 0, $LM$addr = 0, $M = 0, $N = 0, $NB = 0, $X$addr = 0, $add$ptr15 = 0, $add$ptr23 = 0, $add$ptr58 = 0, $add$ptr65 = 0, $add$ptr67 = 0, $add$ptr75 = 0, $arch$addr = 0, $b = 0, $c = 0, $downsample$addr = 0, $effEnd$addr = 0, $freq2 = 0, $freq233 = 0, $i = 0, $inc80 = 0, $inc96 = 0, $isTransient$addr = 0, $mode$addr = 0, $nbEBands = 0, $oldBandE$addr = 0, $out_syn$addr = 0, $overlap = 0, $saved_stack = 0, $shift = 0, $silence$addr = 0, $start$addr = 0, $vla = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $mode$addr = sp + 100 | 0;
 $X$addr = sp + 96 | 0;
 $out_syn$addr = sp + 92 | 0;
 $oldBandE$addr = sp + 88 | 0;
 $start$addr = sp + 84 | 0;
 $effEnd$addr = sp + 80 | 0;
 $C$addr = sp + 76 | 0;
 $CC$addr = sp + 72 | 0;
 $isTransient$addr = sp + 68 | 0;
 $LM$addr = sp + 64 | 0;
 $downsample$addr = sp + 60 | 0;
 $silence$addr = sp + 56 | 0;
 $arch$addr = sp + 52 | 0;
 $c = sp + 48 | 0;
 $i = sp + 44 | 0;
 $M = sp + 40 | 0;
 $b = sp + 36 | 0;
 $B = sp + 32 | 0;
 $N = sp + 28 | 0;
 $NB = sp + 24 | 0;
 $shift = sp + 20 | 0;
 $nbEBands = sp + 16 | 0;
 $overlap = sp + 12 | 0;
 $saved_stack = sp + 8 | 0;
 $freq2 = sp + 4 | 0;
 $freq233 = sp;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$out_syn$addr >> 2] = $out_syn;
 HEAP32[$oldBandE$addr >> 2] = $oldBandE;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$effEnd$addr >> 2] = $effEnd;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$CC$addr >> 2] = $CC;
 HEAP32[$isTransient$addr >> 2] = $isTransient;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$downsample$addr >> 2] = $downsample;
 HEAP32[$silence$addr >> 2] = $silence;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$overlap >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 4 >> 2];
 HEAP32[$nbEBands >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 8 >> 2];
 HEAP32[$N >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 44 >> 2] << HEAP32[$LM$addr >> 2];
 $7 = HEAP32[$N >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($7 << 2) | 0) + 15 & -16) | 0;
 HEAP32[$M >> 2] = 1 << HEAP32[$LM$addr >> 2];
 if (HEAP32[$isTransient$addr >> 2] | 0) {
  HEAP32[$B >> 2] = HEAP32[$M >> 2];
  HEAP32[$NB >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 44 >> 2];
  HEAP32[$shift >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 36 >> 2];
 } else {
  HEAP32[$B >> 2] = 1;
  HEAP32[$NB >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 44 >> 2] << HEAP32[$LM$addr >> 2];
  HEAP32[$shift >> 2] = (HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 36 >> 2] | 0) - (HEAP32[$LM$addr >> 2] | 0);
 }
 L5 : do if ((HEAP32[$CC$addr >> 2] | 0) == 2 & (HEAP32[$C$addr >> 2] | 0) == 1) {
  _denormalise_bands(HEAP32[$mode$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, $vla, HEAP32[$oldBandE$addr >> 2] | 0, HEAP32[$start$addr >> 2] | 0, HEAP32[$effEnd$addr >> 2] | 0, HEAP32[$M >> 2] | 0, HEAP32[$downsample$addr >> 2] | 0, HEAP32[$silence$addr >> 2] | 0);
  HEAP32[$freq2 >> 2] = (HEAP32[(HEAP32[$out_syn$addr >> 2] | 0) + 4 >> 2] | 0) + (((HEAP32[$overlap >> 2] | 0) / 2 | 0) << 2);
  _memcpy(HEAP32[$freq2 >> 2] | 0, $vla | 0, (HEAP32[$N >> 2] << 2) + 0 | 0) | 0;
  HEAP32[$b >> 2] = 0;
  while (1) {
   if ((HEAP32[$b >> 2] | 0) >= (HEAP32[$B >> 2] | 0)) break;
   $add$ptr15 = (HEAP32[HEAP32[$out_syn$addr >> 2] >> 2] | 0) + ((Math_imul(HEAP32[$NB >> 2] | 0, HEAP32[$b >> 2] | 0) | 0) << 2) | 0;
   _clt_mdct_backward_c((HEAP32[$mode$addr >> 2] | 0) + 64 | 0, (HEAP32[$freq2 >> 2] | 0) + (HEAP32[$b >> 2] << 2) | 0, $add$ptr15, HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[$overlap >> 2] | 0, HEAP32[$shift >> 2] | 0, HEAP32[$B >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
   HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
  }
  HEAP32[$b >> 2] = 0;
  while (1) {
   if ((HEAP32[$b >> 2] | 0) >= (HEAP32[$B >> 2] | 0)) break L5;
   $add$ptr23 = (HEAP32[(HEAP32[$out_syn$addr >> 2] | 0) + 4 >> 2] | 0) + ((Math_imul(HEAP32[$NB >> 2] | 0, HEAP32[$b >> 2] | 0) | 0) << 2) | 0;
   _clt_mdct_backward_c((HEAP32[$mode$addr >> 2] | 0) + 64 | 0, $vla + (HEAP32[$b >> 2] << 2) | 0, $add$ptr23, HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[$overlap >> 2] | 0, HEAP32[$shift >> 2] | 0, HEAP32[$B >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
   HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
  }
 } else {
  if (!((HEAP32[$CC$addr >> 2] | 0) == 1 & (HEAP32[$C$addr >> 2] | 0) == 2)) {
   HEAP32[$c >> 2] = 0;
   while (1) {
    $add$ptr65 = (HEAP32[$X$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$N >> 2] | 0) | 0) << 2) | 0;
    $add$ptr67 = (HEAP32[$oldBandE$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands >> 2] | 0) | 0) << 2) | 0;
    _denormalise_bands(HEAP32[$mode$addr >> 2] | 0, $add$ptr65, $vla, $add$ptr67, HEAP32[$start$addr >> 2] | 0, HEAP32[$effEnd$addr >> 2] | 0, HEAP32[$M >> 2] | 0, HEAP32[$downsample$addr >> 2] | 0, HEAP32[$silence$addr >> 2] | 0);
    HEAP32[$b >> 2] = 0;
    while (1) {
     if ((HEAP32[$b >> 2] | 0) >= (HEAP32[$B >> 2] | 0)) break;
     $add$ptr75 = (HEAP32[(HEAP32[$out_syn$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2) >> 2] | 0) + ((Math_imul(HEAP32[$NB >> 2] | 0, HEAP32[$b >> 2] | 0) | 0) << 2) | 0;
     _clt_mdct_backward_c((HEAP32[$mode$addr >> 2] | 0) + 64 | 0, $vla + (HEAP32[$b >> 2] << 2) | 0, $add$ptr75, HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[$overlap >> 2] | 0, HEAP32[$shift >> 2] | 0, HEAP32[$B >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
     HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
    }
    $inc80 = (HEAP32[$c >> 2] | 0) + 1 | 0;
    HEAP32[$c >> 2] = $inc80;
    if (($inc80 | 0) >= (HEAP32[$CC$addr >> 2] | 0)) break L5;
   }
  }
  HEAP32[$freq233 >> 2] = (HEAP32[HEAP32[$out_syn$addr >> 2] >> 2] | 0) + (((HEAP32[$overlap >> 2] | 0) / 2 | 0) << 2);
  _denormalise_bands(HEAP32[$mode$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, $vla, HEAP32[$oldBandE$addr >> 2] | 0, HEAP32[$start$addr >> 2] | 0, HEAP32[$effEnd$addr >> 2] | 0, HEAP32[$M >> 2] | 0, HEAP32[$downsample$addr >> 2] | 0, HEAP32[$silence$addr >> 2] | 0);
  _denormalise_bands(HEAP32[$mode$addr >> 2] | 0, (HEAP32[$X$addr >> 2] | 0) + (HEAP32[$N >> 2] << 2) | 0, HEAP32[$freq233 >> 2] | 0, (HEAP32[$oldBandE$addr >> 2] | 0) + (HEAP32[$nbEBands >> 2] << 2) | 0, HEAP32[$start$addr >> 2] | 0, HEAP32[$effEnd$addr >> 2] | 0, HEAP32[$M >> 2] | 0, HEAP32[$downsample$addr >> 2] | 0, HEAP32[$silence$addr >> 2] | 0);
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
   HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] * .5 + +HEAPF32[(HEAP32[$freq233 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * .5;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$b >> 2] = 0;
  while (1) {
   if ((HEAP32[$b >> 2] | 0) >= (HEAP32[$B >> 2] | 0)) break L5;
   $add$ptr58 = (HEAP32[HEAP32[$out_syn$addr >> 2] >> 2] | 0) + ((Math_imul(HEAP32[$NB >> 2] | 0, HEAP32[$b >> 2] | 0) | 0) << 2) | 0;
   _clt_mdct_backward_c((HEAP32[$mode$addr >> 2] | 0) + 64 | 0, $vla + (HEAP32[$b >> 2] << 2) | 0, $add$ptr58, HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[$overlap >> 2] | 0, HEAP32[$shift >> 2] | 0, HEAP32[$B >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
   HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
   HEAPF32[(HEAP32[(HEAP32[$out_syn$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2) >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[(HEAP32[$out_syn$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2) >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc96 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc96;
 } while (($inc96 | 0) < (HEAP32[$CC$addr >> 2] | 0));
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _alloc_trim_analysis($m, $X, $bandLogE, $end, $LM, $C, $N0, $analysis, $stereo_saving, $tf_estimate, $intensity, $surround_trim, $equiv_rate, $arch) {
 $m = $m | 0;
 $X = $X | 0;
 $bandLogE = $bandLogE | 0;
 $end = $end | 0;
 $LM = $LM | 0;
 $C = $C | 0;
 $N0 = $N0 | 0;
 $analysis = $analysis | 0;
 $stereo_saving = $stereo_saving | 0;
 $tf_estimate = +$tf_estimate;
 $intensity = $intensity | 0;
 $surround_trim = +$surround_trim;
 $equiv_rate = $equiv_rate | 0;
 $arch = $arch | 0;
 var $130 = 0, $95 = 0.0, $C$addr = 0, $LM$addr = 0, $N0$addr = 0, $X$addr = 0, $analysis$addr = 0, $arch$addr = 0, $bandLogE$addr = 0, $c = 0, $cond = 0.0, $cond117 = 0.0, $cond138 = 0.0, $cond172 = 0.0, $cond188 = 0.0, $cond204 = 0.0, $cond222 = 0.0, $cond246 = 0, $cond76 = 0.0, $cond91 = 0.0, $conv162 = 0.0, $diff = 0, $end$addr = 0, $equiv_rate$addr = 0, $frac = 0, $i = 0, $inc157 = 0, $intensity$addr = 0, $logXC = 0, $logXC2 = 0, $m$addr = 0, $minXC = 0, $partial = 0, $partial41 = 0, $stereo_saving$addr = 0, $sum = 0, $surround_trim$addr = 0, $tf_estimate$addr = 0, $trim = 0, $trim_index = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $m$addr = sp + 100 | 0;
 $X$addr = sp + 96 | 0;
 $bandLogE$addr = sp + 92 | 0;
 $end$addr = sp + 88 | 0;
 $LM$addr = sp + 84 | 0;
 $C$addr = sp + 80 | 0;
 $N0$addr = sp + 76 | 0;
 $analysis$addr = sp + 72 | 0;
 $stereo_saving$addr = sp + 68 | 0;
 $tf_estimate$addr = sp + 64 | 0;
 $intensity$addr = sp + 60 | 0;
 $surround_trim$addr = sp + 56 | 0;
 $equiv_rate$addr = sp + 52 | 0;
 $arch$addr = sp + 48 | 0;
 $i = sp + 44 | 0;
 $diff = sp + 40 | 0;
 $c = sp + 36 | 0;
 $trim_index = sp + 32 | 0;
 $trim = sp + 28 | 0;
 $logXC = sp + 24 | 0;
 $logXC2 = sp + 20 | 0;
 $frac = sp + 16 | 0;
 $sum = sp + 12 | 0;
 $minXC = sp + 8 | 0;
 $partial = sp + 4 | 0;
 $partial41 = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$bandLogE$addr >> 2] = $bandLogE;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$N0$addr >> 2] = $N0;
 HEAP32[$analysis$addr >> 2] = $analysis;
 HEAP32[$stereo_saving$addr >> 2] = $stereo_saving;
 HEAPF32[$tf_estimate$addr >> 2] = $tf_estimate;
 HEAP32[$intensity$addr >> 2] = $intensity;
 HEAPF32[$surround_trim$addr >> 2] = $surround_trim;
 HEAP32[$equiv_rate$addr >> 2] = $equiv_rate;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAPF32[$diff >> 2] = 0.0;
 HEAPF32[$trim >> 2] = 5.0;
 if ((HEAP32[$equiv_rate$addr >> 2] | 0) < 64e3) HEAPF32[$trim >> 2] = 4.0; else if ((HEAP32[$equiv_rate$addr >> 2] | 0) < 8e4) {
  HEAP32[$frac >> 2] = (HEAP32[$equiv_rate$addr >> 2] | 0) - 64e3 >> 10;
  HEAPF32[$trim >> 2] = +(HEAP32[$frac >> 2] | 0) * .0625 + 4.0;
 }
 if ((HEAP32[$C$addr >> 2] | 0) == 2) {
  HEAPF32[$sum >> 2] = 0.0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 8) break;
   HEAPF32[$partial >> 2] = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]((HEAP32[$X$addr >> 2] | 0) + (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2] << 2) | 0, (HEAP32[$X$addr >> 2] | 0) + ((HEAP32[$N0$addr >> 2] | 0) + (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2]) << 2) | 0, (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) << HEAP32[$LM$addr >> 2]);
   HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +HEAPF32[$partial >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] * .125;
  if (1.0 < +Math_abs(+(+HEAPF32[$sum >> 2]))) $cond = 1.0; else $cond = +Math_abs(+(+HEAPF32[$sum >> 2]));
  HEAPF32[$sum >> 2] = $cond;
  HEAPF32[$minXC >> 2] = +HEAPF32[$sum >> 2];
  HEAP32[$i >> 2] = 8;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$intensity$addr >> 2] | 0)) break;
   HEAPF32[$partial41 >> 2] = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]((HEAP32[$X$addr >> 2] | 0) + (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2] << 2) | 0, (HEAP32[$X$addr >> 2] | 0) + ((HEAP32[$N0$addr >> 2] | 0) + (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2]) << 2) | 0, (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) << HEAP32[$LM$addr >> 2]);
   if (+HEAPF32[$minXC >> 2] < +Math_abs(+(+HEAPF32[$partial41 >> 2]))) $cond76 = +HEAPF32[$minXC >> 2]; else $cond76 = +Math_abs(+(+HEAPF32[$partial41 >> 2]));
   HEAPF32[$minXC >> 2] = $cond76;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  if (1.0 < +Math_abs(+(+HEAPF32[$minXC >> 2]))) $cond91 = 1.0; else $cond91 = +Math_abs(+(+HEAPF32[$minXC >> 2]));
  HEAPF32[$minXC >> 2] = $cond91;
  HEAPF32[$logXC >> 2] = +Math_log(+(1.0010000467300415 - +HEAPF32[$sum >> 2] * +HEAPF32[$sum >> 2])) * 1.4426950408889634;
  if (+HEAPF32[$logXC >> 2] * .5 > +Math_log(+(1.0010000467300415 - +HEAPF32[$minXC >> 2] * +HEAPF32[$minXC >> 2])) * 1.4426950408889634) $cond117 = +HEAPF32[$logXC >> 2] * .5; else $cond117 = +Math_log(+(1.0010000467300415 - +HEAPF32[$minXC >> 2] * +HEAPF32[$minXC >> 2])) * 1.4426950408889634;
  HEAPF32[$logXC2 >> 2] = $cond117;
  HEAPF32[$trim >> 2] = +HEAPF32[$trim >> 2] + (-4.0 > +HEAPF32[$logXC >> 2] * .75 ? -4.0 : +HEAPF32[$logXC >> 2] * .75);
  if (+HEAPF32[HEAP32[$stereo_saving$addr >> 2] >> 2] + .25 < -(+HEAPF32[$logXC2 >> 2] * .5)) $cond138 = +HEAPF32[HEAP32[$stereo_saving$addr >> 2] >> 2] + .25; else $cond138 = -(+HEAPF32[$logXC2 >> 2] * .5);
  HEAPF32[HEAP32[$stereo_saving$addr >> 2] >> 2] = $cond138;
 }
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$end$addr >> 2] | 0) - 1 | 0)) break;
   $95 = +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[$diff >> 2] = +HEAPF32[$diff >> 2] + $95 * +(2 + (HEAP32[$i >> 2] << 1) - (HEAP32[$end$addr >> 2] | 0) | 0);
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc157 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc157;
 } while (($inc157 | 0) < (HEAP32[$C$addr >> 2] | 0));
 $conv162 = +(Math_imul(HEAP32[$C$addr >> 2] | 0, (HEAP32[$end$addr >> 2] | 0) - 1 | 0) | 0);
 HEAPF32[$diff >> 2] = +HEAPF32[$diff >> 2] / $conv162;
 if (2.0 < (+HEAPF32[$diff >> 2] + 1.0) / 6.0) $cond172 = 2.0; else $cond172 = (+HEAPF32[$diff >> 2] + 1.0) / 6.0;
 if (-2.0 > $cond172) $cond188 = -2.0; else if (2.0 < (+HEAPF32[$diff >> 2] + 1.0) / 6.0) $cond188 = 2.0; else $cond188 = (+HEAPF32[$diff >> 2] + 1.0) / 6.0;
 HEAPF32[$trim >> 2] = +HEAPF32[$trim >> 2] - $cond188;
 HEAPF32[$trim >> 2] = +HEAPF32[$trim >> 2] - +HEAPF32[$surround_trim$addr >> 2];
 HEAPF32[$trim >> 2] = +HEAPF32[$trim >> 2] - +HEAPF32[$tf_estimate$addr >> 2] * 2.0;
 if (HEAP32[HEAP32[$analysis$addr >> 2] >> 2] | 0) {
  if (2.0 < (+HEAPF32[(HEAP32[$analysis$addr >> 2] | 0) + 8 >> 2] + .05000000074505806) * 2.0) $cond204 = 2.0; else $cond204 = (+HEAPF32[(HEAP32[$analysis$addr >> 2] | 0) + 8 >> 2] + .05000000074505806) * 2.0;
  if (-2.0 > $cond204) $cond222 = -2.0; else if (2.0 < (+HEAPF32[(HEAP32[$analysis$addr >> 2] | 0) + 8 >> 2] + .05000000074505806) * 2.0) $cond222 = 2.0; else $cond222 = (+HEAPF32[(HEAP32[$analysis$addr >> 2] | 0) + 8 >> 2] + .05000000074505806) * 2.0;
  HEAPF32[$trim >> 2] = +HEAPF32[$trim >> 2] - $cond222;
 }
 HEAP32[$trim_index >> 2] = ~~+Math_floor(+(+HEAPF32[$trim >> 2] + .5));
 if (0 > ((10 < (HEAP32[$trim_index >> 2] | 0) ? 10 : HEAP32[$trim_index >> 2] | 0) | 0)) {
  $cond246 = 0;
  HEAP32[$trim_index >> 2] = $cond246;
  $130 = HEAP32[$trim_index >> 2] | 0;
  STACKTOP = sp;
  return $130 | 0;
 }
 $cond246 = 10 < (HEAP32[$trim_index >> 2] | 0) ? 10 : HEAP32[$trim_index >> 2] | 0;
 HEAP32[$trim_index >> 2] = $cond246;
 $130 = HEAP32[$trim_index >> 2] | 0;
 STACKTOP = sp;
 return $130 | 0;
}

function _silk_NSQ_c($psEncC, $NSQ, $psIndices, $x16, $pulses, $PredCoef_Q12, $LTPCoef_Q14, $AR_Q13, $HarmShapeGain_Q14, $Tilt_Q14, $LF_shp_Q14, $Gains_Q16, $pitchL, $Lambda_Q10, $LTP_scale_Q14) {
 $psEncC = $psEncC | 0;
 $NSQ = $NSQ | 0;
 $psIndices = $psIndices | 0;
 $x16 = $x16 | 0;
 $pulses = $pulses | 0;
 $PredCoef_Q12 = $PredCoef_Q12 | 0;
 $LTPCoef_Q14 = $LTPCoef_Q14 | 0;
 $AR_Q13 = $AR_Q13 | 0;
 $HarmShapeGain_Q14 = $HarmShapeGain_Q14 | 0;
 $Tilt_Q14 = $Tilt_Q14 | 0;
 $LF_shp_Q14 = $LF_shp_Q14 | 0;
 $Gains_Q16 = $Gains_Q16 | 0;
 $pitchL = $pitchL | 0;
 $Lambda_Q10 = $Lambda_Q10 | 0;
 $LTP_scale_Q14 = $LTP_scale_Q14 | 0;
 var $AR_Q13$addr = 0, $AR_shp_Q13 = 0, $A_Q12 = 0, $B_Q14 = 0, $Gains_Q16$addr = 0, $HarmShapeFIRPacked_Q14 = 0, $HarmShapeGain_Q14$addr = 0, $LF_shp_Q14$addr = 0, $LSF_interpolation_flag = 0, $LTPCoef_Q14$addr = 0, $LTP_scale_Q14$addr = 0, $Lambda_Q10$addr = 0, $NSQ$addr = 0, $PredCoef_Q12$addr = 0, $Tilt_Q14$addr = 0, $add = 0, $arrayidx48 = 0, $k = 0, $lag = 0, $offset_Q10 = 0, $pitchL$addr = 0, $psEncC$addr = 0, $psIndices$addr = 0, $pulses$addr = 0, $pxq = 0, $saved_stack = 0, $start_idx = 0, $vla = 0, $vla10 = 0, $vla9 = 0, $x16$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $psEncC$addr = sp + 100 | 0;
 $NSQ$addr = sp + 96 | 0;
 $psIndices$addr = sp + 92 | 0;
 $x16$addr = sp + 88 | 0;
 $pulses$addr = sp + 84 | 0;
 $PredCoef_Q12$addr = sp + 80 | 0;
 $LTPCoef_Q14$addr = sp + 76 | 0;
 $AR_Q13$addr = sp + 72 | 0;
 $HarmShapeGain_Q14$addr = sp + 68 | 0;
 $Tilt_Q14$addr = sp + 64 | 0;
 $LF_shp_Q14$addr = sp + 60 | 0;
 $Gains_Q16$addr = sp + 56 | 0;
 $pitchL$addr = sp + 52 | 0;
 $Lambda_Q10$addr = sp + 48 | 0;
 $LTP_scale_Q14$addr = sp + 44 | 0;
 $k = sp + 40 | 0;
 $lag = sp + 36 | 0;
 $start_idx = sp + 32 | 0;
 $LSF_interpolation_flag = sp + 28 | 0;
 $A_Q12 = sp + 24 | 0;
 $B_Q14 = sp + 20 | 0;
 $AR_shp_Q13 = sp + 16 | 0;
 $pxq = sp + 12 | 0;
 $HarmShapeFIRPacked_Q14 = sp + 8 | 0;
 $offset_Q10 = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$NSQ$addr >> 2] = $NSQ;
 HEAP32[$psIndices$addr >> 2] = $psIndices;
 HEAP32[$x16$addr >> 2] = $x16;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$PredCoef_Q12$addr >> 2] = $PredCoef_Q12;
 HEAP32[$LTPCoef_Q14$addr >> 2] = $LTPCoef_Q14;
 HEAP32[$AR_Q13$addr >> 2] = $AR_Q13;
 HEAP32[$HarmShapeGain_Q14$addr >> 2] = $HarmShapeGain_Q14;
 HEAP32[$Tilt_Q14$addr >> 2] = $Tilt_Q14;
 HEAP32[$LF_shp_Q14$addr >> 2] = $LF_shp_Q14;
 HEAP32[$Gains_Q16$addr >> 2] = $Gains_Q16;
 HEAP32[$pitchL$addr >> 2] = $pitchL;
 HEAP32[$Lambda_Q10$addr >> 2] = $Lambda_Q10;
 HEAP32[$LTP_scale_Q14$addr >> 2] = $LTP_scale_Q14;
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4340 >> 2] = HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 34 >> 0];
 HEAP32[$lag >> 2] = HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4328 >> 2];
 HEAP32[$offset_Q10 >> 2] = HEAP16[22956 + (HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] >> 1 << 2) + (HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 30 >> 0] << 1) >> 1];
 if ((HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 31 >> 0] | 0) == 4) HEAP32[$LSF_interpolation_flag >> 2] = 0; else HEAP32[$LSF_interpolation_flag >> 2] = 1;
 $add = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add << 2) | 0) + 15 & -16) | 0;
 $vla9 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] | 0) << 1) | 0) + 15 & -16) | 0;
 $vla10 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] << 2) | 0) + 15 & -16) | 0;
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4336 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2];
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2];
 HEAP32[$pxq >> 2] = (HEAP32[$NSQ$addr >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] << 1);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  HEAP32[$A_Q12 >> 2] = (HEAP32[$PredCoef_Q12$addr >> 2] | 0) + ((HEAP32[$k >> 2] >> 1 | 1 - (HEAP32[$LSF_interpolation_flag >> 2] | 0)) << 4 << 1);
  HEAP32[$B_Q14 >> 2] = (HEAP32[$LTPCoef_Q14$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 5 << 1);
  HEAP32[$AR_shp_Q13 >> 2] = (HEAP32[$AR_Q13$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 24 << 1);
  HEAP32[$HarmShapeFIRPacked_Q14 >> 2] = HEAP32[(HEAP32[$HarmShapeGain_Q14$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] >> 2;
  HEAP32[$HarmShapeFIRPacked_Q14 >> 2] = HEAP32[$HarmShapeFIRPacked_Q14 >> 2] | HEAP32[(HEAP32[$HarmShapeGain_Q14$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] >> 1 << 16;
  HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4348 >> 2] = 0;
  if ((HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] | 0) == 2) {
   HEAP32[$lag >> 2] = HEAP32[(HEAP32[$pitchL$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2];
   if (!(HEAP32[$k >> 2] & 3 - (HEAP32[$LSF_interpolation_flag >> 2] << 1))) {
    HEAP32[$start_idx >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0) - (HEAP32[$lag >> 2] | 0) - (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0) - 2;
    $arrayidx48 = (HEAP32[$NSQ$addr >> 2] | 0) + ((HEAP32[$start_idx >> 2] | 0) + (Math_imul(HEAP32[$k >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0) | 0) << 1) | 0;
    _silk_LPC_analysis_filter($vla9 + (HEAP32[$start_idx >> 2] << 1) | 0, $arrayidx48, HEAP32[$A_Q12 >> 2] | 0, (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] | 0) - (HEAP32[$start_idx >> 2] | 0) | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 5088 >> 2] | 0);
    HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4348 >> 2] = 1;
    HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4332 >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2];
   }
  }
  _silk_nsq_scale_states(HEAP32[$psEncC$addr >> 2] | 0, HEAP32[$NSQ$addr >> 2] | 0, HEAP32[$x16$addr >> 2] | 0, $vla10, $vla9, $vla, HEAP32[$k >> 2] | 0, HEAP32[$LTP_scale_Q14$addr >> 2] | 0, HEAP32[$Gains_Q16$addr >> 2] | 0, HEAP32[$pitchL$addr >> 2] | 0, HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] | 0);
  _silk_noise_shape_quantizer(HEAP32[$NSQ$addr >> 2] | 0, HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] | 0, $vla10, HEAP32[$pulses$addr >> 2] | 0, HEAP32[$pxq >> 2] | 0, $vla, HEAP32[$A_Q12 >> 2] | 0, HEAP32[$B_Q14 >> 2] | 0, HEAP32[$AR_shp_Q13 >> 2] | 0, HEAP32[$lag >> 2] | 0, HEAP32[$HarmShapeFIRPacked_Q14 >> 2] | 0, HEAP32[(HEAP32[$Tilt_Q14$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0, HEAP32[(HEAP32[$LF_shp_Q14$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0, HEAP32[(HEAP32[$Gains_Q16$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0, HEAP32[$Lambda_Q10$addr >> 2] | 0, HEAP32[$offset_Q10 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4632 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 5088 >> 2] | 0);
  HEAP32[$x16$addr >> 2] = (HEAP32[$x16$addr >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] << 1);
  HEAP32[$pulses$addr >> 2] = (HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0);
  HEAP32[$pxq >> 2] = (HEAP32[$pxq >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] << 1);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[(HEAP32[$NSQ$addr >> 2] | 0) + 4328 >> 2] = HEAP32[(HEAP32[$pitchL$addr >> 2] | 0) + ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0) - 1 << 2) >> 2];
 _memmove(HEAP32[$NSQ$addr >> 2] | 0, (HEAP32[$NSQ$addr >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] << 1) | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] << 1 | 0) | 0;
 _memmove((HEAP32[$NSQ$addr >> 2] | 0) + 1280 | 0, (HEAP32[$NSQ$addr >> 2] | 0) + 1280 + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4580 >> 2] << 2) | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4588 >> 2] << 2 | 0) | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _kf_bfly4($Fout, $fstride, $st, $m, $N, $mm) {
 $Fout = $Fout | 0;
 $fstride = $fstride | 0;
 $st = $st | 0;
 $m = $m | 0;
 $N = $N | 0;
 $mm = $mm | 0;
 var $13 = 0, $142 = 0, $172 = 0, $36 = 0, $72 = 0, $Fout$addr = 0, $Fout_beg = 0, $N$addr = 0, $fstride$addr = 0, $i = 0, $i15 = 0, $i188 = 0, $i249 = 0, $i49 = 0, $j = 0, $m$addr = 0, $m2 = 0, $m3 = 0, $mm$addr = 0, $scratch = 0, $scratch0 = 0, $scratch1 = 0, $st$addr = 0, $tw1 = 0, $tw2 = 0, $tw3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $Fout$addr = sp + 120 | 0;
 $fstride$addr = sp + 116 | 0;
 $st$addr = sp + 112 | 0;
 $m$addr = sp + 108 | 0;
 $N$addr = sp + 104 | 0;
 $mm$addr = sp + 100 | 0;
 $i = sp + 96 | 0;
 $scratch0 = sp + 88 | 0;
 $scratch1 = sp + 80 | 0;
 $j = sp + 72 | 0;
 $scratch = sp + 24 | 0;
 $tw1 = sp + 20 | 0;
 $tw2 = sp + 16 | 0;
 $tw3 = sp + 12 | 0;
 $m2 = sp + 8 | 0;
 $m3 = sp + 4 | 0;
 $Fout_beg = sp;
 HEAP32[$Fout$addr >> 2] = $Fout;
 HEAP32[$fstride$addr >> 2] = $fstride;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$mm$addr >> 2] = $mm;
 if ((HEAP32[$m$addr >> 2] | 0) == 1) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
   HEAPF32[$scratch0 >> 2] = +HEAPF32[HEAP32[$Fout$addr >> 2] >> 2] - +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 16 >> 2];
   HEAPF32[$scratch0 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 4 >> 2] - +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 16 + 4 >> 2];
   $13 = HEAP32[$Fout$addr >> 2] | 0;
   HEAPF32[$13 >> 2] = +HEAPF32[$13 >> 2] + +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 16 >> 2];
   $i15 = (HEAP32[$Fout$addr >> 2] | 0) + 4 | 0;
   HEAPF32[$i15 >> 2] = +HEAPF32[$i15 >> 2] + +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 16 + 4 >> 2];
   HEAPF32[$scratch1 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 8 >> 2] + +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 24 >> 2];
   HEAPF32[$scratch1 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 8 + 4 >> 2] + +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 24 + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 16 >> 2] = +HEAPF32[HEAP32[$Fout$addr >> 2] >> 2] - +HEAPF32[$scratch1 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 16 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 4 >> 2] - +HEAPF32[$scratch1 + 4 >> 2];
   $36 = HEAP32[$Fout$addr >> 2] | 0;
   HEAPF32[$36 >> 2] = +HEAPF32[$36 >> 2] + +HEAPF32[$scratch1 >> 2];
   $i49 = (HEAP32[$Fout$addr >> 2] | 0) + 4 | 0;
   HEAPF32[$i49 >> 2] = +HEAPF32[$i49 >> 2] + +HEAPF32[$scratch1 + 4 >> 2];
   HEAPF32[$scratch1 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 8 >> 2] - +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 24 >> 2];
   HEAPF32[$scratch1 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 8 + 4 >> 2] - +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 24 + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 8 >> 2] = +HEAPF32[$scratch0 >> 2] + +HEAPF32[$scratch1 + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 8 + 4 >> 2] = +HEAPF32[$scratch0 + 4 >> 2] - +HEAPF32[$scratch1 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 24 >> 2] = +HEAPF32[$scratch0 >> 2] - +HEAPF32[$scratch1 + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 24 + 4 >> 2] = +HEAPF32[$scratch0 + 4 >> 2] + +HEAPF32[$scratch1 >> 2];
   HEAP32[$Fout$addr >> 2] = (HEAP32[$Fout$addr >> 2] | 0) + 32;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  STACKTOP = sp;
  return;
 }
 HEAP32[$m2 >> 2] = HEAP32[$m$addr >> 2] << 1;
 HEAP32[$m3 >> 2] = (HEAP32[$m$addr >> 2] | 0) * 3;
 HEAP32[$Fout_beg >> 2] = HEAP32[$Fout$addr >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAP32[$Fout$addr >> 2] = (HEAP32[$Fout_beg >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$mm$addr >> 2] | 0) | 0) << 3);
  $72 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] | 0;
  HEAP32[$tw1 >> 2] = $72;
  HEAP32[$tw2 >> 2] = $72;
  HEAP32[$tw3 >> 2] = $72;
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$m$addr >> 2] | 0)) break;
   HEAPF32[$scratch >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) >> 2] * +HEAPF32[HEAP32[$tw1 >> 2] >> 2] - +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) + 4 >> 2] * +HEAPF32[(HEAP32[$tw1 >> 2] | 0) + 4 >> 2];
   HEAPF32[$scratch + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) >> 2] * +HEAPF32[(HEAP32[$tw1 >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) + 4 >> 2] * +HEAPF32[HEAP32[$tw1 >> 2] >> 2];
   HEAPF32[$scratch + 8 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) >> 2] * +HEAPF32[HEAP32[$tw2 >> 2] >> 2] - +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) + 4 >> 2] * +HEAPF32[(HEAP32[$tw2 >> 2] | 0) + 4 >> 2];
   HEAPF32[$scratch + 8 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) >> 2] * +HEAPF32[(HEAP32[$tw2 >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) + 4 >> 2] * +HEAPF32[HEAP32[$tw2 >> 2] >> 2];
   HEAPF32[$scratch + 16 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m3 >> 2] << 3) >> 2] * +HEAPF32[HEAP32[$tw3 >> 2] >> 2] - +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m3 >> 2] << 3) + 4 >> 2] * +HEAPF32[(HEAP32[$tw3 >> 2] | 0) + 4 >> 2];
   HEAPF32[$scratch + 16 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m3 >> 2] << 3) >> 2] * +HEAPF32[(HEAP32[$tw3 >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m3 >> 2] << 3) + 4 >> 2] * +HEAPF32[HEAP32[$tw3 >> 2] >> 2];
   HEAPF32[$scratch + 40 >> 2] = +HEAPF32[HEAP32[$Fout$addr >> 2] >> 2] - +HEAPF32[$scratch + 8 >> 2];
   HEAPF32[$scratch + 40 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 4 >> 2] - +HEAPF32[$scratch + 8 + 4 >> 2];
   $142 = HEAP32[$Fout$addr >> 2] | 0;
   HEAPF32[$142 >> 2] = +HEAPF32[$142 >> 2] + +HEAPF32[$scratch + 8 >> 2];
   $i188 = (HEAP32[$Fout$addr >> 2] | 0) + 4 | 0;
   HEAPF32[$i188 >> 2] = +HEAPF32[$i188 >> 2] + +HEAPF32[$scratch + 8 + 4 >> 2];
   HEAPF32[$scratch + 24 >> 2] = +HEAPF32[$scratch >> 2] + +HEAPF32[$scratch + 16 >> 2];
   HEAPF32[$scratch + 24 + 4 >> 2] = +HEAPF32[$scratch + 4 >> 2] + +HEAPF32[$scratch + 16 + 4 >> 2];
   HEAPF32[$scratch + 32 >> 2] = +HEAPF32[$scratch >> 2] - +HEAPF32[$scratch + 16 >> 2];
   HEAPF32[$scratch + 32 + 4 >> 2] = +HEAPF32[$scratch + 4 >> 2] - +HEAPF32[$scratch + 16 + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) >> 2] = +HEAPF32[HEAP32[$Fout$addr >> 2] >> 2] - +HEAPF32[$scratch + 24 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 4 >> 2] - +HEAPF32[$scratch + 24 + 4 >> 2];
   HEAP32[$tw1 >> 2] = (HEAP32[$tw1 >> 2] | 0) + (HEAP32[$fstride$addr >> 2] << 3);
   HEAP32[$tw2 >> 2] = (HEAP32[$tw2 >> 2] | 0) + (HEAP32[$fstride$addr >> 2] << 1 << 3);
   HEAP32[$tw3 >> 2] = (HEAP32[$tw3 >> 2] | 0) + ((HEAP32[$fstride$addr >> 2] | 0) * 3 << 3);
   $172 = HEAP32[$Fout$addr >> 2] | 0;
   HEAPF32[$172 >> 2] = +HEAPF32[$172 >> 2] + +HEAPF32[$scratch + 24 >> 2];
   $i249 = (HEAP32[$Fout$addr >> 2] | 0) + 4 | 0;
   HEAPF32[$i249 >> 2] = +HEAPF32[$i249 >> 2] + +HEAPF32[$scratch + 24 + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) >> 2] = +HEAPF32[$scratch + 40 >> 2] + +HEAPF32[$scratch + 32 + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) + 4 >> 2] = +HEAPF32[$scratch + 40 + 4 >> 2] - +HEAPF32[$scratch + 32 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m3 >> 2] << 3) >> 2] = +HEAPF32[$scratch + 40 >> 2] - +HEAPF32[$scratch + 32 + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m3 >> 2] << 3) + 4 >> 2] = +HEAPF32[$scratch + 40 + 4 >> 2] + +HEAPF32[$scratch + 32 >> 2];
   HEAP32[$Fout$addr >> 2] = (HEAP32[$Fout$addr >> 2] | 0) + 8;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _opus_custom_decoder_ctl($st, $request, $varargs) {
 $st = $st | 0;
 $request = $request | 0;
 $varargs = $varargs | 0;
 var $108 = 0, $109 = 0, $120 = 0, $121 = 0, $132 = 0, $133 = 0, $142 = 0, $143 = 0, $154 = 0, $155 = 0, $166 = 0, $167 = 0, $173 = 0, $21 = 0, $22 = 0, $36 = 0, $37 = 0, $48 = 0, $49 = 0, $6 = 0, $61 = 0, $62 = 0, $7 = 0, $ap = 0, $i = 0, $lpc = 0, $oldBandE = 0, $oldLogE = 0, $oldLogE2 = 0, $request$addr = 0, $retval = 0, $st$addr = 0, $value = 0, $value16 = 0, $value25 = 0, $value33 = 0, $value5 = 0, $value63 = 0, $value70 = 0, $value78 = 0, $value82 = 0, $value90 = 0, $value99 = 0, $varet = 0, $varet101 = 0, $varet18 = 0, $varet27 = 0, $varet35 = 0, $varet65 = 0, $varet7 = 0, $varet72 = 0, $varet80 = 0, $varet84 = 0, $varet92 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $retval = sp + 136 | 0;
 $st$addr = sp + 132 | 0;
 $request$addr = sp + 128 | 0;
 $ap = sp + 112 | 0;
 $value = sp + 104 | 0;
 $varet = sp + 100 | 0;
 $value5 = sp + 96 | 0;
 $varet7 = sp + 92 | 0;
 $value16 = sp + 88 | 0;
 $varet18 = sp + 84 | 0;
 $value25 = sp + 80 | 0;
 $varet27 = sp + 76 | 0;
 $value33 = sp + 72 | 0;
 $varet35 = sp + 68 | 0;
 $i = sp + 64 | 0;
 $lpc = sp + 60 | 0;
 $oldBandE = sp + 56 | 0;
 $oldLogE = sp + 52 | 0;
 $oldLogE2 = sp + 48 | 0;
 $value63 = sp + 44 | 0;
 $varet65 = sp + 40 | 0;
 $value70 = sp + 36 | 0;
 $varet72 = sp + 32 | 0;
 $value78 = sp + 28 | 0;
 $varet80 = sp + 24 | 0;
 $value82 = sp + 20 | 0;
 $varet84 = sp + 16 | 0;
 $value90 = sp + 12 | 0;
 $varet92 = sp + 8 | 0;
 $value99 = sp + 4 | 0;
 $varet101 = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$request$addr >> 2] = $request;
 HEAP32[$ap >> 2] = $varargs;
 do switch (HEAP32[$request$addr >> 2] | 0) {
 case 10010:
  {
   $6 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $7 = HEAP32[$6 >> 2] | 0;
   HEAP32[$ap >> 2] = $6 + 4;
   HEAP32[$varet >> 2] = $7;
   HEAP32[$value >> 2] = HEAP32[$varet >> 2];
   if ((HEAP32[$value >> 2] | 0) < 0) label = 30; else if ((HEAP32[$value >> 2] | 0) >= (HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] | 0)) label = 30; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 20 >> 2] = HEAP32[$value >> 2];
    label = 29;
   }
   break;
  }
 case 10012:
  {
   $21 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $22 = HEAP32[$21 >> 2] | 0;
   HEAP32[$ap >> 2] = $21 + 4;
   HEAP32[$varet7 >> 2] = $22;
   HEAP32[$value5 >> 2] = HEAP32[$varet7 >> 2];
   if ((HEAP32[$value5 >> 2] | 0) < 1) label = 30; else if ((HEAP32[$value5 >> 2] | 0) > (HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] | 0)) label = 30; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] = HEAP32[$value5 >> 2];
    label = 29;
   }
   break;
  }
 case 10008:
  {
   $36 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $37 = HEAP32[$36 >> 2] | 0;
   HEAP32[$ap >> 2] = $36 + 4;
   HEAP32[$varet18 >> 2] = $37;
   HEAP32[$value16 >> 2] = HEAP32[$varet18 >> 2];
   if ((HEAP32[$value16 >> 2] | 0) < 1 | (HEAP32[$value16 >> 2] | 0) > 2) label = 30; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] = HEAP32[$value16 >> 2];
    label = 29;
   }
   break;
  }
 case 10007:
  {
   $48 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $49 = HEAP32[$48 >> 2] | 0;
   HEAP32[$ap >> 2] = $48 + 4;
   HEAP32[$varet27 >> 2] = $49;
   HEAP32[$value25 >> 2] = HEAP32[$varet27 >> 2];
   if (!(HEAP32[$value25 >> 2] | 0)) label = 30; else {
    HEAP32[HEAP32[$value25 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2];
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] = 0;
    label = 29;
   }
   break;
  }
 case 4027:
  {
   $61 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $62 = HEAP32[$61 >> 2] | 0;
   HEAP32[$ap >> 2] = $61 + 4;
   HEAP32[$varet35 >> 2] = $62;
   HEAP32[$value33 >> 2] = HEAP32[$varet35 >> 2];
   if (!(HEAP32[$value33 >> 2] | 0)) label = 30; else {
    HEAP32[HEAP32[$value33 >> 2] >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0) / (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0) | 0;
    label = 29;
   }
   break;
  }
 case 4028:
  {
   HEAP32[$lpc >> 2] = (HEAP32[$st$addr >> 2] | 0) + 92 + ((Math_imul(2048 + (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0) | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2);
   HEAP32[$oldBandE >> 2] = (HEAP32[$lpc >> 2] | 0) + ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) * 24 << 2);
   HEAP32[$oldLogE >> 2] = (HEAP32[$oldBandE >> 2] | 0) + (HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] << 1 << 2);
   HEAP32[$oldLogE2 >> 2] = (HEAP32[$oldLogE >> 2] | 0) + (HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] << 1 << 2);
   _memset((HEAP32[$st$addr >> 2] | 0) + 40 | 0, 0, (_opus_custom_decoder_get_size(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) | 0) - ((HEAP32[$st$addr >> 2] | 0) + 40 - (HEAP32[$st$addr >> 2] | 0)) | 0) | 0;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 8 >> 2] << 1 | 0)) break;
    HEAPF32[(HEAP32[$oldLogE2 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = -28.0;
    HEAPF32[(HEAP32[$oldLogE >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = -28.0;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 56 >> 2] = 1;
   label = 29;
   break;
  }
 case 4033:
  {
   $108 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $109 = HEAP32[$108 >> 2] | 0;
   HEAP32[$ap >> 2] = $108 + 4;
   HEAP32[$varet65 >> 2] = $109;
   HEAP32[$value63 >> 2] = HEAP32[$varet65 >> 2];
   if (!(HEAP32[$value63 >> 2] | 0)) label = 30; else {
    HEAP32[HEAP32[$value63 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2];
    label = 29;
   }
   break;
  }
 case 10015:
  {
   $120 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $121 = HEAP32[$120 >> 2] | 0;
   HEAP32[$ap >> 2] = $120 + 4;
   HEAP32[$varet72 >> 2] = $121;
   HEAP32[$value70 >> 2] = HEAP32[$varet72 >> 2];
   if (!(HEAP32[$value70 >> 2] | 0)) label = 30; else {
    HEAP32[HEAP32[$value70 >> 2] >> 2] = HEAP32[HEAP32[$st$addr >> 2] >> 2];
    label = 29;
   }
   break;
  }
 case 10016:
  {
   $132 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $133 = HEAP32[$132 >> 2] | 0;
   HEAP32[$ap >> 2] = $132 + 4;
   HEAP32[$varet80 >> 2] = $133;
   HEAP32[$value78 >> 2] = HEAP32[$varet80 >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] = HEAP32[$value78 >> 2];
   label = 29;
   break;
  }
 case 4031:
  {
   $142 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $143 = HEAP32[$142 >> 2] | 0;
   HEAP32[$ap >> 2] = $142 + 4;
   HEAP32[$varet84 >> 2] = $143;
   HEAP32[$value82 >> 2] = HEAP32[$varet84 >> 2];
   if (!(HEAP32[$value82 >> 2] | 0)) label = 30; else {
    HEAP32[HEAP32[$value82 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2];
    label = 29;
   }
   break;
  }
 case 4046:
  {
   $154 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $155 = HEAP32[$154 >> 2] | 0;
   HEAP32[$ap >> 2] = $154 + 4;
   HEAP32[$varet92 >> 2] = $155;
   HEAP32[$value90 >> 2] = HEAP32[$varet92 >> 2];
   if ((HEAP32[$value90 >> 2] | 0) < 0 | (HEAP32[$value90 >> 2] | 0) > 1) label = 30; else {
    HEAP32[(HEAP32[$st$addr >> 2] | 0) + 32 >> 2] = HEAP32[$value90 >> 2];
    label = 29;
   }
   break;
  }
 case 4047:
  {
   $166 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $167 = HEAP32[$166 >> 2] | 0;
   HEAP32[$ap >> 2] = $166 + 4;
   HEAP32[$varet101 >> 2] = $167;
   HEAP32[$value99 >> 2] = HEAP32[$varet101 >> 2];
   if (HEAP32[$value99 >> 2] | 0) {
    HEAP32[HEAP32[$value99 >> 2] >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 32 >> 2];
    label = 29;
   } else label = 30;
   break;
  }
 default:
  {
   HEAP32[$retval >> 2] = -5;
   $173 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $173 | 0;
  }
 } while (0);
 if ((label | 0) == 29) {
  HEAP32[$retval >> 2] = 0;
  $173 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $173 | 0;
 } else if ((label | 0) == 30) {
  HEAP32[$retval >> 2] = -1;
  $173 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $173 | 0;
 }
 return 0;
}

function _cwrsi($_n, $_k, $_i, $_y) {
 $_n = $_n | 0;
 $_k = $_k | 0;
 $_i = $_i | 0;
 $_y = $_y | 0;
 var $1 = 0, $100 = 0, $101 = 0.0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $110 = 0.0, $111 = 0, $112 = 0, $113 = 0.0, $42 = 0, $60 = 0, $80 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $_i$addr = 0, $_k$addr = 0, $_n$addr = 0, $_y$addr = 0, $add81 = 0, $add89 = 0.0, $add91 = 0, $add98 = 0.0, $conv22 = 0, $conv58 = 0, $conv83 = 0, $conv84 = 0, $conv86 = 0.0, $conv87 = 0.0, $conv93 = 0, $conv94 = 0, $conv95 = 0.0, $conv96 = 0.0, $dec = 0, $dec46 = 0, $incdec$ptr85 = 0, $k0 = 0, $mul88 = 0.0, $mul97 = 0.0, $p = 0, $q = 0, $row = 0, $s = 0, $sub80 = 0, $sub90 = 0, $val = 0, $xor82 = 0, $xor92 = 0, $yy = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $_n$addr = sp + 36 | 0;
 $_k$addr = sp + 32 | 0;
 $_i$addr = sp + 28 | 0;
 $_y$addr = sp + 24 | 0;
 $p = sp + 20 | 0;
 $s = sp + 16 | 0;
 $k0 = sp + 12 | 0;
 $val = sp + 40 | 0;
 $yy = sp + 8 | 0;
 $q = sp + 4 | 0;
 $row = sp;
 HEAP32[$_n$addr >> 2] = $_n;
 HEAP32[$_k$addr >> 2] = $_k;
 HEAP32[$_i$addr >> 2] = $_i;
 HEAP32[$_y$addr >> 2] = $_y;
 HEAPF32[$yy >> 2] = 0.0;
 while (1) {
  $1 = HEAP32[$_k$addr >> 2] | 0;
  if ((HEAP32[$_n$addr >> 2] | 0) <= 2) break;
  do if (($1 | 0) >= (HEAP32[$_n$addr >> 2] | 0)) {
   HEAP32[$row >> 2] = HEAP32[15496 + (HEAP32[$_n$addr >> 2] << 2) >> 2];
   HEAP32[$p >> 2] = HEAP32[(HEAP32[$row >> 2] | 0) + ((HEAP32[$_k$addr >> 2] | 0) + 1 << 2) >> 2];
   HEAP32[$s >> 2] = 0 - ((HEAP32[$_i$addr >> 2] | 0) >>> 0 >= (HEAP32[$p >> 2] | 0) >>> 0 & 1);
   HEAP32[$_i$addr >> 2] = (HEAP32[$_i$addr >> 2] | 0) - (HEAP32[$p >> 2] & HEAP32[$s >> 2]);
   HEAP32[$k0 >> 2] = HEAP32[$_k$addr >> 2];
   HEAP32[$q >> 2] = HEAP32[(HEAP32[$row >> 2] | 0) + (HEAP32[$_n$addr >> 2] << 2) >> 2];
   L6 : do if ((HEAP32[$q >> 2] | 0) >>> 0 > (HEAP32[$_i$addr >> 2] | 0) >>> 0) {
    HEAP32[$_k$addr >> 2] = HEAP32[$_n$addr >> 2];
    do {
     $dec = (HEAP32[$_k$addr >> 2] | 0) + -1 | 0;
     HEAP32[$_k$addr >> 2] = $dec;
     HEAP32[$p >> 2] = HEAP32[(HEAP32[15496 + ($dec << 2) >> 2] | 0) + (HEAP32[$_n$addr >> 2] << 2) >> 2];
    } while ((HEAP32[$p >> 2] | 0) >>> 0 > (HEAP32[$_i$addr >> 2] | 0) >>> 0);
   } else {
    HEAP32[$p >> 2] = HEAP32[(HEAP32[$row >> 2] | 0) + (HEAP32[$_k$addr >> 2] << 2) >> 2];
    while (1) {
     if ((HEAP32[$p >> 2] | 0) >>> 0 <= (HEAP32[$_i$addr >> 2] | 0) >>> 0) break L6;
     HEAP32[$_k$addr >> 2] = (HEAP32[$_k$addr >> 2] | 0) + -1;
     HEAP32[$p >> 2] = HEAP32[(HEAP32[$row >> 2] | 0) + (HEAP32[$_k$addr >> 2] << 2) >> 2];
    }
   } while (0);
   HEAP32[$_i$addr >> 2] = (HEAP32[$_i$addr >> 2] | 0) - (HEAP32[$p >> 2] | 0);
   HEAP16[$val >> 1] = (HEAP32[$k0 >> 2] | 0) - (HEAP32[$_k$addr >> 2] | 0) + (HEAP32[$s >> 2] | 0) ^ HEAP32[$s >> 2];
   $conv22 = HEAP16[$val >> 1] | 0;
   $42 = HEAP32[$_y$addr >> 2] | 0;
   HEAP32[$_y$addr >> 2] = $42 + 4;
   HEAP32[$42 >> 2] = $conv22;
   HEAPF32[$yy >> 2] = +HEAPF32[$yy >> 2] + +(HEAP16[$val >> 1] | 0) * +(HEAP16[$val >> 1] | 0);
  } else {
   HEAP32[$p >> 2] = HEAP32[(HEAP32[15496 + (HEAP32[$_k$addr >> 2] << 2) >> 2] | 0) + (HEAP32[$_n$addr >> 2] << 2) >> 2];
   HEAP32[$q >> 2] = HEAP32[(HEAP32[15496 + ((HEAP32[$_k$addr >> 2] | 0) + 1 << 2) >> 2] | 0) + (HEAP32[$_n$addr >> 2] << 2) >> 2];
   if ((HEAP32[$p >> 2] | 0) >>> 0 <= (HEAP32[$_i$addr >> 2] | 0) >>> 0) if ((HEAP32[$_i$addr >> 2] | 0) >>> 0 < (HEAP32[$q >> 2] | 0) >>> 0) {
    HEAP32[$_i$addr >> 2] = (HEAP32[$_i$addr >> 2] | 0) - (HEAP32[$p >> 2] | 0);
    $60 = HEAP32[$_y$addr >> 2] | 0;
    HEAP32[$_y$addr >> 2] = $60 + 4;
    HEAP32[$60 >> 2] = 0;
    break;
   }
   HEAP32[$s >> 2] = 0 - ((HEAP32[$_i$addr >> 2] | 0) >>> 0 >= (HEAP32[$q >> 2] | 0) >>> 0 & 1);
   HEAP32[$_i$addr >> 2] = (HEAP32[$_i$addr >> 2] | 0) - (HEAP32[$q >> 2] & HEAP32[$s >> 2]);
   HEAP32[$k0 >> 2] = HEAP32[$_k$addr >> 2];
   do {
    $dec46 = (HEAP32[$_k$addr >> 2] | 0) + -1 | 0;
    HEAP32[$_k$addr >> 2] = $dec46;
    HEAP32[$p >> 2] = HEAP32[(HEAP32[15496 + ($dec46 << 2) >> 2] | 0) + (HEAP32[$_n$addr >> 2] << 2) >> 2];
   } while ((HEAP32[$p >> 2] | 0) >>> 0 > (HEAP32[$_i$addr >> 2] | 0) >>> 0);
   HEAP32[$_i$addr >> 2] = (HEAP32[$_i$addr >> 2] | 0) - (HEAP32[$p >> 2] | 0);
   HEAP16[$val >> 1] = (HEAP32[$k0 >> 2] | 0) - (HEAP32[$_k$addr >> 2] | 0) + (HEAP32[$s >> 2] | 0) ^ HEAP32[$s >> 2];
   $conv58 = HEAP16[$val >> 1] | 0;
   $80 = HEAP32[$_y$addr >> 2] | 0;
   HEAP32[$_y$addr >> 2] = $80 + 4;
   HEAP32[$80 >> 2] = $conv58;
   HEAPF32[$yy >> 2] = +HEAPF32[$yy >> 2] + +(HEAP16[$val >> 1] | 0) * +(HEAP16[$val >> 1] | 0);
  } while (0);
  HEAP32[$_n$addr >> 2] = (HEAP32[$_n$addr >> 2] | 0) + -1;
 }
 HEAP32[$p >> 2] = ($1 << 1) + 1;
 HEAP32[$s >> 2] = 0 - ((HEAP32[$_i$addr >> 2] | 0) >>> 0 >= (HEAP32[$p >> 2] | 0) >>> 0 & 1);
 HEAP32[$_i$addr >> 2] = (HEAP32[$_i$addr >> 2] | 0) - (HEAP32[$p >> 2] & HEAP32[$s >> 2]);
 HEAP32[$k0 >> 2] = HEAP32[$_k$addr >> 2];
 HEAP32[$_k$addr >> 2] = ((HEAP32[$_i$addr >> 2] | 0) + 1 | 0) >>> 1;
 if (!(HEAP32[$_k$addr >> 2] | 0)) {
  $95 = HEAP32[$k0 >> 2] | 0;
  $96 = HEAP32[$_k$addr >> 2] | 0;
  $sub80 = $95 - $96 | 0;
  $97 = HEAP32[$s >> 2] | 0;
  $add81 = $sub80 + $97 | 0;
  $98 = HEAP32[$s >> 2] | 0;
  $xor82 = $add81 ^ $98;
  $conv83 = $xor82 & 65535;
  HEAP16[$val >> 1] = $conv83;
  $99 = HEAP16[$val >> 1] | 0;
  $conv84 = $99 << 16 >> 16;
  $100 = HEAP32[$_y$addr >> 2] | 0;
  $incdec$ptr85 = $100 + 4 | 0;
  HEAP32[$_y$addr >> 2] = $incdec$ptr85;
  HEAP32[$100 >> 2] = $conv84;
  $101 = +HEAPF32[$yy >> 2];
  $102 = HEAP16[$val >> 1] | 0;
  $conv86 = +($102 << 16 >> 16);
  $103 = HEAP16[$val >> 1] | 0;
  $conv87 = +($103 << 16 >> 16);
  $mul88 = $conv86 * $conv87;
  $add89 = $101 + $mul88;
  HEAPF32[$yy >> 2] = $add89;
  $104 = HEAP32[$_i$addr >> 2] | 0;
  $sub90 = 0 - $104 | 0;
  HEAP32[$s >> 2] = $sub90;
  $105 = HEAP32[$_k$addr >> 2] | 0;
  $106 = HEAP32[$s >> 2] | 0;
  $add91 = $105 + $106 | 0;
  $107 = HEAP32[$s >> 2] | 0;
  $xor92 = $add91 ^ $107;
  $conv93 = $xor92 & 65535;
  HEAP16[$val >> 1] = $conv93;
  $108 = HEAP16[$val >> 1] | 0;
  $conv94 = $108 << 16 >> 16;
  $109 = HEAP32[$_y$addr >> 2] | 0;
  HEAP32[$109 >> 2] = $conv94;
  $110 = +HEAPF32[$yy >> 2];
  $111 = HEAP16[$val >> 1] | 0;
  $conv95 = +($111 << 16 >> 16);
  $112 = HEAP16[$val >> 1] | 0;
  $conv96 = +($112 << 16 >> 16);
  $mul97 = $conv95 * $conv96;
  $add98 = $110 + $mul97;
  HEAPF32[$yy >> 2] = $add98;
  $113 = +HEAPF32[$yy >> 2];
  STACKTOP = sp;
  return +$113;
 }
 HEAP32[$_i$addr >> 2] = (HEAP32[$_i$addr >> 2] | 0) - ((HEAP32[$_k$addr >> 2] << 1) - 1);
 $95 = HEAP32[$k0 >> 2] | 0;
 $96 = HEAP32[$_k$addr >> 2] | 0;
 $sub80 = $95 - $96 | 0;
 $97 = HEAP32[$s >> 2] | 0;
 $add81 = $sub80 + $97 | 0;
 $98 = HEAP32[$s >> 2] | 0;
 $xor82 = $add81 ^ $98;
 $conv83 = $xor82 & 65535;
 HEAP16[$val >> 1] = $conv83;
 $99 = HEAP16[$val >> 1] | 0;
 $conv84 = $99 << 16 >> 16;
 $100 = HEAP32[$_y$addr >> 2] | 0;
 $incdec$ptr85 = $100 + 4 | 0;
 HEAP32[$_y$addr >> 2] = $incdec$ptr85;
 HEAP32[$100 >> 2] = $conv84;
 $101 = +HEAPF32[$yy >> 2];
 $102 = HEAP16[$val >> 1] | 0;
 $conv86 = +($102 << 16 >> 16);
 $103 = HEAP16[$val >> 1] | 0;
 $conv87 = +($103 << 16 >> 16);
 $mul88 = $conv86 * $conv87;
 $add89 = $101 + $mul88;
 HEAPF32[$yy >> 2] = $add89;
 $104 = HEAP32[$_i$addr >> 2] | 0;
 $sub90 = 0 - $104 | 0;
 HEAP32[$s >> 2] = $sub90;
 $105 = HEAP32[$_k$addr >> 2] | 0;
 $106 = HEAP32[$s >> 2] | 0;
 $add91 = $105 + $106 | 0;
 $107 = HEAP32[$s >> 2] | 0;
 $xor92 = $add91 ^ $107;
 $conv93 = $xor92 & 65535;
 HEAP16[$val >> 1] = $conv93;
 $108 = HEAP16[$val >> 1] | 0;
 $conv94 = $108 << 16 >> 16;
 $109 = HEAP32[$_y$addr >> 2] | 0;
 HEAP32[$109 >> 2] = $conv94;
 $110 = +HEAPF32[$yy >> 2];
 $111 = HEAP16[$val >> 1] | 0;
 $conv95 = +($111 << 16 >> 16);
 $112 = HEAP16[$val >> 1] | 0;
 $conv96 = +($112 << 16 >> 16);
 $mul97 = $conv95 * $conv96;
 $add98 = $110 + $mul97;
 HEAPF32[$yy >> 2] = $add98;
 $113 = +HEAPF32[$yy >> 2];
 STACKTOP = sp;
 return +$113;
}

function _quant_coarse_energy_impl($m, $start, $end, $eBands, $oldEBands, $budget, $tell, $prob_model, $error, $enc, $C, $LM, $intra, $max_decay, $lfe) {
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $eBands = $eBands | 0;
 $oldEBands = $oldEBands | 0;
 $budget = $budget | 0;
 $tell = $tell | 0;
 $prob_model = $prob_model | 0;
 $error = $error | 0;
 $enc = $enc | 0;
 $C = $C | 0;
 $LM = $LM | 0;
 $intra = $intra | 0;
 $max_decay = +$max_decay;
 $lfe = $lfe | 0;
 var $C$addr = 0, $LM$addr = 0, $add43 = 0, $badness = 0, $beta = 0, $bits_left = 0, $budget$addr = 0, $c = 0, $call161 = 0, $coef = 0, $cond = 0.0, $cond133 = 0, $cond34 = 0.0, $decay_bound = 0, $eBands$addr = 0, $enc$addr = 0, $end$addr = 0, $error$addr = 0, $f = 0, $i = 0, $inc = 0, $intra$addr = 0, $lfe$addr = 0, $m$addr = 0, $max_decay$addr = 0, $oldE = 0, $oldEBands$addr = 0, $pi = 0, $prev = 0, $prob_model$addr = 0, $q = 0, $qi = 0, $qi0 = 0, $start$addr = 0, $tell$addr = 0, $tmp = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $m$addr = sp + 124 | 0;
 $start$addr = sp + 120 | 0;
 $end$addr = sp + 116 | 0;
 $eBands$addr = sp + 112 | 0;
 $oldEBands$addr = sp + 108 | 0;
 $budget$addr = sp + 104 | 0;
 $tell$addr = sp + 100 | 0;
 $prob_model$addr = sp + 96 | 0;
 $error$addr = sp + 92 | 0;
 $enc$addr = sp + 88 | 0;
 $C$addr = sp + 84 | 0;
 $LM$addr = sp + 80 | 0;
 $intra$addr = sp + 76 | 0;
 $max_decay$addr = sp + 72 | 0;
 $lfe$addr = sp + 68 | 0;
 $i = sp + 64 | 0;
 $c = sp + 60 | 0;
 $badness = sp + 56 | 0;
 $prev = sp + 48 | 0;
 $coef = sp + 44 | 0;
 $beta = sp + 40 | 0;
 $bits_left = sp + 36 | 0;
 $qi = sp + 32 | 0;
 $qi0 = sp + 28 | 0;
 $q = sp + 24 | 0;
 $x = sp + 20 | 0;
 $f = sp + 16 | 0;
 $tmp = sp + 12 | 0;
 $oldE = sp + 8 | 0;
 $decay_bound = sp + 4 | 0;
 $pi = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$eBands$addr >> 2] = $eBands;
 HEAP32[$oldEBands$addr >> 2] = $oldEBands;
 HEAP32[$budget$addr >> 2] = $budget;
 HEAP32[$tell$addr >> 2] = $tell;
 HEAP32[$prob_model$addr >> 2] = $prob_model;
 HEAP32[$error$addr >> 2] = $error;
 HEAP32[$enc$addr >> 2] = $enc;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$intra$addr >> 2] = $intra;
 HEAPF32[$max_decay$addr >> 2] = $max_decay;
 HEAP32[$lfe$addr >> 2] = $lfe;
 HEAP32[$badness >> 2] = 0;
 HEAP32[$prev >> 2] = 0;
 HEAP32[$prev + 4 >> 2] = 0;
 if (((HEAP32[$tell$addr >> 2] | 0) + 3 | 0) <= (HEAP32[$budget$addr >> 2] | 0)) _ec_enc_bit_logp(HEAP32[$enc$addr >> 2] | 0, HEAP32[$intra$addr >> 2] | 0, 3);
 if (HEAP32[$intra$addr >> 2] | 0) {
  HEAPF32[$coef >> 2] = 0.0;
  HEAPF32[$beta >> 2] = .149993896484375;
 } else {
  HEAPF32[$beta >> 2] = +HEAPF32[15016 + (HEAP32[$LM$addr >> 2] << 2) >> 2];
  HEAPF32[$coef >> 2] = +HEAPF32[15e3 + (HEAP32[$LM$addr >> 2] << 2) >> 2];
 }
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP32[$c >> 2] = 0;
  do {
   HEAPF32[$x >> 2] = +HEAPF32[(HEAP32[$eBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2];
   if (-9.0 > +HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2]) $cond = -9.0; else $cond = +HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[$oldE >> 2] = $cond;
   HEAPF32[$f >> 2] = +HEAPF32[$x >> 2] - +HEAPF32[$coef >> 2] * +HEAPF32[$oldE >> 2] - +HEAPF32[$prev + (HEAP32[$c >> 2] << 2) >> 2];
   HEAP32[$qi >> 2] = ~~+Math_floor(+(+HEAPF32[$f >> 2] + .5));
   if (-28.0 > +HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2]) $cond34 = -28.0; else $cond34 = +HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[$decay_bound >> 2] = $cond34 - +HEAPF32[$max_decay$addr >> 2];
   if ((HEAP32[$qi >> 2] | 0) < 0) if (+HEAPF32[$x >> 2] < +HEAPF32[$decay_bound >> 2]) {
    $add43 = (HEAP32[$qi >> 2] | 0) + ~~(+HEAPF32[$decay_bound >> 2] - +HEAPF32[$x >> 2]) | 0;
    HEAP32[$qi >> 2] = $add43;
    HEAP32[$qi >> 2] = (HEAP32[$qi >> 2] | 0) > 0 ? 0 : $add43;
   }
   HEAP32[$qi0 >> 2] = HEAP32[$qi >> 2];
   HEAP32[$tell$addr >> 2] = _ec_tell_123(HEAP32[$enc$addr >> 2] | 0) | 0;
   HEAP32[$bits_left >> 2] = (HEAP32[$budget$addr >> 2] | 0) - (HEAP32[$tell$addr >> 2] | 0) - (Math_imul((HEAP32[$C$addr >> 2] | 0) * 3 | 0, (HEAP32[$end$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) | 0) | 0);
   if ((HEAP32[$bits_left >> 2] | 0) < 30 ? (HEAP32[$i >> 2] | 0) != (HEAP32[$start$addr >> 2] | 0) : 0) {
    if ((HEAP32[$bits_left >> 2] | 0) < 24) HEAP32[$qi >> 2] = 1 < (HEAP32[$qi >> 2] | 0) ? 1 : HEAP32[$qi >> 2] | 0;
    if ((HEAP32[$bits_left >> 2] | 0) < 16) HEAP32[$qi >> 2] = -1 > (HEAP32[$qi >> 2] | 0) ? -1 : HEAP32[$qi >> 2] | 0;
   }
   if ((HEAP32[$lfe$addr >> 2] | 0) != 0 & (HEAP32[$i >> 2] | 0) >= 2) HEAP32[$qi >> 2] = (HEAP32[$qi >> 2] | 0) < 0 ? HEAP32[$qi >> 2] | 0 : 0;
   do if (((HEAP32[$budget$addr >> 2] | 0) - (HEAP32[$tell$addr >> 2] | 0) | 0) >= 15) {
    HEAP32[$pi >> 2] = ((HEAP32[$i >> 2] | 0) < 20 ? HEAP32[$i >> 2] | 0 : 20) << 1;
    _ec_laplace_encode(HEAP32[$enc$addr >> 2] | 0, $qi, (HEAPU8[(HEAP32[$prob_model$addr >> 2] | 0) + (HEAP32[$pi >> 2] | 0) >> 0] | 0) << 7, (HEAPU8[(HEAP32[$prob_model$addr >> 2] | 0) + ((HEAP32[$pi >> 2] | 0) + 1) >> 0] | 0) << 6);
   } else if (((HEAP32[$budget$addr >> 2] | 0) - (HEAP32[$tell$addr >> 2] | 0) | 0) >= 2) {
    if (-1 > (((HEAP32[$qi >> 2] | 0) < 1 ? HEAP32[$qi >> 2] | 0 : 1) | 0)) $cond133 = -1; else $cond133 = (HEAP32[$qi >> 2] | 0) < 1 ? HEAP32[$qi >> 2] | 0 : 1;
    HEAP32[$qi >> 2] = $cond133;
    _ec_enc_icdf(HEAP32[$enc$addr >> 2] | 0, HEAP32[$qi >> 2] << 1 ^ 0 - ((HEAP32[$qi >> 2] | 0) < 0 & 1), 31633, 2);
    break;
   } else if (((HEAP32[$budget$addr >> 2] | 0) - (HEAP32[$tell$addr >> 2] | 0) | 0) >= 1) {
    HEAP32[$qi >> 2] = 0 < (HEAP32[$qi >> 2] | 0) ? 0 : HEAP32[$qi >> 2] | 0;
    _ec_enc_bit_logp(HEAP32[$enc$addr >> 2] | 0, 0 - (HEAP32[$qi >> 2] | 0) | 0, 1);
    break;
   } else {
    HEAP32[$qi >> 2] = -1;
    break;
   } while (0);
   HEAPF32[(HEAP32[$error$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2] = +HEAPF32[$f >> 2] - +(HEAP32[$qi >> 2] | 0);
   $call161 = Math_abs((HEAP32[$qi0 >> 2] | 0) - (HEAP32[$qi >> 2] | 0) | 0) | 0;
   HEAP32[$badness >> 2] = (HEAP32[$badness >> 2] | 0) + $call161;
   HEAPF32[$q >> 2] = +(HEAP32[$qi >> 2] | 0);
   HEAPF32[$tmp >> 2] = +HEAPF32[$coef >> 2] * +HEAPF32[$oldE >> 2] + +HEAPF32[$prev + (HEAP32[$c >> 2] << 2) >> 2] + +HEAPF32[$q >> 2];
   HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2] = +HEAPF32[$tmp >> 2];
   HEAPF32[$prev + (HEAP32[$c >> 2] << 2) >> 2] = +HEAPF32[$prev + (HEAP32[$c >> 2] << 2) >> 2] + +HEAPF32[$q >> 2] - +HEAPF32[$beta >> 2] * +HEAPF32[$q >> 2];
   $inc = (HEAP32[$c >> 2] | 0) + 1 | 0;
   HEAP32[$c >> 2] = $inc;
  } while (($inc | 0) < (HEAP32[$C$addr >> 2] | 0));
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return (HEAP32[$lfe$addr >> 2] | 0 ? 0 : HEAP32[$badness >> 2] | 0) | 0;
}

function _compute_stereo_width($pcm, $frame_size, $Fs, $mem) {
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $Fs = $Fs | 0;
 $mem = $mem | 0;
 var $113 = 0, $152 = 0, $80 = 0, $Fs$addr = 0, $XY66 = 0, $YY70 = 0, $cond134 = 0.0, $cond173 = 0.0, $cond185 = 0.0, $cond79 = 0.0, $cond88 = 0.0, $cond97 = 0.0, $conv152 = 0.0, $corr = 0, $frame_rate = 0, $frame_size$addr = 0, $i = 0, $ldiff = 0, $mem$addr = 0, $mul144 = 0.0, $pcm$addr = 0, $pxx = 0, $pxy = 0, $pyy = 0, $qrrt_xx = 0, $qrrt_yy = 0, $short_alpha = 0, $smoothed_width157 = 0, $sqrt_xx = 0, $sqrt_yy = 0, $width = 0, $x = 0, $xx = 0, $xy = 0, $y = 0, $yy = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $pcm$addr = sp + 84 | 0;
 $frame_size$addr = sp + 80 | 0;
 $Fs$addr = sp + 76 | 0;
 $mem$addr = sp + 72 | 0;
 $xx = sp + 68 | 0;
 $xy = sp + 64 | 0;
 $yy = sp + 60 | 0;
 $sqrt_xx = sp + 56 | 0;
 $sqrt_yy = sp + 52 | 0;
 $qrrt_xx = sp + 48 | 0;
 $qrrt_yy = sp + 44 | 0;
 $frame_rate = sp + 40 | 0;
 $i = sp + 36 | 0;
 $short_alpha = sp + 32 | 0;
 $pxx = sp + 28 | 0;
 $pxy = sp + 24 | 0;
 $pyy = sp + 20 | 0;
 $x = sp + 16 | 0;
 $y = sp + 12 | 0;
 $corr = sp + 8 | 0;
 $ldiff = sp + 4 | 0;
 $width = sp;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$mem$addr >> 2] = $mem;
 HEAP32[$frame_rate >> 2] = (HEAP32[$Fs$addr >> 2] | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0;
 HEAPF32[$short_alpha >> 2] = 1.0 - 25.0 / +((50 > (HEAP32[$frame_rate >> 2] | 0) ? 50 : HEAP32[$frame_rate >> 2] | 0) | 0);
 HEAPF32[$yy >> 2] = 0.0;
 HEAPF32[$xy >> 2] = 0.0;
 HEAPF32[$xx >> 2] = 0.0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$frame_size$addr >> 2] | 0) - 3 | 0)) break;
  HEAPF32[$pxx >> 2] = 0.0;
  HEAPF32[$pxy >> 2] = 0.0;
  HEAPF32[$pyy >> 2] = 0.0;
  HEAPF32[$x >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1 << 2) >> 2];
  HEAPF32[$y >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 1 << 2) >> 2];
  HEAPF32[$pxx >> 2] = +HEAPF32[$x >> 2] * +HEAPF32[$x >> 2];
  HEAPF32[$pxy >> 2] = +HEAPF32[$x >> 2] * +HEAPF32[$y >> 2];
  HEAPF32[$pyy >> 2] = +HEAPF32[$y >> 2] * +HEAPF32[$y >> 2];
  HEAPF32[$x >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 2 << 2) >> 2];
  HEAPF32[$y >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 3 << 2) >> 2];
  HEAPF32[$pxx >> 2] = +HEAPF32[$pxx >> 2] + +HEAPF32[$x >> 2] * +HEAPF32[$x >> 2];
  HEAPF32[$pxy >> 2] = +HEAPF32[$pxy >> 2] + +HEAPF32[$x >> 2] * +HEAPF32[$y >> 2];
  HEAPF32[$pyy >> 2] = +HEAPF32[$pyy >> 2] + +HEAPF32[$y >> 2] * +HEAPF32[$y >> 2];
  HEAPF32[$x >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 4 << 2) >> 2];
  HEAPF32[$y >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 5 << 2) >> 2];
  HEAPF32[$pxx >> 2] = +HEAPF32[$pxx >> 2] + +HEAPF32[$x >> 2] * +HEAPF32[$x >> 2];
  HEAPF32[$pxy >> 2] = +HEAPF32[$pxy >> 2] + +HEAPF32[$x >> 2] * +HEAPF32[$y >> 2];
  HEAPF32[$pyy >> 2] = +HEAPF32[$pyy >> 2] + +HEAPF32[$y >> 2] * +HEAPF32[$y >> 2];
  HEAPF32[$x >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 6 << 2) >> 2];
  HEAPF32[$y >> 2] = +HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 7 << 2) >> 2];
  HEAPF32[$pxx >> 2] = +HEAPF32[$pxx >> 2] + +HEAPF32[$x >> 2] * +HEAPF32[$x >> 2];
  HEAPF32[$pxy >> 2] = +HEAPF32[$pxy >> 2] + +HEAPF32[$x >> 2] * +HEAPF32[$y >> 2];
  HEAPF32[$pyy >> 2] = +HEAPF32[$pyy >> 2] + +HEAPF32[$y >> 2] * +HEAPF32[$y >> 2];
  HEAPF32[$xx >> 2] = +HEAPF32[$xx >> 2] + +HEAPF32[$pxx >> 2];
  HEAPF32[$xy >> 2] = +HEAPF32[$xy >> 2] + +HEAPF32[$pxy >> 2];
  HEAPF32[$yy >> 2] = +HEAPF32[$yy >> 2] + +HEAPF32[$pyy >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
 }
 if (+HEAPF32[$xx >> 2] < 1.0e9) if (+HEAPF32[$yy >> 2] < 1.0e9 ? +HEAPF32[$xx >> 2] == +HEAPF32[$xx >> 2] : 0) {
  if (+HEAPF32[$yy >> 2] != +HEAPF32[$yy >> 2]) label = 7;
 } else label = 7; else label = 7;
 if ((label | 0) == 7) {
  HEAPF32[$yy >> 2] = 0.0;
  HEAPF32[$xx >> 2] = 0.0;
  HEAPF32[$xy >> 2] = 0.0;
 }
 $80 = HEAP32[$mem$addr >> 2] | 0;
 HEAPF32[$80 >> 2] = +HEAPF32[$80 >> 2] + +HEAPF32[$short_alpha >> 2] * (+HEAPF32[$xx >> 2] - +HEAPF32[HEAP32[$mem$addr >> 2] >> 2]);
 $XY66 = (HEAP32[$mem$addr >> 2] | 0) + 4 | 0;
 HEAPF32[$XY66 >> 2] = +HEAPF32[$XY66 >> 2] + +HEAPF32[$short_alpha >> 2] * (+HEAPF32[$xy >> 2] - +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2]);
 $YY70 = (HEAP32[$mem$addr >> 2] | 0) + 8 | 0;
 HEAPF32[$YY70 >> 2] = +HEAPF32[$YY70 >> 2] + +HEAPF32[$short_alpha >> 2] * (+HEAPF32[$yy >> 2] - +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 8 >> 2]);
 if (0.0 > +HEAPF32[HEAP32[$mem$addr >> 2] >> 2]) $cond79 = 0.0; else $cond79 = +HEAPF32[HEAP32[$mem$addr >> 2] >> 2];
 HEAPF32[HEAP32[$mem$addr >> 2] >> 2] = $cond79;
 if (0.0 > +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2]) $cond88 = 0.0; else $cond88 = +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2];
 HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2] = $cond88;
 if (0.0 > +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 8 >> 2]) $cond97 = 0.0; else $cond97 = +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 8 >> 2];
 HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 8 >> 2] = $cond97;
 $113 = HEAP32[$mem$addr >> 2] | 0;
 if (+HEAPF32[(+HEAPF32[HEAP32[$mem$addr >> 2] >> 2] > +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 8 >> 2] ? $113 : $113 + 8 | 0) >> 2] > 7.999999797903001e-04) {
  HEAPF32[$sqrt_xx >> 2] = +Math_sqrt(+(+HEAPF32[HEAP32[$mem$addr >> 2] >> 2]));
  HEAPF32[$sqrt_yy >> 2] = +Math_sqrt(+(+HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 8 >> 2]));
  HEAPF32[$qrrt_xx >> 2] = +Math_sqrt(+(+HEAPF32[$sqrt_xx >> 2]));
  HEAPF32[$qrrt_yy >> 2] = +Math_sqrt(+(+HEAPF32[$sqrt_yy >> 2]));
  if (+HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2] < +HEAPF32[$sqrt_xx >> 2] * +HEAPF32[$sqrt_yy >> 2]) $cond134 = +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2]; else $cond134 = +HEAPF32[$sqrt_xx >> 2] * +HEAPF32[$sqrt_yy >> 2];
  HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2] = $cond134;
  HEAPF32[$corr >> 2] = +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2] / (+HEAPF32[$sqrt_xx >> 2] * +HEAPF32[$sqrt_yy >> 2] + 1.0000000036274937e-15);
  $mul144 = +Math_abs(+(+HEAPF32[$qrrt_xx >> 2] - +HEAPF32[$qrrt_yy >> 2])) * 1.0;
  HEAPF32[$ldiff >> 2] = $mul144 / (+HEAPF32[$qrrt_xx >> 2] + 1.0000000036274937e-15 + +HEAPF32[$qrrt_yy >> 2]);
  $conv152 = +Math_sqrt(+(1.0 - +HEAPF32[$corr >> 2] * +HEAPF32[$corr >> 2]));
  HEAPF32[$width >> 2] = $conv152 * +HEAPF32[$ldiff >> 2];
  $smoothed_width157 = (HEAP32[$mem$addr >> 2] | 0) + 12 | 0;
  HEAPF32[$smoothed_width157 >> 2] = +HEAPF32[$smoothed_width157 >> 2] + (+HEAPF32[$width >> 2] - +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 12 >> 2]) / +(HEAP32[$frame_rate >> 2] | 0);
  $152 = HEAP32[$mem$addr >> 2] | 0;
  if (+HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 16 >> 2] - .019999999552965164 / +(HEAP32[$frame_rate >> 2] | 0) > +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 12 >> 2]) $cond173 = +HEAPF32[$152 + 16 >> 2] - .019999999552965164 / +(HEAP32[$frame_rate >> 2] | 0); else $cond173 = +HEAPF32[$152 + 12 >> 2];
  HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 16 >> 2] = $cond173;
 }
 if (1.0 < +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 16 >> 2] * 20.0) {
  $cond185 = 1.0;
  STACKTOP = sp;
  return +$cond185;
 }
 $cond185 = +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 16 >> 2] * 20.0;
 STACKTOP = sp;
 return +$cond185;
}

function _transient_analysis($in, $len, $C, $tf_estimate, $tf_chan, $allow_weak_transients, $weak_transient) {
 $in = $in | 0;
 $len = $len | 0;
 $C = $C | 0;
 $tf_estimate = $tf_estimate | 0;
 $tf_chan = $tf_chan | 0;
 $allow_weak_transients = $allow_weak_transients | 0;
 $weak_transient = $weak_transient | 0;
 var $0 = 0, $100 = 0, $101 = 0, $102 = 0, $C$addr = 0, $allow_weak_transients$addr = 0, $c = 0, $call171 = 0.0, $cond102 = 0.0, $cond146 = 0.0, $cond170 = 0.0, $cond78 = 0.0, $conv172 = 0.0, $forward_decay = 0, $i = 0, $id = 0, $in$addr = 0, $is_transient = 0, $len$addr = 0, $len2 = 0, $mask_metric = 0, $maxE = 0, $mean = 0, $mem0 = 0, $mem1 = 0, $norm = 0, $saved_stack = 0, $tf_chan$addr = 0, $tf_estimate$addr = 0, $tf_max = 0, $unmask = 0, $vla = 0, $weak_transient$addr = 0, $x = 0, $x2 = 0, $y = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $in$addr = sp + 96 | 0;
 $len$addr = sp + 92 | 0;
 $C$addr = sp + 88 | 0;
 $tf_estimate$addr = sp + 84 | 0;
 $tf_chan$addr = sp + 80 | 0;
 $allow_weak_transients$addr = sp + 76 | 0;
 $weak_transient$addr = sp + 72 | 0;
 $i = sp + 68 | 0;
 $mem0 = sp + 64 | 0;
 $mem1 = sp + 60 | 0;
 $is_transient = sp + 56 | 0;
 $mask_metric = sp + 52 | 0;
 $c = sp + 48 | 0;
 $tf_max = sp + 44 | 0;
 $len2 = sp + 40 | 0;
 $forward_decay = sp + 36 | 0;
 $saved_stack = sp + 32 | 0;
 $mean = sp + 28 | 0;
 $unmask = sp + 24 | 0;
 $norm = sp + 20 | 0;
 $maxE = sp + 16 | 0;
 $x = sp + 12 | 0;
 $y = sp + 8 | 0;
 $x2 = sp + 4 | 0;
 $id = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$tf_estimate$addr >> 2] = $tf_estimate;
 HEAP32[$tf_chan$addr >> 2] = $tf_chan;
 HEAP32[$allow_weak_transients$addr >> 2] = $allow_weak_transients;
 HEAP32[$weak_transient$addr >> 2] = $weak_transient;
 HEAP32[$is_transient >> 2] = 0;
 HEAP32[$mask_metric >> 2] = 0;
 HEAPF32[$forward_decay >> 2] = .0625;
 $0 = HEAP32[$len$addr >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($0 << 2) | 0) + 15 & -16) | 0;
 HEAP32[HEAP32[$weak_transient$addr >> 2] >> 2] = 0;
 if (HEAP32[$allow_weak_transients$addr >> 2] | 0) HEAPF32[$forward_decay >> 2] = .03125;
 HEAP32[$len2 >> 2] = (HEAP32[$len$addr >> 2] | 0) / 2 | 0;
 HEAP32[$c >> 2] = 0;
 while (1) {
  if ((HEAP32[$c >> 2] | 0) >= (HEAP32[$C$addr >> 2] | 0)) break;
  HEAP32[$unmask >> 2] = 0;
  HEAPF32[$mem0 >> 2] = 0.0;
  HEAPF32[$mem1 >> 2] = 0.0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
   HEAPF32[$x >> 2] = +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$len$addr >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[$y >> 2] = +HEAPF32[$mem0 >> 2] + +HEAPF32[$x >> 2];
   HEAPF32[$mem0 >> 2] = +HEAPF32[$mem1 >> 2] + +HEAPF32[$y >> 2] - +HEAPF32[$x >> 2] * 2.0;
   HEAPF32[$mem1 >> 2] = +HEAPF32[$x >> 2] - +HEAPF32[$y >> 2] * .5;
   HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$y >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  dest = $vla;
  stop = dest + 48 | 0;
  do {
   HEAP32[dest >> 2] = 0;
   dest = dest + 4 | 0;
  } while ((dest | 0) < (stop | 0));
  HEAPF32[$mean >> 2] = 0.0;
  HEAPF32[$mem0 >> 2] = 0.0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len2 >> 2] | 0)) break;
   HEAPF32[$x2 >> 2] = +HEAPF32[$vla + (HEAP32[$i >> 2] << 1 << 2) >> 2] * +HEAPF32[$vla + (HEAP32[$i >> 2] << 1 << 2) >> 2] + +HEAPF32[$vla + ((HEAP32[$i >> 2] << 1) + 1 << 2) >> 2] * +HEAPF32[$vla + ((HEAP32[$i >> 2] << 1) + 1 << 2) >> 2];
   HEAPF32[$mean >> 2] = +HEAPF32[$mean >> 2] + +HEAPF32[$x2 >> 2];
   HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$mem0 >> 2] + +HEAPF32[$forward_decay >> 2] * (+HEAPF32[$x2 >> 2] - +HEAPF32[$mem0 >> 2]);
   HEAPF32[$mem0 >> 2] = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[$mem0 >> 2] = 0.0;
  HEAPF32[$maxE >> 2] = 0.0;
  HEAP32[$i >> 2] = (HEAP32[$len2 >> 2] | 0) - 1;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) < 0) break;
   HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$mem0 >> 2] + (+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[$mem0 >> 2]) * .125;
   HEAPF32[$mem0 >> 2] = +HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$maxE >> 2] = +HEAPF32[$maxE >> 2] > +HEAPF32[$mem0 >> 2] ? +HEAPF32[$maxE >> 2] : +HEAPF32[$mem0 >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
  }
  HEAPF32[$mean >> 2] = +Math_sqrt(+(+HEAPF32[$mean >> 2] * +HEAPF32[$maxE >> 2] * .5 * +(HEAP32[$len2 >> 2] | 0)));
  HEAPF32[$norm >> 2] = +(HEAP32[$len2 >> 2] | 0) / (+HEAPF32[$mean >> 2] + 1.0000000036274937e-15);
  HEAP32[$unmask >> 2] = 0;
  HEAP32[$i >> 2] = 12;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$len2 >> 2] | 0) - 5 | 0)) break;
   if (127.0 < +Math_floor(+(+HEAPF32[$norm >> 2] * 64.0 * (+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] + 1.0000000036274937e-15)))) $cond78 = 127.0; else $cond78 = +Math_floor(+(+HEAPF32[$norm >> 2] * 64.0 * (+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] + 1.0000000036274937e-15)));
   if (0.0 > $cond78) $cond102 = 0.0; else if (127.0 < +Math_floor(+(+HEAPF32[$norm >> 2] * 64.0 * (+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] + 1.0000000036274937e-15)))) $cond102 = 127.0; else $cond102 = +Math_floor(+(+HEAPF32[$norm >> 2] * 64.0 * (+HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] + 1.0000000036274937e-15)));
   HEAP32[$id >> 2] = ~~$cond102;
   HEAP32[$unmask >> 2] = (HEAP32[$unmask >> 2] | 0) + (HEAPU8[30360 + (HEAP32[$id >> 2] | 0) >> 0] | 0);
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
  }
  HEAP32[$unmask >> 2] = (HEAP32[$unmask >> 2] << 6 << 2 | 0) / (((HEAP32[$len2 >> 2] | 0) - 17 | 0) * 6 | 0) | 0;
  if ((HEAP32[$unmask >> 2] | 0) > (HEAP32[$mask_metric >> 2] | 0)) {
   HEAP32[HEAP32[$tf_chan$addr >> 2] >> 2] = HEAP32[$c >> 2];
   HEAP32[$mask_metric >> 2] = HEAP32[$unmask >> 2];
  }
  HEAP32[$c >> 2] = (HEAP32[$c >> 2] | 0) + 1;
 }
 HEAP32[$is_transient >> 2] = (HEAP32[$mask_metric >> 2] | 0) > 200 & 1;
 if ((HEAP32[$allow_weak_transients$addr >> 2] | 0) != 0 & (HEAP32[$is_transient >> 2] | 0) != 0 & (HEAP32[$mask_metric >> 2] | 0) < 600) {
  HEAP32[$is_transient >> 2] = 0;
  HEAP32[HEAP32[$weak_transient$addr >> 2] >> 2] = 1;
 }
 if (0.0 > +Math_sqrt(+(+((HEAP32[$mask_metric >> 2] | 0) * 27 | 0))) - 42.0) $cond146 = 0.0; else $cond146 = +Math_sqrt(+(+((HEAP32[$mask_metric >> 2] | 0) * 27 | 0))) - 42.0;
 HEAPF32[$tf_max >> 2] = $cond146;
 if (0.0 > (163.0 < +HEAPF32[$tf_max >> 2] ? 163.0 : +HEAPF32[$tf_max >> 2]) * .006899999920278788 - .139) {
  $cond170 = 0.0;
  $call171 = +Math_sqrt(+$cond170);
  $conv172 = $call171;
  $100 = HEAP32[$tf_estimate$addr >> 2] | 0;
  HEAPF32[$100 >> 2] = $conv172;
  $101 = HEAP32[$is_transient >> 2] | 0;
  $102 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($102 | 0);
  STACKTOP = sp;
  return $101 | 0;
 }
 $cond170 = (163.0 < +HEAPF32[$tf_max >> 2] ? 163.0 : +HEAPF32[$tf_max >> 2]) * .006899999920278788 - .139;
 $call171 = +Math_sqrt(+$cond170);
 $conv172 = $call171;
 $100 = HEAP32[$tf_estimate$addr >> 2] | 0;
 HEAPF32[$100 >> 2] = $conv172;
 $101 = HEAP32[$is_transient >> 2] | 0;
 $102 = HEAP32[$saved_stack >> 2] | 0;
 _llvm_stackrestore($102 | 0);
 STACKTOP = sp;
 return $101 | 0;
}

function _encode_multiframe_packet($st, $pcm, $nb_frames, $frame_size, $data, $out_data_bytes, $to_celt, $lsb_depth, $float_api) {
 $st = $st | 0;
 $pcm = $pcm | 0;
 $nb_frames = $nb_frames | 0;
 $frame_size = $frame_size | 0;
 $data = $data | 0;
 $out_data_bytes = $out_data_bytes | 0;
 $to_celt = $to_celt | 0;
 $lsb_depth = $lsb_depth | 0;
 $float_api = $float_api | 0;
 var $44 = 0, $90 = 0, $91 = 0, $add$ptr = 0, $add$ptr47 = 0, $add$ptr55 = 0, $bak_bandwidth = 0, $bak_channels = 0, $bak_mode = 0, $bak_to_mono = 0, $bytes_per_frame = 0, $cbr_bytes = 0, $cleanup$dest$slot = 0, $cond = 0, $cond21 = 0, $data$addr = 0, $float_api$addr = 0, $frame_size$addr = 0, $i = 0, $lsb_depth$addr = 0, $max_header_bytes = 0, $mul22 = 0, $nb_frames$addr = 0, $out_data_bytes$addr = 0, $pcm$addr = 0, $repacketize_len = 0, $ret = 0, $retval = 0, $rp = 0, $saved_stack = 0, $st$addr = 0, $tmp_len = 0, $to_celt$addr = 0, $vla = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 400 | 0;
 $retval = sp + 388 | 0;
 $st$addr = sp + 384 | 0;
 $pcm$addr = sp + 380 | 0;
 $nb_frames$addr = sp + 376 | 0;
 $frame_size$addr = sp + 372 | 0;
 $data$addr = sp + 368 | 0;
 $out_data_bytes$addr = sp + 364 | 0;
 $to_celt$addr = sp + 360 | 0;
 $lsb_depth$addr = sp + 356 | 0;
 $float_api$addr = sp + 352 | 0;
 $i = sp + 348 | 0;
 $ret = sp + 344 | 0;
 $bak_mode = sp + 340 | 0;
 $bak_bandwidth = sp + 336 | 0;
 $bak_channels = sp + 332 | 0;
 $bak_to_mono = sp + 328 | 0;
 $max_header_bytes = sp + 324 | 0;
 $bytes_per_frame = sp + 320 | 0;
 $cbr_bytes = sp + 316 | 0;
 $repacketize_len = sp + 312 | 0;
 $tmp_len = sp + 308 | 0;
 $saved_stack = sp + 304 | 0;
 $rp = sp + 4 | 0;
 $cleanup$dest$slot = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$nb_frames$addr >> 2] = $nb_frames;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$out_data_bytes$addr >> 2] = $out_data_bytes;
 HEAP32[$to_celt$addr >> 2] = $to_celt;
 HEAP32[$lsb_depth$addr >> 2] = $lsb_depth;
 HEAP32[$float_api$addr >> 2] = $float_api;
 HEAP32[$ret >> 2] = 0;
 if ((HEAP32[$nb_frames$addr >> 2] | 0) == 2) $cond = 3; else $cond = 2 + ((HEAP32[$nb_frames$addr >> 2] | 0) - 1 << 1) | 0;
 HEAP32[$max_header_bytes >> 2] = $cond;
 if (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0) label = 5; else if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 164 >> 2] | 0) == -1) label = 5; else {
  HEAP32[$cbr_bytes >> 2] = ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] | 0) * 3 | 0) / (((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) * 24 | 0) / (Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[$nb_frames$addr >> 2] | 0) | 0) | 0 | 0) | 0;
  HEAP32[$repacketize_len >> 2] = (HEAP32[$cbr_bytes >> 2] | 0) < (HEAP32[$out_data_bytes$addr >> 2] | 0) ? HEAP32[$cbr_bytes >> 2] | 0 : HEAP32[$out_data_bytes$addr >> 2] | 0;
 }
 if ((label | 0) == 5) HEAP32[$repacketize_len >> 2] = HEAP32[$out_data_bytes$addr >> 2];
 if (1276 < (1 + (((HEAP32[$repacketize_len >> 2] | 0) - (HEAP32[$max_header_bytes >> 2] | 0) | 0) / (HEAP32[$nb_frames$addr >> 2] | 0) | 0) | 0)) $cond21 = 1276; else $cond21 = 1 + (((HEAP32[$repacketize_len >> 2] | 0) - (HEAP32[$max_header_bytes >> 2] | 0) | 0) / (HEAP32[$nb_frames$addr >> 2] | 0) | 0) | 0;
 HEAP32[$bytes_per_frame >> 2] = $cond21;
 $mul22 = Math_imul(HEAP32[$nb_frames$addr >> 2] | 0, HEAP32[$bytes_per_frame >> 2] | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * $mul22 | 0) + 15 & -16) | 0;
 _opus_repacketizer_init($rp) | 0;
 HEAP32[$bak_mode >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 136 >> 2];
 HEAP32[$bak_bandwidth >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 128 >> 2];
 HEAP32[$bak_channels >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 136 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 128 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2];
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2];
 HEAP32[$bak_to_mono >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 60 >> 2];
 $44 = HEAP32[$st$addr >> 2] | 0;
 if (HEAP32[$bak_to_mono >> 2] | 0) HEAP32[$44 + 120 >> 2] = 1; else HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14228 >> 2] = HEAP32[$44 + 14188 >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nb_frames$addr >> 2] | 0)) {
   label = 22;
   break;
  }
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 60 >> 2] = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 18128 >> 2] = (HEAP32[$i >> 2] | 0) < ((HEAP32[$nb_frames$addr >> 2] | 0) - 1 | 0) & 1;
  if (HEAP32[$to_celt$addr >> 2] | 0) if ((HEAP32[$i >> 2] | 0) == ((HEAP32[$nb_frames$addr >> 2] | 0) - 1 | 0)) HEAP32[(HEAP32[$st$addr >> 2] | 0) + 136 >> 2] = 1002;
  $add$ptr = (HEAP32[$pcm$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0) | 0) | 0) << 2) | 0;
  $add$ptr47 = $vla + (Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$bytes_per_frame >> 2] | 0) | 0) | 0;
  HEAP32[$tmp_len >> 2] = _opus_encode_native(HEAP32[$st$addr >> 2] | 0, $add$ptr, HEAP32[$frame_size$addr >> 2] | 0, $add$ptr47, HEAP32[$bytes_per_frame >> 2] | 0, HEAP32[$lsb_depth$addr >> 2] | 0, 0, 0, 0, 0, 0, 0, HEAP32[$float_api$addr >> 2] | 0) | 0;
  if ((HEAP32[$tmp_len >> 2] | 0) < 0) {
   label = 18;
   break;
  }
  $add$ptr55 = $vla + (Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$bytes_per_frame >> 2] | 0) | 0) | 0;
  HEAP32[$ret >> 2] = _opus_repacketizer_cat($rp, $add$ptr55, HEAP32[$tmp_len >> 2] | 0) | 0;
  if ((HEAP32[$ret >> 2] | 0) < 0) {
   label = 20;
   break;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((label | 0) == 18) {
  HEAP32[$retval >> 2] = -3;
  HEAP32[$cleanup$dest$slot >> 2] = 1;
  $90 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($90 | 0);
  $91 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $91 | 0;
 } else if ((label | 0) == 20) {
  HEAP32[$retval >> 2] = -3;
  HEAP32[$cleanup$dest$slot >> 2] = 1;
  $90 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($90 | 0);
  $91 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $91 | 0;
 } else if ((label | 0) == 22) {
  HEAP32[$ret >> 2] = _opus_repacketizer_out_range_impl($rp, 0, HEAP32[$nb_frames$addr >> 2] | 0, HEAP32[$data$addr >> 2] | 0, HEAP32[$repacketize_len >> 2] | 0, 0, ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] | 0) != 0 ^ 1) & 1) | 0;
  if ((HEAP32[$ret >> 2] | 0) < 0) {
   HEAP32[$retval >> 2] = -3;
   HEAP32[$cleanup$dest$slot >> 2] = 1;
   $90 = HEAP32[$saved_stack >> 2] | 0;
   _llvm_stackrestore($90 | 0);
   $91 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $91 | 0;
  } else {
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 136 >> 2] = HEAP32[$bak_mode >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 128 >> 2] = HEAP32[$bak_bandwidth >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] = HEAP32[$bak_channels >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 60 >> 2] = HEAP32[$bak_to_mono >> 2];
   HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
   HEAP32[$cleanup$dest$slot >> 2] = 1;
   $90 = HEAP32[$saved_stack >> 2] | 0;
   _llvm_stackrestore($90 | 0);
   $91 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $91 | 0;
  }
 }
 return 0;
}

function _silk_stereo_MS_to_LR($state, $x1, $x2, $pred_Q13, $fs_kHz, $frame_length) {
 $state = $state | 0;
 $x1 = $x1 | 0;
 $x2 = $x2 | 0;
 $pred_Q13 = $pred_Q13 | 0;
 $fs_kHz = $fs_kHz | 0;
 $frame_length = $frame_length | 0;
 var $0 = 0, $2 = 0, $arrayidx = 0, $arrayidx6 = 0, $cond175 = 0, $cond219 = 0, $cond234 = 0, $cond98 = 0, $delta0_Q13 = 0, $delta1_Q13 = 0, $denom_Q16 = 0, $diff = 0, $frame_length$addr = 0, $fs_kHz$addr = 0, $mul128 = 0, $mul143 = 0, $mul56 = 0, $mul70 = 0, $n = 0, $pred0_Q13 = 0, $pred1_Q13 = 0, $pred_Q13$addr = 0, $sMid = 0, $sMid2 = 0, $sSide = 0, $sSide4 = 0, $state$addr = 0, $sum = 0, $x1$addr = 0, $x2$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $state$addr = sp + 52 | 0;
 $x1$addr = sp + 48 | 0;
 $x2$addr = sp + 44 | 0;
 $pred_Q13$addr = sp + 40 | 0;
 $fs_kHz$addr = sp + 36 | 0;
 $frame_length$addr = sp + 32 | 0;
 $n = sp + 28 | 0;
 $denom_Q16 = sp + 24 | 0;
 $delta0_Q13 = sp + 20 | 0;
 $delta1_Q13 = sp + 16 | 0;
 $sum = sp + 12 | 0;
 $diff = sp + 8 | 0;
 $pred0_Q13 = sp + 4 | 0;
 $pred1_Q13 = sp;
 HEAP32[$state$addr >> 2] = $state;
 HEAP32[$x1$addr >> 2] = $x1;
 HEAP32[$x2$addr >> 2] = $x2;
 HEAP32[$pred_Q13$addr >> 2] = $pred_Q13;
 HEAP32[$fs_kHz$addr >> 2] = $fs_kHz;
 HEAP32[$frame_length$addr >> 2] = $frame_length;
 $0 = HEAP32[$x1$addr >> 2] | 0;
 $sMid = (HEAP32[$state$addr >> 2] | 0) + 4 | 0;
 HEAP16[$0 >> 1] = HEAP16[$sMid >> 1] | 0;
 HEAP16[$0 + 2 >> 1] = HEAP16[$sMid + 2 >> 1] | 0;
 $2 = HEAP32[$x2$addr >> 2] | 0;
 $sSide = (HEAP32[$state$addr >> 2] | 0) + 8 | 0;
 HEAP16[$2 >> 1] = HEAP16[$sSide >> 1] | 0;
 HEAP16[$2 + 2 >> 1] = HEAP16[$sSide + 2 >> 1] | 0;
 $sMid2 = (HEAP32[$state$addr >> 2] | 0) + 4 | 0;
 $arrayidx = (HEAP32[$x1$addr >> 2] | 0) + (HEAP32[$frame_length$addr >> 2] << 1) | 0;
 HEAP16[$sMid2 >> 1] = HEAP16[$arrayidx >> 1] | 0;
 HEAP16[$sMid2 + 2 >> 1] = HEAP16[$arrayidx + 2 >> 1] | 0;
 $sSide4 = (HEAP32[$state$addr >> 2] | 0) + 8 | 0;
 $arrayidx6 = (HEAP32[$x2$addr >> 2] | 0) + (HEAP32[$frame_length$addr >> 2] << 1) | 0;
 HEAP16[$sSide4 >> 1] = HEAP16[$arrayidx6 >> 1] | 0;
 HEAP16[$sSide4 + 2 >> 1] = HEAP16[$arrayidx6 + 2 >> 1] | 0;
 HEAP32[$pred0_Q13 >> 2] = HEAP16[HEAP32[$state$addr >> 2] >> 1];
 HEAP32[$pred1_Q13 >> 2] = HEAP16[(HEAP32[$state$addr >> 2] | 0) + 2 >> 1];
 HEAP32[$denom_Q16 >> 2] = 65536 / (HEAP32[$fs_kHz$addr >> 2] << 3 | 0) | 0;
 HEAP32[$delta0_Q13 >> 2] = ((Math_imul(((HEAP32[HEAP32[$pred_Q13$addr >> 2] >> 2] | 0) - (HEAP16[HEAP32[$state$addr >> 2] >> 1] | 0) & 65535) << 16 >> 16, (HEAP32[$denom_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 15) + 1 >> 1;
 HEAP32[$delta1_Q13 >> 2] = ((Math_imul(((HEAP32[(HEAP32[$pred_Q13$addr >> 2] | 0) + 4 >> 2] | 0) - (HEAP16[(HEAP32[$state$addr >> 2] | 0) + 2 >> 1] | 0) & 65535) << 16 >> 16, (HEAP32[$denom_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 15) + 1 >> 1;
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$fs_kHz$addr >> 2] << 3 | 0)) break;
  HEAP32[$pred0_Q13 >> 2] = (HEAP32[$pred0_Q13 >> 2] | 0) + (HEAP32[$delta0_Q13 >> 2] | 0);
  HEAP32[$pred1_Q13 >> 2] = (HEAP32[$pred1_Q13 >> 2] | 0) + (HEAP32[$delta1_Q13 >> 2] | 0);
  HEAP32[$sum >> 2] = (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + (HEAP32[$n >> 2] << 1) >> 1] | 0) + (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 2 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 1) << 9;
  $mul56 = Math_imul(HEAP32[$sum >> 2] >> 16, (HEAP32[$pred0_Q13 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$sum >> 2] = (HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 8) + ($mul56 + ((Math_imul(HEAP32[$sum >> 2] & 65535, (HEAP32[$pred0_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  $mul70 = Math_imul(HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 11 >> 16, (HEAP32[$pred1_Q13 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$sum >> 2] = (HEAP32[$sum >> 2] | 0) + ($mul70 + ((Math_imul(HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 11 & 65535, (HEAP32[$pred1_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  if (((HEAP32[$sum >> 2] >> 7) + 1 >> 1 | 0) > 32767) $cond98 = 32767; else if (((HEAP32[$sum >> 2] >> 7) + 1 >> 1 | 0) < -32768) $cond98 = -32768; else $cond98 = (HEAP32[$sum >> 2] >> 7) + 1 >> 1;
  HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] = $cond98;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 HEAP32[$pred0_Q13 >> 2] = HEAP32[HEAP32[$pred_Q13$addr >> 2] >> 2];
 HEAP32[$pred1_Q13 >> 2] = HEAP32[(HEAP32[$pred_Q13$addr >> 2] | 0) + 4 >> 2];
 HEAP32[$n >> 2] = HEAP32[$fs_kHz$addr >> 2] << 3;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$frame_length$addr >> 2] | 0)) break;
  HEAP32[$sum >> 2] = (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + (HEAP32[$n >> 2] << 1) >> 1] | 0) + (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 2 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 1) << 9;
  $mul128 = Math_imul(HEAP32[$sum >> 2] >> 16, (HEAP32[$pred0_Q13 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$sum >> 2] = (HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 8) + ($mul128 + ((Math_imul(HEAP32[$sum >> 2] & 65535, (HEAP32[$pred0_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  $mul143 = Math_imul(HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 11 >> 16, (HEAP32[$pred1_Q13 >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$sum >> 2] = (HEAP32[$sum >> 2] | 0) + ($mul143 + ((Math_imul(HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] << 11 & 65535, (HEAP32[$pred1_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  if (((HEAP32[$sum >> 2] >> 7) + 1 >> 1 | 0) > 32767) $cond175 = 32767; else if (((HEAP32[$sum >> 2] >> 7) + 1 >> 1 | 0) < -32768) $cond175 = -32768; else $cond175 = (HEAP32[$sum >> 2] >> 7) + 1 >> 1;
  HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] = $cond175;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 HEAP16[HEAP32[$state$addr >> 2] >> 1] = HEAP32[HEAP32[$pred_Q13$addr >> 2] >> 2];
 HEAP16[(HEAP32[$state$addr >> 2] | 0) + 2 >> 1] = HEAP32[(HEAP32[$pred_Q13$addr >> 2] | 0) + 4 >> 2];
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$frame_length$addr >> 2] | 0)) break;
  HEAP32[$sum >> 2] = (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0) + (HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0);
  HEAP32[$diff >> 2] = (HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] | 0);
  if ((HEAP32[$sum >> 2] | 0) > 32767) $cond219 = 32767; else $cond219 = (HEAP32[$sum >> 2] | 0) < -32768 ? -32768 : HEAP32[$sum >> 2] | 0;
  HEAP16[(HEAP32[$x1$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] = $cond219;
  if ((HEAP32[$diff >> 2] | 0) > 32767) $cond234 = 32767; else $cond234 = (HEAP32[$diff >> 2] | 0) < -32768 ? -32768 : HEAP32[$diff >> 2] | 0;
  HEAP16[(HEAP32[$x2$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) + 1 << 1) >> 1] = $cond234;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_find_pred_coefs_FLP($psEnc, $psEncCtrl, $res_pitch, $x, $condCoding) {
 $psEnc = $psEnc | 0;
 $psEncCtrl = $psEncCtrl | 0;
 $res_pitch = $res_pitch | 0;
 $x = $x | 0;
 $condCoding = $condCoding | 0;
 var $77 = 0, $78 = 0.0, $79 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $90 = 0, $91 = 0, $LPC_in_pre = 0, $NLSF_Q15 = 0, $PredCoef = 0, $PredCoef95 = 0, $ResNrg = 0, $XXLTP = 0, $condCoding$addr = 0, $i = 0, $invGains = 0, $minInvGain = 0, $nb_subfr102 = 0, $predictLPCOrder104 = 0, $prev_NLSFq_Q15 = 0, $prev_NLSFq_Q15106 = 0, $psEnc$addr = 0, $psEncCtrl$addr = 0, $res_pitch$addr = 0, $subfr_length100 = 0, $x$addr = 0, $xXLTP = 0, $x_pre_ptr = 0, $x_ptr = 0, dest = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 2112 | 0;
 $psEnc$addr = sp + 2068 | 0;
 $psEncCtrl$addr = sp + 2064 | 0;
 $res_pitch$addr = sp + 2060 | 0;
 $x$addr = sp + 2056 | 0;
 $condCoding$addr = sp + 2052 | 0;
 $i = sp + 2048 | 0;
 $XXLTP = sp + 1648 | 0;
 $xXLTP = sp + 1568 | 0;
 $invGains = sp + 1552 | 0;
 $NLSF_Q15 = sp + 2072 | 0;
 $x_ptr = sp + 1548 | 0;
 $x_pre_ptr = sp + 1544 | 0;
 $LPC_in_pre = sp + 8 | 0;
 $minInvGain = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$psEncCtrl$addr >> 2] = $psEncCtrl;
 HEAP32[$res_pitch$addr >> 2] = $res_pitch;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$condCoding$addr >> 2] = $condCoding;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  HEAPF32[$invGains + (HEAP32[$i >> 2] << 2) >> 2] = 1.0 / +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0) == 2) {
  _silk_find_LTP_FLP($XXLTP, $xXLTP, HEAP32[$res_pitch$addr >> 2] | 0, (HEAP32[$psEncCtrl$addr >> 2] | 0) + 228 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0);
  _silk_quant_LTP_gains_FLP((HEAP32[$psEncCtrl$addr >> 2] | 0) + 144 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 4 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 32 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 4652 | 0, (HEAP32[$psEncCtrl$addr >> 2] | 0) + 708 | 0, $XXLTP, $xXLTP, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5088 >> 2] | 0);
  _silk_LTP_scale_ctrl_FLP(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[$psEncCtrl$addr >> 2] | 0, HEAP32[$condCoding$addr >> 2] | 0);
  _silk_LTP_analysis_filter_FLP($LPC_in_pre, (HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4636 >> 2] | 0) << 2) | 0, (HEAP32[$psEncCtrl$addr >> 2] | 0) + 144 | 0, (HEAP32[$psEncCtrl$addr >> 2] | 0) + 228 | 0, $invGains, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4636 >> 2] | 0);
 } else {
  HEAP32[$x_ptr >> 2] = (HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4636 >> 2] | 0) << 2);
  HEAP32[$x_pre_ptr >> 2] = $LPC_in_pre;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
   _silk_scale_copy_vector_FLP(HEAP32[$x_pre_ptr >> 2] | 0, HEAP32[$x_ptr >> 2] | 0, +HEAPF32[$invGains + (HEAP32[$i >> 2] << 2) >> 2], (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4636 >> 2] | 0) | 0);
   HEAP32[$x_pre_ptr >> 2] = (HEAP32[$x_pre_ptr >> 2] | 0) + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4636 >> 2] | 0) << 2);
   HEAP32[$x_ptr >> 2] = (HEAP32[$x_ptr >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] << 2);
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  _memset((HEAP32[$psEncCtrl$addr >> 2] | 0) + 144 | 0, 0, (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0) * 5 << 2 | 0) | 0;
  HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 708 >> 2] = 0.0;
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4652 >> 2] = 0;
 }
 if (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4660 >> 2] | 0) {
  HEAPF32[$minInvGain >> 2] = .009999999776482582;
  $77 = HEAP32[$psEnc$addr >> 2] | 0;
  $78 = +HEAPF32[$minInvGain >> 2];
  _silk_find_LPC_FLP($77, $NLSF_Q15, $LPC_in_pre, $78);
  $79 = HEAP32[$psEnc$addr >> 2] | 0;
  $80 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  $PredCoef = $80 + 16 | 0;
  $81 = HEAP32[$psEnc$addr >> 2] | 0;
  $prev_NLSFq_Q15 = $81 + 4496 | 0;
  _silk_process_NLSFs_FLP($79, $PredCoef, $NLSF_Q15, $prev_NLSFq_Q15);
  $82 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  $ResNrg = $82 + 712 | 0;
  $83 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  $PredCoef95 = $83 + 16 | 0;
  $84 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  $85 = HEAP32[$psEnc$addr >> 2] | 0;
  $subfr_length100 = $85 + 4584 | 0;
  $86 = HEAP32[$subfr_length100 >> 2] | 0;
  $87 = HEAP32[$psEnc$addr >> 2] | 0;
  $nb_subfr102 = $87 + 4576 | 0;
  $88 = HEAP32[$nb_subfr102 >> 2] | 0;
  $89 = HEAP32[$psEnc$addr >> 2] | 0;
  $predictLPCOrder104 = $89 + 4636 | 0;
  $90 = HEAP32[$predictLPCOrder104 >> 2] | 0;
  _silk_residual_energy_FLP($ResNrg, $LPC_in_pre, $PredCoef95, $84, $86, $88, $90);
  $91 = HEAP32[$psEnc$addr >> 2] | 0;
  $prev_NLSFq_Q15106 = $91 + 4496 | 0;
  dest = $prev_NLSFq_Q15106;
  src = $NLSF_Q15;
  stop = dest + 32 | 0;
  do {
   HEAP16[dest >> 1] = HEAP16[src >> 1] | 0;
   dest = dest + 2 | 0;
   src = src + 2 | 0;
  } while ((dest | 0) < (stop | 0));
  STACKTOP = sp;
  return;
 } else {
  HEAPF32[$minInvGain >> 2] = +Math_pow(2.0, +(+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 708 >> 2] / 3.0)) / 1.0e4;
  HEAPF32[$minInvGain >> 2] = +HEAPF32[$minInvGain >> 2] / (+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 700 >> 2] * .75 + .25);
  $77 = HEAP32[$psEnc$addr >> 2] | 0;
  $78 = +HEAPF32[$minInvGain >> 2];
  _silk_find_LPC_FLP($77, $NLSF_Q15, $LPC_in_pre, $78);
  $79 = HEAP32[$psEnc$addr >> 2] | 0;
  $80 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  $PredCoef = $80 + 16 | 0;
  $81 = HEAP32[$psEnc$addr >> 2] | 0;
  $prev_NLSFq_Q15 = $81 + 4496 | 0;
  _silk_process_NLSFs_FLP($79, $PredCoef, $NLSF_Q15, $prev_NLSFq_Q15);
  $82 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  $ResNrg = $82 + 712 | 0;
  $83 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  $PredCoef95 = $83 + 16 | 0;
  $84 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  $85 = HEAP32[$psEnc$addr >> 2] | 0;
  $subfr_length100 = $85 + 4584 | 0;
  $86 = HEAP32[$subfr_length100 >> 2] | 0;
  $87 = HEAP32[$psEnc$addr >> 2] | 0;
  $nb_subfr102 = $87 + 4576 | 0;
  $88 = HEAP32[$nb_subfr102 >> 2] | 0;
  $89 = HEAP32[$psEnc$addr >> 2] | 0;
  $predictLPCOrder104 = $89 + 4636 | 0;
  $90 = HEAP32[$predictLPCOrder104 >> 2] | 0;
  _silk_residual_energy_FLP($ResNrg, $LPC_in_pre, $PredCoef95, $84, $86, $88, $90);
  $91 = HEAP32[$psEnc$addr >> 2] | 0;
  $prev_NLSFq_Q15106 = $91 + 4496 | 0;
  dest = $prev_NLSFq_Q15106;
  src = $NLSF_Q15;
  stop = dest + 32 | 0;
  do {
   HEAP16[dest >> 1] = HEAP16[src >> 1] | 0;
   dest = dest + 2 | 0;
   src = src + 2 | 0;
  } while ((dest | 0) < (stop | 0));
  STACKTOP = sp;
  return;
 }
}

function _silk_quant_LTP_gains($B_Q14, $cbk_index, $periodicity_index, $sum_log_gain_Q7, $pred_gain_dB_Q7, $XX_Q17, $xX_Q17, $subfr_len, $nb_subfr, $arch) {
 $B_Q14 = $B_Q14 | 0;
 $cbk_index = $cbk_index | 0;
 $periodicity_index = $periodicity_index | 0;
 $sum_log_gain_Q7 = $sum_log_gain_Q7 | 0;
 $pred_gain_dB_Q7 = $pred_gain_dB_Q7 | 0;
 $XX_Q17 = $XX_Q17 | 0;
 $xX_Q17 = $xX_Q17 | 0;
 $subfr_len = $subfr_len | 0;
 $nb_subfr = $nb_subfr | 0;
 $arch = $arch | 0;
 var $34 = 0, $37 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $B_Q14$addr = 0, $XX_Q17$addr = 0, $XX_Q17_ptr = 0, $best_sum_log_gain_Q7 = 0, $call = 0, $call71 = 0, $cbk_gain_ptr_Q7 = 0, $cbk_index$addr = 0, $cbk_ptr_Q7 = 0, $cbk_size = 0, $cl_ptr_Q5 = 0, $cond = 0, $cond19 = 0, $cond33 = 0, $conv73 = 0, $conv74 = 0, $gain_Q7 = 0, $gain_safety = 0, $j = 0, $k = 0, $max_gain_Q7 = 0, $min_rate_dist_Q7 = 0, $mul75 = 0, $nb_subfr$addr = 0, $periodicity_index$addr = 0, $pred_gain_dB_Q7$addr = 0, $rate_dist_Q7 = 0, $rate_dist_Q7_subfr = 0, $res_nrg_Q15 = 0, $res_nrg_Q15_subfr = 0, $sub72 = 0, $subfr_len$addr = 0, $sum_log_gain_Q7$addr = 0, $sum_log_gain_tmp_Q7 = 0, $temp_idx = 0, $xX_Q17$addr = 0, $xX_Q17_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $B_Q14$addr = sp + 108 | 0;
 $cbk_index$addr = sp + 104 | 0;
 $periodicity_index$addr = sp + 100 | 0;
 $sum_log_gain_Q7$addr = sp + 96 | 0;
 $pred_gain_dB_Q7$addr = sp + 92 | 0;
 $XX_Q17$addr = sp + 88 | 0;
 $xX_Q17$addr = sp + 84 | 0;
 $subfr_len$addr = sp + 80 | 0;
 $nb_subfr$addr = sp + 76 | 0;
 $j = sp + 68 | 0;
 $k = sp + 64 | 0;
 $cbk_size = sp + 60 | 0;
 $temp_idx = sp + 112 | 0;
 $cl_ptr_Q5 = sp + 56 | 0;
 $cbk_ptr_Q7 = sp + 52 | 0;
 $cbk_gain_ptr_Q7 = sp + 48 | 0;
 $XX_Q17_ptr = sp + 44 | 0;
 $xX_Q17_ptr = sp + 40 | 0;
 $res_nrg_Q15_subfr = sp + 36 | 0;
 $res_nrg_Q15 = sp + 32 | 0;
 $rate_dist_Q7_subfr = sp + 28 | 0;
 $rate_dist_Q7 = sp + 24 | 0;
 $min_rate_dist_Q7 = sp + 20 | 0;
 $sum_log_gain_tmp_Q7 = sp + 16 | 0;
 $best_sum_log_gain_Q7 = sp + 12 | 0;
 $max_gain_Q7 = sp + 8 | 0;
 $gain_Q7 = sp + 4 | 0;
 $gain_safety = sp;
 HEAP32[$B_Q14$addr >> 2] = $B_Q14;
 HEAP32[$cbk_index$addr >> 2] = $cbk_index;
 HEAP32[$periodicity_index$addr >> 2] = $periodicity_index;
 HEAP32[$sum_log_gain_Q7$addr >> 2] = $sum_log_gain_Q7;
 HEAP32[$pred_gain_dB_Q7$addr >> 2] = $pred_gain_dB_Q7;
 HEAP32[$XX_Q17$addr >> 2] = $XX_Q17;
 HEAP32[$xX_Q17$addr >> 2] = $xX_Q17;
 HEAP32[$subfr_len$addr >> 2] = $subfr_len;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[sp + 72 >> 2] = $arch;
 HEAP32[$min_rate_dist_Q7 >> 2] = 2147483647;
 HEAP32[$best_sum_log_gain_Q7 >> 2] = 0;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= 3) break;
  HEAP32[$gain_safety >> 2] = 51;
  HEAP32[$cl_ptr_Q5 >> 2] = HEAP32[15068 + (HEAP32[$k >> 2] << 2) >> 2];
  HEAP32[$cbk_ptr_Q7 >> 2] = HEAP32[15080 + (HEAP32[$k >> 2] << 2) >> 2];
  HEAP32[$cbk_gain_ptr_Q7 >> 2] = HEAP32[15092 + (HEAP32[$k >> 2] << 2) >> 2];
  HEAP32[$cbk_size >> 2] = HEAP8[32176 + (HEAP32[$k >> 2] | 0) >> 0];
  HEAP32[$XX_Q17_ptr >> 2] = HEAP32[$XX_Q17$addr >> 2];
  HEAP32[$xX_Q17_ptr >> 2] = HEAP32[$xX_Q17$addr >> 2];
  HEAP32[$res_nrg_Q15 >> 2] = 0;
  HEAP32[$rate_dist_Q7 >> 2] = 0;
  HEAP32[$sum_log_gain_tmp_Q7 >> 2] = HEAP32[HEAP32[$sum_log_gain_Q7$addr >> 2] >> 2];
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
   $call = _silk_log2lin(5333 - (HEAP32[$sum_log_gain_tmp_Q7 >> 2] | 0) + 896 | 0) | 0;
   HEAP32[$max_gain_Q7 >> 2] = $call - (HEAP32[$gain_safety >> 2] | 0);
   _silk_VQ_WMat_EC_c($temp_idx + (HEAP32[$j >> 2] | 0) | 0, $res_nrg_Q15_subfr, $rate_dist_Q7_subfr, $gain_Q7, HEAP32[$XX_Q17_ptr >> 2] | 0, HEAP32[$xX_Q17_ptr >> 2] | 0, HEAP32[$cbk_ptr_Q7 >> 2] | 0, HEAP32[$cbk_gain_ptr_Q7 >> 2] | 0, HEAP32[$cl_ptr_Q5 >> 2] | 0, HEAP32[$subfr_len$addr >> 2] | 0, HEAP32[$max_gain_Q7 >> 2] | 0, HEAP32[$cbk_size >> 2] | 0);
   if ((HEAP32[$res_nrg_Q15 >> 2] | 0) + (HEAP32[$res_nrg_Q15_subfr >> 2] | 0) & -2147483648 | 0) $cond = 2147483647; else $cond = (HEAP32[$res_nrg_Q15 >> 2] | 0) + (HEAP32[$res_nrg_Q15_subfr >> 2] | 0) | 0;
   HEAP32[$res_nrg_Q15 >> 2] = $cond;
   if ((HEAP32[$rate_dist_Q7 >> 2] | 0) + (HEAP32[$rate_dist_Q7_subfr >> 2] | 0) & -2147483648 | 0) $cond19 = 2147483647; else $cond19 = (HEAP32[$rate_dist_Q7 >> 2] | 0) + (HEAP32[$rate_dist_Q7_subfr >> 2] | 0) | 0;
   HEAP32[$rate_dist_Q7 >> 2] = $cond19;
   $34 = HEAP32[$sum_log_gain_tmp_Q7 >> 2] | 0;
   if (0 > ($34 + (_silk_lin2log((HEAP32[$gain_safety >> 2] | 0) + (HEAP32[$gain_Q7 >> 2] | 0) | 0) | 0) - 896 | 0)) $cond33 = 0; else {
    $37 = HEAP32[$sum_log_gain_tmp_Q7 >> 2] | 0;
    $cond33 = $37 + (_silk_lin2log((HEAP32[$gain_safety >> 2] | 0) + (HEAP32[$gain_Q7 >> 2] | 0) | 0) | 0) - 896 | 0;
   }
   HEAP32[$sum_log_gain_tmp_Q7 >> 2] = $cond33;
   HEAP32[$XX_Q17_ptr >> 2] = (HEAP32[$XX_Q17_ptr >> 2] | 0) + 100;
   HEAP32[$xX_Q17_ptr >> 2] = (HEAP32[$xX_Q17_ptr >> 2] | 0) + 20;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  if ((HEAP32[$rate_dist_Q7 >> 2] | 0) <= (HEAP32[$min_rate_dist_Q7 >> 2] | 0)) {
   HEAP32[$min_rate_dist_Q7 >> 2] = HEAP32[$rate_dist_Q7 >> 2];
   HEAP8[HEAP32[$periodicity_index$addr >> 2] >> 0] = HEAP32[$k >> 2];
   _memcpy(HEAP32[$cbk_index$addr >> 2] | 0, $temp_idx | 0, HEAP32[$nb_subfr$addr >> 2] | 0) | 0;
   HEAP32[$best_sum_log_gain_Q7 >> 2] = HEAP32[$sum_log_gain_tmp_Q7 >> 2];
  }
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$cbk_ptr_Q7 >> 2] = HEAP32[15080 + (HEAP8[HEAP32[$periodicity_index$addr >> 2] >> 0] << 2) >> 2];
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= 5) break;
   HEAP16[(HEAP32[$B_Q14$addr >> 2] | 0) + (((HEAP32[$j >> 2] | 0) * 5 | 0) + (HEAP32[$k >> 2] | 0) << 1) >> 1] = HEAP8[(HEAP32[$cbk_ptr_Q7 >> 2] | 0) + (((HEAP8[(HEAP32[$cbk_index$addr >> 2] | 0) + (HEAP32[$j >> 2] | 0) >> 0] | 0) * 5 | 0) + (HEAP32[$k >> 2] | 0)) >> 0] << 7;
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 $70 = HEAP32[$res_nrg_Q15 >> 2] | 0;
 if ((HEAP32[$nb_subfr$addr >> 2] | 0) == 2) {
  HEAP32[$res_nrg_Q15 >> 2] = $70 >> 1;
  $71 = HEAP32[$best_sum_log_gain_Q7 >> 2] | 0;
  $72 = HEAP32[$sum_log_gain_Q7$addr >> 2] | 0;
  HEAP32[$72 >> 2] = $71;
  $73 = HEAP32[$res_nrg_Q15 >> 2] | 0;
  $call71 = _silk_lin2log($73) | 0;
  $sub72 = $call71 - 1920 | 0;
  $conv73 = $sub72 & 65535;
  $conv74 = $conv73 << 16 >> 16;
  $mul75 = Math_imul(-3, $conv74) | 0;
  $74 = HEAP32[$pred_gain_dB_Q7$addr >> 2] | 0;
  HEAP32[$74 >> 2] = $mul75;
  STACKTOP = sp;
  return;
 } else {
  HEAP32[$res_nrg_Q15 >> 2] = $70 >> 2;
  $71 = HEAP32[$best_sum_log_gain_Q7 >> 2] | 0;
  $72 = HEAP32[$sum_log_gain_Q7$addr >> 2] | 0;
  HEAP32[$72 >> 2] = $71;
  $73 = HEAP32[$res_nrg_Q15 >> 2] | 0;
  $call71 = _silk_lin2log($73) | 0;
  $sub72 = $call71 - 1920 | 0;
  $conv73 = $sub72 & 65535;
  $conv74 = $conv73 << 16 >> 16;
  $mul75 = Math_imul(-3, $conv74) | 0;
  $74 = HEAP32[$pred_gain_dB_Q7$addr >> 2] | 0;
  HEAP32[$74 >> 2] = $mul75;
  STACKTOP = sp;
  return;
 }
}

function _quant_band($ctx, $X, $N, $b, $B, $lowband, $LM, $lowband_out, $gain, $lowband_scratch, $fill) {
 $ctx = $ctx | 0;
 $X = $X | 0;
 $N = $N | 0;
 $b = $b | 0;
 $B = $B | 0;
 $lowband = $lowband | 0;
 $LM = $LM | 0;
 $lowband_out = $lowband_out | 0;
 $gain = +$gain;
 $lowband_scratch = $lowband_scratch | 0;
 $fill = $fill | 0;
 var $141 = 0, $B$addr = 0, $B0 = 0, $LM$addr = 0, $N$addr = 0, $N0 = 0, $N_B = 0, $N_B0 = 0, $X$addr = 0, $b$addr = 0, $cm = 0, $ctx$addr = 0, $encode = 0, $fill$addr = 0, $gain$addr = 0, $j = 0, $k = 0, $longBlocks = 0, $lowband$addr = 0, $lowband_out$addr = 0, $lowband_scratch$addr = 0, $n = 0, $recombine = 0, $retval = 0, $tf_change = 0, $time_divide = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $retval = sp + 96 | 0;
 $ctx$addr = sp + 92 | 0;
 $X$addr = sp + 88 | 0;
 $N$addr = sp + 84 | 0;
 $b$addr = sp + 80 | 0;
 $B$addr = sp + 76 | 0;
 $lowband$addr = sp + 72 | 0;
 $LM$addr = sp + 68 | 0;
 $lowband_out$addr = sp + 64 | 0;
 $gain$addr = sp + 60 | 0;
 $lowband_scratch$addr = sp + 56 | 0;
 $fill$addr = sp + 52 | 0;
 $N0 = sp + 48 | 0;
 $N_B = sp + 44 | 0;
 $N_B0 = sp + 40 | 0;
 $B0 = sp + 36 | 0;
 $time_divide = sp + 32 | 0;
 $recombine = sp + 28 | 0;
 $longBlocks = sp + 24 | 0;
 $cm = sp + 20 | 0;
 $k = sp + 16 | 0;
 $encode = sp + 12 | 0;
 $tf_change = sp + 8 | 0;
 $j = sp + 4 | 0;
 $n = sp;
 HEAP32[$ctx$addr >> 2] = $ctx;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$b$addr >> 2] = $b;
 HEAP32[$B$addr >> 2] = $B;
 HEAP32[$lowband$addr >> 2] = $lowband;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$lowband_out$addr >> 2] = $lowband_out;
 HEAPF32[$gain$addr >> 2] = $gain;
 HEAP32[$lowband_scratch$addr >> 2] = $lowband_scratch;
 HEAP32[$fill$addr >> 2] = $fill;
 HEAP32[$N0 >> 2] = HEAP32[$N$addr >> 2];
 HEAP32[$N_B >> 2] = HEAP32[$N$addr >> 2];
 HEAP32[$B0 >> 2] = HEAP32[$B$addr >> 2];
 HEAP32[$time_divide >> 2] = 0;
 HEAP32[$recombine >> 2] = 0;
 HEAP32[$cm >> 2] = 0;
 HEAP32[$encode >> 2] = HEAP32[HEAP32[$ctx$addr >> 2] >> 2];
 HEAP32[$tf_change >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 24 >> 2];
 HEAP32[$longBlocks >> 2] = (HEAP32[$B0 >> 2] | 0) == 1 & 1;
 HEAP32[$N_B >> 2] = _celt_udiv_365(HEAP32[$N_B >> 2] | 0, HEAP32[$B$addr >> 2] | 0) | 0;
 if ((HEAP32[$N$addr >> 2] | 0) == 1) {
  HEAP32[$retval >> 2] = _quant_band_n1(HEAP32[$ctx$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, 0, HEAP32[$b$addr >> 2] | 0, HEAP32[$lowband_out$addr >> 2] | 0) | 0;
  $141 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $141 | 0;
 }
 if ((HEAP32[$tf_change >> 2] | 0) > 0) HEAP32[$recombine >> 2] = HEAP32[$tf_change >> 2];
 do if ((HEAP32[$lowband_scratch$addr >> 2] | 0) != 0 & (HEAP32[$lowband$addr >> 2] | 0) != 0) {
  if (!(HEAP32[$recombine >> 2] | 0)) if (!((HEAP32[$N_B >> 2] & 1 | 0) == 0 & (HEAP32[$tf_change >> 2] | 0) < 0 | (HEAP32[$B0 >> 2] | 0) > 1)) break;
  _memcpy(HEAP32[$lowband_scratch$addr >> 2] | 0, HEAP32[$lowband$addr >> 2] | 0, (HEAP32[$N$addr >> 2] << 2) + 0 | 0) | 0;
  HEAP32[$lowband$addr >> 2] = HEAP32[$lowband_scratch$addr >> 2];
 } while (0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$recombine >> 2] | 0)) break;
  if (HEAP32[$encode >> 2] | 0) _haar1(HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] >> HEAP32[$k >> 2], 1 << HEAP32[$k >> 2]);
  if (HEAP32[$lowband$addr >> 2] | 0) _haar1(HEAP32[$lowband$addr >> 2] | 0, HEAP32[$N$addr >> 2] >> HEAP32[$k >> 2], 1 << HEAP32[$k >> 2]);
  HEAP32[$fill$addr >> 2] = HEAPU8[33457 + (HEAP32[$fill$addr >> 2] & 15) >> 0] | 0 | (HEAPU8[33457 + (HEAP32[$fill$addr >> 2] >> 4) >> 0] | 0) << 2;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$B$addr >> 2] = HEAP32[$B$addr >> 2] >> HEAP32[$recombine >> 2];
 HEAP32[$N_B >> 2] = HEAP32[$N_B >> 2] << HEAP32[$recombine >> 2];
 while (1) {
  if (!((HEAP32[$N_B >> 2] & 1 | 0) == 0 ? (HEAP32[$tf_change >> 2] | 0) < 0 : 0)) break;
  if (HEAP32[$encode >> 2] | 0) _haar1(HEAP32[$X$addr >> 2] | 0, HEAP32[$N_B >> 2] | 0, HEAP32[$B$addr >> 2] | 0);
  if (HEAP32[$lowband$addr >> 2] | 0) _haar1(HEAP32[$lowband$addr >> 2] | 0, HEAP32[$N_B >> 2] | 0, HEAP32[$B$addr >> 2] | 0);
  HEAP32[$fill$addr >> 2] = HEAP32[$fill$addr >> 2] | HEAP32[$fill$addr >> 2] << HEAP32[$B$addr >> 2];
  HEAP32[$B$addr >> 2] = HEAP32[$B$addr >> 2] << 1;
  HEAP32[$N_B >> 2] = HEAP32[$N_B >> 2] >> 1;
  HEAP32[$time_divide >> 2] = (HEAP32[$time_divide >> 2] | 0) + 1;
  HEAP32[$tf_change >> 2] = (HEAP32[$tf_change >> 2] | 0) + 1;
 }
 HEAP32[$B0 >> 2] = HEAP32[$B$addr >> 2];
 HEAP32[$N_B0 >> 2] = HEAP32[$N_B >> 2];
 if ((HEAP32[$B0 >> 2] | 0) > 1) {
  if (HEAP32[$encode >> 2] | 0) _deinterleave_hadamard(HEAP32[$X$addr >> 2] | 0, HEAP32[$N_B >> 2] >> HEAP32[$recombine >> 2], HEAP32[$B0 >> 2] << HEAP32[$recombine >> 2], HEAP32[$longBlocks >> 2] | 0);
  if (HEAP32[$lowband$addr >> 2] | 0) _deinterleave_hadamard(HEAP32[$lowband$addr >> 2] | 0, HEAP32[$N_B >> 2] >> HEAP32[$recombine >> 2], HEAP32[$B0 >> 2] << HEAP32[$recombine >> 2], HEAP32[$longBlocks >> 2] | 0);
 }
 HEAP32[$cm >> 2] = _quant_partition(HEAP32[$ctx$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$b$addr >> 2] | 0, HEAP32[$B$addr >> 2] | 0, HEAP32[$lowband$addr >> 2] | 0, HEAP32[$LM$addr >> 2] | 0, +HEAPF32[$gain$addr >> 2], HEAP32[$fill$addr >> 2] | 0) | 0;
 if (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 4 >> 2] | 0) {
  if ((HEAP32[$B0 >> 2] | 0) > 1) _interleave_hadamard(HEAP32[$X$addr >> 2] | 0, HEAP32[$N_B >> 2] >> HEAP32[$recombine >> 2], HEAP32[$B0 >> 2] << HEAP32[$recombine >> 2], HEAP32[$longBlocks >> 2] | 0);
  HEAP32[$N_B >> 2] = HEAP32[$N_B0 >> 2];
  HEAP32[$B$addr >> 2] = HEAP32[$B0 >> 2];
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$time_divide >> 2] | 0)) break;
   HEAP32[$B$addr >> 2] = HEAP32[$B$addr >> 2] >> 1;
   HEAP32[$N_B >> 2] = HEAP32[$N_B >> 2] << 1;
   HEAP32[$cm >> 2] = HEAP32[$cm >> 2] | (HEAP32[$cm >> 2] | 0) >>> (HEAP32[$B$addr >> 2] | 0);
   _haar1(HEAP32[$X$addr >> 2] | 0, HEAP32[$N_B >> 2] | 0, HEAP32[$B$addr >> 2] | 0);
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$recombine >> 2] | 0)) break;
   HEAP32[$cm >> 2] = HEAPU8[33473 + (HEAP32[$cm >> 2] | 0) >> 0];
   _haar1(HEAP32[$X$addr >> 2] | 0, HEAP32[$N0 >> 2] >> HEAP32[$k >> 2], 1 << HEAP32[$k >> 2]);
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP32[$B$addr >> 2] = HEAP32[$B$addr >> 2] << HEAP32[$recombine >> 2];
  L54 : do if (HEAP32[$lowband_out$addr >> 2] | 0) {
   HEAPF32[$n >> 2] = +Math_sqrt(+(+(HEAP32[$N0 >> 2] | 0)));
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N0 >> 2] | 0)) break L54;
    HEAPF32[(HEAP32[$lowband_out$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$n >> 2] * +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
  } while (0);
  HEAP32[$cm >> 2] = HEAP32[$cm >> 2] & (1 << HEAP32[$B$addr >> 2]) - 1;
 }
 HEAP32[$retval >> 2] = HEAP32[$cm >> 2];
 $141 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $141 | 0;
}

function _clt_mdct_backward_c($l, $in, $out, $window, $overlap, $shift, $stride, $arch) {
 $l = $l | 0;
 $in = $in | 0;
 $out = $out | 0;
 $window = $window | 0;
 $overlap = $overlap | 0;
 $shift = $shift | 0;
 $stride = $stride | 0;
 $arch = $arch | 0;
 var $140 = 0, $147 = 0, $24 = 0, $N = 0, $N2 = 0, $N4 = 0, $add105 = 0.0, $bitrev = 0, $i = 0, $im = 0, $in$addr = 0, $l$addr = 0, $out$addr = 0, $overlap$addr = 0, $re = 0, $rev = 0, $shift$addr = 0, $shr = 0, $stride$addr = 0, $sub101 = 0.0, $t = 0, $t0 = 0, $t1 = 0, $t45 = 0, $trig = 0, $window$addr = 0, $wp1 = 0, $wp2 = 0, $x1 = 0, $x2 = 0, $xp1 = 0, $xp189 = 0, $xp2 = 0, $yi = 0, $yi54 = 0, $yp = 0, $yp0 = 0, $yp1 = 0, $yp192 = 0, $yr = 0, $yr53 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $l$addr = sp + 140 | 0;
 $in$addr = sp + 136 | 0;
 $out$addr = sp + 132 | 0;
 $window$addr = sp + 128 | 0;
 $overlap$addr = sp + 124 | 0;
 $shift$addr = sp + 120 | 0;
 $stride$addr = sp + 116 | 0;
 $i = sp + 108 | 0;
 $N = sp + 104 | 0;
 $N2 = sp + 100 | 0;
 $N4 = sp + 96 | 0;
 $trig = sp + 92 | 0;
 $xp1 = sp + 88 | 0;
 $xp2 = sp + 84 | 0;
 $yp = sp + 80 | 0;
 $t = sp + 76 | 0;
 $bitrev = sp + 72 | 0;
 $rev = sp + 68 | 0;
 $yr = sp + 64 | 0;
 $yi = sp + 60 | 0;
 $yp0 = sp + 56 | 0;
 $yp1 = sp + 52 | 0;
 $t45 = sp + 48 | 0;
 $re = sp + 44 | 0;
 $im = sp + 40 | 0;
 $yr53 = sp + 36 | 0;
 $yi54 = sp + 32 | 0;
 $t0 = sp + 28 | 0;
 $t1 = sp + 24 | 0;
 $xp189 = sp + 20 | 0;
 $yp192 = sp + 16 | 0;
 $wp1 = sp + 12 | 0;
 $wp2 = sp + 8 | 0;
 $x1 = sp + 4 | 0;
 $x2 = sp;
 HEAP32[$l$addr >> 2] = $l;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$window$addr >> 2] = $window;
 HEAP32[$overlap$addr >> 2] = $overlap;
 HEAP32[$shift$addr >> 2] = $shift;
 HEAP32[$stride$addr >> 2] = $stride;
 HEAP32[sp + 112 >> 2] = $arch;
 HEAP32[$N >> 2] = HEAP32[HEAP32[$l$addr >> 2] >> 2];
 HEAP32[$trig >> 2] = HEAP32[(HEAP32[$l$addr >> 2] | 0) + 24 >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  $shr = HEAP32[$N >> 2] >> 1;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$shift$addr >> 2] | 0)) break;
  HEAP32[$N >> 2] = $shr;
  HEAP32[$trig >> 2] = (HEAP32[$trig >> 2] | 0) + (HEAP32[$N >> 2] << 2);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$N2 >> 2] = $shr;
 HEAP32[$N4 >> 2] = HEAP32[$N >> 2] >> 2;
 HEAP32[$xp1 >> 2] = HEAP32[$in$addr >> 2];
 HEAP32[$xp2 >> 2] = (HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$stride$addr >> 2] | 0, (HEAP32[$N2 >> 2] | 0) - 1 | 0) | 0) << 2);
 HEAP32[$yp >> 2] = (HEAP32[$out$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] >> 1 << 2);
 HEAP32[$t >> 2] = HEAP32[$trig >> 2];
 HEAP32[$bitrev >> 2] = HEAP32[(HEAP32[(HEAP32[$l$addr >> 2] | 0) + 8 + (HEAP32[$shift$addr >> 2] << 2) >> 2] | 0) + 44 >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N4 >> 2] | 0)) break;
  $24 = HEAP32[$bitrev >> 2] | 0;
  HEAP32[$bitrev >> 2] = $24 + 2;
  HEAP32[$rev >> 2] = HEAP16[$24 >> 1];
  HEAPF32[$yr >> 2] = +HEAPF32[HEAP32[$xp2 >> 2] >> 2] * +HEAPF32[(HEAP32[$t >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[HEAP32[$xp1 >> 2] >> 2] * +HEAPF32[(HEAP32[$t >> 2] | 0) + ((HEAP32[$N4 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
  HEAPF32[$yi >> 2] = +HEAPF32[HEAP32[$xp1 >> 2] >> 2] * +HEAPF32[(HEAP32[$t >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[HEAP32[$xp2 >> 2] >> 2] * +HEAPF32[(HEAP32[$t >> 2] | 0) + ((HEAP32[$N4 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
  HEAPF32[(HEAP32[$yp >> 2] | 0) + ((HEAP32[$rev >> 2] << 1) + 1 << 2) >> 2] = +HEAPF32[$yr >> 2];
  HEAPF32[(HEAP32[$yp >> 2] | 0) + (HEAP32[$rev >> 2] << 1 << 2) >> 2] = +HEAPF32[$yi >> 2];
  HEAP32[$xp1 >> 2] = (HEAP32[$xp1 >> 2] | 0) + (HEAP32[$stride$addr >> 2] << 1 << 2);
  HEAP32[$xp2 >> 2] = (HEAP32[$xp2 >> 2] | 0) + (0 - (HEAP32[$stride$addr >> 2] << 1) << 2);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _opus_fft_impl(HEAP32[(HEAP32[$l$addr >> 2] | 0) + 8 + (HEAP32[$shift$addr >> 2] << 2) >> 2] | 0, (HEAP32[$out$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] >> 1 << 2) | 0);
 HEAP32[$yp0 >> 2] = (HEAP32[$out$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] >> 1 << 2);
 HEAP32[$yp1 >> 2] = (HEAP32[$out$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] >> 1 << 2) + (HEAP32[$N2 >> 2] << 2) + -8;
 HEAP32[$t45 >> 2] = HEAP32[$trig >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$N4 >> 2] | 0) + 1 >> 1 | 0)) break;
  HEAPF32[$re >> 2] = +HEAPF32[(HEAP32[$yp0 >> 2] | 0) + 4 >> 2];
  HEAPF32[$im >> 2] = +HEAPF32[HEAP32[$yp0 >> 2] >> 2];
  HEAPF32[$t0 >> 2] = +HEAPF32[(HEAP32[$t45 >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$t1 >> 2] = +HEAPF32[(HEAP32[$t45 >> 2] | 0) + ((HEAP32[$N4 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
  HEAPF32[$yr53 >> 2] = +HEAPF32[$re >> 2] * +HEAPF32[$t0 >> 2] + +HEAPF32[$im >> 2] * +HEAPF32[$t1 >> 2];
  HEAPF32[$yi54 >> 2] = +HEAPF32[$re >> 2] * +HEAPF32[$t1 >> 2] - +HEAPF32[$im >> 2] * +HEAPF32[$t0 >> 2];
  HEAPF32[$re >> 2] = +HEAPF32[(HEAP32[$yp1 >> 2] | 0) + 4 >> 2];
  HEAPF32[$im >> 2] = +HEAPF32[HEAP32[$yp1 >> 2] >> 2];
  HEAPF32[HEAP32[$yp0 >> 2] >> 2] = +HEAPF32[$yr53 >> 2];
  HEAPF32[(HEAP32[$yp1 >> 2] | 0) + 4 >> 2] = +HEAPF32[$yi54 >> 2];
  HEAPF32[$t0 >> 2] = +HEAPF32[(HEAP32[$t45 >> 2] | 0) + ((HEAP32[$N4 >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2];
  HEAPF32[$t1 >> 2] = +HEAPF32[(HEAP32[$t45 >> 2] | 0) + ((HEAP32[$N2 >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2];
  HEAPF32[$yr53 >> 2] = +HEAPF32[$re >> 2] * +HEAPF32[$t0 >> 2] + +HEAPF32[$im >> 2] * +HEAPF32[$t1 >> 2];
  HEAPF32[$yi54 >> 2] = +HEAPF32[$re >> 2] * +HEAPF32[$t1 >> 2] - +HEAPF32[$im >> 2] * +HEAPF32[$t0 >> 2];
  HEAPF32[HEAP32[$yp1 >> 2] >> 2] = +HEAPF32[$yr53 >> 2];
  HEAPF32[(HEAP32[$yp0 >> 2] | 0) + 4 >> 2] = +HEAPF32[$yi54 >> 2];
  HEAP32[$yp0 >> 2] = (HEAP32[$yp0 >> 2] | 0) + 8;
  HEAP32[$yp1 >> 2] = (HEAP32[$yp1 >> 2] | 0) + -8;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$xp189 >> 2] = (HEAP32[$out$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] << 2) + -4;
 HEAP32[$yp192 >> 2] = HEAP32[$out$addr >> 2];
 HEAP32[$wp1 >> 2] = HEAP32[$window$addr >> 2];
 HEAP32[$wp2 >> 2] = (HEAP32[$window$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] << 2) + -4;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$overlap$addr >> 2] | 0) / 2 | 0 | 0)) break;
  HEAPF32[$x1 >> 2] = +HEAPF32[HEAP32[$xp189 >> 2] >> 2];
  HEAPF32[$x2 >> 2] = +HEAPF32[HEAP32[$yp192 >> 2] >> 2];
  $sub101 = +HEAPF32[HEAP32[$wp2 >> 2] >> 2] * +HEAPF32[$x2 >> 2] - +HEAPF32[HEAP32[$wp1 >> 2] >> 2] * +HEAPF32[$x1 >> 2];
  $140 = HEAP32[$yp192 >> 2] | 0;
  HEAP32[$yp192 >> 2] = $140 + 4;
  HEAPF32[$140 >> 2] = $sub101;
  $add105 = +HEAPF32[HEAP32[$wp1 >> 2] >> 2] * +HEAPF32[$x2 >> 2] + +HEAPF32[HEAP32[$wp2 >> 2] >> 2] * +HEAPF32[$x1 >> 2];
  $147 = HEAP32[$xp189 >> 2] | 0;
  HEAP32[$xp189 >> 2] = $147 + -4;
  HEAPF32[$147 >> 2] = $add105;
  HEAP32[$wp1 >> 2] = (HEAP32[$wp1 >> 2] | 0) + 4;
  HEAP32[$wp2 >> 2] = (HEAP32[$wp2 >> 2] | 0) + -4;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _spreading_decision($m, $X, $average, $last_decision, $hf_average, $tapset_decision, $update_hf, $end, $C, $M, $spread_weight) {
 $m = $m | 0;
 $X = $X | 0;
 $average = $average | 0;
 $last_decision = $last_decision | 0;
 $hf_average = $hf_average | 0;
 $tapset_decision = $tapset_decision | 0;
 $update_hf = $update_hf | 0;
 $end = $end | 0;
 $C = $C | 0;
 $M = $M | 0;
 $spread_weight = $spread_weight | 0;
 var $106 = 0, $C$addr = 0, $M$addr = 0, $N = 0, $N0 = 0, $X$addr = 0, $add$ptr = 0, $arrayidx41 = 0, $arrayidx47 = 0, $average$addr = 0, $c = 0, $call = 0, $decision = 0, $eBands = 0, $end$addr = 0, $hf_average$addr = 0, $hf_sum = 0, $i = 0, $inc83 = 0, $j = 0, $last_decision$addr = 0, $m$addr = 0, $mul76 = 0, $nbBands = 0, $retval = 0, $spread_weight$addr = 0, $sum = 0, $tapset_decision$addr = 0, $tcount = 0, $tmp = 0, $update_hf$addr = 0, $x = 0, $x2N = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $retval = sp + 108 | 0;
 $m$addr = sp + 104 | 0;
 $X$addr = sp + 100 | 0;
 $average$addr = sp + 96 | 0;
 $last_decision$addr = sp + 92 | 0;
 $hf_average$addr = sp + 88 | 0;
 $tapset_decision$addr = sp + 84 | 0;
 $update_hf$addr = sp + 80 | 0;
 $end$addr = sp + 76 | 0;
 $C$addr = sp + 72 | 0;
 $M$addr = sp + 68 | 0;
 $spread_weight$addr = sp + 64 | 0;
 $i = sp + 60 | 0;
 $c = sp + 56 | 0;
 $N0 = sp + 52 | 0;
 $sum = sp + 48 | 0;
 $nbBands = sp + 44 | 0;
 $eBands = sp + 40 | 0;
 $decision = sp + 36 | 0;
 $hf_sum = sp + 32 | 0;
 $j = sp + 28 | 0;
 $N = sp + 24 | 0;
 $tmp = sp + 20 | 0;
 $tcount = sp + 8 | 0;
 $x = sp + 4 | 0;
 $x2N = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$average$addr >> 2] = $average;
 HEAP32[$last_decision$addr >> 2] = $last_decision;
 HEAP32[$hf_average$addr >> 2] = $hf_average;
 HEAP32[$tapset_decision$addr >> 2] = $tapset_decision;
 HEAP32[$update_hf$addr >> 2] = $update_hf;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$M$addr >> 2] = $M;
 HEAP32[$spread_weight$addr >> 2] = $spread_weight;
 HEAP32[$sum >> 2] = 0;
 HEAP32[$nbBands >> 2] = 0;
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$hf_sum >> 2] = 0;
 HEAP32[$N0 >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 44 >> 2] | 0) | 0;
 if ((Math_imul(HEAP32[$M$addr >> 2] | 0, (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$end$addr >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$end$addr >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) | 0) <= 8) {
  HEAP32[$retval >> 2] = 0;
  $106 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $106 | 0;
 }
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   HEAP32[$tmp >> 2] = 0;
   HEAP32[$tcount >> 2] = 0;
   HEAP32[$tcount + 4 >> 2] = 0;
   HEAP32[$tcount + 8 >> 2] = 0;
   $add$ptr = (HEAP32[$X$addr >> 2] | 0) + ((Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) << 2) | 0;
   HEAP32[$x >> 2] = $add$ptr + ((Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$N0 >> 2] | 0) | 0) << 2);
   HEAP32[$N >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) | 0;
   if ((HEAP32[$N >> 2] | 0) > 8) {
    HEAP32[$j >> 2] = 0;
    while (1) {
     if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
     HEAPF32[$x2N >> 2] = +HEAPF32[(HEAP32[$x >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$x >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] * +(HEAP32[$N >> 2] | 0);
     if (+HEAPF32[$x2N >> 2] < .25) HEAP32[$tcount >> 2] = (HEAP32[$tcount >> 2] | 0) + 1;
     if (+HEAPF32[$x2N >> 2] < .0625) {
      $arrayidx41 = $tcount + 4 | 0;
      HEAP32[$arrayidx41 >> 2] = (HEAP32[$arrayidx41 >> 2] | 0) + 1;
     }
     if (+HEAPF32[$x2N >> 2] < .015625) {
      $arrayidx47 = $tcount + 8 | 0;
      HEAP32[$arrayidx47 >> 2] = (HEAP32[$arrayidx47 >> 2] | 0) + 1;
     }
     HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
    }
    if ((HEAP32[$i >> 2] | 0) > ((HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) - 4 | 0)) {
     $call = _celt_udiv_365((HEAP32[$tcount + 4 >> 2] | 0) + (HEAP32[$tcount >> 2] | 0) << 5, HEAP32[$N >> 2] | 0) | 0;
     HEAP32[$hf_sum >> 2] = (HEAP32[$hf_sum >> 2] | 0) + $call;
    }
    HEAP32[$tmp >> 2] = ((HEAP32[$tcount + 8 >> 2] << 1 | 0) >= (HEAP32[$N >> 2] | 0) & 1) + ((HEAP32[$tcount + 4 >> 2] << 1 | 0) >= (HEAP32[$N >> 2] | 0) & 1) + ((HEAP32[$tcount >> 2] << 1 | 0) >= (HEAP32[$N >> 2] | 0) & 1);
    $mul76 = Math_imul(HEAP32[$tmp >> 2] | 0, HEAP32[(HEAP32[$spread_weight$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) | 0;
    HEAP32[$sum >> 2] = (HEAP32[$sum >> 2] | 0) + $mul76;
    HEAP32[$nbBands >> 2] = (HEAP32[$nbBands >> 2] | 0) + (HEAP32[(HEAP32[$spread_weight$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0);
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc83 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc83;
 } while (($inc83 | 0) < (HEAP32[$C$addr >> 2] | 0));
 do if (HEAP32[$update_hf$addr >> 2] | 0) {
  if (HEAP32[$hf_sum >> 2] | 0) HEAP32[$hf_sum >> 2] = _celt_udiv_365(HEAP32[$hf_sum >> 2] | 0, Math_imul(HEAP32[$C$addr >> 2] | 0, 4 - (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[$end$addr >> 2] | 0) | 0) | 0) | 0;
  HEAP32[HEAP32[$hf_average$addr >> 2] >> 2] = (HEAP32[HEAP32[$hf_average$addr >> 2] >> 2] | 0) + (HEAP32[$hf_sum >> 2] | 0) >> 1;
  HEAP32[$hf_sum >> 2] = HEAP32[HEAP32[$hf_average$addr >> 2] >> 2];
  if ((HEAP32[HEAP32[$tapset_decision$addr >> 2] >> 2] | 0) == 2) HEAP32[$hf_sum >> 2] = (HEAP32[$hf_sum >> 2] | 0) + 4; else if (!(HEAP32[HEAP32[$tapset_decision$addr >> 2] >> 2] | 0)) HEAP32[$hf_sum >> 2] = (HEAP32[$hf_sum >> 2] | 0) - 4;
  if ((HEAP32[$hf_sum >> 2] | 0) > 22) {
   HEAP32[HEAP32[$tapset_decision$addr >> 2] >> 2] = 2;
   break;
  } else {
   HEAP32[HEAP32[$tapset_decision$addr >> 2] >> 2] = (HEAP32[$hf_sum >> 2] | 0) > 18 ? 1 : 0;
   break;
  }
 } while (0);
 HEAP32[$sum >> 2] = _celt_udiv_365(HEAP32[$sum >> 2] << 8, HEAP32[$nbBands >> 2] | 0) | 0;
 HEAP32[$sum >> 2] = (HEAP32[$sum >> 2] | 0) + (HEAP32[HEAP32[$average$addr >> 2] >> 2] | 0) >> 1;
 HEAP32[HEAP32[$average$addr >> 2] >> 2] = HEAP32[$sum >> 2];
 HEAP32[$sum >> 2] = ((HEAP32[$sum >> 2] | 0) * 3 | 0) + ((3 - (HEAP32[$last_decision$addr >> 2] | 0) << 7) + 64) + 2 >> 2;
 do if ((HEAP32[$sum >> 2] | 0) < 80) HEAP32[$decision >> 2] = 3; else {
  if ((HEAP32[$sum >> 2] | 0) < 256) {
   HEAP32[$decision >> 2] = 2;
   break;
  }
  if ((HEAP32[$sum >> 2] | 0) < 384) {
   HEAP32[$decision >> 2] = 1;
   break;
  } else {
   HEAP32[$decision >> 2] = 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = HEAP32[$decision >> 2];
 $106 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $106 | 0;
}

function _anti_collapse($m, $X_, $collapse_masks, $LM, $C, $size, $start, $end, $logE, $prev1logE, $prev2logE, $pulses, $seed, $arch) {
 $m = $m | 0;
 $X_ = $X_ | 0;
 $collapse_masks = $collapse_masks | 0;
 $LM = $LM | 0;
 $C = $C | 0;
 $size = $size | 0;
 $start = $start | 0;
 $end = $end | 0;
 $logE = $logE | 0;
 $prev1logE = $prev1logE | 0;
 $prev2logE = $prev2logE | 0;
 $pulses = $pulses | 0;
 $seed = $seed | 0;
 $arch = $arch | 0;
 var $104 = 0.0, $C$addr = 0, $Ediff = 0, $LM$addr = 0, $N0 = 0, $X = 0, $X_$addr = 0, $add$ptr = 0, $arch$addr = 0, $c = 0, $call = 0, $collapse_masks$addr = 0, $cond = 0.0, $cond51 = 0.0, $depth = 0, $end$addr = 0, $i = 0, $inc127 = 0, $j = 0, $k = 0, $logE$addr = 0, $m$addr = 0, $mul23 = 0, $mul27 = 0, $mul53 = 0, $mul98 = 0, $prev1 = 0, $prev1logE$addr = 0, $prev2 = 0, $prev2logE$addr = 0, $pulses$addr = 0, $r = 0, $renormalize = 0, $seed$addr = 0, $size$addr = 0, $sqrt_1 = 0, $start$addr = 0, $thresh = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $m$addr = sp + 108 | 0;
 $X_$addr = sp + 104 | 0;
 $collapse_masks$addr = sp + 100 | 0;
 $LM$addr = sp + 96 | 0;
 $C$addr = sp + 92 | 0;
 $size$addr = sp + 88 | 0;
 $start$addr = sp + 84 | 0;
 $end$addr = sp + 80 | 0;
 $logE$addr = sp + 76 | 0;
 $prev1logE$addr = sp + 72 | 0;
 $prev2logE$addr = sp + 68 | 0;
 $pulses$addr = sp + 64 | 0;
 $seed$addr = sp + 60 | 0;
 $arch$addr = sp + 56 | 0;
 $c = sp + 52 | 0;
 $i = sp + 48 | 0;
 $j = sp + 44 | 0;
 $k = sp + 40 | 0;
 $N0 = sp + 36 | 0;
 $thresh = sp + 32 | 0;
 $sqrt_1 = sp + 28 | 0;
 $depth = sp + 24 | 0;
 $X = sp + 20 | 0;
 $prev1 = sp + 16 | 0;
 $prev2 = sp + 12 | 0;
 $Ediff = sp + 8 | 0;
 $r = sp + 4 | 0;
 $renormalize = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$X_$addr >> 2] = $X_;
 HEAP32[$collapse_masks$addr >> 2] = $collapse_masks;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$size$addr >> 2] = $size;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$logE$addr >> 2] = $logE;
 HEAP32[$prev1logE$addr >> 2] = $prev1logE;
 HEAP32[$prev2logE$addr >> 2] = $prev2logE;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$seed$addr >> 2] = $seed;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP32[$N0 >> 2] = (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0);
  $call = _celt_udiv_365(1 + (HEAP32[(HEAP32[$pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) | 0, (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) | 0;
  HEAP32[$depth >> 2] = $call >>> (HEAP32[$LM$addr >> 2] | 0);
  HEAPF32[$thresh >> 2] = +Math_exp(+(+(HEAP32[$depth >> 2] | 0) * -.125 * .6931471805599453)) * .5;
  HEAPF32[$sqrt_1 >> 2] = 1.0 / +Math_sqrt(+(+(HEAP32[$N0 >> 2] << HEAP32[$LM$addr >> 2] | 0)));
  HEAP32[$c >> 2] = 0;
  do {
   HEAP32[$renormalize >> 2] = 0;
   $mul23 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
   HEAPF32[$prev1 >> 2] = +HEAPF32[(HEAP32[$prev1logE$addr >> 2] | 0) + ($mul23 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
   $mul27 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
   HEAPF32[$prev2 >> 2] = +HEAPF32[(HEAP32[$prev2logE$addr >> 2] | 0) + ($mul27 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
   if ((HEAP32[$C$addr >> 2] | 0) == 1) {
    if (+HEAPF32[$prev1 >> 2] > +HEAPF32[(HEAP32[$prev1logE$addr >> 2] | 0) + ((HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2]) $cond = +HEAPF32[$prev1 >> 2]; else $cond = +HEAPF32[(HEAP32[$prev1logE$addr >> 2] | 0) + ((HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
    HEAPF32[$prev1 >> 2] = $cond;
    if (+HEAPF32[$prev2 >> 2] > +HEAPF32[(HEAP32[$prev2logE$addr >> 2] | 0) + ((HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2]) $cond51 = +HEAPF32[$prev2 >> 2]; else $cond51 = +HEAPF32[(HEAP32[$prev2logE$addr >> 2] | 0) + ((HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
    HEAPF32[$prev2 >> 2] = $cond51;
   }
   $mul53 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
   HEAPF32[$Ediff >> 2] = +HEAPF32[(HEAP32[$logE$addr >> 2] | 0) + ($mul53 + (HEAP32[$i >> 2] | 0) << 2) >> 2] - (+HEAPF32[$prev1 >> 2] < +HEAPF32[$prev2 >> 2] ? +HEAPF32[$prev1 >> 2] : +HEAPF32[$prev2 >> 2]);
   HEAPF32[$Ediff >> 2] = 0.0 > +HEAPF32[$Ediff >> 2] ? 0.0 : +HEAPF32[$Ediff >> 2];
   HEAPF32[$r >> 2] = +Math_exp(+(-+HEAPF32[$Ediff >> 2] * .6931471805599453)) * 2.0;
   if ((HEAP32[$LM$addr >> 2] | 0) == 3) HEAPF32[$r >> 2] = +HEAPF32[$r >> 2] * 1.4142135381698608;
   HEAPF32[$r >> 2] = +HEAPF32[$thresh >> 2] < +HEAPF32[$r >> 2] ? +HEAPF32[$thresh >> 2] : +HEAPF32[$r >> 2];
   HEAPF32[$r >> 2] = +HEAPF32[$r >> 2] * +HEAPF32[$sqrt_1 >> 2];
   $add$ptr = (HEAP32[$X_$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$size$addr >> 2] | 0) | 0) << 2) | 0;
   HEAP32[$X >> 2] = $add$ptr + (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2] << 2);
   HEAP32[$k >> 2] = 0;
   while (1) {
    if ((HEAP32[$k >> 2] | 0) >= (1 << HEAP32[$LM$addr >> 2] | 0)) break;
    $mul98 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0;
    if (!(HEAPU8[(HEAP32[$collapse_masks$addr >> 2] | 0) + ($mul98 + (HEAP32[$c >> 2] | 0)) >> 0] & 1 << HEAP32[$k >> 2])) {
     HEAP32[$j >> 2] = 0;
     while (1) {
      if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N0 >> 2] | 0)) break;
      HEAP32[$seed$addr >> 2] = _celt_lcg_rand(HEAP32[$seed$addr >> 2] | 0) | 0;
      $104 = +HEAPF32[$r >> 2];
      HEAPF32[(HEAP32[$X >> 2] | 0) + ((HEAP32[$j >> 2] << HEAP32[$LM$addr >> 2]) + (HEAP32[$k >> 2] | 0) << 2) >> 2] = HEAP32[$seed$addr >> 2] & 32768 | 0 ? $104 : -$104;
      HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
     }
     HEAP32[$renormalize >> 2] = 1;
    }
    HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   }
   if (HEAP32[$renormalize >> 2] | 0) _renormalise_vector(HEAP32[$X >> 2] | 0, HEAP32[$N0 >> 2] << HEAP32[$LM$addr >> 2], 1.0, HEAP32[$arch$addr >> 2] | 0);
   $inc127 = (HEAP32[$c >> 2] | 0) + 1 | 0;
   HEAP32[$c >> 2] = $inc127;
  } while (($inc127 | 0) < (HEAP32[$C$addr >> 2] | 0));
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_NLSF_encode($NLSFIndices, $pNLSF_Q15, $psNLSF_CB, $pW_Q2, $NLSF_mu_Q20, $nSurvivors, $signalType) {
 $NLSFIndices = $NLSFIndices | 0;
 $pNLSF_Q15 = $pNLSF_Q15 | 0;
 $psNLSF_CB = $psNLSF_CB | 0;
 $pW_Q2 = $pW_Q2 | 0;
 $NLSF_mu_Q20 = $NLSF_mu_Q20 | 0;
 $nSurvivors = $nSurvivors | 0;
 $signalType = $signalType | 0;
 var $107 = 0, $7 = 0, $81 = 0, $82 = 0, $NLSFIndices$addr = 0, $NLSF_mu_Q20$addr = 0, $NLSF_tmp_Q15 = 0, $W_adj_Q5 = 0, $W_tmp_Q9 = 0, $add = 0, $bestIndex = 0, $bits_q7 = 0, $call63 = 0, $conv43 = 0, $conv52 = 0, $ec_ix = 0, $i = 0, $iCDF_ptr = 0, $ind1 = 0, $nSurvivors$addr = 0, $pCB_Wght_Q9 = 0, $pCB_element = 0, $pNLSF_Q15$addr = 0, $pW_Q2$addr = 0, $pred_Q8 = 0, $prob_Q8 = 0, $psNLSF_CB$addr = 0, $res_Q10 = 0, $ret = 0, $s = 0, $saved_stack = 0, $signalType$addr = 0, $vla = 0, $vla5 = 0, $vla8 = 0, $vla9 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 $NLSFIndices$addr = sp + 72 | 0;
 $pNLSF_Q15$addr = sp + 68 | 0;
 $psNLSF_CB$addr = sp + 64 | 0;
 $pW_Q2$addr = sp + 60 | 0;
 $NLSF_mu_Q20$addr = sp + 56 | 0;
 $nSurvivors$addr = sp + 52 | 0;
 $signalType$addr = sp + 48 | 0;
 $i = sp + 44 | 0;
 $s = sp + 40 | 0;
 $ind1 = sp + 36 | 0;
 $bestIndex = sp + 32 | 0;
 $prob_Q8 = sp + 28 | 0;
 $bits_q7 = sp + 24 | 0;
 $W_tmp_Q9 = sp + 20 | 0;
 $ret = sp + 16 | 0;
 $res_Q10 = sp + 176 | 0;
 $NLSF_tmp_Q15 = sp + 144 | 0;
 $W_adj_Q5 = sp + 112 | 0;
 $pred_Q8 = sp + 208 | 0;
 $ec_ix = sp + 80 | 0;
 $pCB_element = sp + 12 | 0;
 $iCDF_ptr = sp + 8 | 0;
 $pCB_Wght_Q9 = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$NLSFIndices$addr >> 2] = $NLSFIndices;
 HEAP32[$pNLSF_Q15$addr >> 2] = $pNLSF_Q15;
 HEAP32[$psNLSF_CB$addr >> 2] = $psNLSF_CB;
 HEAP32[$pW_Q2$addr >> 2] = $pW_Q2;
 HEAP32[$NLSF_mu_Q20$addr >> 2] = $NLSF_mu_Q20;
 HEAP32[$nSurvivors$addr >> 2] = $nSurvivors;
 HEAP32[$signalType$addr >> 2] = $signalType;
 _silk_NLSF_stabilize(HEAP32[$pNLSF_Q15$addr >> 2] | 0, HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 36 >> 2] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0);
 $7 = HEAPU16[HEAP32[$psNLSF_CB$addr >> 2] >> 1] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($7 << 2) | 0) + 15 & -16) | 0;
 _silk_NLSF_VQ($vla, HEAP32[$pNLSF_Q15$addr >> 2] | 0, HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 12 >> 2] | 0, HEAP16[HEAP32[$psNLSF_CB$addr >> 2] >> 1] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0);
 $vla5 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nSurvivors$addr >> 2] << 2) | 0) + 15 & -16) | 0;
 _silk_insertion_sort_increasing($vla, $vla5, HEAP16[HEAP32[$psNLSF_CB$addr >> 2] >> 1] | 0, HEAP32[$nSurvivors$addr >> 2] | 0);
 $vla8 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nSurvivors$addr >> 2] << 2) | 0) + 15 & -16) | 0;
 $vla9 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$nSurvivors$addr >> 2] << 4) | 0) + 15 & -16) | 0;
 HEAP32[$s >> 2] = 0;
 while (1) {
  if ((HEAP32[$s >> 2] | 0) >= (HEAP32[$nSurvivors$addr >> 2] | 0)) break;
  HEAP32[$ind1 >> 2] = HEAP32[$vla5 + (HEAP32[$s >> 2] << 2) >> 2];
  HEAP32[$pCB_element >> 2] = (HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 8 >> 2] | 0) + (Math_imul(HEAP32[$ind1 >> 2] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0) | 0);
  HEAP32[$pCB_Wght_Q9 >> 2] = (HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 12 >> 2] | 0) + ((Math_imul(HEAP32[$ind1 >> 2] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0) | 0) << 1);
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0)) break;
   HEAP16[$NLSF_tmp_Q15 + (HEAP32[$i >> 2] << 1) >> 1] = (HEAPU8[(HEAP32[$pCB_element >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] & 65535) << 7;
   HEAP32[$W_tmp_Q9 >> 2] = HEAP16[(HEAP32[$pCB_Wght_Q9 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1];
   $conv43 = (Math_imul(((HEAP16[(HEAP32[$pNLSF_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) - (HEAP16[$NLSF_tmp_Q15 + (HEAP32[$i >> 2] << 1) >> 1] | 0) & 65535) << 16 >> 16, (HEAP32[$W_tmp_Q9 >> 2] & 65535) << 16 >> 16) | 0) >> 14 & 65535;
   HEAP16[$res_Q10 + (HEAP32[$i >> 2] << 1) >> 1] = $conv43;
   $conv52 = (_silk_DIV32_varQ_558(HEAP16[(HEAP32[$pW_Q2$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, Math_imul((HEAP32[$W_tmp_Q9 >> 2] & 65535) << 16 >> 16, (HEAP32[$W_tmp_Q9 >> 2] & 65535) << 16 >> 16) | 0, 21) | 0) & 65535;
   HEAP16[$W_adj_Q5 + (HEAP32[$i >> 2] << 1) >> 1] = $conv52;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  _silk_NLSF_unpack($ec_ix, $pred_Q8, HEAP32[$psNLSF_CB$addr >> 2] | 0, HEAP32[$ind1 >> 2] | 0);
  $call63 = _silk_NLSF_del_dec_quant($vla9 + (HEAP32[$s >> 2] << 4) | 0, $res_Q10, $W_adj_Q5, $pred_Q8, $ec_ix, HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 32 >> 2] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 4 >> 1] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 6 >> 1] | 0, HEAP32[$NLSF_mu_Q20$addr >> 2] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0) | 0;
  HEAP32[$vla8 + (HEAP32[$s >> 2] << 2) >> 2] = $call63;
  HEAP32[$iCDF_ptr >> 2] = (HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 16 >> 2] | 0) + (Math_imul(HEAP32[$signalType$addr >> 2] >> 1, HEAP16[HEAP32[$psNLSF_CB$addr >> 2] >> 1] | 0) | 0);
  $81 = HEAP32[$iCDF_ptr >> 2] | 0;
  $82 = HEAP32[$ind1 >> 2] | 0;
  if (!(HEAP32[$ind1 >> 2] | 0)) HEAP32[$prob_Q8 >> 2] = 256 - (HEAPU8[$81 + $82 >> 0] | 0); else HEAP32[$prob_Q8 >> 2] = (HEAPU8[$81 + ($82 - 1) >> 0] | 0) - (HEAPU8[(HEAP32[$iCDF_ptr >> 2] | 0) + (HEAP32[$ind1 >> 2] | 0) >> 0] | 0);
  HEAP32[$bits_q7 >> 2] = 1024 - (_silk_lin2log(HEAP32[$prob_Q8 >> 2] | 0) | 0);
  $add = (HEAP32[$vla8 + (HEAP32[$s >> 2] << 2) >> 2] | 0) + (Math_imul((HEAP32[$bits_q7 >> 2] & 65535) << 16 >> 16, (HEAP32[$NLSF_mu_Q20$addr >> 2] >> 2 & 65535) << 16 >> 16) | 0) | 0;
  HEAP32[$vla8 + (HEAP32[$s >> 2] << 2) >> 2] = $add;
  HEAP32[$s >> 2] = (HEAP32[$s >> 2] | 0) + 1;
 }
 _silk_insertion_sort_increasing($vla8, $bestIndex, HEAP32[$nSurvivors$addr >> 2] | 0, 1);
 HEAP8[HEAP32[$NLSFIndices$addr >> 2] >> 0] = HEAP32[$vla5 + (HEAP32[$bestIndex >> 2] << 2) >> 2];
 _memcpy((HEAP32[$NLSFIndices$addr >> 2] | 0) + 1 | 0, $vla9 + (HEAP32[$bestIndex >> 2] << 4) | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0) | 0;
 _silk_NLSF_decode(HEAP32[$pNLSF_Q15$addr >> 2] | 0, HEAP32[$NLSFIndices$addr >> 2] | 0, HEAP32[$psNLSF_CB$addr >> 2] | 0);
 HEAP32[$ret >> 2] = HEAP32[$vla8 >> 2];
 $107 = HEAP32[$ret >> 2] | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return $107 | 0;
}

function _silk_setup_complexity($psEncC, $Complexity) {
 $psEncC = $psEncC | 0;
 $Complexity = $Complexity | 0;
 var $$sink$sink$sink$sink$sink$sink = 0, $Complexity$addr = 0, $call = 0, $mul86$sink$sink$sink$sink$sink$sink = 0, $pitchEstimationComplexity61 = 0, $psEncC$addr = 0, $ret = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psEncC$addr = sp + 8 | 0;
 $Complexity$addr = sp + 4 | 0;
 $ret = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$Complexity$addr >> 2] = $Complexity;
 HEAP32[$ret >> 2] = 0;
 do if ((HEAP32[$Complexity$addr >> 2] | 0) < 1) {
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4640 >> 2] = 0;
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4648 >> 2] = 52429;
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4644 >> 2] = 6;
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4632 >> 2] = 12;
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4596 >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 3;
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] = 1;
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4628 >> 2] = 0;
  HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4656 >> 2] = 2;
  $$sink$sink$sink$sink$sink$sink = HEAP32[$psEncC$addr >> 2] | 0;
  $mul86$sink$sink$sink$sink$sink$sink = 0;
 } else {
  if ((HEAP32[$Complexity$addr >> 2] | 0) < 2) {
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4640 >> 2] = 1;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4648 >> 2] = 49807;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4644 >> 2] = 8;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4632 >> 2] = 14;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4596 >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 5;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] = 1;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4628 >> 2] = 0;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4656 >> 2] = 3;
   $$sink$sink$sink$sink$sink$sink = HEAP32[$psEncC$addr >> 2] | 0;
   $mul86$sink$sink$sink$sink$sink$sink = 0;
   break;
  }
  if ((HEAP32[$Complexity$addr >> 2] | 0) < 3) {
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4640 >> 2] = 0;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4648 >> 2] = 52429;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4644 >> 2] = 6;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4632 >> 2] = 12;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4596 >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 3;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] = 2;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4628 >> 2] = 0;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4656 >> 2] = 2;
   $$sink$sink$sink$sink$sink$sink = HEAP32[$psEncC$addr >> 2] | 0;
   $mul86$sink$sink$sink$sink$sink$sink = 0;
   break;
  }
  if ((HEAP32[$Complexity$addr >> 2] | 0) < 4) {
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4640 >> 2] = 1;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4648 >> 2] = 49807;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4644 >> 2] = 8;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4632 >> 2] = 14;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4596 >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 5;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] = 2;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4628 >> 2] = 0;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4656 >> 2] = 4;
   $$sink$sink$sink$sink$sink$sink = HEAP32[$psEncC$addr >> 2] | 0;
   $mul86$sink$sink$sink$sink$sink$sink = 0;
   break;
  }
  if ((HEAP32[$Complexity$addr >> 2] | 0) < 6) {
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4640 >> 2] = 1;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4648 >> 2] = 48497;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4644 >> 2] = 10;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4632 >> 2] = 16;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4596 >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 5;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] = 2;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4628 >> 2] = 1;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4656 >> 2] = 6;
   $$sink$sink$sink$sink$sink$sink = HEAP32[$psEncC$addr >> 2] | 0;
   $mul86$sink$sink$sink$sink$sink$sink = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 983 | 0;
   break;
  }
  $pitchEstimationComplexity61 = (HEAP32[$psEncC$addr >> 2] | 0) + 4640 | 0;
  if ((HEAP32[$Complexity$addr >> 2] | 0) < 8) {
   HEAP32[$pitchEstimationComplexity61 >> 2] = 1;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4648 >> 2] = 47186;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4644 >> 2] = 12;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4632 >> 2] = 20;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4596 >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 5;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] = 3;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4628 >> 2] = 1;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4656 >> 2] = 8;
   $$sink$sink$sink$sink$sink$sink = HEAP32[$psEncC$addr >> 2] | 0;
   $mul86$sink$sink$sink$sink$sink$sink = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 983 | 0;
   break;
  } else {
   HEAP32[$pitchEstimationComplexity61 >> 2] = 2;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4648 >> 2] = 45875;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4644 >> 2] = 16;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4632 >> 2] = 24;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4596 >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 5;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4624 >> 2] = 4;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4628 >> 2] = 1;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4656 >> 2] = 16;
   $$sink$sink$sink$sink$sink$sink = HEAP32[$psEncC$addr >> 2] | 0;
   $mul86$sink$sink$sink$sink$sink$sink = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 983 | 0;
   break;
  }
 } while (0);
 HEAP32[$$sink$sink$sink$sink$sink$sink + 4668 >> 2] = $mul86$sink$sink$sink$sink$sink$sink;
 $call = _silk_min_int(HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4644 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0) | 0;
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4644 >> 2] = $call;
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4600 >> 2] = ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) * 5 | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4596 >> 2] << 1);
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4620 >> 2] = HEAP32[$Complexity$addr >> 2];
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _opus_encoder_init($st, $Fs, $channels, $application) {
 $st = $st | 0;
 $Fs = $Fs | 0;
 $channels = $channels | 0;
 $application = $application | 0;
 var $10 = 0, $25 = 0, $60 = 0, $61 = 0, $98 = 0, $Fs$addr = 0, $add62 = 0, $application$addr = 0, $call21 = 0, $call28 = 0, $celt_enc = 0, $channels$addr = 0, $err = 0, $ret = 0, $retval = 0, $shl = 0, $silkEncSizeBytes = 0, $silk_enc = 0, $st$addr = 0, $vararg_buffer = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $vararg_buffer7 = sp + 8 | 0;
 $vararg_buffer = sp;
 $retval = sp + 48 | 0;
 $st$addr = sp + 44 | 0;
 $Fs$addr = sp + 40 | 0;
 $channels$addr = sp + 36 | 0;
 $application$addr = sp + 32 | 0;
 $silk_enc = sp + 28 | 0;
 $celt_enc = sp + 24 | 0;
 $err = sp + 20 | 0;
 $ret = sp + 16 | 0;
 $silkEncSizeBytes = sp + 12 | 0;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$application$addr >> 2] = $application;
 if (!((HEAP32[$Fs$addr >> 2] | 0) != 48e3 & (HEAP32[$Fs$addr >> 2] | 0) != 24e3 & (HEAP32[$Fs$addr >> 2] | 0) != 16e3 & (HEAP32[$Fs$addr >> 2] | 0) != 12e3 & (HEAP32[$Fs$addr >> 2] | 0) != 8e3)) if (!((HEAP32[$channels$addr >> 2] | 0) != 1 & (HEAP32[$channels$addr >> 2] | 0) != 2)) if (!((HEAP32[$application$addr >> 2] | 0) != 2048 & (HEAP32[$application$addr >> 2] | 0) != 2049 & (HEAP32[$application$addr >> 2] | 0) != 2051)) {
  $10 = HEAP32[$st$addr >> 2] | 0;
  _memset($10 | 0, 0, _opus_encoder_get_size(HEAP32[$channels$addr >> 2] | 0) | 0) | 0;
  HEAP32[$ret >> 2] = _silk_Get_Encoder_Size($silkEncSizeBytes) | 0;
  if (HEAP32[$ret >> 2] | 0) {
   HEAP32[$retval >> 2] = -1;
   $98 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $98 | 0;
  }
  HEAP32[$silkEncSizeBytes >> 2] = _align_7(HEAP32[$silkEncSizeBytes >> 2] | 0) | 0;
  $call21 = _align_7(18136) | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] = $call21;
  HEAP32[HEAP32[$st$addr >> 2] >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[$silkEncSizeBytes >> 2] | 0);
  HEAP32[$silk_enc >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0);
  HEAP32[$celt_enc >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0);
  $25 = HEAP32[$channels$addr >> 2] | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] = $25;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14188 >> 2] = $25;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] = HEAP32[$Fs$addr >> 2];
  $call28 = _opus_select_arch() | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] = $call28;
  HEAP32[$ret >> 2] = _silk_InitEncoder(HEAP32[$silk_enc >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] | 0, (HEAP32[$st$addr >> 2] | 0) + 8 | 0) | 0;
  if (HEAP32[$ret >> 2] | 0) {
   HEAP32[$retval >> 2] = -3;
   $98 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $98 | 0;
  }
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] = HEAP32[$channels$addr >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 4 >> 2] = HEAP32[$channels$addr >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 8 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 12 >> 2] = 16e3;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 16 >> 2] = 8e3;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 20 >> 2] = 16e3;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 24 >> 2] = 20;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 28 >> 2] = 25e3;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 32 >> 2] = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 36 >> 2] = 9;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 40 >> 2] = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 48 >> 2] = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 52 >> 2] = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 68 >> 2] = 0;
  HEAP32[$err >> 2] = _celt_encoder_init(HEAP32[$celt_enc >> 2] | 0, HEAP32[$Fs$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 180 >> 2] | 0) | 0;
  if (HEAP32[$err >> 2] | 0) {
   HEAP32[$retval >> 2] = -3;
   $98 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $98 | 0;
  } else {
   $60 = HEAP32[$celt_enc >> 2] | 0;
   HEAP32[$vararg_buffer >> 2] = 0;
   _opus_custom_encoder_ctl($60, 10016, $vararg_buffer) | 0;
   $61 = HEAP32[$celt_enc >> 2] | 0;
   HEAP32[$vararg_buffer7 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 + 36 >> 2];
   _opus_custom_encoder_ctl($61, 4010, $vararg_buffer7) | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 148 >> 2] = 1;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 152 >> 2] = 1;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 164 >> 2] = -1e3;
   $add62 = 3e3 + (Math_imul(HEAP32[$Fs$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 160 >> 2] = $add62;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2] = HEAP32[$application$addr >> 2];
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 124 >> 2] = -1e3;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 128 >> 2] = -1e3;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 132 >> 2] = 1105;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 120 >> 2] = -1e3;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 136 >> 2] = -1e3;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 140 >> 2] = -1;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 172 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 100 | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 168 >> 2] = 24;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 156 >> 2] = 5e3;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 116 >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 250 | 0;
   HEAP16[(HEAP32[$st$addr >> 2] | 0) + 14192 >> 1] = 16384;
   HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 14200 >> 2] = 1.0;
   $shl = (_silk_lin2log(60) | 0) << 8;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14196 >> 2] = $shl;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14248 >> 2] = 1;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14220 >> 2] = 1001;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 14236 >> 2] = 1105;
   _tonality_analysis_init((HEAP32[$st$addr >> 2] | 0) + 188 | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0);
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 188 + 4 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 108 >> 2];
   HEAP32[$retval >> 2] = 0;
   $98 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $98 | 0;
  }
 }
 HEAP32[$retval >> 2] = -1;
 $98 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $98 | 0;
}

function _silk_noise_shape_quantizer_short_prediction_c_424($buf32, $coef16, $order) {
 $buf32 = $buf32 | 0;
 $coef16 = $coef16 | 0;
 $order = $order | 0;
 var $146 = 0, $buf32$addr = 0, $coef16$addr = 0, $mul = 0, $mul104 = 0, $mul117 = 0, $mul13 = 0, $mul131 = 0, $mul144 = 0, $mul157 = 0, $mul170 = 0, $mul183 = 0, $mul196 = 0, $mul26 = 0, $mul39 = 0, $mul52 = 0, $mul65 = 0, $mul78 = 0, $mul91 = 0, $order$addr = 0, $out = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $buf32$addr = sp + 12 | 0;
 $coef16$addr = sp + 8 | 0;
 $order$addr = sp + 4 | 0;
 $out = sp;
 HEAP32[$buf32$addr >> 2] = $buf32;
 HEAP32[$coef16$addr >> 2] = $coef16;
 HEAP32[$order$addr >> 2] = $order;
 HEAP32[$out >> 2] = HEAP32[$order$addr >> 2] >> 1;
 $mul = Math_imul(HEAP32[HEAP32[$buf32$addr >> 2] >> 2] >> 16, HEAP16[HEAP32[$coef16$addr >> 2] >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul + ((Math_imul(HEAP32[HEAP32[$buf32$addr >> 2] >> 2] & 65535, HEAP16[HEAP32[$coef16$addr >> 2] >> 1] | 0) | 0) >> 16));
 $mul13 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -4 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 2 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul13 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -4 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
 $mul26 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -8 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 4 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul26 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -8 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
 $mul39 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -12 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 6 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul39 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -12 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
 $mul52 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -16 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 8 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul52 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -16 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
 $mul65 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -20 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 10 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul65 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -20 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 10 >> 1] | 0) | 0) >> 16));
 $mul78 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -24 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 12 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul78 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -24 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 12 >> 1] | 0) | 0) >> 16));
 $mul91 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -28 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 14 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul91 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -28 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 14 >> 1] | 0) | 0) >> 16));
 $mul104 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -32 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 16 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul104 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -32 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 16 >> 1] | 0) | 0) >> 16));
 $mul117 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -36 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 18 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul117 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -36 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 18 >> 1] | 0) | 0) >> 16));
 if ((HEAP32[$order$addr >> 2] | 0) != 16) {
  $146 = HEAP32[$out >> 2] | 0;
  STACKTOP = sp;
  return $146 | 0;
 }
 $mul131 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -40 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 20 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul131 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -40 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 20 >> 1] | 0) | 0) >> 16));
 $mul144 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -44 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 22 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul144 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -44 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 22 >> 1] | 0) | 0) >> 16));
 $mul157 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -48 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 24 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul157 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -48 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 24 >> 1] | 0) | 0) >> 16));
 $mul170 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -52 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 26 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul170 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -52 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 26 >> 1] | 0) | 0) >> 16));
 $mul183 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -56 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 28 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul183 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -56 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 28 >> 1] | 0) | 0) >> 16));
 $mul196 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -60 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 30 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul196 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -60 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 30 >> 1] | 0) | 0) >> 16));
 $146 = HEAP32[$out >> 2] | 0;
 STACKTOP = sp;
 return $146 | 0;
}

function _silk_noise_shape_quantizer_short_prediction_c($buf32, $coef16, $order) {
 $buf32 = $buf32 | 0;
 $coef16 = $coef16 | 0;
 $order = $order | 0;
 var $146 = 0, $buf32$addr = 0, $coef16$addr = 0, $mul = 0, $mul104 = 0, $mul117 = 0, $mul13 = 0, $mul131 = 0, $mul144 = 0, $mul157 = 0, $mul170 = 0, $mul183 = 0, $mul196 = 0, $mul26 = 0, $mul39 = 0, $mul52 = 0, $mul65 = 0, $mul78 = 0, $mul91 = 0, $order$addr = 0, $out = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $buf32$addr = sp + 12 | 0;
 $coef16$addr = sp + 8 | 0;
 $order$addr = sp + 4 | 0;
 $out = sp;
 HEAP32[$buf32$addr >> 2] = $buf32;
 HEAP32[$coef16$addr >> 2] = $coef16;
 HEAP32[$order$addr >> 2] = $order;
 HEAP32[$out >> 2] = HEAP32[$order$addr >> 2] >> 1;
 $mul = Math_imul(HEAP32[HEAP32[$buf32$addr >> 2] >> 2] >> 16, HEAP16[HEAP32[$coef16$addr >> 2] >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul + ((Math_imul(HEAP32[HEAP32[$buf32$addr >> 2] >> 2] & 65535, HEAP16[HEAP32[$coef16$addr >> 2] >> 1] | 0) | 0) >> 16));
 $mul13 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -4 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 2 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul13 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -4 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16));
 $mul26 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -8 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 4 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul26 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -8 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 4 >> 1] | 0) | 0) >> 16));
 $mul39 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -12 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 6 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul39 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -12 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 6 >> 1] | 0) | 0) >> 16));
 $mul52 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -16 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 8 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul52 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -16 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 8 >> 1] | 0) | 0) >> 16));
 $mul65 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -20 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 10 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul65 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -20 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 10 >> 1] | 0) | 0) >> 16));
 $mul78 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -24 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 12 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul78 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -24 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 12 >> 1] | 0) | 0) >> 16));
 $mul91 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -28 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 14 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul91 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -28 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 14 >> 1] | 0) | 0) >> 16));
 $mul104 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -32 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 16 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul104 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -32 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 16 >> 1] | 0) | 0) >> 16));
 $mul117 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -36 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 18 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul117 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -36 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 18 >> 1] | 0) | 0) >> 16));
 if ((HEAP32[$order$addr >> 2] | 0) != 16) {
  $146 = HEAP32[$out >> 2] | 0;
  STACKTOP = sp;
  return $146 | 0;
 }
 $mul131 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -40 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 20 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul131 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -40 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 20 >> 1] | 0) | 0) >> 16));
 $mul144 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -44 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 22 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul144 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -44 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 22 >> 1] | 0) | 0) >> 16));
 $mul157 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -48 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 24 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul157 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -48 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 24 >> 1] | 0) | 0) >> 16));
 $mul170 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -52 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 26 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul170 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -52 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 26 >> 1] | 0) | 0) >> 16));
 $mul183 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -56 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 28 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul183 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -56 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 28 >> 1] | 0) | 0) >> 16));
 $mul196 = Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -60 >> 2] >> 16, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 30 >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul196 + ((Math_imul(HEAP32[(HEAP32[$buf32$addr >> 2] | 0) + -60 >> 2] & 65535, HEAP16[(HEAP32[$coef16$addr >> 2] | 0) + 30 >> 1] | 0) | 0) >> 16));
 $146 = HEAP32[$out >> 2] | 0;
 STACKTOP = sp;
 return $146 | 0;
}

function _silk_resampler_init($S, $Fs_Hz_in, $Fs_Hz_out, $forEnc) {
 $S = $S | 0;
 $Fs_Hz_in = $Fs_Hz_in | 0;
 $Fs_Hz_out = $Fs_Hz_out | 0;
 $forEnc = $forEnc | 0;
 var $$sink = 0, $40 = 0, $41 = 0, $91 = 0, $Fs_Hz_in$addr = 0, $Fs_Hz_out$addr = 0, $S$addr = 0, $add161 = 0, $add167 = 0, $conv72$sink = 0, $forEnc$addr = 0, $invRatio_Q16171 = 0, $mul155 = 0, $or$cond1 = 0, $resampler_function = 0, $resampler_function91 = 0, $retval = 0, $up2x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $S$addr = sp + 16 | 0;
 $Fs_Hz_in$addr = sp + 12 | 0;
 $Fs_Hz_out$addr = sp + 8 | 0;
 $forEnc$addr = sp + 4 | 0;
 $up2x = sp;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$Fs_Hz_in$addr >> 2] = $Fs_Hz_in;
 HEAP32[$Fs_Hz_out$addr >> 2] = $Fs_Hz_out;
 HEAP32[$forEnc$addr >> 2] = $forEnc;
 _memset(HEAP32[$S$addr >> 2] | 0, 0, 300) | 0;
 $or$cond1 = (HEAP32[$Fs_Hz_in$addr >> 2] | 0) != 8e3 & (HEAP32[$Fs_Hz_in$addr >> 2] | 0) != 12e3 & (HEAP32[$Fs_Hz_in$addr >> 2] | 0) != 16e3;
 do if (HEAP32[$forEnc$addr >> 2] | 0) {
  if (!($or$cond1 & (HEAP32[$Fs_Hz_in$addr >> 2] | 0) != 24e3 & (HEAP32[$Fs_Hz_in$addr >> 2] | 0) != 48e3)) if (!((HEAP32[$Fs_Hz_out$addr >> 2] | 0) != 8e3 & (HEAP32[$Fs_Hz_out$addr >> 2] | 0) != 12e3 & (HEAP32[$Fs_Hz_out$addr >> 2] | 0) != 16e3)) {
   $$sink = HEAP32[$S$addr >> 2] | 0;
   $conv72$sink = HEAP8[33427 + ((((HEAP32[$Fs_Hz_in$addr >> 2] >> 12) - ((HEAP32[$Fs_Hz_in$addr >> 2] | 0) > 16e3 & 1) >> ((HEAP32[$Fs_Hz_in$addr >> 2] | 0) > 24e3 & 1)) - 1 | 0) * 3 | 0) + (((HEAP32[$Fs_Hz_out$addr >> 2] >> 12) - ((HEAP32[$Fs_Hz_out$addr >> 2] | 0) > 16e3 & 1) >> ((HEAP32[$Fs_Hz_out$addr >> 2] | 0) > 24e3 & 1)) - 1) >> 0] | 0;
   break;
  }
  HEAP32[$retval >> 2] = -1;
  $91 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $91 | 0;
 } else {
  if (!$or$cond1) if (!((HEAP32[$Fs_Hz_out$addr >> 2] | 0) != 8e3 & (HEAP32[$Fs_Hz_out$addr >> 2] | 0) != 12e3 & (HEAP32[$Fs_Hz_out$addr >> 2] | 0) != 16e3 & (HEAP32[$Fs_Hz_out$addr >> 2] | 0) != 24e3 & (HEAP32[$Fs_Hz_out$addr >> 2] | 0) != 48e3)) {
   $$sink = HEAP32[$S$addr >> 2] | 0;
   $conv72$sink = HEAP8[33442 + ((((HEAP32[$Fs_Hz_in$addr >> 2] >> 12) - ((HEAP32[$Fs_Hz_in$addr >> 2] | 0) > 16e3 & 1) >> ((HEAP32[$Fs_Hz_in$addr >> 2] | 0) > 24e3 & 1)) - 1 | 0) * 5 | 0) + (((HEAP32[$Fs_Hz_out$addr >> 2] >> 12) - ((HEAP32[$Fs_Hz_out$addr >> 2] | 0) > 16e3 & 1) >> ((HEAP32[$Fs_Hz_out$addr >> 2] | 0) > 24e3 & 1)) - 1) >> 0] | 0;
   break;
  }
  HEAP32[$retval >> 2] = -1;
  $91 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $91 | 0;
 } while (0);
 HEAP32[$$sink + 292 >> 2] = $conv72$sink;
 HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] = (HEAP32[$Fs_Hz_in$addr >> 2] | 0) / 1e3 | 0;
 HEAP32[(HEAP32[$S$addr >> 2] | 0) + 288 >> 2] = (HEAP32[$Fs_Hz_out$addr >> 2] | 0) / 1e3 | 0;
 HEAP32[(HEAP32[$S$addr >> 2] | 0) + 268 >> 2] = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] | 0) * 10;
 HEAP32[$up2x >> 2] = 0;
 $40 = HEAP32[$Fs_Hz_out$addr >> 2] | 0;
 $41 = HEAP32[$Fs_Hz_in$addr >> 2] | 0;
 do if ((HEAP32[$Fs_Hz_out$addr >> 2] | 0) > (HEAP32[$Fs_Hz_in$addr >> 2] | 0)) {
  $resampler_function = (HEAP32[$S$addr >> 2] | 0) + 264 | 0;
  if (($40 | 0) == ($41 << 1 | 0)) {
   HEAP32[$resampler_function >> 2] = 1;
   break;
  } else {
   HEAP32[$resampler_function >> 2] = 2;
   HEAP32[$up2x >> 2] = 1;
   break;
  }
 } else {
  $resampler_function91 = (HEAP32[$S$addr >> 2] | 0) + 264 | 0;
  if (($40 | 0) >= ($41 | 0)) {
   HEAP32[$resampler_function91 >> 2] = 0;
   break;
  }
  HEAP32[$resampler_function91 >> 2] = 3;
  if ((HEAP32[$Fs_Hz_out$addr >> 2] << 2 | 0) == ((HEAP32[$Fs_Hz_in$addr >> 2] | 0) * 3 | 0)) {
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 280 >> 2] = 3;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 276 >> 2] = 18;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 296 >> 2] = 22982;
   break;
  }
  if (((HEAP32[$Fs_Hz_out$addr >> 2] | 0) * 3 | 0) == (HEAP32[$Fs_Hz_in$addr >> 2] << 1 | 0)) {
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 280 >> 2] = 2;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 276 >> 2] = 18;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 296 >> 2] = 23040;
   break;
  }
  if ((HEAP32[$Fs_Hz_out$addr >> 2] << 1 | 0) == (HEAP32[$Fs_Hz_in$addr >> 2] | 0)) {
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 280 >> 2] = 1;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 276 >> 2] = 24;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 296 >> 2] = 23080;
   break;
  }
  if (((HEAP32[$Fs_Hz_out$addr >> 2] | 0) * 3 | 0) == (HEAP32[$Fs_Hz_in$addr >> 2] | 0)) {
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 280 >> 2] = 1;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 276 >> 2] = 36;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 296 >> 2] = 23108;
   break;
  }
  if ((HEAP32[$Fs_Hz_out$addr >> 2] << 2 | 0) == (HEAP32[$Fs_Hz_in$addr >> 2] | 0)) {
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 280 >> 2] = 1;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 276 >> 2] = 36;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 296 >> 2] = 23148;
   break;
  }
  if (((HEAP32[$Fs_Hz_out$addr >> 2] | 0) * 6 | 0) == (HEAP32[$Fs_Hz_in$addr >> 2] | 0)) {
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 280 >> 2] = 1;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 276 >> 2] = 36;
   HEAP32[(HEAP32[$S$addr >> 2] | 0) + 296 >> 2] = 23188;
   break;
  }
  HEAP32[$retval >> 2] = -1;
  $91 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $91 | 0;
 } while (0);
 HEAP32[(HEAP32[$S$addr >> 2] | 0) + 272 >> 2] = ((HEAP32[$Fs_Hz_in$addr >> 2] << 14 + (HEAP32[$up2x >> 2] | 0) | 0) / (HEAP32[$Fs_Hz_out$addr >> 2] | 0) | 0) << 2;
 while (1) {
  $mul155 = Math_imul(HEAP32[(HEAP32[$S$addr >> 2] | 0) + 272 >> 2] >> 16, (HEAP32[$Fs_Hz_out$addr >> 2] & 65535) << 16 >> 16) | 0;
  $add161 = $mul155 + ((Math_imul(HEAP32[(HEAP32[$S$addr >> 2] | 0) + 272 >> 2] & 65535, (HEAP32[$Fs_Hz_out$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add167 = $add161 + (Math_imul(HEAP32[(HEAP32[$S$addr >> 2] | 0) + 272 >> 2] | 0, (HEAP32[$Fs_Hz_out$addr >> 2] >> 15) + 1 >> 1) | 0) | 0;
  if (($add167 | 0) >= (HEAP32[$Fs_Hz_in$addr >> 2] << HEAP32[$up2x >> 2] | 0)) break;
  $invRatio_Q16171 = (HEAP32[$S$addr >> 2] | 0) + 272 | 0;
  HEAP32[$invRatio_Q16171 >> 2] = (HEAP32[$invRatio_Q16171 >> 2] | 0) + 1;
 }
 HEAP32[$retval >> 2] = 0;
 $91 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $91 | 0;
}

function _comb_filter($y, $x, $T0, $T1, $N, $g0, $g1, $tapset0, $tapset1, $window, $overlap, $arch) {
 $y = $y | 0;
 $x = $x | 0;
 $T0 = $T0 | 0;
 $T1 = $T1 | 0;
 $N = $N | 0;
 $g0 = +$g0;
 $g1 = +$g1;
 $tapset0 = $tapset0 | 0;
 $tapset1 = $tapset1 | 0;
 $window = $window | 0;
 $overlap = $overlap | 0;
 $arch = $arch | 0;
 var $N$addr = 0, $T0$addr = 0, $T1$addr = 0, $arch$addr = 0, $f = 0, $g0$addr = 0, $g00 = 0, $g01 = 0, $g02 = 0, $g1$addr = 0, $g10 = 0, $g11 = 0, $g12 = 0, $i = 0, $overlap$addr = 0, $tapset0$addr = 0, $tapset1$addr = 0, $window$addr = 0, $x$addr = 0, $x0 = 0, $x1 = 0, $x2 = 0, $x3 = 0, $x4 = 0, $y$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $y$addr = sp + 96 | 0;
 $x$addr = sp + 92 | 0;
 $T0$addr = sp + 88 | 0;
 $T1$addr = sp + 84 | 0;
 $N$addr = sp + 80 | 0;
 $g0$addr = sp + 76 | 0;
 $g1$addr = sp + 72 | 0;
 $tapset0$addr = sp + 68 | 0;
 $tapset1$addr = sp + 64 | 0;
 $window$addr = sp + 60 | 0;
 $overlap$addr = sp + 56 | 0;
 $arch$addr = sp + 52 | 0;
 $i = sp + 48 | 0;
 $g00 = sp + 44 | 0;
 $g01 = sp + 40 | 0;
 $g02 = sp + 36 | 0;
 $g10 = sp + 32 | 0;
 $g11 = sp + 28 | 0;
 $g12 = sp + 24 | 0;
 $x0 = sp + 20 | 0;
 $x1 = sp + 16 | 0;
 $x2 = sp + 12 | 0;
 $x3 = sp + 8 | 0;
 $x4 = sp + 4 | 0;
 $f = sp;
 HEAP32[$y$addr >> 2] = $y;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$T0$addr >> 2] = $T0;
 HEAP32[$T1$addr >> 2] = $T1;
 HEAP32[$N$addr >> 2] = $N;
 HEAPF32[$g0$addr >> 2] = $g0;
 HEAPF32[$g1$addr >> 2] = $g1;
 HEAP32[$tapset0$addr >> 2] = $tapset0;
 HEAP32[$tapset1$addr >> 2] = $tapset1;
 HEAP32[$window$addr >> 2] = $window;
 HEAP32[$overlap$addr >> 2] = $overlap;
 HEAP32[$arch$addr >> 2] = $arch;
 if (+HEAPF32[$g0$addr >> 2] == 0.0 & +HEAPF32[$g1$addr >> 2] == 0.0) {
  if ((HEAP32[$x$addr >> 2] | 0) == (HEAP32[$y$addr >> 2] | 0)) {
   STACKTOP = sp;
   return;
  }
  _memmove(HEAP32[$y$addr >> 2] | 0, HEAP32[$x$addr >> 2] | 0, (HEAP32[$N$addr >> 2] << 2) + 0 | 0) | 0;
  STACKTOP = sp;
  return;
 }
 HEAP32[$T0$addr >> 2] = (HEAP32[$T0$addr >> 2] | 0) > 15 ? HEAP32[$T0$addr >> 2] | 0 : 15;
 HEAP32[$T1$addr >> 2] = (HEAP32[$T1$addr >> 2] | 0) > 15 ? HEAP32[$T1$addr >> 2] | 0 : 15;
 HEAPF32[$g00 >> 2] = +HEAPF32[$g0$addr >> 2] * +HEAPF32[15460 + ((HEAP32[$tapset0$addr >> 2] | 0) * 12 | 0) >> 2];
 HEAPF32[$g01 >> 2] = +HEAPF32[$g0$addr >> 2] * +HEAPF32[15460 + ((HEAP32[$tapset0$addr >> 2] | 0) * 12 | 0) + 4 >> 2];
 HEAPF32[$g02 >> 2] = +HEAPF32[$g0$addr >> 2] * +HEAPF32[15460 + ((HEAP32[$tapset0$addr >> 2] | 0) * 12 | 0) + 8 >> 2];
 HEAPF32[$g10 >> 2] = +HEAPF32[$g1$addr >> 2] * +HEAPF32[15460 + ((HEAP32[$tapset1$addr >> 2] | 0) * 12 | 0) >> 2];
 HEAPF32[$g11 >> 2] = +HEAPF32[$g1$addr >> 2] * +HEAPF32[15460 + ((HEAP32[$tapset1$addr >> 2] | 0) * 12 | 0) + 4 >> 2];
 HEAPF32[$g12 >> 2] = +HEAPF32[$g1$addr >> 2] * +HEAPF32[15460 + ((HEAP32[$tapset1$addr >> 2] | 0) * 12 | 0) + 8 >> 2];
 HEAPF32[$x1 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[$T1$addr >> 2] | 0) + 1 << 2) >> 2];
 HEAPF32[$x2 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[$T1$addr >> 2] | 0) << 2) >> 2];
 HEAPF32[$x3 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[$T1$addr >> 2] | 0) - 1 << 2) >> 2];
 HEAPF32[$x4 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[$T1$addr >> 2] | 0) - 2 << 2) >> 2];
 if (+HEAPF32[$g0$addr >> 2] == +HEAPF32[$g1$addr >> 2]) if ((HEAP32[$T0$addr >> 2] | 0) == (HEAP32[$T1$addr >> 2] | 0)) if ((HEAP32[$tapset0$addr >> 2] | 0) == (HEAP32[$tapset1$addr >> 2] | 0)) HEAP32[$overlap$addr >> 2] = 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$overlap$addr >> 2] | 0)) break;
  HEAPF32[$x0 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$T1$addr >> 2] | 0) + 2 << 2) >> 2];
  HEAPF32[$f >> 2] = +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] + (1.0 - +HEAPF32[$f >> 2]) * +HEAPF32[$g00 >> 2] * +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$T0$addr >> 2] | 0) << 2) >> 2] + (1.0 - +HEAPF32[$f >> 2]) * +HEAPF32[$g01 >> 2] * (+HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$T0$addr >> 2] | 0) + 1 << 2) >> 2] + +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$T0$addr >> 2] | 0) - 1 << 2) >> 2]) + (1.0 - +HEAPF32[$f >> 2]) * +HEAPF32[$g02 >> 2] * (+HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$T0$addr >> 2] | 0) + 2 << 2) >> 2] + +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$T0$addr >> 2] | 0) - 2 << 2) >> 2]) + +HEAPF32[$f >> 2] * +HEAPF32[$g10 >> 2] * +HEAPF32[$x2 >> 2] + +HEAPF32[$f >> 2] * +HEAPF32[$g11 >> 2] * (+HEAPF32[$x1 >> 2] + +HEAPF32[$x3 >> 2]) + +HEAPF32[$f >> 2] * +HEAPF32[$g12 >> 2] * (+HEAPF32[$x0 >> 2] + +HEAPF32[$x4 >> 2]);
  HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$x4 >> 2] = +HEAPF32[$x3 >> 2];
  HEAPF32[$x3 >> 2] = +HEAPF32[$x2 >> 2];
  HEAPF32[$x2 >> 2] = +HEAPF32[$x1 >> 2];
  HEAPF32[$x1 >> 2] = +HEAPF32[$x0 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if (!(+HEAPF32[$g1$addr >> 2] == 0.0)) {
  FUNCTION_TABLE_viiiiddd[HEAP32[_COMB_FILTER_CONST_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]((HEAP32[$y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0, (HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0, HEAP32[$T1$addr >> 2] | 0, (HEAP32[$N$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) | 0, +HEAPF32[$g10 >> 2], +HEAPF32[$g11 >> 2], +HEAPF32[$g12 >> 2]);
  STACKTOP = sp;
  return;
 }
 if ((HEAP32[$x$addr >> 2] | 0) == (HEAP32[$y$addr >> 2] | 0)) {
  STACKTOP = sp;
  return;
 }
 _memmove((HEAP32[$y$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] << 2) | 0, (HEAP32[$x$addr >> 2] | 0) + (HEAP32[$overlap$addr >> 2] << 2) | 0, ((HEAP32[$N$addr >> 2] | 0) - (HEAP32[$overlap$addr >> 2] | 0) << 2) + 0 | 0) | 0;
 STACKTOP = sp;
 return;
}

function _silk_setup_fs($psEnc, $fs_kHz, $PacketSize_ms) {
 $psEnc = $psEnc | 0;
 $fs_kHz = $fs_kHz | 0;
 $PacketSize_ms = $PacketSize_ms | 0;
 var $$sink3$sink = 0, $$sink6 = 0, $83 = 0, $86 = 0, $PacketSize_ms$addr = 0, $cmp157 = 0, $cmp91 = 0, $conv161 = 0, $fs_kHz$addr = 0, $mul = 0, $mul140 = 0, $pitch_contour_iCDF52$sink = 0, $prev_NLSFq_Q15 = 0, $psEnc$addr = 0, $ret = 0, $sLP = 0, $sShape = 0, $silk_NLSF_CB_WB$sink = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psEnc$addr = sp + 12 | 0;
 $fs_kHz$addr = sp + 8 | 0;
 $PacketSize_ms$addr = sp + 4 | 0;
 $ret = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$fs_kHz$addr >> 2] = $fs_kHz;
 HEAP32[$PacketSize_ms$addr >> 2] = $PacketSize_ms;
 HEAP32[$ret >> 2] = 0;
 if ((HEAP32[$PacketSize_ms$addr >> 2] | 0) != (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4608 >> 2] | 0)) {
  if ((HEAP32[$PacketSize_ms$addr >> 2] | 0) != 10 & (HEAP32[$PacketSize_ms$addr >> 2] | 0) != 20 & (HEAP32[$PacketSize_ms$addr >> 2] | 0) != 40 & (HEAP32[$PacketSize_ms$addr >> 2] | 0) != 60) HEAP32[$ret >> 2] = -103;
  if ((HEAP32[$PacketSize_ms$addr >> 2] | 0) <= 10) {
   HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5740 >> 2] = 1;
   HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] = (HEAP32[$PacketSize_ms$addr >> 2] | 0) == 10 ? 2 : 1;
   $mul = Math_imul((HEAP32[$PacketSize_ms$addr >> 2] & 65535) << 16 >> 16, (HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) | 0;
   HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] = $mul;
   HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4544 >> 2] = ((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 14;
   $$sink3$sink = (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) == 8 ? 32375 : 32363;
   $pitch_contour_iCDF52$sink = (HEAP32[$psEnc$addr >> 2] | 0) + 4684 | 0;
  } else {
   HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5740 >> 2] = (HEAP32[$PacketSize_ms$addr >> 2] | 0) / 20 | 0;
   HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] = 4;
   HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] = ((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 20;
   HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4544 >> 2] = ((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 24;
   $$sink3$sink = (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) == 8 ? 32352 : 32318;
   $pitch_contour_iCDF52$sink = (HEAP32[$psEnc$addr >> 2] | 0) + 4684 | 0;
  }
  HEAP32[$pitch_contour_iCDF52$sink >> 2] = $$sink3$sink;
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4608 >> 2] = HEAP32[$PacketSize_ms$addr >> 2];
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4604 >> 2] = 0;
 }
 if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) == (HEAP32[$fs_kHz$addr >> 2] | 0)) {
  $86 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $86 | 0;
 }
 $sShape = (HEAP32[$psEnc$addr >> 2] | 0) + 7164 | 0;
 HEAP32[$sShape >> 2] = 0;
 HEAP32[$sShape + 4 >> 2] = 0;
 HEAP32[$sShape + 8 >> 2] = 0;
 _memset((HEAP32[$psEnc$addr >> 2] | 0) + 144 | 0, 0, 4352) | 0;
 $prev_NLSFq_Q15 = (HEAP32[$psEnc$addr >> 2] | 0) + 4496 | 0;
 HEAP32[$prev_NLSFq_Q15 >> 2] = 0;
 HEAP32[$prev_NLSFq_Q15 + 4 >> 2] = 0;
 HEAP32[$prev_NLSFq_Q15 + 8 >> 2] = 0;
 HEAP32[$prev_NLSFq_Q15 + 12 >> 2] = 0;
 HEAP32[$prev_NLSFq_Q15 + 16 >> 2] = 0;
 HEAP32[$prev_NLSFq_Q15 + 20 >> 2] = 0;
 HEAP32[$prev_NLSFq_Q15 + 24 >> 2] = 0;
 HEAP32[$prev_NLSFq_Q15 + 28 >> 2] = 0;
 $sLP = (HEAP32[$psEnc$addr >> 2] | 0) + 16 | 0;
 HEAP32[$sLP >> 2] = 0;
 HEAP32[$sLP + 4 >> 2] = 0;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5736 >> 2] = 0;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5744 >> 2] = 0;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4604 >> 2] = 0;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4540 >> 2] = 100;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4660 >> 2] = 1;
 HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 7164 >> 0] = 10;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 144 + 4328 >> 2] = 100;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 144 + 4344 >> 2] = 65536;
 HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4537 >> 0] = 0;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] = HEAP32[$fs_kHz$addr >> 2];
 $cmp91 = (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0) == 4;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4684 >> 2] = (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) == 8 ? ($cmp91 ? 32352 : 32375) : $cmp91 ? 32318 : 32363;
 if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) == 8) label = 11; else if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) == 12) label = 11; else {
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4636 >> 2] = 16;
  $$sink6 = HEAP32[$psEnc$addr >> 2] | 0;
  $silk_NLSF_CB_WB$sink = 20684;
 }
 if ((label | 0) == 11) {
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4636 >> 2] = 10;
  $$sink6 = HEAP32[$psEnc$addr >> 2] | 0;
  $silk_NLSF_CB_WB$sink = 20644;
 }
 HEAP32[$$sink6 + 4688 >> 2] = $silk_NLSF_CB_WB$sink;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] = (HEAP32[$fs_kHz$addr >> 2] | 0) * 5;
 $mul140 = Math_imul((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] & 65535) << 16 >> 16, (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] = $mul140;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4588 >> 2] = ((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 20;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4592 >> 2] = (HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16 << 1;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4548 >> 2] = ((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 18;
 $cmp157 = (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0) == 4;
 $conv161 = (HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16;
 HEAP32[($cmp157 ? HEAP32[$psEnc$addr >> 2] | 0 : HEAP32[$psEnc$addr >> 2] | 0) + 4544 >> 2] = $cmp157 ? $conv161 * 24 | 0 : $conv161 * 14 | 0;
 $83 = HEAP32[$psEnc$addr >> 2] | 0;
 if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) == 16) {
  HEAP32[$83 + 4680 >> 2] = 32250;
  $86 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $86 | 0;
 } else {
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4680 >> 2] = (HEAP32[$83 + 4572 >> 2] | 0) == 12 ? 32244 : 32235;
  $86 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $86 | 0;
 }
 return 0;
}

function _celt_iir($_x, $den, $_y, $N, $ord, $mem, $arch) {
 $_x = $_x | 0;
 $den = $den | 0;
 $_y = $_y | 0;
 $N = $N | 0;
 $ord = $ord | 0;
 $mem = $mem | 0;
 $arch = $arch | 0;
 var $0 = 0, $N$addr = 0, $_x$addr = 0, $_y$addr = 0, $arch$addr = 0, $den$addr = 0, $i = 0, $j = 0, $mem$addr = 0, $ord$addr = 0, $saved_stack = 0, $sum = 0, $sum119 = 0, $vla = 0, $vla1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $_x$addr = sp + 60 | 0;
 $den$addr = sp + 56 | 0;
 $_y$addr = sp + 52 | 0;
 $N$addr = sp + 48 | 0;
 $ord$addr = sp + 44 | 0;
 $mem$addr = sp + 40 | 0;
 $arch$addr = sp + 36 | 0;
 $i = sp + 32 | 0;
 $j = sp + 28 | 0;
 $saved_stack = sp + 24 | 0;
 $sum = sp + 8 | 0;
 $sum119 = sp;
 HEAP32[$_x$addr >> 2] = $_x;
 HEAP32[$den$addr >> 2] = $den;
 HEAP32[$_y$addr >> 2] = $_y;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$ord$addr >> 2] = $ord;
 HEAP32[$mem$addr >> 2] = $mem;
 HEAP32[$arch$addr >> 2] = $arch;
 $0 = HEAP32[$ord$addr >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($0 << 2) | 0) + 15 & -16) | 0;
 $vla1 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ((HEAP32[$N$addr >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) << 2) | 0) + 15 & -16) | 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$ord$addr >> 2] | 0)) break;
  HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$den$addr >> 2] | 0) + ((HEAP32[$ord$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$ord$addr >> 2] | 0)) break;
  HEAPF32[$vla1 + (HEAP32[$i >> 2] << 2) >> 2] = -+HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + ((HEAP32[$ord$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$N$addr >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) | 0)) break;
  HEAPF32[$vla1 + (HEAP32[$i >> 2] << 2) >> 2] = 0.0;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$N$addr >> 2] | 0) - 3 | 0)) break;
  HEAPF32[$sum >> 2] = +HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$sum + 4 >> 2] = +HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2];
  HEAPF32[$sum + 8 >> 2] = +HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2];
  HEAPF32[$sum + 12 >> 2] = +HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2];
  FUNCTION_TABLE_viiii[HEAP32[_XCORR_KERNEL_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]($vla, $vla1 + (HEAP32[$i >> 2] << 2) | 0, $sum, HEAP32[$ord$addr >> 2] | 0);
  HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) << 2) >> 2] = -+HEAPF32[$sum >> 2];
  HEAPF32[(HEAP32[$_y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$sum >> 2];
  HEAPF32[$sum + 4 >> 2] = +HEAPF32[$sum + 4 >> 2] + +HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) << 2) >> 2] * +HEAPF32[HEAP32[$den$addr >> 2] >> 2];
  HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) + 1 << 2) >> 2] = -+HEAPF32[$sum + 4 >> 2];
  HEAPF32[(HEAP32[$_y$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] = +HEAPF32[$sum + 4 >> 2];
  HEAPF32[$sum + 8 >> 2] = +HEAPF32[$sum + 8 >> 2] + +HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) + 1 << 2) >> 2] * +HEAPF32[HEAP32[$den$addr >> 2] >> 2];
  HEAPF32[$sum + 8 >> 2] = +HEAPF32[$sum + 8 >> 2] + +HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$den$addr >> 2] | 0) + 4 >> 2];
  HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) + 2 << 2) >> 2] = -+HEAPF32[$sum + 8 >> 2];
  HEAPF32[(HEAP32[$_y$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2] = +HEAPF32[$sum + 8 >> 2];
  HEAPF32[$sum + 12 >> 2] = +HEAPF32[$sum + 12 >> 2] + +HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) + 2 << 2) >> 2] * +HEAPF32[HEAP32[$den$addr >> 2] >> 2];
  HEAPF32[$sum + 12 >> 2] = +HEAPF32[$sum + 12 >> 2] + +HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) + 1 << 2) >> 2] * +HEAPF32[(HEAP32[$den$addr >> 2] | 0) + 4 >> 2];
  HEAPF32[$sum + 12 >> 2] = +HEAPF32[$sum + 12 >> 2] + +HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$den$addr >> 2] | 0) + 8 >> 2];
  HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) + 3 << 2) >> 2] = -+HEAPF32[$sum + 12 >> 2];
  HEAPF32[(HEAP32[$_y$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2] = +HEAPF32[$sum + 12 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAPF32[$sum119 >> 2] = +HEAPF32[(HEAP32[$_x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$ord$addr >> 2] | 0)) break;
   HEAPF32[$sum119 >> 2] = +HEAPF32[$sum119 >> 2] - +HEAPF32[$vla + (HEAP32[$j >> 2] << 2) >> 2] * +HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$j >> 2] | 0) << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAPF32[$vla1 + ((HEAP32[$i >> 2] | 0) + (HEAP32[$ord$addr >> 2] | 0) << 2) >> 2] = +HEAPF32[$sum119 >> 2];
  HEAPF32[(HEAP32[$_y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$sum119 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$ord$addr >> 2] | 0)) break;
  HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$_y$addr >> 2] | 0) + ((HEAP32[$N$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_PLC_energy($energy1, $shift1, $energy2, $shift2, $exc_Q14, $prevGain_Q10, $subfr_length, $nb_subfr) {
 $energy1 = $energy1 | 0;
 $shift1 = $shift1 | 0;
 $energy2 = $energy2 | 0;
 $shift2 = $shift2 | 0;
 $exc_Q14 = $exc_Q14 | 0;
 $prevGain_Q10 = $prevGain_Q10 | 0;
 $subfr_length = $subfr_length | 0;
 $nb_subfr = $nb_subfr | 0;
 var $28 = 0, $55 = 0, $82 = 0, $add19 = 0, $add55 = 0, $add93 = 0, $and = 0, $and49 = 0, $and87 = 0, $cond107 = 0, $energy1$addr = 0, $energy2$addr = 0, $exc_Q14$addr = 0, $exc_buf_ptr = 0, $i = 0, $k = 0, $mul = 0, $mul43 = 0, $mul8 = 0, $mul81 = 0, $nb_subfr$addr = 0, $prevGain_Q10$addr = 0, $saved_stack = 0, $shift1$addr = 0, $shift2$addr = 0, $shr = 0, $shr39 = 0, $shr77 = 0, $subfr_length$addr = 0, $vla = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $energy1$addr = sp + 44 | 0;
 $shift1$addr = sp + 40 | 0;
 $energy2$addr = sp + 36 | 0;
 $shift2$addr = sp + 32 | 0;
 $exc_Q14$addr = sp + 28 | 0;
 $prevGain_Q10$addr = sp + 24 | 0;
 $subfr_length$addr = sp + 20 | 0;
 $nb_subfr$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $k = sp + 8 | 0;
 $exc_buf_ptr = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$energy1$addr >> 2] = $energy1;
 HEAP32[$shift1$addr >> 2] = $shift1;
 HEAP32[$energy2$addr >> 2] = $energy2;
 HEAP32[$shift2$addr >> 2] = $shift2;
 HEAP32[$exc_Q14$addr >> 2] = $exc_Q14;
 HEAP32[$prevGain_Q10$addr >> 2] = $prevGain_Q10;
 HEAP32[$subfr_length$addr >> 2] = $subfr_length;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 $mul = HEAP32[$subfr_length$addr >> 2] << 1;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($mul << 1) | 0) + 15 & -16) | 0;
 HEAP32[$exc_buf_ptr >> 2] = $vla;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= 2) break;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$subfr_length$addr >> 2] | 0)) break;
   $shr = HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul((HEAP32[$k >> 2] | 0) + (HEAP32[$nb_subfr$addr >> 2] | 0) - 2 | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) >> 2] >> 16;
   $mul8 = Math_imul($shr, (HEAP32[(HEAP32[$prevGain_Q10$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
   $and = HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul((HEAP32[$k >> 2] | 0) + (HEAP32[$nb_subfr$addr >> 2] | 0) - 2 | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) >> 2] & 65535;
   $add19 = $mul8 + ((Math_imul($and, (HEAP32[(HEAP32[$prevGain_Q10$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   $28 = HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul((HEAP32[$k >> 2] | 0) + (HEAP32[$nb_subfr$addr >> 2] | 0) - 2 | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) >> 2] | 0;
   if (($add19 + (Math_imul($28, (HEAP32[(HEAP32[$prevGain_Q10$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) >> 8 | 0) > 32767) $cond107 = 32767; else {
    $shr39 = HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul((HEAP32[$k >> 2] | 0) + (HEAP32[$nb_subfr$addr >> 2] | 0) - 2 | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) >> 2] >> 16;
    $mul43 = Math_imul($shr39, (HEAP32[(HEAP32[$prevGain_Q10$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
    $and49 = HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul((HEAP32[$k >> 2] | 0) + (HEAP32[$nb_subfr$addr >> 2] | 0) - 2 | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) >> 2] & 65535;
    $add55 = $mul43 + ((Math_imul($and49, (HEAP32[(HEAP32[$prevGain_Q10$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
    $55 = HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul((HEAP32[$k >> 2] | 0) + (HEAP32[$nb_subfr$addr >> 2] | 0) - 2 | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) >> 2] | 0;
    if (($add55 + (Math_imul($55, (HEAP32[(HEAP32[$prevGain_Q10$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) >> 8 | 0) < -32768) $cond107 = -32768; else {
     $shr77 = HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul((HEAP32[$k >> 2] | 0) + (HEAP32[$nb_subfr$addr >> 2] | 0) - 2 | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) >> 2] >> 16;
     $mul81 = Math_imul($shr77, (HEAP32[(HEAP32[$prevGain_Q10$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
     $and87 = HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul((HEAP32[$k >> 2] | 0) + (HEAP32[$nb_subfr$addr >> 2] | 0) - 2 | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) >> 2] & 65535;
     $add93 = $mul81 + ((Math_imul($and87, (HEAP32[(HEAP32[$prevGain_Q10$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
     $82 = HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul((HEAP32[$k >> 2] | 0) + (HEAP32[$nb_subfr$addr >> 2] | 0) - 2 | 0, HEAP32[$subfr_length$addr >> 2] | 0) | 0) << 2) >> 2] | 0;
     $cond107 = $add93 + (Math_imul($82, (HEAP32[(HEAP32[$prevGain_Q10$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) >> 8;
    }
   }
   HEAP16[(HEAP32[$exc_buf_ptr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $cond107;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$exc_buf_ptr >> 2] = (HEAP32[$exc_buf_ptr >> 2] | 0) + (HEAP32[$subfr_length$addr >> 2] << 1);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 _silk_sum_sqr_shift(HEAP32[$energy1$addr >> 2] | 0, HEAP32[$shift1$addr >> 2] | 0, $vla, HEAP32[$subfr_length$addr >> 2] | 0);
 _silk_sum_sqr_shift(HEAP32[$energy2$addr >> 2] | 0, HEAP32[$shift2$addr >> 2] | 0, $vla + (HEAP32[$subfr_length$addr >> 2] << 1) | 0, HEAP32[$subfr_length$addr >> 2] | 0);
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_A2NLSF($NLSF, $a_Q16, $d) {
 $NLSF = $NLSF | 0;
 $a_Q16 = $a_Q16 | 0;
 $d = $d | 0;
 var $44 = 0, $45 = 0, $NLSF$addr = 0, $P = 0, $PQ = 0, $Q = 0, $a_Q16$addr = 0, $conv73 = 0, $d$addr = 0, $dd = 0, $den = 0, $ffrac = 0, $i = 0, $k = 0, $m = 0, $nom = 0, $p = 0, $root_ix = 0, $thr = 0, $xhi = 0, $xlo = 0, $xmid = 0, $yhi = 0, $ylo = 0, $ymid = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 $NLSF$addr = sp + 188 | 0;
 $a_Q16$addr = sp + 184 | 0;
 $d$addr = sp + 180 | 0;
 $i = sp + 176 | 0;
 $k = sp + 172 | 0;
 $m = sp + 168 | 0;
 $dd = sp + 164 | 0;
 $root_ix = sp + 160 | 0;
 $ffrac = sp + 156 | 0;
 $xlo = sp + 152 | 0;
 $xhi = sp + 148 | 0;
 $xmid = sp + 144 | 0;
 $ylo = sp + 140 | 0;
 $yhi = sp + 136 | 0;
 $ymid = sp + 132 | 0;
 $thr = sp + 128 | 0;
 $nom = sp + 124 | 0;
 $den = sp + 120 | 0;
 $P = sp + 68 | 0;
 $Q = sp + 16 | 0;
 $PQ = sp + 8 | 0;
 $p = sp;
 HEAP32[$NLSF$addr >> 2] = $NLSF;
 HEAP32[$a_Q16$addr >> 2] = $a_Q16;
 HEAP32[$d$addr >> 2] = $d;
 HEAP32[$PQ >> 2] = $P;
 HEAP32[$PQ + 4 >> 2] = $Q;
 HEAP32[$dd >> 2] = HEAP32[$d$addr >> 2] >> 1;
 _silk_A2NLSF_init(HEAP32[$a_Q16$addr >> 2] | 0, $P, $Q, HEAP32[$dd >> 2] | 0);
 HEAP32[$p >> 2] = $P;
 HEAP32[$xlo >> 2] = HEAP16[12542];
 HEAP32[$ylo >> 2] = _silk_A2NLSF_eval_poly(HEAP32[$p >> 2] | 0, HEAP32[$xlo >> 2] | 0, HEAP32[$dd >> 2] | 0) | 0;
 if ((HEAP32[$ylo >> 2] | 0) < 0) {
  HEAP16[HEAP32[$NLSF$addr >> 2] >> 1] = 0;
  HEAP32[$p >> 2] = $Q;
  HEAP32[$ylo >> 2] = _silk_A2NLSF_eval_poly(HEAP32[$p >> 2] | 0, HEAP32[$xlo >> 2] | 0, HEAP32[$dd >> 2] | 0) | 0;
  HEAP32[$root_ix >> 2] = 1;
 } else HEAP32[$root_ix >> 2] = 0;
 HEAP32[$k >> 2] = 1;
 HEAP32[$i >> 2] = 0;
 HEAP32[$thr >> 2] = 0;
 L5 : while (1) {
  HEAP32[$xhi >> 2] = HEAP16[25084 + (HEAP32[$k >> 2] << 1) >> 1];
  HEAP32[$yhi >> 2] = _silk_A2NLSF_eval_poly(HEAP32[$p >> 2] | 0, HEAP32[$xhi >> 2] | 0, HEAP32[$dd >> 2] | 0) | 0;
  if ((HEAP32[$ylo >> 2] | 0) <= 0) {
   if ((HEAP32[$yhi >> 2] | 0) < (HEAP32[$thr >> 2] | 0)) label = 7;
  } else label = 7;
  do if ((label | 0) == 7) {
   label = 0;
   if ((HEAP32[$ylo >> 2] | 0) >= 0) if ((HEAP32[$yhi >> 2] | 0) <= (0 - (HEAP32[$thr >> 2] | 0) | 0)) break;
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   HEAP32[$xlo >> 2] = HEAP32[$xhi >> 2];
   HEAP32[$ylo >> 2] = HEAP32[$yhi >> 2];
   HEAP32[$thr >> 2] = 0;
   if ((HEAP32[$k >> 2] | 0) <= 128) continue L5;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   if ((HEAP32[$i >> 2] | 0) > 16) break L5;
   _silk_bwexpander_32(HEAP32[$a_Q16$addr >> 2] | 0, HEAP32[$d$addr >> 2] | 0, 65536 - (1 << HEAP32[$i >> 2]) | 0);
   _silk_A2NLSF_init(HEAP32[$a_Q16$addr >> 2] | 0, $P, $Q, HEAP32[$dd >> 2] | 0);
   HEAP32[$p >> 2] = $P;
   HEAP32[$xlo >> 2] = HEAP16[12542];
   HEAP32[$ylo >> 2] = _silk_A2NLSF_eval_poly(HEAP32[$p >> 2] | 0, HEAP32[$xlo >> 2] | 0, HEAP32[$dd >> 2] | 0) | 0;
   if ((HEAP32[$ylo >> 2] | 0) < 0) {
    HEAP16[HEAP32[$NLSF$addr >> 2] >> 1] = 0;
    HEAP32[$p >> 2] = $Q;
    HEAP32[$ylo >> 2] = _silk_A2NLSF_eval_poly(HEAP32[$p >> 2] | 0, HEAP32[$xlo >> 2] | 0, HEAP32[$dd >> 2] | 0) | 0;
    HEAP32[$root_ix >> 2] = 1;
   } else HEAP32[$root_ix >> 2] = 0;
   HEAP32[$k >> 2] = 1;
   continue L5;
  } while (0);
  if (!(HEAP32[$yhi >> 2] | 0)) HEAP32[$thr >> 2] = 1; else HEAP32[$thr >> 2] = 0;
  HEAP32[$ffrac >> 2] = -256;
  HEAP32[$m >> 2] = 0;
  while (1) {
   if ((HEAP32[$m >> 2] | 0) >= 3) break;
   HEAP32[$xmid >> 2] = ((HEAP32[$xlo >> 2] | 0) + (HEAP32[$xhi >> 2] | 0) >> 1) + ((HEAP32[$xlo >> 2] | 0) + (HEAP32[$xhi >> 2] | 0) & 1);
   HEAP32[$ymid >> 2] = _silk_A2NLSF_eval_poly(HEAP32[$p >> 2] | 0, HEAP32[$xmid >> 2] | 0, HEAP32[$dd >> 2] | 0) | 0;
   if ((HEAP32[$ylo >> 2] | 0) <= 0 & (HEAP32[$ymid >> 2] | 0) >= 0) label = 16; else if ((HEAP32[$ylo >> 2] | 0) >= 0 & (HEAP32[$ymid >> 2] | 0) <= 0) label = 16; else {
    HEAP32[$xlo >> 2] = HEAP32[$xmid >> 2];
    HEAP32[$ylo >> 2] = HEAP32[$ymid >> 2];
    HEAP32[$ffrac >> 2] = (HEAP32[$ffrac >> 2] | 0) + (128 >> HEAP32[$m >> 2]);
   }
   if ((label | 0) == 16) {
    label = 0;
    HEAP32[$xhi >> 2] = HEAP32[$xmid >> 2];
    HEAP32[$yhi >> 2] = HEAP32[$ymid >> 2];
   }
   HEAP32[$m >> 2] = (HEAP32[$m >> 2] | 0) + 1;
  }
  $44 = HEAP32[$ylo >> 2] | 0;
  $45 = HEAP32[$ylo >> 2] | 0;
  if ((((HEAP32[$ylo >> 2] | 0) > 0 ? $44 : 0 - $44 | 0) | 0) < 65536) {
   HEAP32[$den >> 2] = $45 - (HEAP32[$yhi >> 2] | 0);
   HEAP32[$nom >> 2] = (HEAP32[$ylo >> 2] << 5) + (HEAP32[$den >> 2] >> 1);
   if (HEAP32[$den >> 2] | 0) HEAP32[$ffrac >> 2] = (HEAP32[$ffrac >> 2] | 0) + ((HEAP32[$nom >> 2] | 0) / (HEAP32[$den >> 2] | 0) | 0);
  } else HEAP32[$ffrac >> 2] = (HEAP32[$ffrac >> 2] | 0) + (($45 | 0) / ((HEAP32[$ylo >> 2] | 0) - (HEAP32[$yhi >> 2] | 0) >> 5 | 0) | 0);
  $conv73 = (_silk_min_32_470((HEAP32[$k >> 2] << 8) + (HEAP32[$ffrac >> 2] | 0) | 0, 32767) | 0) & 65535;
  HEAP16[(HEAP32[$NLSF$addr >> 2] | 0) + (HEAP32[$root_ix >> 2] << 1) >> 1] = $conv73;
  HEAP32[$root_ix >> 2] = (HEAP32[$root_ix >> 2] | 0) + 1;
  if ((HEAP32[$root_ix >> 2] | 0) >= (HEAP32[$d$addr >> 2] | 0)) {
   label = 34;
   break;
  }
  HEAP32[$p >> 2] = HEAP32[$PQ + ((HEAP32[$root_ix >> 2] & 1) << 2) >> 2];
  HEAP32[$xlo >> 2] = HEAP16[25084 + ((HEAP32[$k >> 2] | 0) - 1 << 1) >> 1];
  HEAP32[$ylo >> 2] = 1 - (HEAP32[$root_ix >> 2] & 2) << 12;
 }
 if ((label | 0) == 34) {
  STACKTOP = sp;
  return;
 }
 HEAP16[HEAP32[$NLSF$addr >> 2] >> 1] = 32768 / ((HEAP32[$d$addr >> 2] | 0) + 1 | 0) | 0;
 HEAP32[$k >> 2] = 1;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$d$addr >> 2] | 0)) break;
  HEAP16[(HEAP32[$NLSF$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = (HEAP16[(HEAP32[$NLSF$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - 1 << 1) >> 1] | 0) + (HEAP16[HEAP32[$NLSF$addr >> 2] >> 1] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_NSQ_wrapper_FLP($psEnc, $psEncCtrl, $psIndices, $psNSQ, $pulses, $x) {
 $psEnc = $psEnc | 0;
 $psEncCtrl = $psEncCtrl | 0;
 $psIndices = $psIndices | 0;
 $psNSQ = $psNSQ | 0;
 $pulses = $pulses | 0;
 $x = $x | 0;
 var $17 = 0, $AR_Q13 = 0, $Gains_Q16 = 0, $HarmShapeGain_Q14 = 0, $LF_shp_Q14 = 0, $LTPCoef_Q14 = 0, $LTP_scale_Q14 = 0, $Lambda_Q10 = 0, $PredCoef_Q12 = 0, $Tilt_Q14 = 0, $call29 = 0, $call33 = 0, $call85 = 0, $cmp56 = 0, $conv = 0, $conv102 = 0, $conv50 = 0, $conv68 = 0, $i = 0, $j = 0, $or = 0, $psEnc$addr = 0, $psEncCtrl$addr = 0, $psIndices$addr = 0, $psNSQ$addr = 0, $pulses$addr = 0, $shl = 0, $x$addr = 0, $x16 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1056 | 0;
 $psEnc$addr = sp + 108 | 0;
 $psEncCtrl$addr = sp + 104 | 0;
 $psIndices$addr = sp + 100 | 0;
 $psNSQ$addr = sp + 96 | 0;
 $pulses$addr = sp + 92 | 0;
 $x$addr = sp + 88 | 0;
 $i = sp + 84 | 0;
 $j = sp + 80 | 0;
 $x16 = sp + 408 | 0;
 $Gains_Q16 = sp + 64 | 0;
 $PredCoef_Q12 = sp + 344 | 0;
 $LTPCoef_Q14 = sp + 304 | 0;
 $LTP_scale_Q14 = sp + 56 | 0;
 $AR_Q13 = sp + 112 | 0;
 $LF_shp_Q14 = sp + 40 | 0;
 $Lambda_Q10 = sp + 32 | 0;
 $Tilt_Q14 = sp + 16 | 0;
 $HarmShapeGain_Q14 = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$psEncCtrl$addr >> 2] = $psEncCtrl;
 HEAP32[$psIndices$addr >> 2] = $psIndices;
 HEAP32[$psNSQ$addr >> 2] = $psNSQ;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4632 >> 2] | 0)) break;
   $conv = (_silk_float2int(+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 244 + (((HEAP32[$i >> 2] | 0) * 24 | 0) + (HEAP32[$j >> 2] | 0) << 2) >> 2] * 8192.0) | 0) & 65535;
   HEAP16[$AR_Q13 + (((HEAP32[$i >> 2] | 0) * 24 | 0) + (HEAP32[$j >> 2] | 0) << 1) >> 1] = $conv;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  $17 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  $shl = (_silk_float2int(+HEAPF32[$17 + 644 + (HEAP32[$i >> 2] << 2) >> 2] * 16384.0) | 0) << 16;
  $or = $shl | (_silk_float2int(+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 628 + (HEAP32[$i >> 2] << 2) >> 2] * 16384.0) | 0) & 65535;
  HEAP32[$LF_shp_Q14 + (HEAP32[$i >> 2] << 2) >> 2] = $or;
  $call29 = _silk_float2int(+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 660 + (HEAP32[$i >> 2] << 2) >> 2] * 16384.0) | 0;
  HEAP32[$Tilt_Q14 + (HEAP32[$i >> 2] << 2) >> 2] = $call29;
  $call33 = _silk_float2int(+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 676 + (HEAP32[$i >> 2] << 2) >> 2] * 16384.0) | 0;
  HEAP32[$HarmShapeGain_Q14 + (HEAP32[$i >> 2] << 2) >> 2] = $call33;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$Lambda_Q10 >> 2] = _silk_float2int(+HEAPF32[$17 + 692 >> 2] * 1024.0) | 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0) * 5 | 0)) break;
  $conv50 = (_silk_float2int(+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 144 + (HEAP32[$i >> 2] << 2) >> 2] * 16384.0) | 0) & 65535;
  HEAP16[$LTPCoef_Q14 + (HEAP32[$i >> 2] << 1) >> 1] = $conv50;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$j >> 2] = 0;
 while (1) {
  $cmp56 = (HEAP32[$j >> 2] | 0) < 2;
  HEAP32[$i >> 2] = 0;
  if (!$cmp56) break;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4636 >> 2] | 0)) break;
   $conv68 = (_silk_float2int(+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 16 + (HEAP32[$j >> 2] << 6) + (HEAP32[$i >> 2] << 2) >> 2] * 4096.0) | 0) & 65535;
   HEAP16[$PredCoef_Q12 + (HEAP32[$j >> 2] << 5) + (HEAP32[$i >> 2] << 1) >> 1] = $conv68;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  $call85 = _silk_float2int(+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * 65536.0) | 0;
  HEAP32[$Gains_Q16 + (HEAP32[$i >> 2] << 2) >> 2] = $call85;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 29 >> 0] | 0) == 2) HEAP32[$LTP_scale_Q14 >> 2] = HEAP16[22964 + (HEAP8[(HEAP32[$psIndices$addr >> 2] | 0) + 33 >> 0] << 1) >> 1]; else HEAP32[$LTP_scale_Q14 >> 2] = 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] | 0)) break;
  $conv102 = (_silk_float2int(+HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) | 0) & 65535;
  HEAP16[$x16 + (HEAP32[$i >> 2] << 1) >> 1] = $conv102;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4624 >> 2] | 0) <= 1) if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4668 >> 2] | 0) <= 0) {
  _silk_NSQ_c(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[$psNSQ$addr >> 2] | 0, HEAP32[$psIndices$addr >> 2] | 0, $x16, HEAP32[$pulses$addr >> 2] | 0, $PredCoef_Q12, $LTPCoef_Q14, $AR_Q13, $HarmShapeGain_Q14, $Tilt_Q14, $LF_shp_Q14, $Gains_Q16, (HEAP32[$psEncCtrl$addr >> 2] | 0) + 228 | 0, HEAP32[$Lambda_Q10 >> 2] | 0, HEAP32[$LTP_scale_Q14 >> 2] | 0);
  STACKTOP = sp;
  return;
 }
 _silk_NSQ_del_dec_c(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[$psNSQ$addr >> 2] | 0, HEAP32[$psIndices$addr >> 2] | 0, $x16, HEAP32[$pulses$addr >> 2] | 0, $PredCoef_Q12, $LTPCoef_Q14, $AR_Q13, $HarmShapeGain_Q14, $Tilt_Q14, $LF_shp_Q14, $Gains_Q16, (HEAP32[$psEncCtrl$addr >> 2] | 0) + 228 | 0, HEAP32[$Lambda_Q10 >> 2] | 0, HEAP32[$LTP_scale_Q14 >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_stereo_find_predictor($ratio_Q14, $x, $y, $mid_res_amp_Q0, $length, $smooth_coef_Q16) {
 $ratio_Q14 = $ratio_Q14 | 0;
 $x = $x | 0;
 $y = $y | 0;
 $mid_res_amp_Q0 = $mid_res_amp_Q0 | 0;
 $length = $length | 0;
 $smooth_coef_Q16 = $smooth_coef_Q16 | 0;
 var $30 = 0, $33 = 0, $56 = 0, $81 = 0, $82 = 0, $add45 = 0, $add90 = 0, $call101 = 0, $call28 = 0, $call35 = 0, $call72 = 0, $call80 = 0, $cond10 = 0, $cond100 = 0, $cond113 = 0, $corr = 0, $length$addr = 0, $mid_res_amp_Q0$addr = 0, $mul = 0, $mul34 = 0, $mul50 = 0, $mul62 = 0, $mul79 = 0, $nrgx = 0, $nrgy = 0, $pred2_Q10 = 0, $pred_Q13 = 0, $ratio_Q14$addr = 0, $scale = 0, $scale1 = 0, $scale2 = 0, $smooth_coef_Q16$addr = 0, $x$addr = 0, $y$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $ratio_Q14$addr = sp + 52 | 0;
 $x$addr = sp + 48 | 0;
 $y$addr = sp + 44 | 0;
 $mid_res_amp_Q0$addr = sp + 40 | 0;
 $length$addr = sp + 36 | 0;
 $smooth_coef_Q16$addr = sp + 32 | 0;
 $scale = sp + 28 | 0;
 $scale1 = sp + 24 | 0;
 $scale2 = sp + 20 | 0;
 $nrgx = sp + 16 | 0;
 $nrgy = sp + 12 | 0;
 $corr = sp + 8 | 0;
 $pred_Q13 = sp + 4 | 0;
 $pred2_Q10 = sp;
 HEAP32[$ratio_Q14$addr >> 2] = $ratio_Q14;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$y$addr >> 2] = $y;
 HEAP32[$mid_res_amp_Q0$addr >> 2] = $mid_res_amp_Q0;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$smooth_coef_Q16$addr >> 2] = $smooth_coef_Q16;
 _silk_sum_sqr_shift($nrgx, $scale1, HEAP32[$x$addr >> 2] | 0, HEAP32[$length$addr >> 2] | 0);
 _silk_sum_sqr_shift($nrgy, $scale2, HEAP32[$y$addr >> 2] | 0, HEAP32[$length$addr >> 2] | 0);
 HEAP32[$scale >> 2] = _silk_max_int_274(HEAP32[$scale1 >> 2] | 0, HEAP32[$scale2 >> 2] | 0) | 0;
 HEAP32[$scale >> 2] = (HEAP32[$scale >> 2] | 0) + (HEAP32[$scale >> 2] & 1);
 HEAP32[$nrgy >> 2] = HEAP32[$nrgy >> 2] >> (HEAP32[$scale >> 2] | 0) - (HEAP32[$scale2 >> 2] | 0);
 HEAP32[$nrgx >> 2] = HEAP32[$nrgx >> 2] >> (HEAP32[$scale >> 2] | 0) - (HEAP32[$scale1 >> 2] | 0);
 HEAP32[$nrgx >> 2] = _silk_max_int_274(HEAP32[$nrgx >> 2] | 0, 1) | 0;
 HEAP32[$corr >> 2] = _silk_inner_prod_aligned_scale(HEAP32[$x$addr >> 2] | 0, HEAP32[$y$addr >> 2] | 0, HEAP32[$scale >> 2] | 0, HEAP32[$length$addr >> 2] | 0) | 0;
 HEAP32[$pred_Q13 >> 2] = _silk_DIV32_varQ_275(HEAP32[$corr >> 2] | 0, HEAP32[$nrgx >> 2] | 0, 13) | 0;
 if ((HEAP32[$pred_Q13 >> 2] | 0) > 16384) $cond10 = 16384; else $cond10 = (HEAP32[$pred_Q13 >> 2] | 0) < -16384 ? -16384 : HEAP32[$pred_Q13 >> 2] | 0;
 HEAP32[$pred_Q13 >> 2] = $cond10;
 $mul = Math_imul(HEAP32[$pred_Q13 >> 2] >> 16, (HEAP32[$pred_Q13 >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$pred2_Q10 >> 2] = $mul + ((Math_imul(HEAP32[$pred_Q13 >> 2] & 65535, (HEAP32[$pred_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 $30 = HEAP32[$pred2_Q10 >> 2] | 0;
 HEAP32[$smooth_coef_Q16$addr >> 2] = _silk_max_int_274(HEAP32[$smooth_coef_Q16$addr >> 2] | 0, (HEAP32[$pred2_Q10 >> 2] | 0) > 0 ? $30 : 0 - $30 | 0) | 0;
 HEAP32[$scale >> 2] = HEAP32[$scale >> 2] >> 1;
 $33 = HEAP32[HEAP32[$mid_res_amp_Q0$addr >> 2] >> 2] | 0;
 $call28 = _silk_SQRT_APPROX(HEAP32[$nrgx >> 2] | 0) | 0;
 $mul34 = Math_imul(($call28 << HEAP32[$scale >> 2]) - (HEAP32[HEAP32[$mid_res_amp_Q0$addr >> 2] >> 2] | 0) >> 16, (HEAP32[$smooth_coef_Q16$addr >> 2] & 65535) << 16 >> 16) | 0;
 $call35 = _silk_SQRT_APPROX(HEAP32[$nrgx >> 2] | 0) | 0;
 $add45 = $33 + ($mul34 + ((Math_imul(($call35 << HEAP32[$scale >> 2]) - (HEAP32[HEAP32[$mid_res_amp_Q0$addr >> 2] >> 2] | 0) & 65535, (HEAP32[$smooth_coef_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
 HEAP32[HEAP32[$mid_res_amp_Q0$addr >> 2] >> 2] = $add45;
 $mul50 = Math_imul(HEAP32[$corr >> 2] >> 16, (HEAP32[$pred_Q13 >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$nrgy >> 2] = (HEAP32[$nrgy >> 2] | 0) - ($mul50 + ((Math_imul(HEAP32[$corr >> 2] & 65535, (HEAP32[$pred_Q13 >> 2] & 65535) << 16 >> 16) | 0) >> 16) << 4);
 $mul62 = Math_imul(HEAP32[$nrgx >> 2] >> 16, (HEAP32[$pred2_Q10 >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$nrgy >> 2] = (HEAP32[$nrgy >> 2] | 0) + ($mul62 + ((Math_imul(HEAP32[$nrgx >> 2] & 65535, (HEAP32[$pred2_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 16) << 6);
 $56 = HEAP32[(HEAP32[$mid_res_amp_Q0$addr >> 2] | 0) + 4 >> 2] | 0;
 $call72 = _silk_SQRT_APPROX(HEAP32[$nrgy >> 2] | 0) | 0;
 $mul79 = Math_imul(($call72 << HEAP32[$scale >> 2]) - (HEAP32[(HEAP32[$mid_res_amp_Q0$addr >> 2] | 0) + 4 >> 2] | 0) >> 16, (HEAP32[$smooth_coef_Q16$addr >> 2] & 65535) << 16 >> 16) | 0;
 $call80 = _silk_SQRT_APPROX(HEAP32[$nrgy >> 2] | 0) | 0;
 $add90 = $56 + ($mul79 + ((Math_imul(($call80 << HEAP32[$scale >> 2]) - (HEAP32[(HEAP32[$mid_res_amp_Q0$addr >> 2] | 0) + 4 >> 2] | 0) & 65535, (HEAP32[$smooth_coef_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
 HEAP32[(HEAP32[$mid_res_amp_Q0$addr >> 2] | 0) + 4 >> 2] = $add90;
 if ((HEAP32[HEAP32[$mid_res_amp_Q0$addr >> 2] >> 2] | 0) > 1) $cond100 = HEAP32[HEAP32[$mid_res_amp_Q0$addr >> 2] >> 2] | 0; else $cond100 = 1;
 $call101 = _silk_DIV32_varQ_275(HEAP32[(HEAP32[$mid_res_amp_Q0$addr >> 2] | 0) + 4 >> 2] | 0, $cond100, 14) | 0;
 HEAP32[HEAP32[$ratio_Q14$addr >> 2] >> 2] = $call101;
 if ((HEAP32[HEAP32[$ratio_Q14$addr >> 2] >> 2] | 0) > 32767) {
  $cond113 = 32767;
  $81 = HEAP32[$ratio_Q14$addr >> 2] | 0;
  HEAP32[$81 >> 2] = $cond113;
  $82 = HEAP32[$pred_Q13 >> 2] | 0;
  STACKTOP = sp;
  return $82 | 0;
 }
 if ((HEAP32[HEAP32[$ratio_Q14$addr >> 2] >> 2] | 0) < 0) {
  $cond113 = 0;
  $81 = HEAP32[$ratio_Q14$addr >> 2] | 0;
  HEAP32[$81 >> 2] = $cond113;
  $82 = HEAP32[$pred_Q13 >> 2] | 0;
  STACKTOP = sp;
  return $82 | 0;
 }
 $cond113 = HEAP32[HEAP32[$ratio_Q14$addr >> 2] >> 2] | 0;
 $81 = HEAP32[$ratio_Q14$addr >> 2] | 0;
 HEAP32[$81 >> 2] = $cond113;
 $82 = HEAP32[$pred_Q13 >> 2] | 0;
 STACKTOP = sp;
 return $82 | 0;
}

function _compute_gru($gru, $state, $input) {
 $gru = $gru | 0;
 $state = $state | 0;
 $input = $input | 0;
 var $M = 0, $N = 0, $add116 = 0, $add136 = 0.0, $add47 = 0, $add64 = 0, $add98 = 0, $call = 0.0, $call76 = 0.0, $gru$addr = 0, $h = 0, $i = 0, $input$addr = 0, $j = 0, $mul131 = 0.0, $mul16 = 0, $mul5 = 0, $r = 0, $state$addr = 0, $stride = 0, $sub = 0.0, $sum = 0, $sum36 = 0, $sum85 = 0, $z = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 432 | 0;
 $gru$addr = sp + 428 | 0;
 $state$addr = sp + 424 | 0;
 $input$addr = sp + 420 | 0;
 $i = sp + 416 | 0;
 $j = sp + 412 | 0;
 $N = sp + 408 | 0;
 $M = sp + 404 | 0;
 $stride = sp + 400 | 0;
 $z = sp + 272 | 0;
 $r = sp + 144 | 0;
 $h = sp + 16 | 0;
 $sum = sp + 8 | 0;
 $sum36 = sp + 4 | 0;
 $sum85 = sp;
 HEAP32[$gru$addr >> 2] = $gru;
 HEAP32[$state$addr >> 2] = $state;
 HEAP32[$input$addr >> 2] = $input;
 HEAP32[$M >> 2] = HEAP32[(HEAP32[$gru$addr >> 2] | 0) + 12 >> 2];
 HEAP32[$N >> 2] = HEAP32[(HEAP32[$gru$addr >> 2] | 0) + 16 >> 2];
 HEAP32[$stride >> 2] = (HEAP32[$N >> 2] | 0) * 3;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
  HEAPF32[$sum >> 2] = +(HEAP8[(HEAP32[HEAP32[$gru$addr >> 2] >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] | 0);
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$M >> 2] | 0)) break;
   $mul5 = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride >> 2] | 0) | 0;
   HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +(HEAP8[(HEAP32[(HEAP32[$gru$addr >> 2] | 0) + 4 >> 2] | 0) + ($mul5 + (HEAP32[$i >> 2] | 0)) >> 0] | 0) * +HEAPF32[(HEAP32[$input$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
   $mul16 = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride >> 2] | 0) | 0;
   HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +(HEAP8[(HEAP32[(HEAP32[$gru$addr >> 2] | 0) + 8 >> 2] | 0) + ($mul16 + (HEAP32[$i >> 2] | 0)) >> 0] | 0) * +HEAPF32[(HEAP32[$state$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  $call = +_sigmoid_approx(+HEAPF32[$sum >> 2] * .0078125);
  HEAPF32[$z + (HEAP32[$i >> 2] << 2) >> 2] = $call;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
  HEAPF32[$sum36 >> 2] = +(HEAP8[(HEAP32[HEAP32[$gru$addr >> 2] >> 2] | 0) + ((HEAP32[$N >> 2] | 0) + (HEAP32[$i >> 2] | 0)) >> 0] | 0);
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$M >> 2] | 0)) break;
   $add47 = (HEAP32[$N >> 2] | 0) + (Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride >> 2] | 0) | 0) | 0;
   HEAPF32[$sum36 >> 2] = +HEAPF32[$sum36 >> 2] + +(HEAP8[(HEAP32[(HEAP32[$gru$addr >> 2] | 0) + 4 >> 2] | 0) + ($add47 + (HEAP32[$i >> 2] | 0)) >> 0] | 0) * +HEAPF32[(HEAP32[$input$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
   $add64 = (HEAP32[$N >> 2] | 0) + (Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride >> 2] | 0) | 0) | 0;
   HEAPF32[$sum36 >> 2] = +HEAPF32[$sum36 >> 2] + +(HEAP8[(HEAP32[(HEAP32[$gru$addr >> 2] | 0) + 8 >> 2] | 0) + ($add64 + (HEAP32[$i >> 2] | 0)) >> 0] | 0) * +HEAPF32[(HEAP32[$state$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  $call76 = +_sigmoid_approx(+HEAPF32[$sum36 >> 2] * .0078125);
  HEAPF32[$r + (HEAP32[$i >> 2] << 2) >> 2] = $call76;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
  HEAPF32[$sum85 >> 2] = +(HEAP8[(HEAP32[HEAP32[$gru$addr >> 2] >> 2] | 0) + ((HEAP32[$N >> 2] << 1) + (HEAP32[$i >> 2] | 0)) >> 0] | 0);
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$M >> 2] | 0)) break;
   $add98 = (HEAP32[$N >> 2] << 1) + (Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride >> 2] | 0) | 0) | 0;
   HEAPF32[$sum85 >> 2] = +HEAPF32[$sum85 >> 2] + +(HEAP8[(HEAP32[(HEAP32[$gru$addr >> 2] | 0) + 4 >> 2] | 0) + ($add98 + (HEAP32[$i >> 2] | 0)) >> 0] | 0) * +HEAPF32[(HEAP32[$input$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
   $add116 = (HEAP32[$N >> 2] << 1) + (Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride >> 2] | 0) | 0) | 0;
   HEAPF32[$sum85 >> 2] = +HEAPF32[$sum85 >> 2] + +(HEAP8[(HEAP32[(HEAP32[$gru$addr >> 2] | 0) + 8 >> 2] | 0) + ($add116 + (HEAP32[$i >> 2] | 0)) >> 0] | 0) * +HEAPF32[(HEAP32[$state$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] * +HEAPF32[$r + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  $mul131 = +HEAPF32[$z + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$state$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  $sub = 1.0 - +HEAPF32[$z + (HEAP32[$i >> 2] << 2) >> 2];
  $add136 = $mul131 + $sub * +_tansig_approx(+HEAPF32[$sum85 >> 2] * .0078125);
  HEAPF32[$h + (HEAP32[$i >> 2] << 2) >> 2] = $add136;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
  HEAPF32[(HEAP32[$state$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$h + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_PLC_update($psDec, $psDecCtrl) {
 $psDec = $psDec | 0;
 $psDecCtrl = $psDecCtrl | 0;
 var $LTPCoef_Q14105 = 0, $LTPCoef_Q1425 = 0, $LTPCoef_Q1443 = 0, $LTP_Gain_Q14 = 0, $arrayidx116 = 0, $arrayidx33 = 0, $conv63 = 0, $conv91 = 0, $i = 0, $j = 0, $mul = 0, $prevGain_Q16 = 0, $psDec$addr = 0, $psDecCtrl$addr = 0, $psPLC = 0, $scale_Q10 = 0, $scale_Q14 = 0, $temp_LTP_Gain_Q14 = 0, $tmp = 0, $tmp72 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $psDec$addr = sp + 40 | 0;
 $psDecCtrl$addr = sp + 36 | 0;
 $LTP_Gain_Q14 = sp + 32 | 0;
 $temp_LTP_Gain_Q14 = sp + 28 | 0;
 $i = sp + 24 | 0;
 $j = sp + 20 | 0;
 $psPLC = sp + 16 | 0;
 $scale_Q10 = sp + 12 | 0;
 $tmp = sp + 8 | 0;
 $scale_Q14 = sp + 4 | 0;
 $tmp72 = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$psDecCtrl$addr >> 2] = $psDecCtrl;
 HEAP32[$psPLC >> 2] = (HEAP32[$psDec$addr >> 2] | 0) + 4172;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4164 >> 2] = HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0];
 HEAP32[$LTP_Gain_Q14 >> 2] = 0;
 L1 : do if ((HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] | 0) == 2) {
  HEAP32[$j >> 2] = 0;
  while (1) {
   $mul = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] | 0) | 0;
   if (($mul | 0) >= (HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) - 1 << 2) >> 2] | 0)) break;
   if ((HEAP32[$j >> 2] | 0) == (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0)) break;
   HEAP32[$temp_LTP_Gain_Q14 >> 2] = 0;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= 5) break;
    HEAP32[$temp_LTP_Gain_Q14 >> 2] = (HEAP32[$temp_LTP_Gain_Q14 >> 2] | 0) + (HEAP16[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 96 + ((((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) - 1 - (HEAP32[$j >> 2] | 0) | 0) * 5 | 0) + (HEAP32[$i >> 2] | 0) << 1) >> 1] | 0);
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
   if ((HEAP32[$temp_LTP_Gain_Q14 >> 2] | 0) > (HEAP32[$LTP_Gain_Q14 >> 2] | 0)) {
    HEAP32[$LTP_Gain_Q14 >> 2] = HEAP32[$temp_LTP_Gain_Q14 >> 2];
    $LTPCoef_Q1425 = (HEAP32[$psPLC >> 2] | 0) + 4 | 0;
    $arrayidx33 = (HEAP32[$psDecCtrl$addr >> 2] | 0) + 96 + ((((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) - 1 - (HEAP32[$j >> 2] | 0) & 65535) << 16 >> 16) * 5 << 1) | 0;
    HEAP16[$LTPCoef_Q1425 >> 1] = HEAP16[$arrayidx33 >> 1] | 0;
    HEAP16[$LTPCoef_Q1425 + 2 >> 1] = HEAP16[$arrayidx33 + 2 >> 1] | 0;
    HEAP16[$LTPCoef_Q1425 + 4 >> 1] = HEAP16[$arrayidx33 + 4 >> 1] | 0;
    HEAP16[$LTPCoef_Q1425 + 6 >> 1] = HEAP16[$arrayidx33 + 6 >> 1] | 0;
    HEAP16[$LTPCoef_Q1425 + 8 >> 1] = HEAP16[$arrayidx33 + 8 >> 1] | 0;
    HEAP32[HEAP32[$psPLC >> 2] >> 2] = HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) - 1 - (HEAP32[$j >> 2] | 0) << 2) >> 2] << 8;
   }
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  $LTPCoef_Q1443 = (HEAP32[$psPLC >> 2] | 0) + 4 | 0;
  HEAP32[$LTPCoef_Q1443 >> 2] = 0;
  HEAP32[$LTPCoef_Q1443 + 4 >> 2] = 0;
  HEAP16[$LTPCoef_Q1443 + 8 >> 1] = 0;
  HEAP16[(HEAP32[$psPLC >> 2] | 0) + 4 + 4 >> 1] = HEAP32[$LTP_Gain_Q14 >> 2];
  if ((HEAP32[$LTP_Gain_Q14 >> 2] | 0) < 11469) {
   HEAP32[$tmp >> 2] = 11744256;
   HEAP32[$scale_Q10 >> 2] = (HEAP32[$tmp >> 2] | 0) / (((HEAP32[$LTP_Gain_Q14 >> 2] | 0) > 1 ? HEAP32[$LTP_Gain_Q14 >> 2] | 0 : 1) | 0) | 0;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= 5) break L1;
    $conv63 = (Math_imul(HEAP16[(HEAP32[$psPLC >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 1) >> 1] | 0, (HEAP32[$scale_Q10 >> 2] & 65535) << 16 >> 16) | 0) >> 10 & 65535;
    HEAP16[(HEAP32[$psPLC >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 1) >> 1] = $conv63;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  }
  if ((HEAP32[$LTP_Gain_Q14 >> 2] | 0) > 15565) {
   HEAP32[$tmp72 >> 2] = 255016960;
   HEAP32[$scale_Q14 >> 2] = (HEAP32[$tmp72 >> 2] | 0) / (((HEAP32[$LTP_Gain_Q14 >> 2] | 0) > 1 ? HEAP32[$LTP_Gain_Q14 >> 2] | 0 : 1) | 0) | 0;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= 5) break L1;
    $conv91 = (Math_imul(HEAP16[(HEAP32[$psPLC >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 1) >> 1] | 0, (HEAP32[$scale_Q14 >> 2] & 65535) << 16 >> 16) | 0) >> 14 & 65535;
    HEAP16[(HEAP32[$psPLC >> 2] | 0) + 4 + (HEAP32[$i >> 2] << 1) >> 1] = $conv91;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  }
 } else {
  HEAP32[HEAP32[$psPLC >> 2] >> 2] = ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] & 65535) << 16 >> 16) * 18 << 8;
  $LTPCoef_Q14105 = (HEAP32[$psPLC >> 2] | 0) + 4 | 0;
  HEAP32[$LTPCoef_Q14105 >> 2] = 0;
  HEAP32[$LTPCoef_Q14105 + 4 >> 2] = 0;
  HEAP16[$LTPCoef_Q14105 + 8 >> 1] = 0;
 } while (0);
 _memcpy((HEAP32[$psPLC >> 2] | 0) + 14 | 0, (HEAP32[$psDecCtrl$addr >> 2] | 0) + 32 + 32 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] << 1 | 0) | 0;
 HEAP16[(HEAP32[$psPLC >> 2] | 0) + 68 >> 1] = HEAP32[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 136 >> 2];
 $prevGain_Q16 = (HEAP32[$psPLC >> 2] | 0) + 72 | 0;
 $arrayidx116 = (HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 + ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) - 2 << 2) | 0;
 HEAP32[$prevGain_Q16 >> 2] = HEAP32[$arrayidx116 >> 2];
 HEAP32[$prevGain_Q16 + 4 >> 2] = HEAP32[$arrayidx116 + 4 >> 2];
 HEAP32[(HEAP32[$psPLC >> 2] | 0) + 88 >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2];
 HEAP32[(HEAP32[$psPLC >> 2] | 0) + 84 >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2];
 STACKTOP = sp;
 return;
}

function _silk_gains_quant($ind, $gain_Q16, $prev_ind, $conditional, $nb_subfr) {
 $ind = $ind | 0;
 $gain_Q16 = $gain_Q16 | 0;
 $prev_ind = $prev_ind | 0;
 $conditional = $conditional | 0;
 $nb_subfr = $nb_subfr | 0;
 var $101 = 0, $106 = 0, $arrayidx15 = 0, $arrayidx155 = 0, $call170 = 0, $cond131 = 0, $cond29 = 0, $cond88 = 0, $conditional$addr = 0, $conv140 = 0, $conv147 = 0, $conv43 = 0, $conv8 = 0, $double_step_size_threshold = 0, $gain_Q16$addr = 0, $ind$addr = 0, $k = 0, $nb_subfr$addr = 0, $prev_ind$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $ind$addr = sp + 24 | 0;
 $gain_Q16$addr = sp + 20 | 0;
 $prev_ind$addr = sp + 16 | 0;
 $conditional$addr = sp + 12 | 0;
 $nb_subfr$addr = sp + 8 | 0;
 $k = sp + 4 | 0;
 $double_step_size_threshold = sp;
 HEAP32[$ind$addr >> 2] = $ind;
 HEAP32[$gain_Q16$addr >> 2] = $gain_Q16;
 HEAP32[$prev_ind$addr >> 2] = $prev_ind;
 HEAP32[$conditional$addr >> 2] = $conditional;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  _silk_lin2log(HEAP32[(HEAP32[$gain_Q16$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) | 0;
  $conv8 = 0 + ((((_silk_lin2log(HEAP32[(HEAP32[$gain_Q16$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) | 0) - 2090 & 65535) << 16 >> 16) * 2251 >> 16) & 255;
  HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] = $conv8;
  if ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) < (HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0)) {
   $arrayidx15 = (HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) | 0;
   HEAP8[$arrayidx15 >> 0] = (HEAP8[$arrayidx15 >> 0] | 0) + 1 << 24 >> 24;
  }
  if ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) > 63) $cond29 = 63; else if ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) < 0) $cond29 = 0; else $cond29 = HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0;
  HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] = $cond29;
  if ((HEAP32[$k >> 2] | 0) == 0 & (HEAP32[$conditional$addr >> 2] | 0) == 0) {
   $conv43 = HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0;
   do if (((HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0) + -4 | 0) > 63) {
    if (($conv43 | 0) > ((HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0) + -4 | 0)) {
     $cond88 = (HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0) + -4 | 0;
     break;
    }
    if ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) < 63) $cond88 = 63; else $cond88 = HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0;
   } else if (($conv43 | 0) > 63) $cond88 = 63; else if ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) < ((HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0) + -4 | 0)) {
    $cond88 = (HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0) + -4 | 0;
    break;
   } else {
    $cond88 = HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0;
    break;
   } while (0);
   HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] = $cond88;
   HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] = HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0;
  } else {
   HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] = (HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) - (HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0);
   HEAP32[$double_step_size_threshold >> 2] = 8 + (HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0);
   if ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) > (HEAP32[$double_step_size_threshold >> 2] | 0)) HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] = (HEAP32[$double_step_size_threshold >> 2] | 0) + ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) - (HEAP32[$double_step_size_threshold >> 2] | 0) + 1 >> 1);
   if ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) > 36) $cond131 = 36; else if ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) < -4) $cond131 = -4; else $cond131 = HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0;
   HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] = $cond131;
   $conv140 = HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0;
   if ((HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) > (HEAP32[$double_step_size_threshold >> 2] | 0)) {
    $101 = HEAP32[$prev_ind$addr >> 2] | 0;
    HEAP8[$101 >> 0] = (HEAP8[$101 >> 0] | 0) + (($conv140 << 1) - (HEAP32[$double_step_size_threshold >> 2] | 0));
    $conv147 = (_silk_min_int_407(HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0, 63) | 0) & 255;
    HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] = $conv147;
   } else {
    $106 = HEAP32[$prev_ind$addr >> 2] | 0;
    HEAP8[$106 >> 0] = (HEAP8[$106 >> 0] | 0) + $conv140;
   }
   $arrayidx155 = (HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) | 0;
   HEAP8[$arrayidx155 >> 0] = (HEAP8[$arrayidx155 >> 0] | 0) + 4;
  }
  $call170 = _silk_log2lin(_silk_min_32(((HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] << 16 >> 16) * 29 | 0) + ((HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] << 16 >> 16) * 7281 >> 16) + 2090 | 0, 3967) | 0) | 0;
  HEAP32[(HEAP32[$gain_Q16$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = $call170;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_find_pitch_lags_FLP($psEnc, $psEncCtrl, $res, $x, $arch) {
 $psEnc = $psEnc | 0;
 $psEncCtrl = $psEncCtrl | 0;
 $res = $res | 0;
 $x = $x | 0;
 $arch = $arch | 0;
 var $A = 0, $Wsig = 0, $Wsig_ptr = 0, $arch$addr = 0, $auto_corr = 0, $buf_len = 0, $cmp102 = 0, $pitchL112 = 0, $psEnc$addr = 0, $psEncCtrl$addr = 0, $refl_coef = 0, $res$addr = 0, $res_nrg = 0, $thrhld = 0, $x$addr = 0, $x_buf = 0, $x_buf_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1792 | 0;
 $psEnc$addr = sp + 1776 | 0;
 $psEncCtrl$addr = sp + 1772 | 0;
 $res$addr = sp + 1768 | 0;
 $x$addr = sp + 1764 | 0;
 $arch$addr = sp + 1760 | 0;
 $buf_len = sp + 1756 | 0;
 $thrhld = sp + 1752 | 0;
 $res_nrg = sp + 1748 | 0;
 $x_buf_ptr = sp + 1744 | 0;
 $x_buf = sp + 1740 | 0;
 $auto_corr = sp + 1672 | 0;
 $A = sp + 1608 | 0;
 $refl_coef = sp + 1544 | 0;
 $Wsig = sp + 8 | 0;
 $Wsig_ptr = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$psEncCtrl$addr >> 2] = $psEncCtrl;
 HEAP32[$res$addr >> 2] = $res;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$buf_len >> 2] = (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4592 >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4580 >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4588 >> 2] | 0);
 HEAP32[$x_buf >> 2] = (HEAP32[$x$addr >> 2] | 0) + (0 - (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4588 >> 2] | 0) << 2);
 HEAP32[$x_buf_ptr >> 2] = (HEAP32[$x_buf >> 2] | 0) + (HEAP32[$buf_len >> 2] << 2) + (0 - (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4544 >> 2] | 0) << 2);
 HEAP32[$Wsig_ptr >> 2] = $Wsig;
 _silk_apply_sine_window_FLP(HEAP32[$Wsig_ptr >> 2] | 0, HEAP32[$x_buf_ptr >> 2] | 0, 1, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4592 >> 2] | 0);
 HEAP32[$Wsig_ptr >> 2] = (HEAP32[$Wsig_ptr >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4592 >> 2] << 2);
 HEAP32[$x_buf_ptr >> 2] = (HEAP32[$x_buf_ptr >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4592 >> 2] << 2);
 _memcpy(HEAP32[$Wsig_ptr >> 2] | 0, HEAP32[$x_buf_ptr >> 2] | 0, (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4544 >> 2] | 0) - (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4592 >> 2] << 1) << 2 | 0) | 0;
 HEAP32[$Wsig_ptr >> 2] = (HEAP32[$Wsig_ptr >> 2] | 0) + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4544 >> 2] | 0) - (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4592 >> 2] << 1) << 2);
 HEAP32[$x_buf_ptr >> 2] = (HEAP32[$x_buf_ptr >> 2] | 0) + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4544 >> 2] | 0) - (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4592 >> 2] << 1) << 2);
 _silk_apply_sine_window_FLP(HEAP32[$Wsig_ptr >> 2] | 0, HEAP32[$x_buf_ptr >> 2] | 0, 2, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4592 >> 2] | 0);
 _silk_autocorrelation_FLP($auto_corr, $Wsig, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4544 >> 2] | 0, (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4644 >> 2] | 0) + 1 | 0);
 HEAPF32[$auto_corr >> 2] = +HEAPF32[$auto_corr >> 2] + (+HEAPF32[$auto_corr >> 2] * 1.0000000474974513e-03 + 1.0);
 HEAPF32[$res_nrg >> 2] = +_silk_schur_FLP($refl_coef, $auto_corr, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4644 >> 2] | 0);
 HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 704 >> 2] = +HEAPF32[$auto_corr >> 2] / (+HEAPF32[$res_nrg >> 2] > 1.0 ? +HEAPF32[$res_nrg >> 2] : 1.0);
 _silk_k2a_FLP($A, $refl_coef, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4644 >> 2] | 0);
 _silk_bwexpander_FLP($A, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4644 >> 2] | 0, .9900000095367432);
 _silk_LPC_analysis_filter_FLP(HEAP32[$res$addr >> 2] | 0, $A, HEAP32[$x_buf >> 2] | 0, HEAP32[$buf_len >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4644 >> 2] | 0);
 if (HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0) if (!(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4660 >> 2] | 0)) {
  HEAPF32[$thrhld >> 2] = .6000000238418579;
  HEAPF32[$thrhld >> 2] = +HEAPF32[$thrhld >> 2] - +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4644 >> 2] | 0) * .004000000189989805;
  HEAPF32[$thrhld >> 2] = +HEAPF32[$thrhld >> 2] - +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4528 >> 2] | 0) * .10000000149011612 * .00390625;
  HEAPF32[$thrhld >> 2] = +HEAPF32[$thrhld >> 2] - +(HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4537 >> 0] >> 1 | 0) * .15000000596046448;
  HEAPF32[$thrhld >> 2] = +HEAPF32[$thrhld >> 2] - +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4708 >> 2] | 0) * .10000000149011612 * .000030517578125;
  $cmp102 = (_silk_pitch_analysis_core_FLP(HEAP32[$res$addr >> 2] | 0, (HEAP32[$psEncCtrl$addr >> 2] | 0) + 228 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 26 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 28 | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 10056 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4540 >> 2] | 0, +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4648 >> 2] | 0) / 65536.0, +HEAPF32[$thrhld >> 2], HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4640 >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0, HEAP32[$arch$addr >> 2] | 0) | 0) == 0;
  HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] = $cmp102 ? 2 : 1;
  STACKTOP = sp;
  return;
 }
 $pitchL112 = (HEAP32[$psEncCtrl$addr >> 2] | 0) + 228 | 0;
 HEAP32[$pitchL112 >> 2] = 0;
 HEAP32[$pitchL112 + 4 >> 2] = 0;
 HEAP32[$pitchL112 + 8 >> 2] = 0;
 HEAP32[$pitchL112 + 12 >> 2] = 0;
 HEAP16[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 26 >> 1] = 0;
 HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 28 >> 0] = 0;
 HEAPF32[(HEAP32[$psEnc$addr >> 2] | 0) + 10056 >> 2] = 0.0;
 STACKTOP = sp;
 return;
}

function _silk_LP_interpolate_filter_taps($B_Q28, $A_Q28, $ind, $fac_Q16) {
 $B_Q28 = $B_Q28 | 0;
 $A_Q28 = $A_Q28 | 0;
 $ind = $ind | 0;
 $fac_Q16 = $fac_Q16 | 0;
 var $87 = 0, $89 = 0, $91 = 0, $92 = 0, $A_Q28$addr = 0, $B_Q28$addr = 0, $add125 = 0, $add23 = 0, $add53 = 0, $add89 = 0, $arrayidx131 = 0, $arrayidx132 = 0, $cmp3 = 0, $fac_Q16$addr = 0, $ind$addr = 0, $mul = 0, $mul111 = 0, $mul40 = 0, $mul75 = 0, $na = 0, $nb = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $B_Q28$addr = sp + 20 | 0;
 $A_Q28$addr = sp + 16 | 0;
 $ind$addr = sp + 12 | 0;
 $fac_Q16$addr = sp + 8 | 0;
 $nb = sp + 4 | 0;
 $na = sp;
 HEAP32[$B_Q28$addr >> 2] = $B_Q28;
 HEAP32[$A_Q28$addr >> 2] = $A_Q28;
 HEAP32[$ind$addr >> 2] = $ind;
 HEAP32[$fac_Q16$addr >> 2] = $fac_Q16;
 if ((HEAP32[$ind$addr >> 2] | 0) >= 4) {
  $91 = HEAP32[$B_Q28$addr >> 2] | 0;
  HEAP32[$91 >> 2] = HEAP32[3814];
  HEAP32[$91 + 4 >> 2] = HEAP32[3815];
  HEAP32[$91 + 8 >> 2] = HEAP32[3816];
  $92 = HEAP32[$A_Q28$addr >> 2] | 0;
  HEAP32[$92 >> 2] = HEAP32[3825];
  HEAP32[$92 + 4 >> 2] = HEAP32[3826];
  STACKTOP = sp;
  return;
 }
 if ((HEAP32[$fac_Q16$addr >> 2] | 0) <= 0) {
  $87 = HEAP32[$B_Q28$addr >> 2] | 0;
  $arrayidx131 = 15208 + ((HEAP32[$ind$addr >> 2] | 0) * 12 | 0) | 0;
  HEAP32[$87 >> 2] = HEAP32[$arrayidx131 >> 2];
  HEAP32[$87 + 4 >> 2] = HEAP32[$arrayidx131 + 4 >> 2];
  HEAP32[$87 + 8 >> 2] = HEAP32[$arrayidx131 + 8 >> 2];
  $89 = HEAP32[$A_Q28$addr >> 2] | 0;
  $arrayidx132 = 15268 + (HEAP32[$ind$addr >> 2] << 3) | 0;
  HEAP32[$89 >> 2] = HEAP32[$arrayidx132 >> 2];
  HEAP32[$89 + 4 >> 2] = HEAP32[$arrayidx132 + 4 >> 2];
  STACKTOP = sp;
  return;
 }
 $cmp3 = (HEAP32[$fac_Q16$addr >> 2] | 0) < 32768;
 HEAP32[$nb >> 2] = 0;
 if ($cmp3) {
  while (1) {
   if ((HEAP32[$nb >> 2] | 0) >= 3) break;
   $mul = Math_imul((HEAP32[15208 + (((HEAP32[$ind$addr >> 2] | 0) + 1 | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) - (HEAP32[15208 + ((HEAP32[$ind$addr >> 2] | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) >> 16, (HEAP32[$fac_Q16$addr >> 2] & 65535) << 16 >> 16) | 0;
   $add23 = (HEAP32[15208 + ((HEAP32[$ind$addr >> 2] | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) + ($mul + ((Math_imul((HEAP32[15208 + (((HEAP32[$ind$addr >> 2] | 0) + 1 | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) - (HEAP32[15208 + ((HEAP32[$ind$addr >> 2] | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) & 65535, (HEAP32[$fac_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
   HEAP32[(HEAP32[$B_Q28$addr >> 2] | 0) + (HEAP32[$nb >> 2] << 2) >> 2] = $add23;
   HEAP32[$nb >> 2] = (HEAP32[$nb >> 2] | 0) + 1;
  }
  HEAP32[$na >> 2] = 0;
  while (1) {
   if ((HEAP32[$na >> 2] | 0) >= 2) break;
   $mul40 = Math_imul((HEAP32[15268 + ((HEAP32[$ind$addr >> 2] | 0) + 1 << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) - (HEAP32[15268 + (HEAP32[$ind$addr >> 2] << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) >> 16, (HEAP32[$fac_Q16$addr >> 2] & 65535) << 16 >> 16) | 0;
   $add53 = (HEAP32[15268 + (HEAP32[$ind$addr >> 2] << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) + ($mul40 + ((Math_imul((HEAP32[15268 + ((HEAP32[$ind$addr >> 2] | 0) + 1 << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) - (HEAP32[15268 + (HEAP32[$ind$addr >> 2] << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) & 65535, (HEAP32[$fac_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
   HEAP32[(HEAP32[$A_Q28$addr >> 2] | 0) + (HEAP32[$na >> 2] << 2) >> 2] = $add53;
   HEAP32[$na >> 2] = (HEAP32[$na >> 2] | 0) + 1;
  }
  STACKTOP = sp;
  return;
 } else {
  while (1) {
   if ((HEAP32[$nb >> 2] | 0) >= 3) break;
   $mul75 = Math_imul((HEAP32[15208 + (((HEAP32[$ind$addr >> 2] | 0) + 1 | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) - (HEAP32[15208 + ((HEAP32[$ind$addr >> 2] | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) >> 16, ((HEAP32[$fac_Q16$addr >> 2] | 0) - 65536 & 65535) << 16 >> 16) | 0;
   $add89 = (HEAP32[15208 + (((HEAP32[$ind$addr >> 2] | 0) + 1 | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) + ($mul75 + ((Math_imul((HEAP32[15208 + (((HEAP32[$ind$addr >> 2] | 0) + 1 | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) - (HEAP32[15208 + ((HEAP32[$ind$addr >> 2] | 0) * 12 | 0) + (HEAP32[$nb >> 2] << 2) >> 2] | 0) & 65535, ((HEAP32[$fac_Q16$addr >> 2] | 0) - 65536 & 65535) << 16 >> 16) | 0) >> 16)) | 0;
   HEAP32[(HEAP32[$B_Q28$addr >> 2] | 0) + (HEAP32[$nb >> 2] << 2) >> 2] = $add89;
   HEAP32[$nb >> 2] = (HEAP32[$nb >> 2] | 0) + 1;
  }
  HEAP32[$na >> 2] = 0;
  while (1) {
   if ((HEAP32[$na >> 2] | 0) >= 2) break;
   $mul111 = Math_imul((HEAP32[15268 + ((HEAP32[$ind$addr >> 2] | 0) + 1 << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) - (HEAP32[15268 + (HEAP32[$ind$addr >> 2] << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) >> 16, ((HEAP32[$fac_Q16$addr >> 2] | 0) - 65536 & 65535) << 16 >> 16) | 0;
   $add125 = (HEAP32[15268 + ((HEAP32[$ind$addr >> 2] | 0) + 1 << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) + ($mul111 + ((Math_imul((HEAP32[15268 + ((HEAP32[$ind$addr >> 2] | 0) + 1 << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) - (HEAP32[15268 + (HEAP32[$ind$addr >> 2] << 3) + (HEAP32[$na >> 2] << 2) >> 2] | 0) & 65535, ((HEAP32[$fac_Q16$addr >> 2] | 0) - 65536 & 65535) << 16 >> 16) | 0) >> 16)) | 0;
   HEAP32[(HEAP32[$A_Q28$addr >> 2] | 0) + (HEAP32[$na >> 2] << 2) >> 2] = $add125;
   HEAP32[$na >> 2] = (HEAP32[$na >> 2] | 0) + 1;
  }
  STACKTOP = sp;
  return;
 }
}

function _pitch_search($x_lp, $y, $len, $max_pitch, $pitch, $arch) {
 $x_lp = $x_lp | 0;
 $y = $y | 0;
 $len = $len | 0;
 $max_pitch = $max_pitch | 0;
 $pitch = $pitch | 0;
 $arch = $arch | 0;
 var $62 = 0, $63 = 0, $64 = 0, $65 = 0, $a = 0, $arch$addr = 0, $b = 0, $best_pitch = 0, $c = 0, $i = 0, $j = 0, $lag = 0, $len$addr = 0, $max_pitch$addr = 0, $mul77 = 0, $offset = 0, $pitch$addr = 0, $saved_stack = 0, $shr = 0, $sub78 = 0, $sum = 0, $vla = 0, $vla2 = 0, $vla4 = 0, $x_lp$addr = 0, $y$addr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $x_lp$addr = sp + 64 | 0;
 $y$addr = sp + 60 | 0;
 $len$addr = sp + 56 | 0;
 $max_pitch$addr = sp + 52 | 0;
 $pitch$addr = sp + 48 | 0;
 $arch$addr = sp + 44 | 0;
 $i = sp + 40 | 0;
 $j = sp + 36 | 0;
 $lag = sp + 32 | 0;
 $best_pitch = sp + 24 | 0;
 $offset = sp + 20 | 0;
 $saved_stack = sp + 16 | 0;
 $sum = sp + 12 | 0;
 $a = sp + 8 | 0;
 $b = sp + 4 | 0;
 $c = sp;
 HEAP32[$x_lp$addr >> 2] = $x_lp;
 HEAP32[$y$addr >> 2] = $y;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$max_pitch$addr >> 2] = $max_pitch;
 HEAP32[$pitch$addr >> 2] = $pitch;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$best_pitch >> 2] = 0;
 HEAP32[$best_pitch + 4 >> 2] = 0;
 HEAP32[$lag >> 2] = (HEAP32[$len$addr >> 2] | 0) + (HEAP32[$max_pitch$addr >> 2] | 0);
 $shr = HEAP32[$len$addr >> 2] >> 2;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($shr << 2) | 0) + 15 & -16) | 0;
 $vla2 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$lag >> 2] >> 2 << 2) | 0) + 15 & -16) | 0;
 $vla4 = STACKTOP;
 STACKTOP = STACKTOP + ((1 * (HEAP32[$max_pitch$addr >> 2] >> 1 << 2) | 0) + 15 & -16) | 0;
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$len$addr >> 2] >> 2 | 0)) break;
  HEAPF32[$vla + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$x_lp$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1 << 2) >> 2];
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$lag >> 2] >> 2 | 0)) break;
  HEAPF32[$vla2 + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1 << 2) >> 2];
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 _celt_pitch_xcorr_c($vla, $vla2, $vla4, HEAP32[$len$addr >> 2] >> 2, HEAP32[$max_pitch$addr >> 2] >> 2, HEAP32[$arch$addr >> 2] | 0);
 _find_best_pitch($vla4, $vla2, HEAP32[$len$addr >> 2] >> 2, HEAP32[$max_pitch$addr >> 2] >> 2, $best_pitch);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$max_pitch$addr >> 2] >> 1 | 0)) break;
  HEAPF32[$vla4 + (HEAP32[$i >> 2] << 2) >> 2] = 0.0;
  if ((Math_abs((HEAP32[$i >> 2] | 0) - (HEAP32[$best_pitch >> 2] << 1) | 0) | 0) > 2) {
   if ((Math_abs((HEAP32[$i >> 2] | 0) - (HEAP32[$best_pitch + 4 >> 2] << 1) | 0) | 0) <= 2) label = 11;
  } else label = 11;
  if ((label | 0) == 11) {
   label = 0;
   HEAPF32[$sum >> 2] = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$x_lp$addr >> 2] | 0, (HEAP32[$y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0, HEAP32[$len$addr >> 2] >> 1);
   HEAPF32[$vla4 + (HEAP32[$i >> 2] << 2) >> 2] = -1.0 > +HEAPF32[$sum >> 2] ? -1.0 : +HEAPF32[$sum >> 2];
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _find_best_pitch($vla4, HEAP32[$y$addr >> 2] | 0, HEAP32[$len$addr >> 2] >> 1, HEAP32[$max_pitch$addr >> 2] >> 1, $best_pitch);
 if ((HEAP32[$best_pitch >> 2] | 0) > 0) if ((HEAP32[$best_pitch >> 2] | 0) < ((HEAP32[$max_pitch$addr >> 2] >> 1) - 1 | 0)) {
  HEAPF32[$a >> 2] = +HEAPF32[$vla4 + ((HEAP32[$best_pitch >> 2] | 0) - 1 << 2) >> 2];
  HEAPF32[$b >> 2] = +HEAPF32[$vla4 + (HEAP32[$best_pitch >> 2] << 2) >> 2];
  HEAPF32[$c >> 2] = +HEAPF32[$vla4 + ((HEAP32[$best_pitch >> 2] | 0) + 1 << 2) >> 2];
  if (+HEAPF32[$c >> 2] - +HEAPF32[$a >> 2] > (+HEAPF32[$b >> 2] - +HEAPF32[$a >> 2]) * .699999988079071) {
   HEAP32[$offset >> 2] = 1;
   $62 = HEAP32[$best_pitch >> 2] | 0;
   $mul77 = $62 << 1;
   $63 = HEAP32[$offset >> 2] | 0;
   $sub78 = $mul77 - $63 | 0;
   $64 = HEAP32[$pitch$addr >> 2] | 0;
   HEAP32[$64 >> 2] = $sub78;
   $65 = HEAP32[$saved_stack >> 2] | 0;
   _llvm_stackrestore($65 | 0);
   STACKTOP = sp;
   return;
  }
  if (+HEAPF32[$a >> 2] - +HEAPF32[$c >> 2] > (+HEAPF32[$b >> 2] - +HEAPF32[$c >> 2]) * .699999988079071) {
   HEAP32[$offset >> 2] = -1;
   $62 = HEAP32[$best_pitch >> 2] | 0;
   $mul77 = $62 << 1;
   $63 = HEAP32[$offset >> 2] | 0;
   $sub78 = $mul77 - $63 | 0;
   $64 = HEAP32[$pitch$addr >> 2] | 0;
   HEAP32[$64 >> 2] = $sub78;
   $65 = HEAP32[$saved_stack >> 2] | 0;
   _llvm_stackrestore($65 | 0);
   STACKTOP = sp;
   return;
  } else {
   HEAP32[$offset >> 2] = 0;
   $62 = HEAP32[$best_pitch >> 2] | 0;
   $mul77 = $62 << 1;
   $63 = HEAP32[$offset >> 2] | 0;
   $sub78 = $mul77 - $63 | 0;
   $64 = HEAP32[$pitch$addr >> 2] | 0;
   HEAP32[$64 >> 2] = $sub78;
   $65 = HEAP32[$saved_stack >> 2] | 0;
   _llvm_stackrestore($65 | 0);
   STACKTOP = sp;
   return;
  }
 }
 HEAP32[$offset >> 2] = 0;
 $62 = HEAP32[$best_pitch >> 2] | 0;
 $mul77 = $62 << 1;
 $63 = HEAP32[$offset >> 2] | 0;
 $sub78 = $mul77 - $63 | 0;
 $64 = HEAP32[$pitch$addr >> 2] | 0;
 HEAP32[$64 >> 2] = $sub78;
 $65 = HEAP32[$saved_stack >> 2] | 0;
 _llvm_stackrestore($65 | 0);
 STACKTOP = sp;
 return;
}

function _silk_control_audio_bandwidth($psEncC, $encControl) {
 $psEncC = $psEncC | 0;
 $encControl = $encControl | 0;
 var $46 = 0, $69 = 0, $8 = 0, $86 = 0, $cond25 = 0, $cond33 = 0, $encControl$addr = 0, $fs_Hz = 0, $fs_kHz = 0, $maxBits118 = 0, $maxBits77 = 0, $psEncC$addr = 0, $sLP101 = 0, $sLP58 = 0, $sLP63 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psEncC$addr = sp + 12 | 0;
 $encControl$addr = sp + 8 | 0;
 $fs_kHz = sp + 4 | 0;
 $fs_Hz = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$encControl$addr >> 2] = $encControl;
 HEAP32[$fs_kHz >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2];
 HEAP32[$fs_Hz >> 2] = ((HEAP32[$fs_kHz >> 2] & 65535) << 16 >> 16) * 1e3;
 if (!(HEAP32[$fs_Hz >> 2] | 0)) {
  $8 = HEAP32[$psEncC$addr >> 2] | 0;
  HEAP32[$fs_Hz >> 2] = HEAP32[((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4568 >> 2] | 0) < (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4552 >> 2] | 0) ? $8 + 4568 | 0 : $8 + 4552 | 0) >> 2];
  HEAP32[$fs_kHz >> 2] = (HEAP32[$fs_Hz >> 2] | 0) / 1e3 | 0;
  $86 = HEAP32[$fs_kHz >> 2] | 0;
  STACKTOP = sp;
  return $86 | 0;
 }
 if ((HEAP32[$fs_Hz >> 2] | 0) <= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4552 >> 2] | 0)) if ((HEAP32[$fs_Hz >> 2] | 0) <= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4560 >> 2] | 0)) if ((HEAP32[$fs_Hz >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4564 >> 2] | 0)) {
  if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 16 + 8 >> 2] | 0) >= 256) HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 16 + 12 >> 2] = 0;
  if (!(HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4532 >> 2] | 0)) if (!(HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 64 >> 2] | 0)) {
   $86 = HEAP32[$fs_kHz >> 2] | 0;
   STACKTOP = sp;
   return $86 | 0;
  }
  $46 = HEAP32[$psEncC$addr >> 2] | 0;
  if ((((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] & 65535) << 16 >> 16) * 1e3 | 0) > (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4568 >> 2] | 0)) {
   if (!(HEAP32[$46 + 16 + 12 >> 2] | 0)) {
    HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 16 + 8 >> 2] = 256;
    $sLP58 = (HEAP32[$psEncC$addr >> 2] | 0) + 16 | 0;
    HEAP32[$sLP58 >> 2] = 0;
    HEAP32[$sLP58 + 4 >> 2] = 0;
   }
   $sLP63 = (HEAP32[$psEncC$addr >> 2] | 0) + 16 | 0;
   if (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 64 >> 2] | 0) {
    HEAP32[$sLP63 + 12 >> 2] = 0;
    HEAP32[$fs_kHz >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) == 16 ? 12 : 8;
    $86 = HEAP32[$fs_kHz >> 2] | 0;
    STACKTOP = sp;
    return $86 | 0;
   }
   if ((HEAP32[$sLP63 + 8 >> 2] | 0) <= 0) {
    HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 88 >> 2] = 1;
    $maxBits77 = (HEAP32[$encControl$addr >> 2] | 0) + 56 | 0;
    HEAP32[$maxBits77 >> 2] = (HEAP32[$maxBits77 >> 2] | 0) - (((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 56 >> 2] | 0) * 5 | 0) / ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) + 5 | 0) | 0);
    $86 = HEAP32[$fs_kHz >> 2] | 0;
    STACKTOP = sp;
    return $86 | 0;
   } else {
    HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 16 + 12 >> 2] = -2;
    $86 = HEAP32[$fs_kHz >> 2] | 0;
    STACKTOP = sp;
    return $86 | 0;
   }
  }
  if ((((HEAP32[$46 + 4572 >> 2] & 65535) << 16 >> 16) * 1e3 | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4568 >> 2] | 0)) {
   if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 16 + 12 >> 2] | 0) >= 0) {
    $86 = HEAP32[$fs_kHz >> 2] | 0;
    STACKTOP = sp;
    return $86 | 0;
   }
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 16 + 12 >> 2] = 1;
   $86 = HEAP32[$fs_kHz >> 2] | 0;
   STACKTOP = sp;
   return $86 | 0;
  }
  $69 = HEAP32[$psEncC$addr >> 2] | 0;
  if (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 64 >> 2] | 0) {
   HEAP32[$fs_kHz >> 2] = (HEAP32[$69 + 4572 >> 2] | 0) == 8 ? 12 : 16;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 16 + 8 >> 2] = 0;
   $sLP101 = (HEAP32[$psEncC$addr >> 2] | 0) + 16 | 0;
   HEAP32[$sLP101 >> 2] = 0;
   HEAP32[$sLP101 + 4 >> 2] = 0;
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 16 + 12 >> 2] = 1;
   $86 = HEAP32[$fs_kHz >> 2] | 0;
   STACKTOP = sp;
   return $86 | 0;
  }
  if (!(HEAP32[$69 + 16 + 12 >> 2] | 0)) {
   HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 88 >> 2] = 1;
   $maxBits118 = (HEAP32[$encControl$addr >> 2] | 0) + 56 | 0;
   HEAP32[$maxBits118 >> 2] = (HEAP32[$maxBits118 >> 2] | 0) - (((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 56 >> 2] | 0) * 5 | 0) / ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) + 5 | 0) | 0);
   $86 = HEAP32[$fs_kHz >> 2] | 0;
   STACKTOP = sp;
   return $86 | 0;
  } else {
   HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 16 + 12 >> 2] = 1;
   $86 = HEAP32[$fs_kHz >> 2] | 0;
   STACKTOP = sp;
   return $86 | 0;
  }
 }
 HEAP32[$fs_Hz >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4552 >> 2];
 if ((HEAP32[$fs_Hz >> 2] | 0) < (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4560 >> 2] | 0)) $cond25 = HEAP32[$fs_Hz >> 2] | 0; else $cond25 = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4560 >> 2] | 0;
 HEAP32[$fs_Hz >> 2] = $cond25;
 if ((HEAP32[$fs_Hz >> 2] | 0) > (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4564 >> 2] | 0)) $cond33 = HEAP32[$fs_Hz >> 2] | 0; else $cond33 = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4564 >> 2] | 0;
 HEAP32[$fs_Hz >> 2] = $cond33;
 HEAP32[$fs_kHz >> 2] = (HEAP32[$fs_Hz >> 2] | 0) / 1e3 | 0;
 $86 = HEAP32[$fs_kHz >> 2] | 0;
 STACKTOP = sp;
 return $86 | 0;
}

function _patch_transient_decision($newE, $oldE, $nbEBands, $start, $end, $C) {
 $newE = $newE | 0;
 $oldE = $oldE | 0;
 $nbEBands = $nbEBands | 0;
 $start = $start | 0;
 $end = $end | 0;
 $C = $C | 0;
 var $25 = 0, $3 = 0.0, $42 = 0, $55 = 0, $67 = 0, $C$addr = 0, $c = 0, $cond = 0.0, $cond103 = 0.0, $cond110 = 0.0, $cond117 = 0.0, $cond60 = 0.0, $cond81 = 0.0, $end$addr = 0, $i = 0, $inc122 = 0, $mean_diff = 0, $nbEBands$addr = 0, $newE$addr = 0, $oldE$addr = 0, $spread_old = 0, $start$addr = 0, $x1 = 0, $x2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 $newE$addr = sp + 144 | 0;
 $oldE$addr = sp + 140 | 0;
 $nbEBands$addr = sp + 136 | 0;
 $start$addr = sp + 132 | 0;
 $end$addr = sp + 128 | 0;
 $C$addr = sp + 124 | 0;
 $i = sp + 120 | 0;
 $c = sp + 116 | 0;
 $mean_diff = sp + 112 | 0;
 $spread_old = sp + 8 | 0;
 $x1 = sp + 4 | 0;
 $x2 = sp;
 HEAP32[$newE$addr >> 2] = $newE;
 HEAP32[$oldE$addr >> 2] = $oldE;
 HEAP32[$nbEBands$addr >> 2] = $nbEBands;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$C$addr >> 2] = $C;
 HEAPF32[$mean_diff >> 2] = 0.0;
 $3 = +HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + (HEAP32[$start$addr >> 2] << 2) >> 2];
 L1 : do if ((HEAP32[$C$addr >> 2] | 0) == 1) {
  HEAPF32[$spread_old + (HEAP32[$start$addr >> 2] << 2) >> 2] = $3;
  HEAP32[$i >> 2] = (HEAP32[$start$addr >> 2] | 0) + 1;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break L1;
   if (+HEAPF32[$spread_old + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] - 1.0 > +HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $cond = +HEAPF32[$spread_old + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] - 1.0; else $cond = +HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$spread_old + (HEAP32[$i >> 2] << 2) >> 2] = $cond;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } else {
  $25 = HEAP32[$start$addr >> 2] | 0;
  HEAPF32[$spread_old + (HEAP32[$start$addr >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + (($3 > +HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + ((HEAP32[$start$addr >> 2] | 0) + (HEAP32[$nbEBands$addr >> 2] | 0) << 2) >> 2] ? $25 : $25 + (HEAP32[$nbEBands$addr >> 2] | 0) | 0) << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$start$addr >> 2] | 0) + 1;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break L1;
   $42 = HEAP32[$i >> 2] | 0;
   if (+HEAPF32[$spread_old + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] - 1.0 > +HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + ((+HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (HEAP32[$nbEBands$addr >> 2] | 0) << 2) >> 2] ? $42 : $42 + (HEAP32[$nbEBands$addr >> 2] | 0) | 0) << 2) >> 2]) $cond60 = +HEAPF32[$spread_old + ((HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] - 1.0; else {
    $55 = HEAP32[$i >> 2] | 0;
    $cond60 = +HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + ((+HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[(HEAP32[$oldE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (HEAP32[$nbEBands$addr >> 2] | 0) << 2) >> 2] ? $55 : $55 + (HEAP32[$nbEBands$addr >> 2] | 0) | 0) << 2) >> 2];
   }
   HEAPF32[$spread_old + (HEAP32[$i >> 2] << 2) >> 2] = $cond60;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$i >> 2] = (HEAP32[$end$addr >> 2] | 0) - 2;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < (HEAP32[$start$addr >> 2] | 0)) break;
  $67 = HEAP32[$i >> 2] | 0;
  if (+HEAPF32[$spread_old + (HEAP32[$i >> 2] << 2) >> 2] > +HEAPF32[$spread_old + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] - 1.0) $cond81 = +HEAPF32[$spread_old + ($67 << 2) >> 2]; else $cond81 = +HEAPF32[$spread_old + ($67 + 1 << 2) >> 2] - 1.0;
  HEAPF32[$spread_old + (HEAP32[$i >> 2] << 2) >> 2] = $cond81;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 2 > (HEAP32[$start$addr >> 2] | 0) ? 2 : HEAP32[$start$addr >> 2] | 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$end$addr >> 2] | 0) - 1 | 0)) break;
   if (0.0 > +HEAPF32[(HEAP32[$newE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0) << 2) >> 2]) $cond103 = 0.0; else $cond103 = +HEAPF32[(HEAP32[$newE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$nbEBands$addr >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[$x1 >> 2] = $cond103;
   if (0.0 > +HEAPF32[$spread_old + (HEAP32[$i >> 2] << 2) >> 2]) $cond110 = 0.0; else $cond110 = +HEAPF32[$spread_old + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$x2 >> 2] = $cond110;
   if (0.0 > +HEAPF32[$x1 >> 2] - +HEAPF32[$x2 >> 2]) $cond117 = 0.0; else $cond117 = +HEAPF32[$x1 >> 2] - +HEAPF32[$x2 >> 2];
   HEAPF32[$mean_diff >> 2] = +HEAPF32[$mean_diff >> 2] + $cond117;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc122 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc122;
 } while (($inc122 | 0) < (HEAP32[$C$addr >> 2] | 0));
 HEAPF32[$mean_diff >> 2] = +HEAPF32[$mean_diff >> 2] / +(Math_imul(HEAP32[$C$addr >> 2] | 0, (HEAP32[$end$addr >> 2] | 0) - 1 - (2 > (HEAP32[$start$addr >> 2] | 0) ? 2 : HEAP32[$start$addr >> 2] | 0) | 0) | 0);
 STACKTOP = sp;
 return +HEAPF32[$mean_diff >> 2] > 1.0 | 0;
}

function _silk_resampler_down2_3($S, $out, $in, $inLen) {
 $S = $S | 0;
 $out = $out | 0;
 $in = $in | 0;
 $inLen = $inLen | 0;
 var $0 = 0, $38 = 0, $69 = 0, $78 = 0, $S$addr = 0, $arrayidx137 = 0, $arrayidx139 = 0, $buf = 0, $buf_ptr = 0, $cond129 = 0, $cond64 = 0, $counter = 0, $in$addr = 0, $inLen$addr = 0, $mul = 0, $mul101 = 0, $mul14 = 0, $mul25 = 0, $mul36 = 0, $mul69 = 0, $mul79 = 0, $mul90 = 0, $nSamplesIn = 0, $out$addr = 0, $res_Q6 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1968 | 0;
 $S$addr = sp + 1964 | 0;
 $out$addr = sp + 1960 | 0;
 $in$addr = sp + 1956 | 0;
 $inLen$addr = sp + 1952 | 0;
 $nSamplesIn = sp + 1948 | 0;
 $counter = sp + 1944 | 0;
 $res_Q6 = sp + 1940 | 0;
 $buf_ptr = sp + 1936 | 0;
 $buf = sp;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$inLen$addr >> 2] = $inLen;
 $0 = HEAP32[$S$addr >> 2] | 0;
 HEAP32[$buf >> 2] = HEAP32[$0 >> 2];
 HEAP32[$buf + 4 >> 2] = HEAP32[$0 + 4 >> 2];
 HEAP32[$buf + 8 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$buf + 12 >> 2] = HEAP32[$0 + 12 >> 2];
 while (1) {
  HEAP32[$nSamplesIn >> 2] = (HEAP32[$inLen$addr >> 2] | 0) < 480 ? HEAP32[$inLen$addr >> 2] | 0 : 480;
  _silk_resampler_private_AR2((HEAP32[$S$addr >> 2] | 0) + 16 | 0, $buf + 16 | 0, HEAP32[$in$addr >> 2] | 0, 23228, HEAP32[$nSamplesIn >> 2] | 0);
  HEAP32[$buf_ptr >> 2] = $buf;
  HEAP32[$counter >> 2] = HEAP32[$nSamplesIn >> 2];
  while (1) {
   if ((HEAP32[$counter >> 2] | 0) <= 2) break;
   $mul = Math_imul(HEAP32[HEAP32[$buf_ptr >> 2] >> 2] >> 16, HEAP16[11616] | 0) | 0;
   HEAP32[$res_Q6 >> 2] = $mul + ((Math_imul(HEAP32[HEAP32[$buf_ptr >> 2] >> 2] & 65535, HEAP16[11616] | 0) | 0) >> 16);
   $mul14 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] >> 16, HEAP16[11617] | 0) | 0;
   HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul14 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] & 65535, HEAP16[11617] | 0) | 0) >> 16));
   $mul25 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] >> 16, HEAP16[11619] | 0) | 0;
   HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul25 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] & 65535, HEAP16[11619] | 0) | 0) >> 16));
   $mul36 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] >> 16, HEAP16[11618] | 0) | 0;
   HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul36 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] & 65535, HEAP16[11618] | 0) | 0) >> 16));
   if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) > 32767) $cond64 = 32767; else if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) < -32768) $cond64 = -32768; else $cond64 = (HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1;
   $38 = HEAP32[$out$addr >> 2] | 0;
   HEAP32[$out$addr >> 2] = $38 + 2;
   HEAP16[$38 >> 1] = $cond64;
   $mul69 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] >> 16, HEAP16[11618] | 0) | 0;
   HEAP32[$res_Q6 >> 2] = $mul69 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 2] & 65535, HEAP16[11618] | 0) | 0) >> 16);
   $mul79 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] >> 16, HEAP16[11619] | 0) | 0;
   HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul79 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 2] & 65535, HEAP16[11619] | 0) | 0) >> 16));
   $mul90 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] >> 16, HEAP16[11617] | 0) | 0;
   HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul90 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 2] & 65535, HEAP16[11617] | 0) | 0) >> 16));
   $mul101 = Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 16 >> 2] >> 16, HEAP16[11616] | 0) | 0;
   HEAP32[$res_Q6 >> 2] = (HEAP32[$res_Q6 >> 2] | 0) + ($mul101 + ((Math_imul(HEAP32[(HEAP32[$buf_ptr >> 2] | 0) + 16 >> 2] & 65535, HEAP16[11616] | 0) | 0) >> 16));
   if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) > 32767) $cond129 = 32767; else if (((HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1 | 0) < -32768) $cond129 = -32768; else $cond129 = (HEAP32[$res_Q6 >> 2] >> 5) + 1 >> 1;
   $69 = HEAP32[$out$addr >> 2] | 0;
   HEAP32[$out$addr >> 2] = $69 + 2;
   HEAP16[$69 >> 1] = $cond129;
   HEAP32[$buf_ptr >> 2] = (HEAP32[$buf_ptr >> 2] | 0) + 12;
   HEAP32[$counter >> 2] = (HEAP32[$counter >> 2] | 0) - 3;
  }
  HEAP32[$in$addr >> 2] = (HEAP32[$in$addr >> 2] | 0) + (HEAP32[$nSamplesIn >> 2] << 1);
  HEAP32[$inLen$addr >> 2] = (HEAP32[$inLen$addr >> 2] | 0) - (HEAP32[$nSamplesIn >> 2] | 0);
  if ((HEAP32[$inLen$addr >> 2] | 0) <= 0) break;
  $arrayidx137 = $buf + (HEAP32[$nSamplesIn >> 2] << 2) | 0;
  HEAP32[$buf >> 2] = HEAP32[$arrayidx137 >> 2];
  HEAP32[$buf + 4 >> 2] = HEAP32[$arrayidx137 + 4 >> 2];
  HEAP32[$buf + 8 >> 2] = HEAP32[$arrayidx137 + 8 >> 2];
  HEAP32[$buf + 12 >> 2] = HEAP32[$arrayidx137 + 12 >> 2];
 }
 $78 = HEAP32[$S$addr >> 2] | 0;
 $arrayidx139 = $buf + (HEAP32[$nSamplesIn >> 2] << 2) | 0;
 HEAP32[$78 >> 2] = HEAP32[$arrayidx139 >> 2];
 HEAP32[$78 + 4 >> 2] = HEAP32[$arrayidx139 + 4 >> 2];
 HEAP32[$78 + 8 >> 2] = HEAP32[$arrayidx139 + 8 >> 2];
 HEAP32[$78 + 12 >> 2] = HEAP32[$arrayidx139 + 12 >> 2];
 STACKTOP = sp;
 return;
}

function _kf_bfly3($Fout, $fstride, $st, $m, $N, $mm) {
 $Fout = $Fout | 0;
 $fstride = $fstride | 0;
 $st = $st | 0;
 $m = $m | 0;
 $N = $N | 0;
 $mm = $mm | 0;
 var $12 = 0, $81 = 0, $Fout$addr = 0, $Fout_beg = 0, $N$addr = 0, $arrayidx = 0, $dec = 0, $epi3 = 0, $fstride$addr = 0, $i = 0, $i104 = 0, $i114 = 0, $k = 0, $m$addr = 0, $m2 = 0, $mm$addr = 0, $scratch = 0, $st$addr = 0, $tw1 = 0, $tw2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $Fout$addr = sp + 96 | 0;
 $fstride$addr = sp + 92 | 0;
 $st$addr = sp + 88 | 0;
 $m$addr = sp + 84 | 0;
 $N$addr = sp + 80 | 0;
 $mm$addr = sp + 76 | 0;
 $i = sp + 72 | 0;
 $k = sp + 68 | 0;
 $m2 = sp + 64 | 0;
 $tw1 = sp + 60 | 0;
 $tw2 = sp + 56 | 0;
 $scratch = sp + 16 | 0;
 $epi3 = sp + 8 | 0;
 $Fout_beg = sp;
 HEAP32[$Fout$addr >> 2] = $Fout;
 HEAP32[$fstride$addr >> 2] = $fstride;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$mm$addr >> 2] = $mm;
 HEAP32[$m2 >> 2] = HEAP32[$m$addr >> 2] << 1;
 HEAP32[$Fout_beg >> 2] = HEAP32[$Fout$addr >> 2];
 $arrayidx = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] | 0) + ((Math_imul(HEAP32[$fstride$addr >> 2] | 0, HEAP32[$m$addr >> 2] | 0) | 0) << 3) | 0;
 HEAP32[$epi3 >> 2] = HEAP32[$arrayidx >> 2];
 HEAP32[$epi3 + 4 >> 2] = HEAP32[$arrayidx + 4 >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAP32[$Fout$addr >> 2] = (HEAP32[$Fout_beg >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$mm$addr >> 2] | 0) | 0) << 3);
  $12 = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] | 0;
  HEAP32[$tw2 >> 2] = $12;
  HEAP32[$tw1 >> 2] = $12;
  HEAP32[$k >> 2] = HEAP32[$m$addr >> 2];
  do {
   HEAPF32[$scratch + 8 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) >> 2] * +HEAPF32[HEAP32[$tw1 >> 2] >> 2] - +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) + 4 >> 2] * +HEAPF32[(HEAP32[$tw1 >> 2] | 0) + 4 >> 2];
   HEAPF32[$scratch + 8 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) >> 2] * +HEAPF32[(HEAP32[$tw1 >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) + 4 >> 2] * +HEAPF32[HEAP32[$tw1 >> 2] >> 2];
   HEAPF32[$scratch + 16 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) >> 2] * +HEAPF32[HEAP32[$tw2 >> 2] >> 2] - +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) + 4 >> 2] * +HEAPF32[(HEAP32[$tw2 >> 2] | 0) + 4 >> 2];
   HEAPF32[$scratch + 16 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) >> 2] * +HEAPF32[(HEAP32[$tw2 >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) + 4 >> 2] * +HEAPF32[HEAP32[$tw2 >> 2] >> 2];
   HEAPF32[$scratch + 24 >> 2] = +HEAPF32[$scratch + 8 >> 2] + +HEAPF32[$scratch + 16 >> 2];
   HEAPF32[$scratch + 24 + 4 >> 2] = +HEAPF32[$scratch + 8 + 4 >> 2] + +HEAPF32[$scratch + 16 + 4 >> 2];
   HEAPF32[$scratch >> 2] = +HEAPF32[$scratch + 8 >> 2] - +HEAPF32[$scratch + 16 >> 2];
   HEAPF32[$scratch + 4 >> 2] = +HEAPF32[$scratch + 8 + 4 >> 2] - +HEAPF32[$scratch + 16 + 4 >> 2];
   HEAP32[$tw1 >> 2] = (HEAP32[$tw1 >> 2] | 0) + (HEAP32[$fstride$addr >> 2] << 3);
   HEAP32[$tw2 >> 2] = (HEAP32[$tw2 >> 2] | 0) + (HEAP32[$fstride$addr >> 2] << 1 << 3);
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) >> 2] = +HEAPF32[HEAP32[$Fout$addr >> 2] >> 2] - +HEAPF32[$scratch + 24 >> 2] * .5;
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 4 >> 2] - +HEAPF32[$scratch + 24 + 4 >> 2] * .5;
   HEAPF32[$scratch >> 2] = +HEAPF32[$scratch >> 2] * +HEAPF32[$epi3 + 4 >> 2];
   $i104 = $scratch + 4 | 0;
   HEAPF32[$i104 >> 2] = +HEAPF32[$i104 >> 2] * +HEAPF32[$epi3 + 4 >> 2];
   $81 = HEAP32[$Fout$addr >> 2] | 0;
   HEAPF32[$81 >> 2] = +HEAPF32[$81 >> 2] + +HEAPF32[$scratch + 24 >> 2];
   $i114 = (HEAP32[$Fout$addr >> 2] | 0) + 4 | 0;
   HEAPF32[$i114 >> 2] = +HEAPF32[$i114 >> 2] + +HEAPF32[$scratch + 24 + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) >> 2] + +HEAPF32[$scratch + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m2 >> 2] << 3) + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) + 4 >> 2] - +HEAPF32[$scratch >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) >> 2] - +HEAPF32[$scratch + 4 >> 2];
   HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + (HEAP32[$m$addr >> 2] << 3) + 4 >> 2] + +HEAPF32[$scratch >> 2];
   HEAP32[$Fout$addr >> 2] = (HEAP32[$Fout$addr >> 2] | 0) + 8;
   $dec = (HEAP32[$k >> 2] | 0) + -1 | 0;
   HEAP32[$k >> 2] = $dec;
  } while (($dec | 0) != 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _check_control_input($encControl) {
 $encControl = $encControl | 0;
 var $84 = 0, $encControl$addr = 0, $retval = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $retval = sp + 4 | 0;
 $encControl$addr = sp;
 HEAP32[$encControl$addr >> 2] = $encControl;
 if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) != 8e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) != 12e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) != 16e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) != 24e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) != 32e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) != 44100) {
  if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2] | 0) == 48e3) label = 8;
 } else label = 8; else label = 8; else label = 8; else label = 8; else label = 8; else label = 8;
 do if ((label | 0) == 8) {
  if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 20 >> 2] | 0) != 8e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 20 >> 2] | 0) != 12e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 20 >> 2] | 0) != 16e3) break;
  if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 12 >> 2] | 0) != 8e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 12 >> 2] | 0) != 12e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 12 >> 2] | 0) != 16e3) break;
  if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 16 >> 2] | 0) != 8e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 16 >> 2] | 0) != 12e3) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 16 >> 2] | 0) != 16e3) break;
  if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 16 >> 2] | 0) <= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 20 >> 2] | 0)) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 12 >> 2] | 0) >= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 20 >> 2] | 0)) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 16 >> 2] | 0) <= (HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 12 >> 2] | 0)) {
   if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) != 10) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) != 20) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) != 40) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) != 60) {
    HEAP32[$retval >> 2] = -103;
    $84 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $84 | 0;
   }
   if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 32 >> 2] | 0) >= 0) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 32 >> 2] | 0) <= 100) {
    if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 48 >> 2] | 0) >= 0) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 48 >> 2] | 0) <= 1) {
     if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 52 >> 2] | 0) >= 0) if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 52 >> 2] | 0) <= 1) {
      do if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 40 >> 2] | 0) >= 0) {
       if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 40 >> 2] | 0) > 1) break;
       do if ((HEAP32[HEAP32[$encControl$addr >> 2] >> 2] | 0) >= 1) {
        if ((HEAP32[HEAP32[$encControl$addr >> 2] >> 2] | 0) > 2) break;
        do if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) >= 1) {
         if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) > 2) break;
         if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2] | 0) > (HEAP32[HEAP32[$encControl$addr >> 2] >> 2] | 0)) {
          HEAP32[$retval >> 2] = -111;
          $84 = HEAP32[$retval >> 2] | 0;
          STACKTOP = sp;
          return $84 | 0;
         }
         do if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 36 >> 2] | 0) >= 0) {
          if ((HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 36 >> 2] | 0) > 10) break;
          HEAP32[$retval >> 2] = 0;
          $84 = HEAP32[$retval >> 2] | 0;
          STACKTOP = sp;
          return $84 | 0;
         } while (0);
         HEAP32[$retval >> 2] = -106;
         $84 = HEAP32[$retval >> 2] | 0;
         STACKTOP = sp;
         return $84 | 0;
        } while (0);
        HEAP32[$retval >> 2] = -111;
        $84 = HEAP32[$retval >> 2] | 0;
        STACKTOP = sp;
        return $84 | 0;
       } while (0);
       HEAP32[$retval >> 2] = -111;
       $84 = HEAP32[$retval >> 2] | 0;
       STACKTOP = sp;
       return $84 | 0;
      } while (0);
      HEAP32[$retval >> 2] = -107;
      $84 = HEAP32[$retval >> 2] | 0;
      STACKTOP = sp;
      return $84 | 0;
     }
     HEAP32[$retval >> 2] = -109;
     $84 = HEAP32[$retval >> 2] | 0;
     STACKTOP = sp;
     return $84 | 0;
    }
    HEAP32[$retval >> 2] = -108;
    $84 = HEAP32[$retval >> 2] | 0;
    STACKTOP = sp;
    return $84 | 0;
   }
   HEAP32[$retval >> 2] = -105;
   $84 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $84 | 0;
  }
 } while (0);
 HEAP32[$retval >> 2] = -102;
 $84 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $84 | 0;
}

function _silk_decode_parameters($psDec, $psDecCtrl, $condCoding) {
 $psDec = $psDec | 0;
 $psDecCtrl = $psDecCtrl | 0;
 $condCoding = $condCoding | 0;
 var $$sink = 0, $$sink1 = 0, $Ix = 0, $LTP_scale_Q14114 = 0, $cbk_ptr_Q7 = 0, $condCoding$addr = 0, $conv29 = 0, $i = 0, $indices77 = 0, $k = 0, $pNLSF0_Q15 = 0, $pNLSF_Q15 = 0, $psDec$addr = 0, $psDecCtrl$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $psDec$addr = sp + 24 | 0;
 $psDecCtrl$addr = sp + 20 | 0;
 $condCoding$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $k = sp + 8 | 0;
 $Ix = sp + 4 | 0;
 $pNLSF_Q15 = sp + 64 | 0;
 $pNLSF0_Q15 = sp + 32 | 0;
 $cbk_ptr_Q7 = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$psDecCtrl$addr >> 2] = $psDecCtrl;
 HEAP32[$condCoding$addr >> 2] = $condCoding;
 _silk_gains_dequant((HEAP32[$psDecCtrl$addr >> 2] | 0) + 16 | 0, (HEAP32[$psDec$addr >> 2] | 0) + 2736 | 0, (HEAP32[$psDec$addr >> 2] | 0) + 2312 | 0, (HEAP32[$condCoding$addr >> 2] | 0) == 2 & 1, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0);
 _silk_NLSF_decode($pNLSF_Q15, (HEAP32[$psDec$addr >> 2] | 0) + 2736 + 8 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2732 >> 2] | 0);
 _silk_NLSF2A((HEAP32[$psDecCtrl$addr >> 2] | 0) + 32 + 32 | 0, $pNLSF_Q15, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4168 >> 2] | 0);
 if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2376 >> 2] | 0) == 1) HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 31 >> 0] = 4;
 if ((HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 31 >> 0] | 0) < 4) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0)) break;
   $conv29 = (HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2344 + (HEAP32[$i >> 2] << 1) >> 1] | 0) + ((Math_imul(HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 31 >> 0] | 0, (HEAP16[$pNLSF_Q15 + (HEAP32[$i >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2344 + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) | 0) >> 2) & 65535;
   HEAP16[$pNLSF0_Q15 + (HEAP32[$i >> 2] << 1) >> 1] = $conv29;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  _silk_NLSF2A((HEAP32[$psDecCtrl$addr >> 2] | 0) + 32 | 0, $pNLSF0_Q15, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4168 >> 2] | 0);
 } else _memcpy((HEAP32[$psDecCtrl$addr >> 2] | 0) + 32 | 0, (HEAP32[$psDecCtrl$addr >> 2] | 0) + 32 + 32 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] << 1 | 0) | 0;
 _memcpy((HEAP32[$psDec$addr >> 2] | 0) + 2344 | 0, $pNLSF_Q15 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] << 1 | 0) | 0;
 if (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4160 >> 2] | 0) {
  _silk_bwexpander((HEAP32[$psDecCtrl$addr >> 2] | 0) + 32 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0, 63570);
  _silk_bwexpander((HEAP32[$psDecCtrl$addr >> 2] | 0) + 32 + 32 | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0, 63570);
 }
 if ((HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] | 0) != 2) {
  _memset(HEAP32[$psDecCtrl$addr >> 2] | 0, 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] << 2 | 0) | 0;
  _memset((HEAP32[$psDecCtrl$addr >> 2] | 0) + 96 | 0, 0, (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) * 5 << 1 | 0) | 0;
  HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 32 >> 0] = 0;
  $$sink = 0;
  $$sink1 = HEAP32[$psDecCtrl$addr >> 2] | 0;
  $LTP_scale_Q14114 = $$sink1 + 136 | 0;
  HEAP32[$LTP_scale_Q14114 >> 2] = $$sink;
  STACKTOP = sp;
  return;
 }
 _silk_decode_pitch(HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 26 >> 1] | 0, HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 28 >> 0] | 0, HEAP32[$psDecCtrl$addr >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0);
 HEAP32[$cbk_ptr_Q7 >> 2] = HEAP32[15080 + (HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 32 >> 0] << 2) >> 2];
 HEAP32[$k >> 2] = 0;
 while (1) {
  $indices77 = (HEAP32[$psDec$addr >> 2] | 0) + 2736 | 0;
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0)) break;
  HEAP32[$Ix >> 2] = HEAP8[$indices77 + 4 + (HEAP32[$k >> 2] | 0) >> 0];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 5) break;
   HEAP16[(HEAP32[$psDecCtrl$addr >> 2] | 0) + 96 + (((HEAP32[$k >> 2] | 0) * 5 | 0) + (HEAP32[$i >> 2] | 0) << 1) >> 1] = HEAP8[(HEAP32[$cbk_ptr_Q7 >> 2] | 0) + (((HEAP32[$Ix >> 2] | 0) * 5 | 0) + (HEAP32[$i >> 2] | 0)) >> 0] << 7;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$Ix >> 2] = HEAP8[$indices77 + 33 >> 0];
 $$sink = HEAP16[22964 + (HEAP32[$Ix >> 2] << 1) >> 1] | 0;
 $$sink1 = HEAP32[$psDecCtrl$addr >> 2] | 0;
 $LTP_scale_Q14114 = $$sink1 + 136 | 0;
 HEAP32[$LTP_scale_Q14114 >> 2] = $$sink;
 STACKTOP = sp;
 return;
}

function _compute_mdcts($mode, $shortBlocks, $in, $out, $C, $CC, $LM, $upsample, $arch) {
 $mode = $mode | 0;
 $shortBlocks = $shortBlocks | 0;
 $in = $in | 0;
 $out = $out | 0;
 $C = $C | 0;
 $CC = $CC | 0;
 $LM = $LM | 0;
 $upsample = $upsample | 0;
 $arch = $arch | 0;
 var $B = 0, $C$addr = 0, $CC$addr = 0, $LM$addr = 0, $N = 0, $add$ptr = 0, $add$ptr6 = 0, $arch$addr = 0, $arrayidx = 0, $arrayidx41 = 0, $b = 0, $bound = 0, $c = 0, $i = 0, $in$addr = 0, $inc10 = 0, $inc54 = 0, $mode$addr = 0, $mul = 0, $mul21 = 0, $mul34 = 0, $mul38 = 0, $mul39 = 0, $mul46 = 0, $mul47 = 0, $mul50 = 0, $mul7 = 0, $out$addr = 0, $overlap = 0, $shift = 0, $shortBlocks$addr = 0, $upsample$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $mode$addr = sp + 64 | 0;
 $shortBlocks$addr = sp + 60 | 0;
 $in$addr = sp + 56 | 0;
 $out$addr = sp + 52 | 0;
 $C$addr = sp + 48 | 0;
 $CC$addr = sp + 44 | 0;
 $LM$addr = sp + 40 | 0;
 $upsample$addr = sp + 36 | 0;
 $arch$addr = sp + 32 | 0;
 $overlap = sp + 28 | 0;
 $N = sp + 24 | 0;
 $B = sp + 20 | 0;
 $shift = sp + 16 | 0;
 $i = sp + 12 | 0;
 $b = sp + 8 | 0;
 $c = sp + 4 | 0;
 $bound = sp;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$shortBlocks$addr >> 2] = $shortBlocks;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$CC$addr >> 2] = $CC;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$upsample$addr >> 2] = $upsample;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$overlap >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 4 >> 2];
 if (HEAP32[$shortBlocks$addr >> 2] | 0) {
  HEAP32[$B >> 2] = HEAP32[$shortBlocks$addr >> 2];
  HEAP32[$N >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 44 >> 2];
  HEAP32[$shift >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 36 >> 2];
 } else {
  HEAP32[$B >> 2] = 1;
  HEAP32[$N >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 44 >> 2] << HEAP32[$LM$addr >> 2];
  HEAP32[$shift >> 2] = (HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 36 >> 2] | 0) - (HEAP32[$LM$addr >> 2] | 0);
 }
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$b >> 2] = 0;
  while (1) {
   if ((HEAP32[$b >> 2] | 0) >= (HEAP32[$B >> 2] | 0)) break;
   $mul = Math_imul(HEAP32[$B >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
   $add$ptr = (HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$c >> 2] | 0, $mul + (HEAP32[$overlap >> 2] | 0) | 0) | 0) << 2) | 0;
   $add$ptr6 = $add$ptr + ((Math_imul(HEAP32[$b >> 2] | 0, HEAP32[$N >> 2] | 0) | 0) << 2) | 0;
   $mul7 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
   $arrayidx = (HEAP32[$out$addr >> 2] | 0) + ((HEAP32[$b >> 2] | 0) + (Math_imul($mul7, HEAP32[$B >> 2] | 0) | 0) << 2) | 0;
   _clt_mdct_forward_c((HEAP32[$mode$addr >> 2] | 0) + 64 | 0, $add$ptr6, $arrayidx, HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 60 >> 2] | 0, HEAP32[$overlap >> 2] | 0, HEAP32[$shift >> 2] | 0, HEAP32[$B >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
   HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
  }
  $inc10 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc10;
 } while (($inc10 | 0) < (HEAP32[$CC$addr >> 2] | 0));
 L12 : do if ((HEAP32[$CC$addr >> 2] | 0) == 2 & (HEAP32[$C$addr >> 2] | 0) == 1) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$B >> 2] | 0, HEAP32[$N >> 2] | 0) | 0)) break L12;
   $mul21 = Math_imul(HEAP32[$B >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * .5 + +HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ($mul21 + (HEAP32[$i >> 2] | 0) << 2) >> 2] * .5;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 if ((HEAP32[$upsample$addr >> 2] | 0) == 1) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$c >> 2] = 0;
 do {
  $mul34 = Math_imul(HEAP32[$B >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
  HEAP32[$bound >> 2] = ($mul34 | 0) / (HEAP32[$upsample$addr >> 2] | 0) | 0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$bound >> 2] | 0)) break;
   $mul38 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$B >> 2] | 0) | 0;
   $mul39 = Math_imul($mul38, HEAP32[$N >> 2] | 0) | 0;
   $arrayidx41 = (HEAP32[$out$addr >> 2] | 0) + ($mul39 + (HEAP32[$i >> 2] | 0) << 2) | 0;
   HEAPF32[$arrayidx41 >> 2] = +HEAPF32[$arrayidx41 >> 2] * +(HEAP32[$upsample$addr >> 2] | 0);
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $mul46 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$B >> 2] | 0) | 0;
  $mul47 = Math_imul($mul46, HEAP32[$N >> 2] | 0) | 0;
  $mul50 = Math_imul(HEAP32[$B >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
  _memset((HEAP32[$out$addr >> 2] | 0) + ($mul47 + (HEAP32[$bound >> 2] | 0) << 2) | 0, 0, $mul50 - (HEAP32[$bound >> 2] | 0) << 2 | 0) | 0;
  $inc54 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc54;
 } while (($inc54 | 0) < (HEAP32[$C$addr >> 2] | 0));
 STACKTOP = sp;
 return;
}

function _dc_reject($in, $cutoff_Hz, $out, $hp_mem, $len, $channels, $Fs) {
 $in = $in | 0;
 $cutoff_Hz = $cutoff_Hz | 0;
 $out = $out | 0;
 $hp_mem = $hp_mem | 0;
 $len = $len | 0;
 $channels = $channels | 0;
 $Fs = $Fs | 0;
 var $$sink = 0.0, $5 = 0.0, $Fs$addr = 0, $arrayidx67$sink = 0, $channels$addr = 0, $coef = 0, $coef2 = 0, $cutoff_Hz$addr = 0, $hp_mem$addr = 0, $i = 0, $in$addr = 0, $len$addr = 0, $m0 = 0, $m043 = 0, $m1 = 0, $m144 = 0, $m2 = 0, $m3 = 0, $out$addr = 0, $out0 = 0, $out1 = 0, $tmp = 0, $tmp0 = 0, $tmp1 = 0, $x = 0, $x0 = 0, $x1 = 0, $y = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $in$addr = sp + 96 | 0;
 $cutoff_Hz$addr = sp + 92 | 0;
 $out$addr = sp + 88 | 0;
 $hp_mem$addr = sp + 84 | 0;
 $len$addr = sp + 80 | 0;
 $channels$addr = sp + 76 | 0;
 $Fs$addr = sp + 72 | 0;
 $i = sp + 68 | 0;
 $coef = sp + 64 | 0;
 $coef2 = sp + 60 | 0;
 $m0 = sp + 56 | 0;
 $m1 = sp + 52 | 0;
 $m2 = sp + 48 | 0;
 $m3 = sp + 44 | 0;
 $x0 = sp + 40 | 0;
 $x1 = sp + 36 | 0;
 $tmp0 = sp + 32 | 0;
 $tmp1 = sp + 28 | 0;
 $out0 = sp + 24 | 0;
 $out1 = sp + 20 | 0;
 $m043 = sp + 16 | 0;
 $m144 = sp + 12 | 0;
 $x = sp + 8 | 0;
 $tmp = sp + 4 | 0;
 $y = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$cutoff_Hz$addr >> 2] = $cutoff_Hz;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$hp_mem$addr >> 2] = $hp_mem;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAPF32[$coef >> 2] = +(HEAP32[$cutoff_Hz$addr >> 2] | 0) * 4.0 / +(HEAP32[$Fs$addr >> 2] | 0);
 HEAPF32[$coef2 >> 2] = 1.0 - +HEAPF32[$coef >> 2];
 $5 = +HEAPF32[HEAP32[$hp_mem$addr >> 2] >> 2];
 if ((HEAP32[$channels$addr >> 2] | 0) == 2) {
  HEAPF32[$m0 >> 2] = $5;
  HEAPF32[$m1 >> 2] = +HEAPF32[(HEAP32[$hp_mem$addr >> 2] | 0) + 4 >> 2];
  HEAPF32[$m2 >> 2] = +HEAPF32[(HEAP32[$hp_mem$addr >> 2] | 0) + 8 >> 2];
  HEAPF32[$m3 >> 2] = +HEAPF32[(HEAP32[$hp_mem$addr >> 2] | 0) + 12 >> 2];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
   HEAPF32[$x0 >> 2] = +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 0 << 2) >> 2];
   HEAPF32[$x1 >> 2] = +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 1 << 2) >> 2];
   HEAPF32[$tmp0 >> 2] = +HEAPF32[$x0 >> 2] - +HEAPF32[$m0 >> 2];
   HEAPF32[$tmp1 >> 2] = +HEAPF32[$x1 >> 2] - +HEAPF32[$m2 >> 2];
   HEAPF32[$m0 >> 2] = +HEAPF32[$coef >> 2] * +HEAPF32[$x0 >> 2] + 1.0000000031710769e-30 + +HEAPF32[$coef2 >> 2] * +HEAPF32[$m0 >> 2];
   HEAPF32[$m2 >> 2] = +HEAPF32[$coef >> 2] * +HEAPF32[$x1 >> 2] + 1.0000000031710769e-30 + +HEAPF32[$coef2 >> 2] * +HEAPF32[$m2 >> 2];
   HEAPF32[$out0 >> 2] = +HEAPF32[$tmp0 >> 2] - +HEAPF32[$m1 >> 2];
   HEAPF32[$out1 >> 2] = +HEAPF32[$tmp1 >> 2] - +HEAPF32[$m3 >> 2];
   HEAPF32[$m1 >> 2] = +HEAPF32[$coef >> 2] * +HEAPF32[$tmp0 >> 2] + 1.0000000031710769e-30 + +HEAPF32[$coef2 >> 2] * +HEAPF32[$m1 >> 2];
   HEAPF32[$m3 >> 2] = +HEAPF32[$coef >> 2] * +HEAPF32[$tmp1 >> 2] + 1.0000000031710769e-30 + +HEAPF32[$coef2 >> 2] * +HEAPF32[$m3 >> 2];
   HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 0 << 2) >> 2] = +HEAPF32[$out0 >> 2];
   HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 1 << 2) >> 2] = +HEAPF32[$out1 >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[HEAP32[$hp_mem$addr >> 2] >> 2] = +HEAPF32[$m0 >> 2];
  HEAPF32[(HEAP32[$hp_mem$addr >> 2] | 0) + 4 >> 2] = +HEAPF32[$m1 >> 2];
  HEAPF32[(HEAP32[$hp_mem$addr >> 2] | 0) + 8 >> 2] = +HEAPF32[$m2 >> 2];
  $$sink = +HEAPF32[$m3 >> 2];
  $arrayidx67$sink = (HEAP32[$hp_mem$addr >> 2] | 0) + 12 | 0;
  HEAPF32[$arrayidx67$sink >> 2] = $$sink;
  STACKTOP = sp;
  return;
 } else {
  HEAPF32[$m043 >> 2] = $5;
  HEAPF32[$m144 >> 2] = +HEAPF32[(HEAP32[$hp_mem$addr >> 2] | 0) + 4 >> 2];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
   HEAPF32[$x >> 2] = +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$tmp >> 2] = +HEAPF32[$x >> 2] - +HEAPF32[$m043 >> 2];
   HEAPF32[$m043 >> 2] = +HEAPF32[$coef >> 2] * +HEAPF32[$x >> 2] + 1.0000000031710769e-30 + +HEAPF32[$coef2 >> 2] * +HEAPF32[$m043 >> 2];
   HEAPF32[$y >> 2] = +HEAPF32[$tmp >> 2] - +HEAPF32[$m144 >> 2];
   HEAPF32[$m144 >> 2] = +HEAPF32[$coef >> 2] * +HEAPF32[$tmp >> 2] + 1.0000000031710769e-30 + +HEAPF32[$coef2 >> 2] * +HEAPF32[$m144 >> 2];
   HEAPF32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$y >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[HEAP32[$hp_mem$addr >> 2] >> 2] = +HEAPF32[$m043 >> 2];
  $$sink = +HEAPF32[$m144 >> 2];
  $arrayidx67$sink = (HEAP32[$hp_mem$addr >> 2] | 0) + 4 | 0;
  HEAPF32[$arrayidx67$sink >> 2] = $$sink;
  STACKTOP = sp;
  return;
 }
}

function _silk_LPC_fit($a_QOUT, $a_QIN, $QOUT, $QIN, $d) {
 $a_QOUT = $a_QOUT | 0;
 $a_QIN = $a_QIN | 0;
 $QOUT = $QOUT | 0;
 $QIN = $QIN | 0;
 $d = $d | 0;
 var $16 = 0, $37 = 0, $47 = 0, $57 = 0, $79 = 0, $8 = 0, $QIN$addr = 0, $QOUT$addr = 0, $a_QIN$addr = 0, $a_QOUT$addr = 0, $absval = 0, $chirp_Q16 = 0, $cmp34 = 0, $cond131 = 0, $cond18 = 0, $cond55 = 0, $cond75 = 0, $cond99 = 0, $d$addr = 0, $i = 0, $idx = 0, $k = 0, $maxabs = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $a_QOUT$addr = sp + 40 | 0;
 $a_QIN$addr = sp + 36 | 0;
 $QOUT$addr = sp + 32 | 0;
 $QIN$addr = sp + 28 | 0;
 $d$addr = sp + 24 | 0;
 $i = sp + 20 | 0;
 $k = sp + 16 | 0;
 $idx = sp + 12 | 0;
 $maxabs = sp + 8 | 0;
 $absval = sp + 4 | 0;
 $chirp_Q16 = sp;
 HEAP32[$a_QOUT$addr >> 2] = $a_QOUT;
 HEAP32[$a_QIN$addr >> 2] = $a_QIN;
 HEAP32[$QOUT$addr >> 2] = $QOUT;
 HEAP32[$QIN$addr >> 2] = $QIN;
 HEAP32[$d$addr >> 2] = $d;
 HEAP32[$idx >> 2] = 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 10) break;
  HEAP32[$maxabs >> 2] = 0;
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$d$addr >> 2] | 0)) break;
   $8 = HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
   HEAP32[$absval >> 2] = (HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) > 0 ? $8 : 0 - $8 | 0;
   if ((HEAP32[$absval >> 2] | 0) > (HEAP32[$maxabs >> 2] | 0)) {
    HEAP32[$maxabs >> 2] = HEAP32[$absval >> 2];
    HEAP32[$idx >> 2] = HEAP32[$k >> 2];
   }
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  $16 = HEAP32[$maxabs >> 2] | 0;
  if (((HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) | 0) == 1) $cond18 = ($16 >> 1) + (HEAP32[$maxabs >> 2] & 1) | 0; else $cond18 = ($16 >> (HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) - 1) + 1 >> 1;
  HEAP32[$maxabs >> 2] = $cond18;
  if ((HEAP32[$maxabs >> 2] | 0) <= 32767) break;
  HEAP32[$maxabs >> 2] = (HEAP32[$maxabs >> 2] | 0) < 163838 ? HEAP32[$maxabs >> 2] | 0 : 163838;
  HEAP32[$chirp_Q16 >> 2] = 65470 - (((HEAP32[$maxabs >> 2] | 0) - 32767 << 14 | 0) / ((Math_imul(HEAP32[$maxabs >> 2] | 0, (HEAP32[$idx >> 2] | 0) + 1 | 0) | 0) >> 2 | 0) | 0);
  _silk_bwexpander_32(HEAP32[$a_QIN$addr >> 2] | 0, HEAP32[$d$addr >> 2] | 0, HEAP32[$chirp_Q16 >> 2] | 0);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 $cmp34 = (HEAP32[$i >> 2] | 0) == 10;
 HEAP32[$k >> 2] = 0;
 if (!$cmp34) {
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$d$addr >> 2] | 0)) break;
   $79 = HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
   if (((HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) | 0) == 1) $cond131 = ($79 >> 1) + (HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 1) | 0; else $cond131 = ($79 >> (HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) - 1) + 1 >> 1;
   HEAP16[(HEAP32[$a_QOUT$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $cond131;
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  STACKTOP = sp;
  return;
 }
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$d$addr >> 2] | 0)) break;
  $37 = HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
  if (((HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) | 0) == 1) $cond55 = ($37 >> 1) + (HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 1) | 0; else $cond55 = ($37 >> (HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) - 1) + 1 >> 1;
  do if (($cond55 | 0) > 32767) $cond99 = 32767; else {
   $47 = HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
   if (((HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) | 0) == 1) $cond75 = ($47 >> 1) + (HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 1) | 0; else $cond75 = ($47 >> (HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) - 1) + 1 >> 1;
   if (($cond75 | 0) < -32768) $cond99 = -32768; else {
    $57 = HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
    if (((HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) | 0) == 1) {
     $cond99 = ($57 >> 1) + (HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] & 1) | 0;
     break;
    } else {
     $cond99 = ($57 >> (HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0) - 1) + 1 >> 1;
     break;
    }
   }
  } while (0);
  HEAP16[(HEAP32[$a_QOUT$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $cond99;
  HEAP32[(HEAP32[$a_QIN$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = HEAP16[(HEAP32[$a_QOUT$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] << (HEAP32[$QIN$addr >> 2] | 0) - (HEAP32[$QOUT$addr >> 2] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_decode_pulses($psRangeDec, $pulses, $signalType, $quantOffsetType, $frame_length) {
 $psRangeDec = $psRangeDec | 0;
 $pulses = $pulses | 0;
 $signalType = $signalType | 0;
 $quantOffsetType = $quantOffsetType | 0;
 $frame_length = $frame_length | 0;
 var $$sink = 0, $15 = 0, $45 = 0, $RateLevelIndex = 0, $abs_q = 0, $arrayidx10 = 0, $arrayidx28 = 0, $arrayidx71 = 0, $call14 = 0, $call14$sink = 0, $call6 = 0, $call61 = 0, $cdf_ptr = 0, $frame_length$addr = 0, $i = 0, $iter = 0, $j = 0, $k = 0, $nLS = 0, $nLshifts = 0, $psRangeDec$addr = 0, $pulses$addr = 0, $pulses_ptr = 0, $quantOffsetType$addr = 0, $signalType$addr = 0, $sum_pulses = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 $psRangeDec$addr = sp + 212 | 0;
 $pulses$addr = sp + 208 | 0;
 $signalType$addr = sp + 204 | 0;
 $quantOffsetType$addr = sp + 200 | 0;
 $frame_length$addr = sp + 196 | 0;
 $i = sp + 192 | 0;
 $j = sp + 188 | 0;
 $k = sp + 184 | 0;
 $iter = sp + 180 | 0;
 $abs_q = sp + 176 | 0;
 $nLS = sp + 172 | 0;
 $RateLevelIndex = sp + 168 | 0;
 $sum_pulses = sp + 88 | 0;
 $nLshifts = sp + 8 | 0;
 $pulses_ptr = sp + 4 | 0;
 $cdf_ptr = sp;
 HEAP32[$psRangeDec$addr >> 2] = $psRangeDec;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$signalType$addr >> 2] = $signalType;
 HEAP32[$quantOffsetType$addr >> 2] = $quantOffsetType;
 HEAP32[$frame_length$addr >> 2] = $frame_length;
 HEAP32[$RateLevelIndex >> 2] = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32724 + ((HEAP32[$signalType$addr >> 2] >> 1) * 9 | 0) | 0, 8) | 0;
 HEAP32[$iter >> 2] = HEAP32[$frame_length$addr >> 2] >> 4;
 if ((HEAP32[$iter >> 2] << 4 | 0) < (HEAP32[$frame_length$addr >> 2] | 0)) HEAP32[$iter >> 2] = (HEAP32[$iter >> 2] | 0) + 1;
 HEAP32[$cdf_ptr >> 2] = 32382 + ((HEAP32[$RateLevelIndex >> 2] | 0) * 18 | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$iter >> 2] | 0)) break;
  HEAP32[$nLshifts + (HEAP32[$i >> 2] << 2) >> 2] = 0;
  $call6 = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[$cdf_ptr >> 2] | 0, 8) | 0;
  $$sink = HEAP32[$i >> 2] | 0;
  $call14$sink = $call6;
  while (1) {
   HEAP32[$sum_pulses + ($$sink << 2) >> 2] = $call14$sink;
   $15 = HEAP32[$i >> 2] | 0;
   if ((HEAP32[$sum_pulses + (HEAP32[$i >> 2] << 2) >> 2] | 0) != 17) break;
   $arrayidx10 = $nLshifts + ($15 << 2) | 0;
   HEAP32[$arrayidx10 >> 2] = (HEAP32[$arrayidx10 >> 2] | 0) + 1;
   $call14 = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32544 + ((HEAP32[$nLshifts + (HEAP32[$i >> 2] << 2) >> 2] | 0) == 10 & 1) | 0, 8) | 0;
   $$sink = HEAP32[$i >> 2] | 0;
   $call14$sink = $call14;
  }
  HEAP32[$i >> 2] = $15 + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$iter >> 2] | 0)) break;
  $arrayidx28 = (HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] & 65535) << 16 >> 16 << 4 << 1) | 0;
  if ((HEAP32[$sum_pulses + (HEAP32[$i >> 2] << 2) >> 2] | 0) > 0) _silk_shell_decoder($arrayidx28, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[$sum_pulses + (HEAP32[$i >> 2] << 2) >> 2] | 0); else {
   dest = $arrayidx28;
   stop = dest + 32 | 0;
   do {
    HEAP16[dest >> 1] = 0;
    dest = dest + 2 | 0;
   } while ((dest | 0) < (stop | 0));
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$iter >> 2] | 0)) break;
  if ((HEAP32[$nLshifts + (HEAP32[$i >> 2] << 2) >> 2] | 0) > 0) {
   HEAP32[$nLS >> 2] = HEAP32[$nLshifts + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$pulses_ptr >> 2] = (HEAP32[$pulses$addr >> 2] | 0) + ((HEAP32[$i >> 2] & 65535) << 16 >> 16 << 4 << 1);
   HEAP32[$k >> 2] = 0;
   while (1) {
    if ((HEAP32[$k >> 2] | 0) >= 16) break;
    HEAP32[$abs_q >> 2] = HEAP16[(HEAP32[$pulses_ptr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1];
    HEAP32[$j >> 2] = 0;
    while (1) {
     $45 = HEAP32[$abs_q >> 2] | 0;
     if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$nLS >> 2] | 0)) break;
     HEAP32[$abs_q >> 2] = $45 << 1;
     $call61 = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32216, 8) | 0;
     HEAP32[$abs_q >> 2] = (HEAP32[$abs_q >> 2] | 0) + $call61;
     HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
    }
    HEAP16[(HEAP32[$pulses_ptr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $45;
    HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
   }
   $arrayidx71 = $sum_pulses + (HEAP32[$i >> 2] << 2) | 0;
   HEAP32[$arrayidx71 >> 2] = HEAP32[$arrayidx71 >> 2] | HEAP32[$nLS >> 2] << 5;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _silk_decode_signs(HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[$pulses$addr >> 2] | 0, HEAP32[$frame_length$addr >> 2] | 0, HEAP32[$signalType$addr >> 2] | 0, HEAP32[$quantOffsetType$addr >> 2] | 0, $sum_pulses);
 STACKTOP = sp;
 return;
}

function _silk_P_Ana_calc_energy_st3($energies_st3, $frame, $start_lag, $sf_length, $nb_subfr, $complexity) {
 $energies_st3 = $energies_st3 | 0;
 $frame = $frame | 0;
 $start_lag = $start_lag | 0;
 $sf_length = $sf_length | 0;
 $nb_subfr = $nb_subfr | 0;
 $complexity = $complexity | 0;
 var $Lag_CB_ptr = 0, $Lag_range_ptr = 0, $basis_ptr = 0, $cbk_size = 0, $complexity$addr = 0, $delta = 0, $energies_st3$addr = 0, $energy = 0, $frame$addr = 0, $i = 0, $idx = 0, $j = 0, $k = 0, $lag_counter = 0, $lag_diff = 0, $mul54 = 0, $nb_cbk_search = 0, $nb_subfr$addr = 0, $scratch_mem = 0, $sf_length$addr = 0, $start_lag$addr = 0, $target_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 $energies_st3$addr = sp + 168 | 0;
 $frame$addr = sp + 164 | 0;
 $start_lag$addr = sp + 160 | 0;
 $sf_length$addr = sp + 156 | 0;
 $nb_subfr$addr = sp + 152 | 0;
 $complexity$addr = sp + 148 | 0;
 $target_ptr = sp + 144 | 0;
 $basis_ptr = sp + 140 | 0;
 $energy = sp;
 $k = sp + 136 | 0;
 $i = sp + 132 | 0;
 $j = sp + 128 | 0;
 $lag_counter = sp + 124 | 0;
 $nb_cbk_search = sp + 120 | 0;
 $delta = sp + 116 | 0;
 $idx = sp + 112 | 0;
 $cbk_size = sp + 108 | 0;
 $lag_diff = sp + 104 | 0;
 $scratch_mem = sp + 16 | 0;
 $Lag_range_ptr = sp + 12 | 0;
 $Lag_CB_ptr = sp + 8 | 0;
 HEAP32[$energies_st3$addr >> 2] = $energies_st3;
 HEAP32[$frame$addr >> 2] = $frame;
 HEAP32[$start_lag$addr >> 2] = $start_lag;
 HEAP32[$sf_length$addr >> 2] = $sf_length;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$complexity$addr >> 2] = $complexity;
 if ((HEAP32[$nb_subfr$addr >> 2] | 0) == 4) {
  HEAP32[$Lag_range_ptr >> 2] = 35473 + (HEAP32[$complexity$addr >> 2] << 3);
  HEAP32[$Lag_CB_ptr >> 2] = 35337;
  HEAP32[$nb_cbk_search >> 2] = HEAP8[35497 + (HEAP32[$complexity$addr >> 2] | 0) >> 0];
  HEAP32[$cbk_size >> 2] = 34;
 } else {
  HEAP32[$Lag_range_ptr >> 2] = 35289;
  HEAP32[$Lag_CB_ptr >> 2] = 35265;
  HEAP32[$nb_cbk_search >> 2] = 12;
  HEAP32[$cbk_size >> 2] = 12;
 }
 HEAP32[$target_ptr >> 2] = (HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$sf_length$addr >> 2] << 2 << 2);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  HEAP32[$lag_counter >> 2] = 0;
  HEAP32[$basis_ptr >> 2] = (HEAP32[$target_ptr >> 2] | 0) + (0 - ((HEAP32[$start_lag$addr >> 2] | 0) + (HEAP8[(HEAP32[$Lag_range_ptr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 0) >> 0] | 0)) << 2);
  HEAPF64[$energy >> 3] = +_silk_energy_FLP(HEAP32[$basis_ptr >> 2] | 0, HEAP32[$sf_length$addr >> 2] | 0) + .001;
  HEAPF32[$scratch_mem + (HEAP32[$lag_counter >> 2] << 2) >> 2] = +HEAPF64[$energy >> 3];
  HEAP32[$lag_counter >> 2] = (HEAP32[$lag_counter >> 2] | 0) + 1;
  HEAP32[$lag_diff >> 2] = (HEAP8[(HEAP32[$Lag_range_ptr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 1) >> 0] | 0) - (HEAP8[(HEAP32[$Lag_range_ptr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 0) >> 0] | 0) + 1;
  HEAP32[$i >> 2] = 1;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$lag_diff >> 2] | 0)) break;
   HEAPF64[$energy >> 3] = +HEAPF64[$energy >> 3] - +HEAPF32[(HEAP32[$basis_ptr >> 2] | 0) + ((HEAP32[$sf_length$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$basis_ptr >> 2] | 0) + ((HEAP32[$sf_length$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) << 2) >> 2];
   HEAPF64[$energy >> 3] = +HEAPF64[$energy >> 3] + +HEAPF32[(HEAP32[$basis_ptr >> 2] | 0) + (0 - (HEAP32[$i >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$basis_ptr >> 2] | 0) + (0 - (HEAP32[$i >> 2] | 0) << 2) >> 2];
   HEAPF32[$scratch_mem + (HEAP32[$lag_counter >> 2] << 2) >> 2] = +HEAPF64[$energy >> 3];
   HEAP32[$lag_counter >> 2] = (HEAP32[$lag_counter >> 2] | 0) + 1;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$delta >> 2] = HEAP8[(HEAP32[$Lag_range_ptr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 0) >> 0];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nb_cbk_search >> 2] | 0)) break;
   $mul54 = Math_imul(HEAP32[$k >> 2] | 0, HEAP32[$cbk_size >> 2] | 0) | 0;
   HEAP32[$idx >> 2] = (HEAP8[(HEAP32[$Lag_CB_ptr >> 2] | 0) + ($mul54 + (HEAP32[$i >> 2] | 0)) >> 0] | 0) - (HEAP32[$delta >> 2] | 0);
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= 5) break;
    HEAPF32[(HEAP32[$energies_st3$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 680 | 0) + ((HEAP32[$i >> 2] | 0) * 20 | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$scratch_mem + ((HEAP32[$idx >> 2] | 0) + (HEAP32[$j >> 2] | 0) << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$target_ptr >> 2] = (HEAP32[$target_ptr >> 2] | 0) + (HEAP32[$sf_length$addr >> 2] << 2);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _warped_true2monic_coefs($coefs, $lambda, $limit, $order) {
 $coefs = $coefs | 0;
 $lambda = +$lambda;
 $limit = +$limit;
 $order = $order | 0;
 var $2 = 0.0, $62 = 0.0, $arrayidx11 = 0, $arrayidx2 = 0, $arrayidx39 = 0, $arrayidx49 = 0, $arrayidx72 = 0, $arrayidx87 = 0, $chirp = 0, $coefs$addr = 0, $gain = 0, $i = 0, $ind = 0, $iter = 0, $lambda$addr = 0, $limit$addr = 0, $maxabs = 0, $order$addr = 0, $tmp = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $coefs$addr = sp + 40 | 0;
 $lambda$addr = sp + 36 | 0;
 $limit$addr = sp + 32 | 0;
 $order$addr = sp + 28 | 0;
 $i = sp + 24 | 0;
 $iter = sp + 20 | 0;
 $ind = sp + 16 | 0;
 $tmp = sp + 12 | 0;
 $maxabs = sp + 8 | 0;
 $chirp = sp + 4 | 0;
 $gain = sp;
 HEAP32[$coefs$addr >> 2] = $coefs;
 HEAPF32[$lambda$addr >> 2] = $lambda;
 HEAPF32[$limit$addr >> 2] = $limit;
 HEAP32[$order$addr >> 2] = $order;
 HEAP32[$ind >> 2] = 0;
 HEAP32[$i >> 2] = (HEAP32[$order$addr >> 2] | 0) - 1;
 while (1) {
  $2 = +HEAPF32[$lambda$addr >> 2];
  if ((HEAP32[$i >> 2] | 0) <= 0) break;
  $arrayidx2 = (HEAP32[$coefs$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 << 2) | 0;
  HEAPF32[$arrayidx2 >> 2] = +HEAPF32[$arrayidx2 >> 2] - $2 * +HEAPF32[(HEAP32[$coefs$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 HEAPF32[$gain >> 2] = (1.0 - $2 * +HEAPF32[$lambda$addr >> 2]) / (+HEAPF32[$lambda$addr >> 2] * +HEAPF32[HEAP32[$coefs$addr >> 2] >> 2] + 1.0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
  $arrayidx11 = (HEAP32[$coefs$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
  HEAPF32[$arrayidx11 >> 2] = +HEAPF32[$arrayidx11 >> 2] * +HEAPF32[$gain >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$iter >> 2] = 0;
 while (1) {
  if ((HEAP32[$iter >> 2] | 0) >= 10) {
   label = 28;
   break;
  }
  HEAPF32[$maxabs >> 2] = -1.0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
   HEAPF32[$tmp >> 2] = +Math_abs(+(+HEAPF32[(HEAP32[$coefs$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]));
   if (+HEAPF32[$tmp >> 2] > +HEAPF32[$maxabs >> 2]) {
    HEAPF32[$maxabs >> 2] = +HEAPF32[$tmp >> 2];
    HEAP32[$ind >> 2] = HEAP32[$i >> 2];
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  if (+HEAPF32[$maxabs >> 2] <= +HEAPF32[$limit$addr >> 2]) {
   label = 28;
   break;
  }
  HEAP32[$i >> 2] = 1;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
   $arrayidx39 = (HEAP32[$coefs$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 << 2) | 0;
   HEAPF32[$arrayidx39 >> 2] = +HEAPF32[$arrayidx39 >> 2] + +HEAPF32[$lambda$addr >> 2] * +HEAPF32[(HEAP32[$coefs$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[$gain >> 2] = 1.0 / +HEAPF32[$gain >> 2];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
   $arrayidx49 = (HEAP32[$coefs$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[$arrayidx49 >> 2] = +HEAPF32[$arrayidx49 >> 2] * +HEAPF32[$gain >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[$chirp >> 2] = .9900000095367432 - (+(HEAP32[$iter >> 2] | 0) * .10000000149011612 + .800000011920929) * (+HEAPF32[$maxabs >> 2] - +HEAPF32[$limit$addr >> 2]) / (+HEAPF32[$maxabs >> 2] * +((HEAP32[$ind >> 2] | 0) + 1 | 0));
  _silk_bwexpander_FLP(HEAP32[$coefs$addr >> 2] | 0, HEAP32[$order$addr >> 2] | 0, +HEAPF32[$chirp >> 2]);
  HEAP32[$i >> 2] = (HEAP32[$order$addr >> 2] | 0) - 1;
  while (1) {
   $62 = +HEAPF32[$lambda$addr >> 2];
   if ((HEAP32[$i >> 2] | 0) <= 0) break;
   $arrayidx72 = (HEAP32[$coefs$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 << 2) | 0;
   HEAPF32[$arrayidx72 >> 2] = +HEAPF32[$arrayidx72 >> 2] - $62 * +HEAPF32[(HEAP32[$coefs$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
  }
  HEAPF32[$gain >> 2] = (1.0 - $62 * +HEAPF32[$lambda$addr >> 2]) / (+HEAPF32[$lambda$addr >> 2] * +HEAPF32[HEAP32[$coefs$addr >> 2] >> 2] + 1.0);
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
   $arrayidx87 = (HEAP32[$coefs$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[$arrayidx87 >> 2] = +HEAPF32[$arrayidx87 >> 2] * +HEAPF32[$gain >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$iter >> 2] = (HEAP32[$iter >> 2] | 0) + 1;
 }
 if ((label | 0) == 28) {
  STACKTOP = sp;
  return;
 }
}

function _silk_A2NLSF_eval_poly($p, $x, $dd) {
 $p = $p | 0;
 $x = $x | 0;
 $dd = $dd | 0;
 var $81 = 0, $add110 = 0, $add127 = 0, $add146 = 0, $add25 = 0, $add42 = 0, $add59 = 0, $add76 = 0, $add8 = 0, $add93 = 0, $dd$addr = 0, $mul = 0, $mul103 = 0, $mul120 = 0, $mul139 = 0, $mul18 = 0, $mul35 = 0, $mul52 = 0, $mul69 = 0, $mul86 = 0, $n = 0, $p$addr = 0, $x$addr = 0, $x_Q16 = 0, $y32 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $p$addr = sp + 20 | 0;
 $x$addr = sp + 16 | 0;
 $dd$addr = sp + 12 | 0;
 $n = sp + 8 | 0;
 $x_Q16 = sp + 4 | 0;
 $y32 = sp;
 HEAP32[$p$addr >> 2] = $p;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$dd$addr >> 2] = $dd;
 HEAP32[$y32 >> 2] = HEAP32[(HEAP32[$p$addr >> 2] | 0) + (HEAP32[$dd$addr >> 2] << 2) >> 2];
 HEAP32[$x_Q16 >> 2] = HEAP32[$x$addr >> 2] << 4;
 if (8 == (HEAP32[$dd$addr >> 2] | 0) ^ 1 ^ 1) {
  $mul = Math_imul(HEAP32[$y32 >> 2] >> 16, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add8 = (HEAP32[(HEAP32[$p$addr >> 2] | 0) + 28 >> 2] | 0) + ($mul + ((Math_imul(HEAP32[$y32 >> 2] & 65535, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[$y32 >> 2] = $add8 + (Math_imul(HEAP32[$y32 >> 2] | 0, (HEAP32[$x_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  $mul18 = Math_imul(HEAP32[$y32 >> 2] >> 16, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add25 = (HEAP32[(HEAP32[$p$addr >> 2] | 0) + 24 >> 2] | 0) + ($mul18 + ((Math_imul(HEAP32[$y32 >> 2] & 65535, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[$y32 >> 2] = $add25 + (Math_imul(HEAP32[$y32 >> 2] | 0, (HEAP32[$x_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  $mul35 = Math_imul(HEAP32[$y32 >> 2] >> 16, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add42 = (HEAP32[(HEAP32[$p$addr >> 2] | 0) + 20 >> 2] | 0) + ($mul35 + ((Math_imul(HEAP32[$y32 >> 2] & 65535, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[$y32 >> 2] = $add42 + (Math_imul(HEAP32[$y32 >> 2] | 0, (HEAP32[$x_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  $mul52 = Math_imul(HEAP32[$y32 >> 2] >> 16, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add59 = (HEAP32[(HEAP32[$p$addr >> 2] | 0) + 16 >> 2] | 0) + ($mul52 + ((Math_imul(HEAP32[$y32 >> 2] & 65535, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[$y32 >> 2] = $add59 + (Math_imul(HEAP32[$y32 >> 2] | 0, (HEAP32[$x_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  $mul69 = Math_imul(HEAP32[$y32 >> 2] >> 16, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add76 = (HEAP32[(HEAP32[$p$addr >> 2] | 0) + 12 >> 2] | 0) + ($mul69 + ((Math_imul(HEAP32[$y32 >> 2] & 65535, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[$y32 >> 2] = $add76 + (Math_imul(HEAP32[$y32 >> 2] | 0, (HEAP32[$x_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  $mul86 = Math_imul(HEAP32[$y32 >> 2] >> 16, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add93 = (HEAP32[(HEAP32[$p$addr >> 2] | 0) + 8 >> 2] | 0) + ($mul86 + ((Math_imul(HEAP32[$y32 >> 2] & 65535, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[$y32 >> 2] = $add93 + (Math_imul(HEAP32[$y32 >> 2] | 0, (HEAP32[$x_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  $mul103 = Math_imul(HEAP32[$y32 >> 2] >> 16, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add110 = (HEAP32[(HEAP32[$p$addr >> 2] | 0) + 4 >> 2] | 0) + ($mul103 + ((Math_imul(HEAP32[$y32 >> 2] & 65535, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[$y32 >> 2] = $add110 + (Math_imul(HEAP32[$y32 >> 2] | 0, (HEAP32[$x_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  $mul120 = Math_imul(HEAP32[$y32 >> 2] >> 16, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add127 = (HEAP32[HEAP32[$p$addr >> 2] >> 2] | 0) + ($mul120 + ((Math_imul(HEAP32[$y32 >> 2] & 65535, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[$y32 >> 2] = $add127 + (Math_imul(HEAP32[$y32 >> 2] | 0, (HEAP32[$x_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  $81 = HEAP32[$y32 >> 2] | 0;
  STACKTOP = sp;
  return $81 | 0;
 }
 HEAP32[$n >> 2] = (HEAP32[$dd$addr >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) < 0) break;
  $mul139 = Math_imul(HEAP32[$y32 >> 2] >> 16, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0;
  $add146 = (HEAP32[(HEAP32[$p$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2] | 0) + ($mul139 + ((Math_imul(HEAP32[$y32 >> 2] & 65535, (HEAP32[$x_Q16 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[$y32 >> 2] = $add146 + (Math_imul(HEAP32[$y32 >> 2] | 0, (HEAP32[$x_Q16 >> 2] >> 15) + 1 >> 1) | 0);
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + -1;
 }
 $81 = HEAP32[$y32 >> 2] | 0;
 STACKTOP = sp;
 return $81 | 0;
}

function _silk_resampler_private_up2_HQ($S, $out, $in, $len) {
 $S = $S | 0;
 $out = $out | 0;
 $in = $in | 0;
 $len = $len | 0;
 var $S$addr = 0, $X = 0, $Y = 0, $cond122 = 0, $cond55 = 0, $in$addr = 0, $in32 = 0, $k = 0, $len$addr = 0, $mul = 0, $mul14 = 0, $mul28 = 0, $mul63 = 0, $mul77 = 0, $mul91 = 0, $out$addr = 0, $out32_1 = 0, $out32_2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $S$addr = sp + 36 | 0;
 $out$addr = sp + 32 | 0;
 $in$addr = sp + 28 | 0;
 $len$addr = sp + 24 | 0;
 $k = sp + 20 | 0;
 $in32 = sp + 16 | 0;
 $out32_1 = sp + 12 | 0;
 $out32_2 = sp + 8 | 0;
 $Y = sp + 4 | 0;
 $X = sp;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  HEAP32[$in32 >> 2] = HEAP16[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] << 10;
  HEAP32[$Y >> 2] = (HEAP32[$in32 >> 2] | 0) - (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0);
  $mul = Math_imul(HEAP32[$Y >> 2] >> 16, HEAP16[11485] | 0) | 0;
  HEAP32[$X >> 2] = $mul + ((Math_imul(HEAP32[$Y >> 2] & 65535, HEAP16[11485] | 0) | 0) >> 16);
  HEAP32[$out32_1 >> 2] = (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[HEAP32[$S$addr >> 2] >> 2] = (HEAP32[$in32 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[$Y >> 2] = (HEAP32[$out32_1 >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0);
  $mul14 = Math_imul(HEAP32[$Y >> 2] >> 16, HEAP16[11486] | 0) | 0;
  HEAP32[$X >> 2] = $mul14 + ((Math_imul(HEAP32[$Y >> 2] & 65535, HEAP16[11486] | 0) | 0) >> 16);
  HEAP32[$out32_2 >> 2] = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] = (HEAP32[$out32_1 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[$Y >> 2] = (HEAP32[$out32_2 >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 8 >> 2] | 0);
  $mul28 = Math_imul(HEAP32[$Y >> 2] >> 16, HEAP16[11487] | 0) | 0;
  HEAP32[$X >> 2] = (HEAP32[$Y >> 2] | 0) + ($mul28 + ((Math_imul(HEAP32[$Y >> 2] & 65535, HEAP16[11487] | 0) | 0) >> 16));
  HEAP32[$out32_1 >> 2] = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 8 >> 2] = (HEAP32[$out32_2 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  if (((HEAP32[$out32_1 >> 2] >> 9) + 1 >> 1 | 0) > 32767) $cond55 = 32767; else if (((HEAP32[$out32_1 >> 2] >> 9) + 1 >> 1 | 0) < -32768) $cond55 = -32768; else $cond55 = (HEAP32[$out32_1 >> 2] >> 9) + 1 >> 1;
  HEAP16[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1 << 1) >> 1] = $cond55;
  HEAP32[$Y >> 2] = (HEAP32[$in32 >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 12 >> 2] | 0);
  $mul63 = Math_imul(HEAP32[$Y >> 2] >> 16, HEAP16[11488] | 0) | 0;
  HEAP32[$X >> 2] = $mul63 + ((Math_imul(HEAP32[$Y >> 2] & 65535, HEAP16[11488] | 0) | 0) >> 16);
  HEAP32[$out32_1 >> 2] = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 12 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 12 >> 2] = (HEAP32[$in32 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[$Y >> 2] = (HEAP32[$out32_1 >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 16 >> 2] | 0);
  $mul77 = Math_imul(HEAP32[$Y >> 2] >> 16, HEAP16[11489] | 0) | 0;
  HEAP32[$X >> 2] = $mul77 + ((Math_imul(HEAP32[$Y >> 2] & 65535, HEAP16[11489] | 0) | 0) >> 16);
  HEAP32[$out32_2 >> 2] = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 16 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 16 >> 2] = (HEAP32[$out32_1 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[$Y >> 2] = (HEAP32[$out32_2 >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 20 >> 2] | 0);
  $mul91 = Math_imul(HEAP32[$Y >> 2] >> 16, HEAP16[11490] | 0) | 0;
  HEAP32[$X >> 2] = (HEAP32[$Y >> 2] | 0) + ($mul91 + ((Math_imul(HEAP32[$Y >> 2] & 65535, HEAP16[11490] | 0) | 0) >> 16));
  HEAP32[$out32_1 >> 2] = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 20 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 20 >> 2] = (HEAP32[$out32_2 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  if (((HEAP32[$out32_1 >> 2] >> 9) + 1 >> 1 | 0) > 32767) $cond122 = 32767; else if (((HEAP32[$out32_1 >> 2] >> 9) + 1 >> 1 | 0) < -32768) $cond122 = -32768; else $cond122 = (HEAP32[$out32_1 >> 2] >> 9) + 1 >> 1;
  HEAP16[(HEAP32[$out$addr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 1 << 1) >> 1] = $cond122;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _unquant_coarse_energy($m, $start, $end, $oldEBands, $intra, $dec, $C, $LM) {
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $oldEBands = $oldEBands | 0;
 $intra = $intra | 0;
 $dec = $dec | 0;
 $C = $C | 0;
 $LM = $LM | 0;
 var $C$addr = 0, $LM$addr = 0, $beta = 0, $budget = 0, $c = 0, $coef = 0, $cond44 = 0.0, $dec$addr = 0, $end$addr = 0, $i = 0, $inc = 0, $intra$addr = 0, $m$addr = 0, $mul53 = 0.0, $oldEBands$addr = 0, $pi = 0, $prev = 0, $prob_model = 0, $q = 0, $qi = 0, $start$addr = 0, $tell = 0, $tmp = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $m$addr = sp + 80 | 0;
 $start$addr = sp + 76 | 0;
 $end$addr = sp + 72 | 0;
 $oldEBands$addr = sp + 68 | 0;
 $intra$addr = sp + 64 | 0;
 $dec$addr = sp + 60 | 0;
 $C$addr = sp + 56 | 0;
 $LM$addr = sp + 52 | 0;
 $prob_model = sp + 48 | 0;
 $i = sp + 44 | 0;
 $c = sp + 40 | 0;
 $prev = sp + 32 | 0;
 $coef = sp + 28 | 0;
 $beta = sp + 24 | 0;
 $budget = sp + 20 | 0;
 $tell = sp + 16 | 0;
 $qi = sp + 12 | 0;
 $q = sp + 8 | 0;
 $tmp = sp + 4 | 0;
 $pi = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$oldEBands$addr >> 2] = $oldEBands;
 HEAP32[$intra$addr >> 2] = $intra;
 HEAP32[$dec$addr >> 2] = $dec;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$prob_model >> 2] = 31297 + ((HEAP32[$LM$addr >> 2] | 0) * 84 | 0) + ((HEAP32[$intra$addr >> 2] | 0) * 42 | 0);
 HEAP32[$prev >> 2] = 0;
 HEAP32[$prev + 4 >> 2] = 0;
 if (HEAP32[$intra$addr >> 2] | 0) {
  HEAPF32[$coef >> 2] = 0.0;
  HEAPF32[$beta >> 2] = .149993896484375;
 } else {
  HEAPF32[$beta >> 2] = +HEAPF32[15016 + (HEAP32[$LM$addr >> 2] << 2) >> 2];
  HEAPF32[$coef >> 2] = +HEAPF32[15e3 + (HEAP32[$LM$addr >> 2] << 2) >> 2];
 }
 HEAP32[$budget >> 2] = HEAP32[(HEAP32[$dec$addr >> 2] | 0) + 4 >> 2] << 3;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP32[$c >> 2] = 0;
  do {
   HEAP32[$tell >> 2] = _ec_tell_123(HEAP32[$dec$addr >> 2] | 0) | 0;
   do if (((HEAP32[$budget >> 2] | 0) - (HEAP32[$tell >> 2] | 0) | 0) >= 15) {
    HEAP32[$pi >> 2] = ((HEAP32[$i >> 2] | 0) < 20 ? HEAP32[$i >> 2] | 0 : 20) << 1;
    HEAP32[$qi >> 2] = _ec_laplace_decode(HEAP32[$dec$addr >> 2] | 0, (HEAPU8[(HEAP32[$prob_model >> 2] | 0) + (HEAP32[$pi >> 2] | 0) >> 0] | 0) << 7, (HEAPU8[(HEAP32[$prob_model >> 2] | 0) + ((HEAP32[$pi >> 2] | 0) + 1) >> 0] | 0) << 6) | 0;
   } else {
    if (((HEAP32[$budget >> 2] | 0) - (HEAP32[$tell >> 2] | 0) | 0) >= 2) {
     HEAP32[$qi >> 2] = _ec_dec_icdf(HEAP32[$dec$addr >> 2] | 0, 31633, 2) | 0;
     HEAP32[$qi >> 2] = HEAP32[$qi >> 2] >> 1 ^ 0 - (HEAP32[$qi >> 2] & 1);
     break;
    }
    if (((HEAP32[$budget >> 2] | 0) - (HEAP32[$tell >> 2] | 0) | 0) >= 1) {
     HEAP32[$qi >> 2] = 0 - (_ec_dec_bit_logp(HEAP32[$dec$addr >> 2] | 0, 1) | 0);
     break;
    } else {
     HEAP32[$qi >> 2] = -1;
     break;
    }
   } while (0);
   HEAPF32[$q >> 2] = +(HEAP32[$qi >> 2] | 0);
   if (-9.0 > +HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2]) $cond44 = -9.0; else $cond44 = +HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2] = $cond44;
   $mul53 = +HEAPF32[$coef >> 2] * +HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[$tmp >> 2] = $mul53 + +HEAPF32[$prev + (HEAP32[$c >> 2] << 2) >> 2] + +HEAPF32[$q >> 2];
   HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2] = +HEAPF32[$tmp >> 2];
   HEAPF32[$prev + (HEAP32[$c >> 2] << 2) >> 2] = +HEAPF32[$prev + (HEAP32[$c >> 2] << 2) >> 2] + +HEAPF32[$q >> 2] - +HEAPF32[$beta >> 2] * +HEAPF32[$q >> 2];
   $inc = (HEAP32[$c >> 2] | 0) + 1 | 0;
   HEAP32[$c >> 2] = $inc;
  } while (($inc | 0) < (HEAP32[$C$addr >> 2] | 0));
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_biquad_alt_stride1($in, $B_Q28, $A_Q28, $S, $out, $len) {
 $in = $in | 0;
 $B_Q28 = $B_Q28 | 0;
 $A_Q28 = $A_Q28 | 0;
 $S = $S | 0;
 $out = $out | 0;
 $len = $len | 0;
 var $A0_L_Q28 = 0, $A0_U_Q28 = 0, $A1_L_Q28 = 0, $A1_U_Q28 = 0, $A_Q28$addr = 0, $B_Q28$addr = 0, $S$addr = 0, $add106 = 0, $add36 = 0, $add49 = 0, $add64 = 0, $add91 = 0, $cond124 = 0, $in$addr = 0, $inval = 0, $k = 0, $len$addr = 0, $mul = 0, $mul26 = 0, $mul42 = 0, $mul56 = 0, $mul69 = 0, $mul84 = 0, $mul98 = 0, $out$addr = 0, $out32_Q14 = 0, $shr78 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $in$addr = sp + 48 | 0;
 $B_Q28$addr = sp + 44 | 0;
 $A_Q28$addr = sp + 40 | 0;
 $S$addr = sp + 36 | 0;
 $out$addr = sp + 32 | 0;
 $len$addr = sp + 28 | 0;
 $k = sp + 24 | 0;
 $inval = sp + 20 | 0;
 $A0_U_Q28 = sp + 16 | 0;
 $A0_L_Q28 = sp + 12 | 0;
 $A1_U_Q28 = sp + 8 | 0;
 $A1_L_Q28 = sp + 4 | 0;
 $out32_Q14 = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$B_Q28$addr >> 2] = $B_Q28;
 HEAP32[$A_Q28$addr >> 2] = $A_Q28;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$A0_L_Q28 >> 2] = 0 - (HEAP32[HEAP32[$A_Q28$addr >> 2] >> 2] | 0) & 16383;
 HEAP32[$A0_U_Q28 >> 2] = 0 - (HEAP32[HEAP32[$A_Q28$addr >> 2] >> 2] | 0) >> 14;
 HEAP32[$A1_L_Q28 >> 2] = 0 - (HEAP32[(HEAP32[$A_Q28$addr >> 2] | 0) + 4 >> 2] | 0) & 16383;
 HEAP32[$A1_U_Q28 >> 2] = 0 - (HEAP32[(HEAP32[$A_Q28$addr >> 2] | 0) + 4 >> 2] | 0) >> 14;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  HEAP32[$inval >> 2] = HEAP16[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1];
  $mul = Math_imul(HEAP32[HEAP32[$B_Q28$addr >> 2] >> 2] >> 16, (HEAP32[$inval >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$out32_Q14 >> 2] = (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0) + ($mul + ((Math_imul(HEAP32[HEAP32[$B_Q28$addr >> 2] >> 2] & 65535, (HEAP32[$inval >> 2] & 65535) << 16 >> 16) | 0) >> 16)) << 2;
  $mul26 = Math_imul(HEAP32[$out32_Q14 >> 2] >> 16, (HEAP32[$A0_L_Q28 >> 2] & 65535) << 16 >> 16) | 0;
  $add36 = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0) + (($mul26 + ((Math_imul(HEAP32[$out32_Q14 >> 2] & 65535, (HEAP32[$A0_L_Q28 >> 2] & 65535) << 16 >> 16) | 0) >> 16) >> 13) + 1 >> 1) | 0;
  HEAP32[HEAP32[$S$addr >> 2] >> 2] = $add36;
  $mul42 = Math_imul(HEAP32[$out32_Q14 >> 2] >> 16, (HEAP32[$A0_U_Q28 >> 2] & 65535) << 16 >> 16) | 0;
  $add49 = (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0) + ($mul42 + ((Math_imul(HEAP32[$out32_Q14 >> 2] & 65535, (HEAP32[$A0_U_Q28 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[HEAP32[$S$addr >> 2] >> 2] = $add49;
  $mul56 = Math_imul(HEAP32[(HEAP32[$B_Q28$addr >> 2] | 0) + 4 >> 2] >> 16, (HEAP32[$inval >> 2] & 65535) << 16 >> 16) | 0;
  $add64 = (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0) + ($mul56 + ((Math_imul(HEAP32[(HEAP32[$B_Q28$addr >> 2] | 0) + 4 >> 2] & 65535, (HEAP32[$inval >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[HEAP32[$S$addr >> 2] >> 2] = $add64;
  $mul69 = Math_imul(HEAP32[$out32_Q14 >> 2] >> 16, (HEAP32[$A1_L_Q28 >> 2] & 65535) << 16 >> 16) | 0;
  $shr78 = ($mul69 + ((Math_imul(HEAP32[$out32_Q14 >> 2] & 65535, (HEAP32[$A1_L_Q28 >> 2] & 65535) << 16 >> 16) | 0) >> 16) >> 13) + 1 >> 1;
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] = $shr78;
  $mul84 = Math_imul(HEAP32[$out32_Q14 >> 2] >> 16, (HEAP32[$A1_U_Q28 >> 2] & 65535) << 16 >> 16) | 0;
  $add91 = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0) + ($mul84 + ((Math_imul(HEAP32[$out32_Q14 >> 2] & 65535, (HEAP32[$A1_U_Q28 >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] = $add91;
  $mul98 = Math_imul(HEAP32[(HEAP32[$B_Q28$addr >> 2] | 0) + 8 >> 2] >> 16, (HEAP32[$inval >> 2] & 65535) << 16 >> 16) | 0;
  $add106 = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0) + ($mul98 + ((Math_imul(HEAP32[(HEAP32[$B_Q28$addr >> 2] | 0) + 8 >> 2] & 65535, (HEAP32[$inval >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] = $add106;
  if (((HEAP32[$out32_Q14 >> 2] | 0) + 16384 - 1 >> 14 | 0) > 32767) $cond124 = 32767; else if (((HEAP32[$out32_Q14 >> 2] | 0) + 16384 - 1 >> 14 | 0) < -32768) $cond124 = -32768; else $cond124 = (HEAP32[$out32_Q14 >> 2] | 0) + 16384 - 1 >> 14;
  HEAP16[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $cond124;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_setup_resamplers($psEnc, $fs_kHz) {
 $psEnc = $psEnc | 0;
 $fs_kHz = $fs_kHz | 0;
 var $49 = 0, $50 = 0, $51 = 0, $52 = 0, $9 = 0, $API_fs_Hz53 = 0, $api_buf_samples = 0, $buf_length_ms = 0, $call = 0, $call27 = 0, $call34 = 0, $call43 = 0, $call47 = 0, $cond = 0, $fs_kHz$addr = 0, $new_buf_samples = 0, $old_buf_samples = 0, $prev_API_fs_Hz55 = 0, $psEnc$addr = 0, $ret = 0, $saved_stack = 0, $temp_resampler_state = 0, $vla = 0, $vla32 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 336 | 0;
 $psEnc$addr = sp + 328 | 0;
 $fs_kHz$addr = sp + 324 | 0;
 $ret = sp + 320 | 0;
 $new_buf_samples = sp + 316 | 0;
 $api_buf_samples = sp + 312 | 0;
 $old_buf_samples = sp + 308 | 0;
 $buf_length_ms = sp + 304 | 0;
 $saved_stack = sp + 300 | 0;
 $temp_resampler_state = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$fs_kHz$addr >> 2] = $fs_kHz;
 HEAP32[$ret >> 2] = 0;
 if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) == (HEAP32[$fs_kHz$addr >> 2] | 0)) if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4556 >> 2] | 0) == (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4552 >> 2] | 0)) {
  $49 = HEAP32[$psEnc$addr >> 2] | 0;
  $API_fs_Hz53 = $49 + 4552 | 0;
  $50 = HEAP32[$API_fs_Hz53 >> 2] | 0;
  $51 = HEAP32[$psEnc$addr >> 2] | 0;
  $prev_API_fs_Hz55 = $51 + 4556 | 0;
  HEAP32[$prev_API_fs_Hz55 >> 2] = $50;
  $52 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $52 | 0;
 }
 $9 = HEAP32[$psEnc$addr >> 2] | 0;
 if (!(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0)) {
  $call = _silk_resampler_init($9 + 5772 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4552 >> 2] | 0, (HEAP32[$fs_kHz$addr >> 2] | 0) * 1e3 | 0, 1) | 0;
  HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call;
  $49 = HEAP32[$psEnc$addr >> 2] | 0;
  $API_fs_Hz53 = $49 + 4552 | 0;
  $50 = HEAP32[$API_fs_Hz53 >> 2] | 0;
  $51 = HEAP32[$psEnc$addr >> 2] | 0;
  $prev_API_fs_Hz55 = $51 + 4556 | 0;
  HEAP32[$prev_API_fs_Hz55 >> 2] = $50;
  $52 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $52 | 0;
 } else {
  HEAP32[$buf_length_ms >> 2] = ((HEAP32[$9 + 4576 >> 2] | 0) * 5 << 1) + 5;
  HEAP32[$old_buf_samples >> 2] = Math_imul(HEAP32[$buf_length_ms >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) | 0;
  HEAP32[$new_buf_samples >> 2] = Math_imul(HEAP32[$buf_length_ms >> 2] | 0, HEAP32[$fs_kHz$addr >> 2] | 0) | 0;
  $cond = (HEAP32[$old_buf_samples >> 2] | 0) > (HEAP32[$new_buf_samples >> 2] | 0) ? HEAP32[$old_buf_samples >> 2] | 0 : HEAP32[$new_buf_samples >> 2] | 0;
  HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
  $vla = STACKTOP;
  STACKTOP = STACKTOP + ((1 * ($cond << 1) | 0) + 15 & -16) | 0;
  _silk_float2short_array($vla, (HEAP32[$psEnc$addr >> 2] | 0) + 7176 | 0, HEAP32[$old_buf_samples >> 2] | 0);
  $call27 = _silk_resampler_init($temp_resampler_state, ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] & 65535) << 16 >> 16) * 1e3 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4552 >> 2] | 0, 0) | 0;
  HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call27;
  HEAP32[$api_buf_samples >> 2] = Math_imul(HEAP32[$buf_length_ms >> 2] | 0, (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4552 >> 2] | 0) / 1e3 | 0) | 0;
  $vla32 = STACKTOP;
  STACKTOP = STACKTOP + ((1 * (HEAP32[$api_buf_samples >> 2] << 1) | 0) + 15 & -16) | 0;
  $call34 = _silk_resampler($temp_resampler_state, $vla32, $vla, HEAP32[$old_buf_samples >> 2] | 0) | 0;
  HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call34;
  $call43 = _silk_resampler_init((HEAP32[$psEnc$addr >> 2] | 0) + 5772 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4552 >> 2] | 0, ((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 1e3 | 0, 1) | 0;
  HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call43;
  $call47 = _silk_resampler((HEAP32[$psEnc$addr >> 2] | 0) + 5772 | 0, $vla, $vla32, HEAP32[$api_buf_samples >> 2] | 0) | 0;
  HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call47;
  _silk_short2float_array((HEAP32[$psEnc$addr >> 2] | 0) + 7176 | 0, $vla, HEAP32[$new_buf_samples >> 2] | 0);
  _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
  $49 = HEAP32[$psEnc$addr >> 2] | 0;
  $API_fs_Hz53 = $49 + 4552 | 0;
  $50 = HEAP32[$API_fs_Hz53 >> 2] | 0;
  $51 = HEAP32[$psEnc$addr >> 2] | 0;
  $prev_API_fs_Hz55 = $51 + 4556 | 0;
  HEAP32[$prev_API_fs_Hz55 >> 2] = $50;
  $52 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $52 | 0;
 }
 return 0;
}

function _downmix_and_resample($downmix, $_x, $y, $S, $subframe, $offset, $c1, $c2, $C, $Fs) {
 $downmix = $downmix | 0;
 $_x = $_x | 0;
 $y = $y | 0;
 $S = $S | 0;
 $subframe = $subframe | 0;
 $offset = $offset | 0;
 $c1 = $c1 | 0;
 $c2 = $c2 | 0;
 $C = $C | 0;
 $Fs = $Fs | 0;
 var $56 = 0.0, $7 = 0, $C$addr = 0, $Fs$addr = 0, $S$addr = 0, $_x$addr = 0, $arrayidx = 0, $c1$addr = 0, $c2$addr = 0, $downmix$addr = 0, $j = 0, $mul37 = 0, $offset$addr = 0, $ret = 0, $retval = 0, $saved_stack = 0, $saved_stack38 = 0, $scale = 0, $subframe$addr = 0, $vla = 0, $vla39 = 0, $y$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $retval = sp + 60 | 0;
 $downmix$addr = sp + 56 | 0;
 $_x$addr = sp + 52 | 0;
 $y$addr = sp + 48 | 0;
 $S$addr = sp + 44 | 0;
 $subframe$addr = sp + 40 | 0;
 $offset$addr = sp + 36 | 0;
 $c1$addr = sp + 32 | 0;
 $c2$addr = sp + 28 | 0;
 $C$addr = sp + 24 | 0;
 $Fs$addr = sp + 20 | 0;
 $scale = sp + 16 | 0;
 $j = sp + 12 | 0;
 $ret = sp + 8 | 0;
 $saved_stack = sp + 4 | 0;
 $saved_stack38 = sp;
 HEAP32[$downmix$addr >> 2] = $downmix;
 HEAP32[$_x$addr >> 2] = $_x;
 HEAP32[$y$addr >> 2] = $y;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$subframe$addr >> 2] = $subframe;
 HEAP32[$offset$addr >> 2] = $offset;
 HEAP32[$c1$addr >> 2] = $c1;
 HEAP32[$c2$addr >> 2] = $c2;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAPF32[$ret >> 2] = 0.0;
 if (!(HEAP32[$subframe$addr >> 2] | 0)) {
  HEAPF32[$retval >> 2] = 0.0;
  $56 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$56;
 }
 if ((HEAP32[$Fs$addr >> 2] | 0) == 48e3) {
  HEAP32[$subframe$addr >> 2] = HEAP32[$subframe$addr >> 2] << 1;
  HEAP32[$offset$addr >> 2] = HEAP32[$offset$addr >> 2] << 1;
 } else if ((HEAP32[$Fs$addr >> 2] | 0) == 16e3) {
  HEAP32[$subframe$addr >> 2] = (HEAP32[$subframe$addr >> 2] << 1 | 0) / 3 | 0;
  HEAP32[$offset$addr >> 2] = (HEAP32[$offset$addr >> 2] << 1 | 0) / 3 | 0;
 }
 $7 = HEAP32[$subframe$addr >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($7 << 2) | 0) + 15 & -16) | 0;
 FUNCTION_TABLE_viiiiiii[HEAP32[$downmix$addr >> 2] & 1](HEAP32[$_x$addr >> 2] | 0, $vla, HEAP32[$subframe$addr >> 2] | 0, HEAP32[$offset$addr >> 2] | 0, HEAP32[$c1$addr >> 2] | 0, HEAP32[$c2$addr >> 2] | 0, HEAP32[$C$addr >> 2] | 0);
 HEAPF32[$scale >> 2] = .000030517578125;
 if ((HEAP32[$c2$addr >> 2] | 0) == -2) HEAPF32[$scale >> 2] = +HEAPF32[$scale >> 2] / +(HEAP32[$C$addr >> 2] | 0); else if ((HEAP32[$c2$addr >> 2] | 0) > -1) HEAPF32[$scale >> 2] = +HEAPF32[$scale >> 2] / 2.0;
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$subframe$addr >> 2] | 0)) break;
  $arrayidx = $vla + (HEAP32[$j >> 2] << 2) | 0;
  HEAPF32[$arrayidx >> 2] = +HEAPF32[$arrayidx >> 2] * +HEAPF32[$scale >> 2];
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 do if ((HEAP32[$Fs$addr >> 2] | 0) == 48e3) HEAPF32[$ret >> 2] = +_silk_resampler_down2_hp(HEAP32[$S$addr >> 2] | 0, HEAP32[$y$addr >> 2] | 0, $vla, HEAP32[$subframe$addr >> 2] | 0); else {
  if ((HEAP32[$Fs$addr >> 2] | 0) == 24e3) {
   _memcpy(HEAP32[$y$addr >> 2] | 0, $vla | 0, (HEAP32[$subframe$addr >> 2] << 2) + 0 | 0) | 0;
   break;
  }
  if ((HEAP32[$Fs$addr >> 2] | 0) == 16e3) {
   $mul37 = (HEAP32[$subframe$addr >> 2] | 0) * 3 | 0;
   HEAP32[$saved_stack38 >> 2] = _llvm_stacksave() | 0;
   $vla39 = STACKTOP;
   STACKTOP = STACKTOP + ((1 * ($mul37 << 2) | 0) + 15 & -16) | 0;
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$subframe$addr >> 2] | 0)) break;
    HEAPF32[$vla39 + ((HEAP32[$j >> 2] | 0) * 3 << 2) >> 2] = +HEAPF32[$vla + (HEAP32[$j >> 2] << 2) >> 2];
    HEAPF32[$vla39 + (((HEAP32[$j >> 2] | 0) * 3 | 0) + 1 << 2) >> 2] = +HEAPF32[$vla + (HEAP32[$j >> 2] << 2) >> 2];
    HEAPF32[$vla39 + (((HEAP32[$j >> 2] | 0) * 3 | 0) + 2 << 2) >> 2] = +HEAPF32[$vla + (HEAP32[$j >> 2] << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   +_silk_resampler_down2_hp(HEAP32[$S$addr >> 2] | 0, HEAP32[$y$addr >> 2] | 0, $vla39, (HEAP32[$subframe$addr >> 2] | 0) * 3 | 0);
   _llvm_stackrestore(HEAP32[$saved_stack38 >> 2] | 0);
  }
 } while (0);
 HEAPF32[$retval >> 2] = +HEAPF32[$ret >> 2];
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 $56 = +HEAPF32[$retval >> 2];
 STACKTOP = sp;
 return +$56;
}

function _silk_process_gains_FLP($psEnc, $psEncCtrl, $condCoding) {
 $psEnc = $psEnc | 0;
 $psEncCtrl = $psEncCtrl | 0;
 $condCoding = $condCoding | 0;
 var $15 = 0.0, $38 = 0, $InvMaxSqrVal = 0, $arrayidx = 0, $condCoding$addr = 0, $gain = 0, $k = 0, $pGains_Q16 = 0, $psEnc$addr = 0, $psEncCtrl$addr = 0, $psShapeSt = 0, $quant_offset = 0, $s = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $psEnc$addr = sp + 48 | 0;
 $psEncCtrl$addr = sp + 44 | 0;
 $condCoding$addr = sp + 40 | 0;
 $psShapeSt = sp + 36 | 0;
 $k = sp + 32 | 0;
 $pGains_Q16 = sp + 16 | 0;
 $s = sp + 12 | 0;
 $InvMaxSqrVal = sp + 8 | 0;
 $gain = sp + 4 | 0;
 $quant_offset = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$psEncCtrl$addr >> 2] = $psEncCtrl;
 HEAP32[$condCoding$addr >> 2] = $condCoding;
 HEAP32[$psShapeSt >> 2] = (HEAP32[$psEnc$addr >> 2] | 0) + 7164;
 L1 : do if ((HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0) == 2) {
  HEAPF32[$s >> 2] = 1.0 - +_silk_sigmoid_302((+HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 708 >> 2] - 12.0) * .25) * .5;
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break L1;
   $arrayidx = (HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) | 0;
   HEAPF32[$arrayidx >> 2] = +HEAPF32[$arrayidx >> 2] * +HEAPF32[$s >> 2];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
 } while (0);
 $15 = +Math_pow(2.0, +((21.0 - +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4712 >> 2] | 0) * .0078125) * .33000001311302185));
 HEAPF32[$InvMaxSqrVal >> 2] = $15 / +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4584 >> 2] | 0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  HEAPF32[$gain >> 2] = +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2];
  HEAPF32[$gain >> 2] = +Math_sqrt(+(+HEAPF32[$gain >> 2] * +HEAPF32[$gain >> 2] + +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 712 + (HEAP32[$k >> 2] << 2) >> 2] * +HEAPF32[$InvMaxSqrVal >> 2]));
  HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = +HEAPF32[$gain >> 2] < 32767.0 ? +HEAPF32[$gain >> 2] : 32767.0;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$k >> 2] = 0;
 while (1) {
  $38 = HEAP32[$psEncCtrl$addr >> 2] | 0;
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  HEAP32[$pGains_Q16 + (HEAP32[$k >> 2] << 2) >> 2] = ~~(+HEAPF32[$38 + (HEAP32[$k >> 2] << 2) >> 2] * 65536.0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 _memcpy($38 + 728 | 0, $pGains_Q16 | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] << 2 | 0) | 0;
 HEAP8[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 744 >> 0] = HEAP8[HEAP32[$psShapeSt >> 2] >> 0] | 0;
 _silk_gains_quant((HEAP32[$psEnc$addr >> 2] | 0) + 4732 | 0, $pGains_Q16, HEAP32[$psShapeSt >> 2] | 0, (HEAP32[$condCoding$addr >> 2] | 0) == 2 & 1, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = +(HEAP32[$pGains_Q16 + (HEAP32[$k >> 2] << 2) >> 2] | 0) / 65536.0;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 if ((HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] | 0) == 2) HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 30 >> 0] = +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 708 >> 2] + +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4708 >> 2] | 0) * .000030517578125 > 1.0 ? 0 : 1;
 HEAPF32[$quant_offset >> 2] = +(HEAP16[22956 + (HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] >> 1 << 2) + (HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 30 >> 0] << 1) >> 1] | 0) / 1024.0;
 HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 692 >> 2] = +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4624 >> 2] | 0) * -.05000000074505806 + 1.2000000476837158 + +(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4528 >> 2] | 0) * -.20000000298023224 * .00390625 + +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 696 >> 2] * -.10000000149011612 + +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 700 >> 2] * -.20000000298023224 + +HEAPF32[$quant_offset >> 2] * .800000011920929;
 STACKTOP = sp;
 return;
}

function _silk_P_Ana_calc_corr_st3($cross_corr_st3, $frame, $start_lag, $sf_length, $nb_subfr, $complexity, $arch) {
 $cross_corr_st3 = $cross_corr_st3 | 0;
 $frame = $frame | 0;
 $start_lag = $start_lag | 0;
 $sf_length = $sf_length | 0;
 $nb_subfr = $nb_subfr | 0;
 $complexity = $complexity | 0;
 $arch = $arch | 0;
 var $Lag_CB_ptr = 0, $Lag_range_ptr = 0, $arch$addr = 0, $cbk_size = 0, $complexity$addr = 0, $cross_corr_st3$addr = 0, $delta = 0, $frame$addr = 0, $i = 0, $idx = 0, $j = 0, $k = 0, $lag_counter = 0, $lag_high = 0, $lag_low = 0, $mul32 = 0, $nb_cbk_search = 0, $nb_subfr$addr = 0, $scratch_mem = 0, $sf_length$addr = 0, $start_lag$addr = 0, $target_ptr = 0, $xcorr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 $cross_corr_st3$addr = sp + 252 | 0;
 $frame$addr = sp + 248 | 0;
 $start_lag$addr = sp + 244 | 0;
 $sf_length$addr = sp + 240 | 0;
 $nb_subfr$addr = sp + 236 | 0;
 $complexity$addr = sp + 232 | 0;
 $arch$addr = sp + 228 | 0;
 $target_ptr = sp + 224 | 0;
 $i = sp + 220 | 0;
 $j = sp + 216 | 0;
 $k = sp + 212 | 0;
 $lag_counter = sp + 208 | 0;
 $lag_low = sp + 204 | 0;
 $lag_high = sp + 200 | 0;
 $nb_cbk_search = sp + 196 | 0;
 $delta = sp + 192 | 0;
 $idx = sp + 188 | 0;
 $cbk_size = sp + 184 | 0;
 $scratch_mem = sp + 96 | 0;
 $xcorr = sp + 8 | 0;
 $Lag_range_ptr = sp + 4 | 0;
 $Lag_CB_ptr = sp;
 HEAP32[$cross_corr_st3$addr >> 2] = $cross_corr_st3;
 HEAP32[$frame$addr >> 2] = $frame;
 HEAP32[$start_lag$addr >> 2] = $start_lag;
 HEAP32[$sf_length$addr >> 2] = $sf_length;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$complexity$addr >> 2] = $complexity;
 HEAP32[$arch$addr >> 2] = $arch;
 if ((HEAP32[$nb_subfr$addr >> 2] | 0) == 4) {
  HEAP32[$Lag_range_ptr >> 2] = 35473 + (HEAP32[$complexity$addr >> 2] << 3);
  HEAP32[$Lag_CB_ptr >> 2] = 35337;
  HEAP32[$nb_cbk_search >> 2] = HEAP8[35497 + (HEAP32[$complexity$addr >> 2] | 0) >> 0];
  HEAP32[$cbk_size >> 2] = 34;
 } else {
  HEAP32[$Lag_range_ptr >> 2] = 35289;
  HEAP32[$Lag_CB_ptr >> 2] = 35265;
  HEAP32[$nb_cbk_search >> 2] = 12;
  HEAP32[$cbk_size >> 2] = 12;
 }
 HEAP32[$target_ptr >> 2] = (HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$sf_length$addr >> 2] << 2 << 2);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  HEAP32[$lag_counter >> 2] = 0;
  HEAP32[$lag_low >> 2] = HEAP8[(HEAP32[$Lag_range_ptr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 0) >> 0];
  HEAP32[$lag_high >> 2] = HEAP8[(HEAP32[$Lag_range_ptr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 1) >> 0];
  _celt_pitch_xcorr_c(HEAP32[$target_ptr >> 2] | 0, (HEAP32[$target_ptr >> 2] | 0) + (0 - (HEAP32[$start_lag$addr >> 2] | 0) << 2) + (0 - (HEAP32[$lag_high >> 2] | 0) << 2) | 0, $xcorr, HEAP32[$sf_length$addr >> 2] | 0, (HEAP32[$lag_high >> 2] | 0) - (HEAP32[$lag_low >> 2] | 0) + 1 | 0, HEAP32[$arch$addr >> 2] | 0);
  HEAP32[$j >> 2] = HEAP32[$lag_low >> 2];
  while (1) {
   if ((HEAP32[$j >> 2] | 0) > (HEAP32[$lag_high >> 2] | 0)) break;
   HEAPF32[$scratch_mem + (HEAP32[$lag_counter >> 2] << 2) >> 2] = +HEAPF32[$xcorr + ((HEAP32[$lag_high >> 2] | 0) - (HEAP32[$j >> 2] | 0) << 2) >> 2];
   HEAP32[$lag_counter >> 2] = (HEAP32[$lag_counter >> 2] | 0) + 1;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$delta >> 2] = HEAP8[(HEAP32[$Lag_range_ptr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 0) >> 0];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$nb_cbk_search >> 2] | 0)) break;
   $mul32 = Math_imul(HEAP32[$k >> 2] | 0, HEAP32[$cbk_size >> 2] | 0) | 0;
   HEAP32[$idx >> 2] = (HEAP8[(HEAP32[$Lag_CB_ptr >> 2] | 0) + ($mul32 + (HEAP32[$i >> 2] | 0)) >> 0] | 0) - (HEAP32[$delta >> 2] | 0);
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= 5) break;
    HEAPF32[(HEAP32[$cross_corr_st3$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) * 680 | 0) + ((HEAP32[$i >> 2] | 0) * 20 | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$scratch_mem + ((HEAP32[$idx >> 2] | 0) + (HEAP32[$j >> 2] | 0) << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$target_ptr >> 2] = (HEAP32[$target_ptr >> 2] | 0) + (HEAP32[$sf_length$addr >> 2] << 2);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _stereo_fade($in, $out, $g1, $g2, $overlap48, $frame_size, $channels, $window, $Fs) {
 $in = $in | 0;
 $out = $out | 0;
 $g1 = +$g1;
 $g2 = +$g2;
 $overlap48 = $overlap48 | 0;
 $frame_size = $frame_size | 0;
 $channels = $channels | 0;
 $window = $window | 0;
 $Fs = $Fs | 0;
 var $10 = 0.0, $22 = 0.0, $32 = 0.0, $40 = 0.0, $51 = 0.0, $61 = 0.0, $69 = 0.0, $Fs$addr = 0, $channels$addr = 0, $diff = 0, $diff33 = 0, $frame_size$addr = 0, $g = 0, $g1$addr = 0, $g2$addr = 0, $i = 0, $in$addr = 0, $inc = 0, $out$addr = 0, $overlap = 0, $overlap48$addr = 0, $w = 0, $window$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $in$addr = sp + 60 | 0;
 $out$addr = sp + 56 | 0;
 $g1$addr = sp + 52 | 0;
 $g2$addr = sp + 48 | 0;
 $overlap48$addr = sp + 44 | 0;
 $frame_size$addr = sp + 40 | 0;
 $channels$addr = sp + 36 | 0;
 $window$addr = sp + 32 | 0;
 $Fs$addr = sp + 28 | 0;
 $i = sp + 24 | 0;
 $overlap = sp + 20 | 0;
 $inc = sp + 16 | 0;
 $diff = sp + 12 | 0;
 $g = sp + 8 | 0;
 $w = sp + 4 | 0;
 $diff33 = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$out$addr >> 2] = $out;
 HEAPF32[$g1$addr >> 2] = $g1;
 HEAPF32[$g2$addr >> 2] = $g2;
 HEAP32[$overlap48$addr >> 2] = $overlap48;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$window$addr >> 2] = $window;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$inc >> 2] = 48e3 / (HEAP32[$Fs$addr >> 2] | 0) | 0;
 HEAP32[$overlap >> 2] = (HEAP32[$overlap48$addr >> 2] | 0) / (HEAP32[$inc >> 2] | 0) | 0;
 HEAPF32[$g1$addr >> 2] = 1.0 - +HEAPF32[$g1$addr >> 2];
 HEAPF32[$g2$addr >> 2] = 1.0 - +HEAPF32[$g2$addr >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$overlap >> 2] | 0)) break;
  $10 = +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$inc >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[$w >> 2] = $10 * +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$inc >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[$g >> 2] = +HEAPF32[$w >> 2] * +HEAPF32[$g2$addr >> 2] + (1.0 - +HEAPF32[$w >> 2]) * +HEAPF32[$g1$addr >> 2];
  $22 = +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[$diff >> 2] = ($22 - +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) + 1 << 2) >> 2]) * .5;
  HEAPF32[$diff >> 2] = +HEAPF32[$g >> 2] * +HEAPF32[$diff >> 2];
  $32 = +HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) << 2) >> 2] = $32 - +HEAPF32[$diff >> 2];
  $40 = +HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) + 1 << 2) >> 2];
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) + 1 << 2) >> 2] = $40 + +HEAPF32[$diff >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$frame_size$addr >> 2] | 0)) break;
  $51 = +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[$diff33 >> 2] = ($51 - +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) + 1 << 2) >> 2]) * .5;
  HEAPF32[$diff33 >> 2] = +HEAPF32[$g2$addr >> 2] * +HEAPF32[$diff33 >> 2];
  $61 = +HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) << 2) >> 2] = $61 - +HEAPF32[$diff33 >> 2];
  $69 = +HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) + 1 << 2) >> 2];
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) + 1 << 2) >> 2] = $69 + +HEAPF32[$diff33 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _deemphasis($in, $pcm, $N, $C, $downsample, $coef, $mem, $accum) {
 $in = $in | 0;
 $pcm = $pcm | 0;
 $N = $N | 0;
 $C = $C | 0;
 $downsample = $downsample | 0;
 $coef = $coef | 0;
 $mem = $mem | 0;
 $accum = $accum | 0;
 var $9 = 0, $C$addr = 0, $N$addr = 0, $Nd = 0, $accum$addr = 0, $apply_downsampling = 0, $c = 0, $cmp6 = 0, $coef$addr = 0, $coef0 = 0, $downsample$addr = 0, $in$addr = 0, $inc42 = 0, $j = 0, $m = 0, $mem$addr = 0, $mul35 = 0.0, $pcm$addr = 0, $saved_stack = 0, $tmp = 0, $tmp15 = 0, $vla = 0, $x = 0, $y = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $in$addr = sp + 72 | 0;
 $pcm$addr = sp + 68 | 0;
 $N$addr = sp + 64 | 0;
 $C$addr = sp + 60 | 0;
 $downsample$addr = sp + 56 | 0;
 $coef$addr = sp + 52 | 0;
 $mem$addr = sp + 48 | 0;
 $accum$addr = sp + 44 | 0;
 $c = sp + 40 | 0;
 $Nd = sp + 36 | 0;
 $apply_downsampling = sp + 32 | 0;
 $coef0 = sp + 28 | 0;
 $saved_stack = sp + 24 | 0;
 $j = sp + 20 | 0;
 $x = sp + 16 | 0;
 $y = sp + 12 | 0;
 $m = sp + 8 | 0;
 $tmp = sp + 4 | 0;
 $tmp15 = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$downsample$addr >> 2] = $downsample;
 HEAP32[$coef$addr >> 2] = $coef;
 HEAP32[$mem$addr >> 2] = $mem;
 HEAP32[$accum$addr >> 2] = $accum;
 HEAP32[$apply_downsampling >> 2] = 0;
 if (!((HEAP32[$downsample$addr >> 2] | 0) == 1 & (HEAP32[$C$addr >> 2] | 0) == 2 ^ 1 | (HEAP32[$accum$addr >> 2] | 0) != 0)) {
  _deemphasis_stereo_simple(HEAP32[$in$addr >> 2] | 0, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, +HEAPF32[HEAP32[$coef$addr >> 2] >> 2], HEAP32[$mem$addr >> 2] | 0);
  STACKTOP = sp;
  return;
 }
 $9 = HEAP32[$N$addr >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($9 << 2) | 0) + 15 & -16) | 0;
 HEAPF32[$coef0 >> 2] = +HEAPF32[HEAP32[$coef$addr >> 2] >> 2];
 HEAP32[$Nd >> 2] = (HEAP32[$N$addr >> 2] | 0) / (HEAP32[$downsample$addr >> 2] | 0) | 0;
 HEAP32[$c >> 2] = 0;
 do {
  HEAPF32[$m >> 2] = +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2) >> 2];
  HEAP32[$x >> 2] = HEAP32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2) >> 2];
  HEAP32[$y >> 2] = (HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2);
  $cmp6 = (HEAP32[$downsample$addr >> 2] | 0) > 1;
  HEAP32[$j >> 2] = 0;
  L7 : do if ($cmp6) {
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
    HEAPF32[$tmp >> 2] = +HEAPF32[(HEAP32[$x >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] + 1.0000000031710769e-30 + +HEAPF32[$m >> 2];
    HEAPF32[$m >> 2] = +HEAPF32[$coef0 >> 2] * +HEAPF32[$tmp >> 2];
    HEAPF32[$vla + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$tmp >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$apply_downsampling >> 2] = 1;
  } else while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break L7;
   HEAPF32[$tmp15 >> 2] = +HEAPF32[(HEAP32[$x >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] + 1.0000000031710769e-30 + +HEAPF32[$m >> 2];
   HEAPF32[$m >> 2] = +HEAPF32[$coef0 >> 2] * +HEAPF32[$tmp15 >> 2];
   HEAPF32[(HEAP32[$y >> 2] | 0) + ((Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] = +HEAPF32[$tmp15 >> 2] * .000030517578125;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  } while (0);
  HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + (HEAP32[$c >> 2] << 2) >> 2] = +HEAPF32[$m >> 2];
  L16 : do if (HEAP32[$apply_downsampling >> 2] | 0) {
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$Nd >> 2] | 0)) break L16;
    $mul35 = +HEAPF32[$vla + ((Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$downsample$addr >> 2] | 0) | 0) << 2) >> 2] * .000030517578125;
    HEAPF32[(HEAP32[$y >> 2] | 0) + ((Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$C$addr >> 2] | 0) | 0) << 2) >> 2] = $mul35;
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
  } while (0);
  $inc42 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc42;
 } while (($inc42 | 0) < (HEAP32[$C$addr >> 2] | 0));
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _celt_preemphasis($pcmp, $inp, $N, $CC, $upsample, $coef, $mem, $clip) {
 $pcmp = $pcmp | 0;
 $inp = $inp | 0;
 $N = $N | 0;
 $CC = $CC | 0;
 $upsample = $upsample | 0;
 $coef = $coef | 0;
 $mem = $mem | 0;
 $clip = $clip | 0;
 var $CC$addr = 0, $N$addr = 0, $Nu = 0, $clip$addr = 0, $coef$addr = 0, $coef0 = 0, $cond = 0.0, $cond47 = 0.0, $i = 0, $inp$addr = 0, $m = 0, $mem$addr = 0, $mul18 = 0.0, $pcmp$addr = 0, $upsample$addr = 0, $x = 0, $x57 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $pcmp$addr = sp + 52 | 0;
 $inp$addr = sp + 48 | 0;
 $N$addr = sp + 44 | 0;
 $CC$addr = sp + 40 | 0;
 $upsample$addr = sp + 36 | 0;
 $coef$addr = sp + 32 | 0;
 $mem$addr = sp + 28 | 0;
 $clip$addr = sp + 24 | 0;
 $i = sp + 20 | 0;
 $coef0 = sp + 16 | 0;
 $m = sp + 12 | 0;
 $Nu = sp + 8 | 0;
 $x = sp + 4 | 0;
 $x57 = sp;
 HEAP32[$pcmp$addr >> 2] = $pcmp;
 HEAP32[$inp$addr >> 2] = $inp;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$CC$addr >> 2] = $CC;
 HEAP32[$upsample$addr >> 2] = $upsample;
 HEAP32[$coef$addr >> 2] = $coef;
 HEAP32[$mem$addr >> 2] = $mem;
 HEAP32[$clip$addr >> 2] = $clip;
 HEAPF32[$coef0 >> 2] = +HEAPF32[HEAP32[$coef$addr >> 2] >> 2];
 HEAPF32[$m >> 2] = +HEAPF32[HEAP32[$mem$addr >> 2] >> 2];
 if (!(((HEAP32[$upsample$addr >> 2] | 0) == 1 ? +HEAPF32[(HEAP32[$coef$addr >> 2] | 0) + 4 >> 2] == 0.0 : 0) ^ 1 | (HEAP32[$clip$addr >> 2] | 0) != 0)) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
   HEAPF32[$x >> 2] = +HEAPF32[(HEAP32[$pcmp$addr >> 2] | 0) + ((Math_imul(HEAP32[$CC$addr >> 2] | 0, HEAP32[$i >> 2] | 0) | 0) << 2) >> 2] * 32768.0;
   HEAPF32[(HEAP32[$inp$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$x >> 2] - +HEAPF32[$m >> 2];
   HEAPF32[$m >> 2] = +HEAPF32[$coef0 >> 2] * +HEAPF32[$x >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAPF32[HEAP32[$mem$addr >> 2] >> 2] = +HEAPF32[$m >> 2];
  STACKTOP = sp;
  return;
 }
 HEAP32[$Nu >> 2] = (HEAP32[$N$addr >> 2] | 0) / (HEAP32[$upsample$addr >> 2] | 0) | 0;
 if ((HEAP32[$upsample$addr >> 2] | 0) != 1) _memset(HEAP32[$inp$addr >> 2] | 0, 0, HEAP32[$N$addr >> 2] << 2 | 0) | 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$Nu >> 2] | 0)) break;
  $mul18 = +HEAPF32[(HEAP32[$pcmp$addr >> 2] | 0) + ((Math_imul(HEAP32[$CC$addr >> 2] | 0, HEAP32[$i >> 2] | 0) | 0) << 2) >> 2] * 32768.0;
  HEAPF32[(HEAP32[$inp$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$upsample$addr >> 2] | 0) | 0) << 2) >> 2] = $mul18;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 L16 : do if (HEAP32[$clip$addr >> 2] | 0) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$Nu >> 2] | 0)) break L16;
   if (65536.0 < +HEAPF32[(HEAP32[$inp$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$upsample$addr >> 2] | 0) | 0) << 2) >> 2]) $cond = 65536.0; else $cond = +HEAPF32[(HEAP32[$inp$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$upsample$addr >> 2] | 0) | 0) << 2) >> 2];
   if (-65536.0 > $cond) $cond47 = -65536.0; else if (65536.0 < +HEAPF32[(HEAP32[$inp$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$upsample$addr >> 2] | 0) | 0) << 2) >> 2]) $cond47 = 65536.0; else $cond47 = +HEAPF32[(HEAP32[$inp$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$upsample$addr >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[(HEAP32[$inp$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$upsample$addr >> 2] | 0) | 0) << 2) >> 2] = $cond47;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAPF32[$x57 >> 2] = +HEAPF32[(HEAP32[$inp$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[(HEAP32[$inp$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$x57 >> 2] - +HEAPF32[$m >> 2];
  HEAPF32[$m >> 2] = +HEAPF32[$coef0 >> 2] * +HEAPF32[$x57 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[HEAP32[$mem$addr >> 2] >> 2] = +HEAPF32[$m >> 2];
 STACKTOP = sp;
 return;
}

function _silk_decode_frame($psDec, $psRangeDec, $pOut, $pN, $lostFlag, $condCoding, $arch) {
 $psDec = $psDec | 0;
 $psRangeDec = $psRangeDec | 0;
 $pOut = $pOut | 0;
 $pN = $pN | 0;
 $lostFlag = $lostFlag | 0;
 $condCoding = $condCoding | 0;
 $arch = $arch | 0;
 var $L = 0, $and = 0, $arch$addr = 0, $condCoding$addr = 0, $lostFlag$addr = 0, $mv_len = 0, $pN$addr = 0, $pOut$addr = 0, $psDec$addr = 0, $psDecCtrl = 0, $psRangeDec$addr = 0, $ret = 0, $saved_stack = 0, $vla = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 $psDec$addr = sp + 180 | 0;
 $psRangeDec$addr = sp + 176 | 0;
 $pOut$addr = sp + 172 | 0;
 $pN$addr = sp + 168 | 0;
 $lostFlag$addr = sp + 164 | 0;
 $condCoding$addr = sp + 160 | 0;
 $arch$addr = sp + 156 | 0;
 $L = sp + 152 | 0;
 $mv_len = sp + 148 | 0;
 $ret = sp + 144 | 0;
 $psDecCtrl = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$psRangeDec$addr >> 2] = $psRangeDec;
 HEAP32[$pOut$addr >> 2] = $pOut;
 HEAP32[$pN$addr >> 2] = $pN;
 HEAP32[$lostFlag$addr >> 2] = $lostFlag;
 HEAP32[$condCoding$addr >> 2] = $condCoding;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$L >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2];
 HEAP32[$psDecCtrl + 136 >> 2] = 0;
 do if (!(HEAP32[$lostFlag$addr >> 2] | 0)) label = 4; else {
  if ((HEAP32[$lostFlag$addr >> 2] | 0) == 2) if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2420 + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2388 >> 2] << 2) >> 2] | 0) == 1) {
   label = 4;
   break;
  }
  HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4164 >> 2];
  _silk_PLC(HEAP32[$psDec$addr >> 2] | 0, $psDecCtrl, HEAP32[$pOut$addr >> 2] | 0, 1, HEAP32[$arch$addr >> 2] | 0);
 } while (0);
 if ((label | 0) == 4) {
  $and = (HEAP32[$L >> 2] | 0) + 16 - 1 & -16;
  HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
  $vla = STACKTOP;
  STACKTOP = STACKTOP + ((1 * ($and << 1) | 0) + 15 & -16) | 0;
  _silk_decode_indices(HEAP32[$psDec$addr >> 2] | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2388 >> 2] | 0, HEAP32[$lostFlag$addr >> 2] | 0, HEAP32[$condCoding$addr >> 2] | 0);
  _silk_decode_pulses(HEAP32[$psRangeDec$addr >> 2] | 0, $vla, HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0] | 0, HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 30 >> 0] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] | 0);
  _silk_decode_parameters(HEAP32[$psDec$addr >> 2] | 0, $psDecCtrl, HEAP32[$condCoding$addr >> 2] | 0);
  _silk_decode_core(HEAP32[$psDec$addr >> 2] | 0, $psDecCtrl, HEAP32[$pOut$addr >> 2] | 0, $vla, HEAP32[$arch$addr >> 2] | 0);
  _silk_PLC(HEAP32[$psDec$addr >> 2] | 0, $psDecCtrl, HEAP32[$pOut$addr >> 2] | 0, 0, HEAP32[$arch$addr >> 2] | 0);
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4160 >> 2] = 0;
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4164 >> 2] = HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2736 + 29 >> 0];
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2376 >> 2] = 0;
  _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 }
 HEAP32[$mv_len >> 2] = (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] | 0) - (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] | 0);
 _memmove((HEAP32[$psDec$addr >> 2] | 0) + 1348 | 0, (HEAP32[$psDec$addr >> 2] | 0) + 1348 + (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] << 1) | 0, HEAP32[$mv_len >> 2] << 1 | 0) | 0;
 _memcpy((HEAP32[$psDec$addr >> 2] | 0) + 1348 + (HEAP32[$mv_len >> 2] << 1) | 0, HEAP32[$pOut$addr >> 2] | 0, HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] << 1 | 0) | 0;
 _silk_CNG(HEAP32[$psDec$addr >> 2] | 0, $psDecCtrl, HEAP32[$pOut$addr >> 2] | 0, HEAP32[$L >> 2] | 0);
 _silk_PLC_glue_frames(HEAP32[$psDec$addr >> 2] | 0, HEAP32[$pOut$addr >> 2] | 0, HEAP32[$L >> 2] | 0);
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2308 >> 2] = HEAP32[$psDecCtrl + ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) - 1 << 2) >> 2];
 HEAP32[HEAP32[$pN$addr >> 2] >> 2] = HEAP32[$L >> 2];
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _silk_process_NLSFs($psEncC, $PredCoef_Q12, $pNLSF_Q15, $prev_NLSFq_Q15) {
 $psEncC = $psEncC | 0;
 $PredCoef_Q12 = $PredCoef_Q12 | 0;
 $pNLSF_Q15 = $pNLSF_Q15 | 0;
 $prev_NLSFq_Q15 = $prev_NLSFq_Q15 | 0;
 var $15 = 0, $NLSF_mu_Q20 = 0, $PredCoef_Q12$addr = 0, $conv45 = 0, $doInterpolate = 0, $i = 0, $i_sqr_Q15 = 0, $mul = 0, $pNLSF0_temp_Q15 = 0, $pNLSFW0_temp_QW = 0, $pNLSFW_QW = 0, $pNLSF_Q15$addr = 0, $prev_NLSFq_Q15$addr = 0, $psEncC$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $psEncC$addr = sp + 24 | 0;
 $PredCoef_Q12$addr = sp + 20 | 0;
 $pNLSF_Q15$addr = sp + 16 | 0;
 $prev_NLSFq_Q15$addr = sp + 12 | 0;
 $i = sp + 8 | 0;
 $doInterpolate = sp + 4 | 0;
 $NLSF_mu_Q20 = sp;
 $i_sqr_Q15 = sp + 128 | 0;
 $pNLSF0_temp_Q15 = sp + 96 | 0;
 $pNLSFW_QW = sp + 64 | 0;
 $pNLSFW0_temp_QW = sp + 32 | 0;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$PredCoef_Q12$addr >> 2] = $PredCoef_Q12;
 HEAP32[$pNLSF_Q15$addr >> 2] = $pNLSF_Q15;
 HEAP32[$prev_NLSFq_Q15$addr >> 2] = $prev_NLSFq_Q15;
 $mul = Math_imul(-5, (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4528 >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$NLSF_mu_Q20 >> 2] = 3146 + ($mul + (((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4528 >> 2] & 65535) << 16 >> 16) * 59246 >> 16));
 if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0) == 2) HEAP32[$NLSF_mu_Q20 >> 2] = (HEAP32[$NLSF_mu_Q20 >> 2] | 0) + (HEAP32[$NLSF_mu_Q20 >> 2] >> 1);
 _silk_NLSF_VQ_weights_laroia($pNLSFW_QW, HEAP32[$pNLSF_Q15$addr >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
 if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4628 >> 2] | 0) == 1) $15 = (HEAP8[(HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 31 >> 0] | 0) < 4; else $15 = 0;
 HEAP32[$doInterpolate >> 2] = $15 & 1;
 L7 : do if (HEAP32[$doInterpolate >> 2] | 0) {
  _silk_interpolate($pNLSF0_temp_Q15, HEAP32[$prev_NLSFq_Q15$addr >> 2] | 0, HEAP32[$pNLSF_Q15$addr >> 2] | 0, HEAP8[(HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 31 >> 0] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
  _silk_NLSF_VQ_weights_laroia($pNLSFW0_temp_QW, $pNLSF0_temp_Q15, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
  HEAP16[$i_sqr_Q15 >> 1] = (Math_imul(HEAP8[(HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 31 >> 0] << 16 >> 16, HEAP8[(HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 31 >> 0] << 16 >> 16) | 0) << 11;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0)) break L7;
   $conv45 = (HEAP16[$pNLSFW_QW + (HEAP32[$i >> 2] << 1) >> 1] >> 1) + ((Math_imul(HEAP16[$pNLSFW0_temp_QW + (HEAP32[$i >> 2] << 1) >> 1] | 0, HEAP16[$i_sqr_Q15 >> 1] | 0) | 0) >> 16) & 65535;
   HEAP16[$pNLSFW_QW + (HEAP32[$i >> 2] << 1) >> 1] = $conv45;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } while (0);
 _silk_NLSF_encode((HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 8 | 0, HEAP32[$pNLSF_Q15$addr >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4688 >> 2] | 0, $pNLSFW_QW, HEAP32[$NLSF_mu_Q20 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4656 >> 2] | 0, HEAP8[(HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 29 >> 0] | 0) | 0;
 _silk_NLSF2A((HEAP32[$PredCoef_Q12$addr >> 2] | 0) + 32 | 0, HEAP32[$pNLSF_Q15$addr >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 5088 >> 2] | 0);
 if (HEAP32[$doInterpolate >> 2] | 0) {
  _silk_interpolate($pNLSF0_temp_Q15, HEAP32[$prev_NLSFq_Q15$addr >> 2] | 0, HEAP32[$pNLSF_Q15$addr >> 2] | 0, HEAP8[(HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 31 >> 0] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
  _silk_NLSF2A(HEAP32[$PredCoef_Q12$addr >> 2] | 0, $pNLSF0_temp_Q15, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 5088 >> 2] | 0);
  STACKTOP = sp;
  return;
 } else {
  _memcpy(HEAP32[$PredCoef_Q12$addr >> 2] | 0, (HEAP32[$PredCoef_Q12$addr >> 2] | 0) + 32 | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] << 1 | 0) | 0;
  STACKTOP = sp;
  return;
 }
}

function _silk_HP_variable_cutoff($state_Fxx) {
 $state_Fxx = $state_Fxx | 0;
 var $10 = 0, $15 = 0, $20 = 0, $39 = 0, $41 = 0, $45 = 0, $add77 = 0, $and35 = 0, $cmp83 = 0, $cond134 = 0, $cond58 = 0, $delta_freq_Q7 = 0, $mul20 = 0, $mul26 = 0, $mul66 = 0, $mul7 = 0, $pitch_freq_Hz_Q16 = 0, $pitch_freq_log_Q7 = 0, $psEncC1 = 0, $quality_Q15 = 0, $shl80 = 0, $shr14 = 0, $state_Fxx$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $state_Fxx$addr = sp + 20 | 0;
 $quality_Q15 = sp + 16 | 0;
 $pitch_freq_Hz_Q16 = sp + 12 | 0;
 $pitch_freq_log_Q7 = sp + 8 | 0;
 $delta_freq_Q7 = sp + 4 | 0;
 $psEncC1 = sp;
 HEAP32[$state_Fxx$addr >> 2] = $state_Fxx;
 HEAP32[$psEncC1 >> 2] = HEAP32[$state_Fxx$addr >> 2];
 if ((HEAP8[(HEAP32[$psEncC1 >> 2] | 0) + 4537 >> 0] | 0) != 2) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$pitch_freq_Hz_Q16 >> 2] = ((HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 4572 >> 2] | 0) * 1e3 << 16 | 0) / (HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 4540 >> 2] | 0) | 0;
 HEAP32[$pitch_freq_log_Q7 >> 2] = (_silk_lin2log(HEAP32[$pitch_freq_Hz_Q16 >> 2] | 0) | 0) - 2048;
 HEAP32[$quality_Q15 >> 2] = HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 4692 >> 2];
 $10 = HEAP32[$pitch_freq_log_Q7 >> 2] | 0;
 $mul7 = Math_imul(0 - (HEAP32[$quality_Q15 >> 2] | 0) << 2 >> 16, (HEAP32[$quality_Q15 >> 2] & 65535) << 16 >> 16) | 0;
 $shr14 = $mul7 + ((Math_imul(0 - (HEAP32[$quality_Q15 >> 2] | 0) << 2 & 65535, (HEAP32[$quality_Q15 >> 2] & 65535) << 16 >> 16) | 0) >> 16) >> 16;
 $15 = HEAP32[$pitch_freq_log_Q7 >> 2] | 0;
 $mul20 = Math_imul($shr14, ($15 - ((_silk_lin2log(3932160) | 0) - 2048) & 65535) << 16 >> 16) | 0;
 $mul26 = Math_imul(0 - (HEAP32[$quality_Q15 >> 2] | 0) << 2 >> 16, (HEAP32[$quality_Q15 >> 2] & 65535) << 16 >> 16) | 0;
 $and35 = $mul26 + ((Math_imul(0 - (HEAP32[$quality_Q15 >> 2] | 0) << 2 & 65535, (HEAP32[$quality_Q15 >> 2] & 65535) << 16 >> 16) | 0) >> 16) & 65535;
 $20 = HEAP32[$pitch_freq_log_Q7 >> 2] | 0;
 HEAP32[$pitch_freq_log_Q7 >> 2] = $10 + ($mul20 + ((Math_imul($and35, ($20 - ((_silk_lin2log(3932160) | 0) - 2048) & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$delta_freq_Q7 >> 2] = (HEAP32[$pitch_freq_log_Q7 >> 2] | 0) - (HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 8 >> 2] >> 8);
 if ((HEAP32[$delta_freq_Q7 >> 2] | 0) < 0) HEAP32[$delta_freq_Q7 >> 2] = (HEAP32[$delta_freq_Q7 >> 2] | 0) * 3;
 if ((HEAP32[$delta_freq_Q7 >> 2] | 0) > 51) $cond58 = 51; else $cond58 = (HEAP32[$delta_freq_Q7 >> 2] | 0) < -51 ? -51 : HEAP32[$delta_freq_Q7 >> 2] | 0;
 HEAP32[$delta_freq_Q7 >> 2] = $cond58;
 $mul66 = ((Math_imul((HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 4528 >> 2] & 65535) << 16 >> 16, (HEAP32[$delta_freq_Q7 >> 2] & 65535) << 16 >> 16) | 0) >> 16) * 6554 | 0;
 $add77 = (HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 8 >> 2] | 0) + ($mul66 + (((Math_imul((HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 4528 >> 2] & 65535) << 16 >> 16, (HEAP32[$delta_freq_Q7 >> 2] & 65535) << 16 >> 16) | 0) & 65535) * 6554 >> 16)) | 0;
 HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 8 >> 2] = $add77;
 $shl80 = (_silk_lin2log(60) | 0) << 8;
 $cmp83 = ($shl80 | 0) > ((_silk_lin2log(100) | 0) << 8 | 0);
 $39 = HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 8 >> 2] | 0;
 do if ($cmp83) {
  if (($39 | 0) > ((_silk_lin2log(60) | 0) << 8 | 0)) {
   $cond134 = (_silk_lin2log(60) | 0) << 8;
   break;
  }
  $41 = HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 8 >> 2] | 0;
  if (($41 | 0) < ((_silk_lin2log(100) | 0) << 8 | 0)) {
   $cond134 = (_silk_lin2log(100) | 0) << 8;
   break;
  } else {
   $cond134 = HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 8 >> 2] | 0;
   break;
  }
 } else {
  if (($39 | 0) > ((_silk_lin2log(100) | 0) << 8 | 0)) {
   $cond134 = (_silk_lin2log(100) | 0) << 8;
   break;
  }
  $45 = HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 8 >> 2] | 0;
  if (($45 | 0) < ((_silk_lin2log(60) | 0) << 8 | 0)) {
   $cond134 = (_silk_lin2log(60) | 0) << 8;
   break;
  } else {
   $cond134 = HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 8 >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[(HEAP32[$psEncC1 >> 2] | 0) + 8 >> 2] = $cond134;
 STACKTOP = sp;
 return;
}
function _run_analysis($analysis, $celt_mode, $analysis_pcm, $analysis_frame_size, $frame_size, $c1, $c2, $C, $Fs, $lsb_depth, $downmix, $analysis_info) {
 $analysis = $analysis | 0;
 $celt_mode = $celt_mode | 0;
 $analysis_pcm = $analysis_pcm | 0;
 $analysis_frame_size = $analysis_frame_size | 0;
 $frame_size = $frame_size | 0;
 $c1 = $c1 | 0;
 $c2 = $c2 | 0;
 $C = $C | 0;
 $Fs = $Fs | 0;
 $lsb_depth = $lsb_depth | 0;
 $downmix = $downmix | 0;
 $analysis_info = $analysis_info | 0;
 var $35 = 0, $36 = 0, $37 = 0, $38 = 0, $C$addr = 0, $Fs$addr = 0, $analysis$addr = 0, $analysis_frame_size$addr = 0, $analysis_info$addr = 0, $analysis_offset18 = 0, $analysis_pcm$addr = 0, $c1$addr = 0, $c2$addr = 0, $celt_mode$addr = 0, $cond = 0, $cond13 = 0, $downmix$addr = 0, $frame_size$addr = 0, $lsb_depth$addr = 0, $offset = 0, $pcm_len = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $analysis$addr = sp + 52 | 0;
 $celt_mode$addr = sp + 48 | 0;
 $analysis_pcm$addr = sp + 44 | 0;
 $analysis_frame_size$addr = sp + 40 | 0;
 $frame_size$addr = sp + 36 | 0;
 $c1$addr = sp + 32 | 0;
 $c2$addr = sp + 28 | 0;
 $C$addr = sp + 24 | 0;
 $Fs$addr = sp + 20 | 0;
 $lsb_depth$addr = sp + 16 | 0;
 $downmix$addr = sp + 12 | 0;
 $analysis_info$addr = sp + 8 | 0;
 $offset = sp + 4 | 0;
 $pcm_len = sp;
 HEAP32[$analysis$addr >> 2] = $analysis;
 HEAP32[$celt_mode$addr >> 2] = $celt_mode;
 HEAP32[$analysis_pcm$addr >> 2] = $analysis_pcm;
 HEAP32[$analysis_frame_size$addr >> 2] = $analysis_frame_size;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$c1$addr >> 2] = $c1;
 HEAP32[$c2$addr >> 2] = $c2;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$lsb_depth$addr >> 2] = $lsb_depth;
 HEAP32[$downmix$addr >> 2] = $downmix;
 HEAP32[$analysis_info$addr >> 2] = $analysis_info;
 HEAP32[$analysis_frame_size$addr >> 2] = (HEAP32[$analysis_frame_size$addr >> 2] | 0) - (HEAP32[$analysis_frame_size$addr >> 2] & 1);
 if (!(HEAP32[$analysis_pcm$addr >> 2] | 0)) {
  $35 = HEAP32[$analysis_info$addr >> 2] | 0;
  HEAP32[$35 >> 2] = 0;
  $36 = HEAP32[$analysis$addr >> 2] | 0;
  $37 = HEAP32[$analysis_info$addr >> 2] | 0;
  $38 = HEAP32[$frame_size$addr >> 2] | 0;
  _tonality_get_info($36, $37, $38);
  STACKTOP = sp;
  return;
 }
 if ((((HEAP32[$Fs$addr >> 2] | 0) * 95 | 0) / 50 | 0 | 0) < (HEAP32[$analysis_frame_size$addr >> 2] | 0)) $cond = ((HEAP32[$Fs$addr >> 2] | 0) * 95 | 0) / 50 | 0; else $cond = HEAP32[$analysis_frame_size$addr >> 2] | 0;
 HEAP32[$analysis_frame_size$addr >> 2] = $cond;
 HEAP32[$pcm_len >> 2] = (HEAP32[$analysis_frame_size$addr >> 2] | 0) - (HEAP32[(HEAP32[$analysis$addr >> 2] | 0) + 7440 >> 2] | 0);
 HEAP32[$offset >> 2] = HEAP32[(HEAP32[$analysis$addr >> 2] | 0) + 7440 >> 2];
 while (1) {
  if ((HEAP32[$pcm_len >> 2] | 0) <= 0) break;
  if (((HEAP32[$Fs$addr >> 2] | 0) / 50 | 0 | 0) < (HEAP32[$pcm_len >> 2] | 0)) $cond13 = (HEAP32[$Fs$addr >> 2] | 0) / 50 | 0; else $cond13 = HEAP32[$pcm_len >> 2] | 0;
  _tonality_analysis(HEAP32[$analysis$addr >> 2] | 0, HEAP32[$celt_mode$addr >> 2] | 0, HEAP32[$analysis_pcm$addr >> 2] | 0, $cond13, HEAP32[$offset >> 2] | 0, HEAP32[$c1$addr >> 2] | 0, HEAP32[$c2$addr >> 2] | 0, HEAP32[$C$addr >> 2] | 0, HEAP32[$lsb_depth$addr >> 2] | 0, HEAP32[$downmix$addr >> 2] | 0);
  HEAP32[$offset >> 2] = (HEAP32[$offset >> 2] | 0) + ((HEAP32[$Fs$addr >> 2] | 0) / 50 | 0);
  HEAP32[$pcm_len >> 2] = (HEAP32[$pcm_len >> 2] | 0) - ((HEAP32[$Fs$addr >> 2] | 0) / 50 | 0);
 }
 HEAP32[(HEAP32[$analysis$addr >> 2] | 0) + 7440 >> 2] = HEAP32[$analysis_frame_size$addr >> 2];
 $analysis_offset18 = (HEAP32[$analysis$addr >> 2] | 0) + 7440 | 0;
 HEAP32[$analysis_offset18 >> 2] = (HEAP32[$analysis_offset18 >> 2] | 0) - (HEAP32[$frame_size$addr >> 2] | 0);
 $35 = HEAP32[$analysis_info$addr >> 2] | 0;
 HEAP32[$35 >> 2] = 0;
 $36 = HEAP32[$analysis$addr >> 2] | 0;
 $37 = HEAP32[$analysis_info$addr >> 2] | 0;
 $38 = HEAP32[$frame_size$addr >> 2] | 0;
 _tonality_get_info($36, $37, $38);
 STACKTOP = sp;
 return;
}

function _silk_control_encoder($psEnc, $encControl, $allow_bw_switch, $channelNb, $force_fs_kHz) {
 $psEnc = $psEnc | 0;
 $encControl = $encControl | 0;
 $allow_bw_switch = $allow_bw_switch | 0;
 $channelNb = $channelNb | 0;
 $force_fs_kHz = $force_fs_kHz | 0;
 var $70 = 0, $allow_bw_switch$addr = 0, $call = 0, $call36 = 0, $call38 = 0, $call41 = 0, $call45 = 0, $channelNb$addr = 0, $encControl$addr = 0, $force_fs_kHz$addr = 0, $fs_kHz = 0, $psEnc$addr = 0, $ret = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 28 | 0;
 $psEnc$addr = sp + 24 | 0;
 $encControl$addr = sp + 20 | 0;
 $allow_bw_switch$addr = sp + 16 | 0;
 $channelNb$addr = sp + 12 | 0;
 $force_fs_kHz$addr = sp + 8 | 0;
 $fs_kHz = sp + 4 | 0;
 $ret = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$encControl$addr >> 2] = $encControl;
 HEAP32[$allow_bw_switch$addr >> 2] = $allow_bw_switch;
 HEAP32[$channelNb$addr >> 2] = $channelNb;
 HEAP32[$force_fs_kHz$addr >> 2] = $force_fs_kHz;
 HEAP32[$ret >> 2] = 0;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 6072 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 48 >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4672 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 52 >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4552 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 8 >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4560 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 12 >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4564 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 16 >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4568 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 20 >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 6084 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 40 >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5748 >> 2] = HEAP32[HEAP32[$encControl$addr >> 2] >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5752 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 4 >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4532 >> 2] = HEAP32[$allow_bw_switch$addr >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5756 >> 2] = HEAP32[$channelNb$addr >> 2];
 if (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4664 >> 2] | 0) if (!(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4676 >> 2] | 0)) {
  if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4552 >> 2] | 0) != (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4556 >> 2] | 0)) if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) > 0) {
   $call = _silk_setup_resamplers(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4572 >> 2] | 0) | 0;
   HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call;
  }
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $70 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $70 | 0;
 }
 HEAP32[$fs_kHz >> 2] = _silk_control_audio_bandwidth(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[$encControl$addr >> 2] | 0) | 0;
 if (HEAP32[$force_fs_kHz$addr >> 2] | 0) HEAP32[$fs_kHz >> 2] = HEAP32[$force_fs_kHz$addr >> 2];
 $call36 = _silk_setup_resamplers(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[$fs_kHz >> 2] | 0) | 0;
 HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call36;
 $call38 = _silk_setup_fs(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[$fs_kHz >> 2] | 0, HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 24 >> 2] | 0) | 0;
 HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call38;
 $call41 = _silk_setup_complexity(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 36 >> 2] | 0) | 0;
 HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call41;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4612 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 32 >> 2];
 $call45 = _silk_setup_LBRR(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[$encControl$addr >> 2] | 0) | 0;
 HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call45;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4664 >> 2] = 1;
 HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
 $70 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $70 | 0;
}

function _denormalise_bands($m, $X, $freq, $bandLogE, $start, $end, $M, $downsample, $silence) {
 $m = $m | 0;
 $X = $X | 0;
 $freq = $freq | 0;
 $bandLogE = $bandLogE | 0;
 $start = $start | 0;
 $end = $end | 0;
 $M = $M | 0;
 $downsample = $downsample | 0;
 $silence = $silence | 0;
 var $28 = 0, $48 = 0, $51 = 0, $M$addr = 0, $N = 0, $X$addr = 0, $bandLogE$addr = 0, $band_end = 0, $bound = 0, $cond = 0, $downsample$addr = 0, $eBands = 0, $end$addr = 0, $f = 0, $freq$addr = 0, $g = 0, $i = 0, $inc42 = 0, $j = 0, $lg = 0, $m$addr = 0, $mul40 = 0.0, $silence$addr = 0, $start$addr = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $m$addr = sp + 72 | 0;
 $X$addr = sp + 68 | 0;
 $freq$addr = sp + 64 | 0;
 $bandLogE$addr = sp + 60 | 0;
 $start$addr = sp + 56 | 0;
 $end$addr = sp + 52 | 0;
 $M$addr = sp + 48 | 0;
 $downsample$addr = sp + 44 | 0;
 $silence$addr = sp + 40 | 0;
 $i = sp + 36 | 0;
 $N = sp + 32 | 0;
 $bound = sp + 28 | 0;
 $f = sp + 24 | 0;
 $x = sp + 20 | 0;
 $eBands = sp + 16 | 0;
 $j = sp + 12 | 0;
 $band_end = sp + 8 | 0;
 $g = sp + 4 | 0;
 $lg = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$freq$addr >> 2] = $freq;
 HEAP32[$bandLogE$addr >> 2] = $bandLogE;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$M$addr >> 2] = $M;
 HEAP32[$downsample$addr >> 2] = $downsample;
 HEAP32[$silence$addr >> 2] = $silence;
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$N >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 44 >> 2] | 0) | 0;
 HEAP32[$bound >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$end$addr >> 2] << 1) >> 1] | 0) | 0;
 if ((HEAP32[$downsample$addr >> 2] | 0) != 1) {
  if ((HEAP32[$bound >> 2] | 0) < ((HEAP32[$N >> 2] | 0) / (HEAP32[$downsample$addr >> 2] | 0) | 0 | 0)) $cond = HEAP32[$bound >> 2] | 0; else $cond = (HEAP32[$N >> 2] | 0) / (HEAP32[$downsample$addr >> 2] | 0) | 0;
  HEAP32[$bound >> 2] = $cond;
 }
 if (HEAP32[$silence$addr >> 2] | 0) {
  HEAP32[$bound >> 2] = 0;
  HEAP32[$end$addr >> 2] = 0;
  HEAP32[$start$addr >> 2] = 0;
 }
 HEAP32[$f >> 2] = HEAP32[$freq$addr >> 2];
 HEAP32[$x >> 2] = (HEAP32[$X$addr >> 2] | 0) + ((Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0) | 0) << 2);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0) | 0)) break;
  $28 = HEAP32[$f >> 2] | 0;
  HEAP32[$f >> 2] = $28 + 4;
  HEAPF32[$28 >> 2] = 0.0;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP32[$j >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
  HEAP32[$band_end >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) | 0;
  HEAPF32[$lg >> 2] = +HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[14900 + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$g >> 2] = +Math_exp(+((32.0 < +HEAPF32[$lg >> 2] ? 32.0 : +HEAPF32[$lg >> 2]) * .6931471805599453));
  do {
   $48 = HEAP32[$x >> 2] | 0;
   HEAP32[$x >> 2] = $48 + 4;
   $mul40 = +HEAPF32[$48 >> 2] * +HEAPF32[$g >> 2];
   $51 = HEAP32[$f >> 2] | 0;
   HEAP32[$f >> 2] = $51 + 4;
   HEAPF32[$51 >> 2] = $mul40;
   $inc42 = (HEAP32[$j >> 2] | 0) + 1 | 0;
   HEAP32[$j >> 2] = $inc42;
  } while (($inc42 | 0) < (HEAP32[$band_end >> 2] | 0));
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _memset((HEAP32[$freq$addr >> 2] | 0) + (HEAP32[$bound >> 2] << 2) | 0, 0, (HEAP32[$N >> 2] | 0) - (HEAP32[$bound >> 2] | 0) << 2 | 0) | 0;
 STACKTOP = sp;
 return;
}

function _gain_fade($in, $out, $g1, $g2, $overlap48, $frame_size, $channels, $window, $Fs) {
 $in = $in | 0;
 $out = $out | 0;
 $g1 = +$g1;
 $g2 = +$g2;
 $overlap48 = $overlap48 | 0;
 $frame_size = $frame_size | 0;
 $channels = $channels | 0;
 $window = $window | 0;
 $Fs = $Fs | 0;
 var $30 = 0.0, $9 = 0.0, $Fs$addr = 0, $c = 0, $channels$addr = 0, $cmp = 0, $frame_size$addr = 0, $g = 0, $g1$addr = 0, $g15 = 0, $g2$addr = 0, $i = 0, $in$addr = 0, $inc = 0, $inc54 = 0, $mul44 = 0, $mul48 = 0, $out$addr = 0, $overlap = 0, $overlap48$addr = 0, $w = 0, $w16 = 0, $window$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $in$addr = sp + 64 | 0;
 $out$addr = sp + 60 | 0;
 $g1$addr = sp + 56 | 0;
 $g2$addr = sp + 52 | 0;
 $overlap48$addr = sp + 48 | 0;
 $frame_size$addr = sp + 44 | 0;
 $channels$addr = sp + 40 | 0;
 $window$addr = sp + 36 | 0;
 $Fs$addr = sp + 32 | 0;
 $i = sp + 28 | 0;
 $inc = sp + 24 | 0;
 $overlap = sp + 20 | 0;
 $c = sp + 16 | 0;
 $g = sp + 12 | 0;
 $w = sp + 8 | 0;
 $g15 = sp + 4 | 0;
 $w16 = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$out$addr >> 2] = $out;
 HEAPF32[$g1$addr >> 2] = $g1;
 HEAPF32[$g2$addr >> 2] = $g2;
 HEAP32[$overlap48$addr >> 2] = $overlap48;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$window$addr >> 2] = $window;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$inc >> 2] = 48e3 / (HEAP32[$Fs$addr >> 2] | 0) | 0;
 HEAP32[$overlap >> 2] = (HEAP32[$overlap48$addr >> 2] | 0) / (HEAP32[$inc >> 2] | 0) | 0;
 $cmp = (HEAP32[$channels$addr >> 2] | 0) == 1;
 HEAP32[$i >> 2] = 0;
 L1 : do if ($cmp) while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$overlap >> 2] | 0)) break L1;
  $9 = +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$inc >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[$w >> 2] = $9 * +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$inc >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[$g >> 2] = +HEAPF32[$w >> 2] * +HEAPF32[$g2$addr >> 2] + (1.0 - +HEAPF32[$w >> 2]) * +HEAPF32[$g1$addr >> 2];
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$g >> 2] * +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 } else while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$overlap >> 2] | 0)) break L1;
  $30 = +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$inc >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[$w16 >> 2] = $30 * +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$inc >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[$g15 >> 2] = +HEAPF32[$w16 >> 2] * +HEAPF32[$g2$addr >> 2] + (1.0 - +HEAPF32[$w16 >> 2]) * +HEAPF32[$g1$addr >> 2];
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1 << 2) >> 2] = +HEAPF32[$g15 >> 2] * +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1 << 2) >> 2];
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 1 << 2) >> 2] = +HEAPF32[$g15 >> 2] * +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 1 << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 } while (0);
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = HEAP32[$overlap >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$frame_size$addr >> 2] | 0)) break;
   $mul44 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
   $mul48 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ($mul48 + (HEAP32[$c >> 2] | 0) << 2) >> 2] = +HEAPF32[$g2$addr >> 2] * +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ($mul44 + (HEAP32[$c >> 2] | 0) << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc54 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc54;
 } while (($inc54 | 0) < (HEAP32[$channels$addr >> 2] | 0));
 STACKTOP = sp;
 return;
}

function _silk_decoder_set_fs($psDec, $fs_kHz, $fs_API_Hz) {
 $psDec = $psDec | 0;
 $fs_kHz = $fs_kHz | 0;
 $fs_API_Hz = $fs_API_Hz | 0;
 var $$sink2 = 0, $$sink3 = 0, $$sink4 = 0, $54 = 0, $LPC_order = 0, $call = 0, $cmp28 = 0, $frame_length = 0, $fs_API_Hz$addr = 0, $fs_kHz$addr = 0, $psDec$addr = 0, $ret = 0, $silk_NLSF_CB_WB$sink = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $psDec$addr = sp + 16 | 0;
 $fs_kHz$addr = sp + 12 | 0;
 $fs_API_Hz$addr = sp + 8 | 0;
 $frame_length = sp + 4 | 0;
 $ret = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$fs_kHz$addr >> 2] = $fs_kHz;
 HEAP32[$fs_API_Hz$addr >> 2] = $fs_API_Hz;
 HEAP32[$ret >> 2] = 0;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] = ((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 5;
 HEAP32[$frame_length >> 2] = Math_imul((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] & 65535) << 16 >> 16, (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2332 >> 2] & 65535) << 16 >> 16) | 0;
 if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] | 0) != (HEAP32[$fs_kHz$addr >> 2] | 0)) label = 3; else if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2320 >> 2] | 0) != (HEAP32[$fs_API_Hz$addr >> 2] | 0)) label = 3;
 if ((label | 0) == 3) {
  $call = _silk_resampler_init((HEAP32[$psDec$addr >> 2] | 0) + 2432 | 0, ((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 1e3 | 0, HEAP32[$fs_API_Hz$addr >> 2] | 0, 0) | 0;
  HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call;
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2320 >> 2] = HEAP32[$fs_API_Hz$addr >> 2];
 }
 if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] | 0) == (HEAP32[$fs_kHz$addr >> 2] | 0)) if ((HEAP32[$frame_length >> 2] | 0) == (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] | 0)) {
  $54 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $54 | 0;
 }
 $cmp28 = (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2324 >> 2] | 0) == 4;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2384 >> 2] = (HEAP32[$fs_kHz$addr >> 2] | 0) == 8 ? ($cmp28 ? 32352 : 32375) : $cmp28 ? 32318 : 32363;
 if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] | 0) != (HEAP32[$fs_kHz$addr >> 2] | 0)) {
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2336 >> 2] = ((HEAP32[$fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 20;
  $LPC_order = (HEAP32[$psDec$addr >> 2] | 0) + 2340 | 0;
  if ((HEAP32[$fs_kHz$addr >> 2] | 0) == 8 | (HEAP32[$fs_kHz$addr >> 2] | 0) == 12) {
   HEAP32[$LPC_order >> 2] = 10;
   $$sink2 = HEAP32[$psDec$addr >> 2] | 0;
   $silk_NLSF_CB_WB$sink = 20644;
  } else {
   HEAP32[$LPC_order >> 2] = 16;
   $$sink2 = HEAP32[$psDec$addr >> 2] | 0;
   $silk_NLSF_CB_WB$sink = 20684;
  }
  HEAP32[$$sink2 + 2732 >> 2] = $silk_NLSF_CB_WB$sink;
  do if ((HEAP32[$fs_kHz$addr >> 2] | 0) == 16) {
   $$sink3 = 32250;
   $$sink4 = HEAP32[$psDec$addr >> 2] | 0;
   label = 16;
  } else {
   if ((HEAP32[$fs_kHz$addr >> 2] | 0) == 12) {
    $$sink3 = 32244;
    $$sink4 = HEAP32[$psDec$addr >> 2] | 0;
    label = 16;
    break;
   }
   if ((HEAP32[$fs_kHz$addr >> 2] | 0) == 8) {
    $$sink3 = 32235;
    $$sink4 = HEAP32[$psDec$addr >> 2] | 0;
    label = 16;
   }
  } while (0);
  if ((label | 0) == 16) HEAP32[$$sink4 + 2380 >> 2] = $$sink3;
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2376 >> 2] = 1;
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2308 >> 2] = 100;
  HEAP8[(HEAP32[$psDec$addr >> 2] | 0) + 2312 >> 0] = 10;
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4164 >> 2] = 0;
  _memset((HEAP32[$psDec$addr >> 2] | 0) + 1348 | 0, 0, 960) | 0;
  dest = (HEAP32[$psDec$addr >> 2] | 0) + 1284 | 0;
  stop = dest + 64 | 0;
  do {
   HEAP32[dest >> 2] = 0;
   dest = dest + 4 | 0;
  } while ((dest | 0) < (stop | 0));
 }
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] = HEAP32[$fs_kHz$addr >> 2];
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] = HEAP32[$frame_length >> 2];
 $54 = HEAP32[$ret >> 2] | 0;
 STACKTOP = sp;
 return $54 | 0;
}

function _silk_find_LPC_FLP($psEncC, $NLSF_Q15, $x, $minInvGain) {
 $psEncC = $psEncC | 0;
 $NLSF_Q15 = $NLSF_Q15 | 0;
 $x = $x | 0;
 $minInvGain = +$minInvGain;
 var $55 = 0.0, $LPC_res = 0, $NLSF0_Q15 = 0, $NLSF_Q15$addr = 0, $a = 0, $a_tmp = 0, $call27 = 0.0, $call8 = 0.0, $k = 0, $minInvGain$addr = 0, $psEncC$addr = 0, $res_nrg = 0, $res_nrg_2nd = 0, $res_nrg_interp = 0, $subfr_length = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1744 | 0;
 $psEncC$addr = sp + 1700 | 0;
 $NLSF_Q15$addr = sp + 1696 | 0;
 $x$addr = sp + 1692 | 0;
 $minInvGain$addr = sp + 1688 | 0;
 $k = sp + 1684 | 0;
 $subfr_length = sp + 1680 | 0;
 $a = sp + 1616 | 0;
 $res_nrg = sp + 1608 | 0;
 $res_nrg_2nd = sp + 1604 | 0;
 $res_nrg_interp = sp + 1600 | 0;
 $NLSF0_Q15 = sp + 1704 | 0;
 $a_tmp = sp + 1536 | 0;
 $LPC_res = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$NLSF_Q15$addr >> 2] = $NLSF_Q15;
 HEAP32[$x$addr >> 2] = $x;
 HEAPF32[$minInvGain$addr >> 2] = $minInvGain;
 HEAP32[$subfr_length >> 2] = (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4584 >> 2] | 0) + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
 HEAP8[(HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 31 >> 0] = 4;
 HEAPF32[$res_nrg >> 2] = +_silk_burg_modified_FLP($a, HEAP32[$x$addr >> 2] | 0, +HEAPF32[$minInvGain$addr >> 2], HEAP32[$subfr_length >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
 L1 : do if (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4628 >> 2] | 0) if (!(HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4660 >> 2] | 0)) if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0) == 4) {
  $call8 = +_silk_burg_modified_FLP($a_tmp, (HEAP32[$x$addr >> 2] | 0) + (HEAP32[$subfr_length >> 2] << 1 << 2) | 0, +HEAPF32[$minInvGain$addr >> 2], HEAP32[$subfr_length >> 2] | 0, 2, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
  HEAPF32[$res_nrg >> 2] = +HEAPF32[$res_nrg >> 2] - $call8;
  _silk_A2NLSF_FLP(HEAP32[$NLSF_Q15$addr >> 2] | 0, $a_tmp, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
  HEAPF32[$res_nrg_2nd >> 2] = 3402823466385288598117041.0e14;
  HEAP32[$k >> 2] = 3;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) < 0) break L1;
   _silk_interpolate($NLSF0_Q15, (HEAP32[$psEncC$addr >> 2] | 0) + 4496 | 0, HEAP32[$NLSF_Q15$addr >> 2] | 0, HEAP32[$k >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
   _silk_NLSF2A_FLP($a_tmp, $NLSF0_Q15, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 5088 >> 2] | 0);
   _silk_LPC_analysis_filter_FLP($LPC_res, $a_tmp, HEAP32[$x$addr >> 2] | 0, HEAP32[$subfr_length >> 2] << 1, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
   $call27 = +_silk_energy_FLP($LPC_res + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] << 2) | 0, (HEAP32[$subfr_length >> 2] | 0) - (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0) | 0);
   HEAPF32[$res_nrg_interp >> 2] = $call27 + +_silk_energy_FLP($LPC_res + (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] << 2) + (HEAP32[$subfr_length >> 2] << 2) | 0, (HEAP32[$subfr_length >> 2] | 0) - (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0) | 0);
   $55 = +HEAPF32[$res_nrg_interp >> 2];
   if (+HEAPF32[$res_nrg_interp >> 2] < +HEAPF32[$res_nrg >> 2]) {
    HEAPF32[$res_nrg >> 2] = $55;
    HEAP8[(HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 31 >> 0] = HEAP32[$k >> 2];
   } else if ($55 > +HEAPF32[$res_nrg_2nd >> 2]) break L1;
   HEAPF32[$res_nrg_2nd >> 2] = +HEAPF32[$res_nrg_interp >> 2];
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + -1;
  }
 } while (0);
 if ((HEAP8[(HEAP32[$psEncC$addr >> 2] | 0) + 4732 + 31 >> 0] | 0) != 4) {
  STACKTOP = sp;
  return;
 }
 _silk_A2NLSF_FLP(HEAP32[$NLSF_Q15$addr >> 2] | 0, $a, HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _pitch_downsample($x, $x_lp, $len, $C, $arch) {
 $x = $x | 0;
 $x_lp = $x_lp | 0;
 $len = $len | 0;
 $C = $C | 0;
 $arch = $arch | 0;
 var $26 = 0, $3 = 0, $45 = 0, $C$addr = 0, $ac = 0, $arch$addr = 0, $arrayidx41 = 0, $arrayidx67 = 0, $c1 = 0, $i = 0, $len$addr = 0, $lpc = 0, $lpc2 = 0, $tmp = 0, $x$addr = 0, $x_lp$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $x$addr = sp + 84 | 0;
 $x_lp$addr = sp + 80 | 0;
 $len$addr = sp + 76 | 0;
 $C$addr = sp + 72 | 0;
 $arch$addr = sp + 68 | 0;
 $i = sp + 64 | 0;
 $ac = sp + 44 | 0;
 $tmp = sp + 40 | 0;
 $lpc = sp + 24 | 0;
 $lpc2 = sp + 4 | 0;
 $c1 = sp;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$x_lp$addr >> 2] = $x_lp;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAPF32[$tmp >> 2] = 1.0;
 HEAPF32[$c1 >> 2] = .800000011920929;
 HEAP32[$i >> 2] = 1;
 while (1) {
  $3 = HEAP32[HEAP32[$x$addr >> 2] >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] >> 1 | 0)) break;
  HEAPF32[(HEAP32[$x_lp$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = ((+HEAPF32[$3 + ((HEAP32[$i >> 2] << 1) - 1 << 2) >> 2] + +HEAPF32[(HEAP32[HEAP32[$x$addr >> 2] >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 1 << 2) >> 2]) * .5 + +HEAPF32[(HEAP32[HEAP32[$x$addr >> 2] >> 2] | 0) + (HEAP32[$i >> 2] << 1 << 2) >> 2]) * .5;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[HEAP32[$x_lp$addr >> 2] >> 2] = (+HEAPF32[$3 + 4 >> 2] * .5 + +HEAPF32[HEAP32[HEAP32[$x$addr >> 2] >> 2] >> 2]) * .5;
 if ((HEAP32[$C$addr >> 2] | 0) == 2) {
  HEAP32[$i >> 2] = 1;
  while (1) {
   $26 = HEAP32[(HEAP32[$x$addr >> 2] | 0) + 4 >> 2] | 0;
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] >> 1 | 0)) break;
   $arrayidx41 = (HEAP32[$x_lp$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[$arrayidx41 >> 2] = +HEAPF32[$arrayidx41 >> 2] + ((+HEAPF32[$26 + ((HEAP32[$i >> 2] << 1) - 1 << 2) >> 2] + +HEAPF32[(HEAP32[(HEAP32[$x$addr >> 2] | 0) + 4 >> 2] | 0) + ((HEAP32[$i >> 2] << 1) + 1 << 2) >> 2]) * .5 + +HEAPF32[(HEAP32[(HEAP32[$x$addr >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[$i >> 2] << 1 << 2) >> 2]) * .5;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $45 = HEAP32[$x_lp$addr >> 2] | 0;
  HEAPF32[$45 >> 2] = +HEAPF32[$45 >> 2] + (+HEAPF32[$26 + 4 >> 2] * .5 + +HEAPF32[HEAP32[(HEAP32[$x$addr >> 2] | 0) + 4 >> 2] >> 2]) * .5;
 }
 __celt_autocorr(HEAP32[$x_lp$addr >> 2] | 0, $ac, 0, 0, 4, HEAP32[$len$addr >> 2] >> 1, HEAP32[$arch$addr >> 2] | 0) | 0;
 HEAPF32[$ac >> 2] = +HEAPF32[$ac >> 2] * 1.000100016593933;
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) > 4) break;
  $arrayidx67 = $ac + (HEAP32[$i >> 2] << 2) | 0;
  HEAPF32[$arrayidx67 >> 2] = +HEAPF32[$arrayidx67 >> 2] - +HEAPF32[$ac + (HEAP32[$i >> 2] << 2) >> 2] * (+(HEAP32[$i >> 2] | 0) * .00800000037997961) * (+(HEAP32[$i >> 2] | 0) * .00800000037997961);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 __celt_lpc($lpc, $ac, 4);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 4) break;
  HEAPF32[$tmp >> 2] = +HEAPF32[$tmp >> 2] * .8999999761581421;
  HEAPF32[$lpc + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$lpc + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[$tmp >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[$lpc2 >> 2] = +HEAPF32[$lpc >> 2] + .800000011920929;
 HEAPF32[$lpc2 + 4 >> 2] = +HEAPF32[$lpc + 4 >> 2] + +HEAPF32[$c1 >> 2] * +HEAPF32[$lpc >> 2];
 HEAPF32[$lpc2 + 8 >> 2] = +HEAPF32[$lpc + 8 >> 2] + +HEAPF32[$c1 >> 2] * +HEAPF32[$lpc + 4 >> 2];
 HEAPF32[$lpc2 + 12 >> 2] = +HEAPF32[$lpc + 12 >> 2] + +HEAPF32[$c1 >> 2] * +HEAPF32[$lpc + 8 >> 2];
 HEAPF32[$lpc2 + 16 >> 2] = +HEAPF32[$c1 >> 2] * +HEAPF32[$lpc + 12 >> 2];
 _celt_fir5(HEAP32[$x_lp$addr >> 2] | 0, $lpc2, HEAP32[$len$addr >> 2] >> 1);
 STACKTOP = sp;
 return;
}

function _silk_PLC_glue_frames($psDec, $frame, $length) {
 $psDec = $psDec | 0;
 $frame = $frame | 0;
 $length = $length | 0;
 var $$sink = 0, $$sink1 = 0, $38 = 0, $LZ = 0, $conv41 = 0, $energy = 0, $energy_shift = 0, $frac_Q24 = 0, $frame$addr = 0, $gain_Q16 = 0, $i = 0, $last_frame_lost50 = 0, $length$addr = 0, $mul = 0, $psDec$addr = 0, $psPLC = 0, $slope_Q16 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $psDec$addr = sp + 40 | 0;
 $frame$addr = sp + 36 | 0;
 $length$addr = sp + 32 | 0;
 $i = sp + 28 | 0;
 $energy_shift = sp + 24 | 0;
 $energy = sp + 20 | 0;
 $psPLC = sp + 16 | 0;
 $frac_Q24 = sp + 12 | 0;
 $LZ = sp + 8 | 0;
 $gain_Q16 = sp + 4 | 0;
 $slope_Q16 = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$frame$addr >> 2] = $frame;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$psPLC >> 2] = (HEAP32[$psDec$addr >> 2] | 0) + 4172;
 if (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4160 >> 2] | 0) {
  _silk_sum_sqr_shift((HEAP32[$psPLC >> 2] | 0) + 60 | 0, (HEAP32[$psPLC >> 2] | 0) + 64 | 0, HEAP32[$frame$addr >> 2] | 0, HEAP32[$length$addr >> 2] | 0);
  $$sink = 1;
  $$sink1 = HEAP32[$psPLC >> 2] | 0;
  $last_frame_lost50 = $$sink1 + 48 | 0;
  HEAP32[$last_frame_lost50 >> 2] = $$sink;
  STACKTOP = sp;
  return;
 }
 L5 : do if (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 48 >> 2] | 0) {
  _silk_sum_sqr_shift($energy, $energy_shift, HEAP32[$frame$addr >> 2] | 0, HEAP32[$length$addr >> 2] | 0);
  if ((HEAP32[$energy_shift >> 2] | 0) > (HEAP32[(HEAP32[$psPLC >> 2] | 0) + 64 >> 2] | 0)) HEAP32[(HEAP32[$psPLC >> 2] | 0) + 60 >> 2] = HEAP32[(HEAP32[$psPLC >> 2] | 0) + 60 >> 2] >> (HEAP32[$energy_shift >> 2] | 0) - (HEAP32[(HEAP32[$psPLC >> 2] | 0) + 64 >> 2] | 0); else if ((HEAP32[$energy_shift >> 2] | 0) < (HEAP32[(HEAP32[$psPLC >> 2] | 0) + 64 >> 2] | 0)) HEAP32[$energy >> 2] = HEAP32[$energy >> 2] >> (HEAP32[(HEAP32[$psPLC >> 2] | 0) + 64 >> 2] | 0) - (HEAP32[$energy_shift >> 2] | 0);
  if ((HEAP32[$energy >> 2] | 0) > (HEAP32[(HEAP32[$psPLC >> 2] | 0) + 60 >> 2] | 0)) {
   HEAP32[$LZ >> 2] = _silk_CLZ32_436(HEAP32[(HEAP32[$psPLC >> 2] | 0) + 60 >> 2] | 0) | 0;
   HEAP32[$LZ >> 2] = (HEAP32[$LZ >> 2] | 0) - 1;
   HEAP32[(HEAP32[$psPLC >> 2] | 0) + 60 >> 2] = HEAP32[(HEAP32[$psPLC >> 2] | 0) + 60 >> 2] << HEAP32[$LZ >> 2];
   $38 = HEAP32[$energy >> 2] | 0;
   HEAP32[$energy >> 2] = $38 >> (_silk_max_32(24 - (HEAP32[$LZ >> 2] | 0) | 0, 0) | 0);
   HEAP32[$frac_Q24 >> 2] = (HEAP32[(HEAP32[$psPLC >> 2] | 0) + 60 >> 2] | 0) / (((HEAP32[$energy >> 2] | 0) > 1 ? HEAP32[$energy >> 2] | 0 : 1) | 0) | 0;
   HEAP32[$gain_Q16 >> 2] = (_silk_SQRT_APPROX_439(HEAP32[$frac_Q24 >> 2] | 0) | 0) << 4;
   HEAP32[$slope_Q16 >> 2] = (65536 - (HEAP32[$gain_Q16 >> 2] | 0) | 0) / (HEAP32[$length$addr >> 2] | 0) | 0;
   HEAP32[$slope_Q16 >> 2] = HEAP32[$slope_Q16 >> 2] << 2;
   HEAP32[$i >> 2] = 0;
   while (1) {
    if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break L5;
    $mul = Math_imul(HEAP32[$gain_Q16 >> 2] >> 16, HEAP16[(HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
    $conv41 = $mul + ((Math_imul(HEAP32[$gain_Q16 >> 2] & 65535, HEAP16[(HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) >> 16) & 65535;
    HEAP16[(HEAP32[$frame$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $conv41;
    HEAP32[$gain_Q16 >> 2] = (HEAP32[$gain_Q16 >> 2] | 0) + (HEAP32[$slope_Q16 >> 2] | 0);
    if ((HEAP32[$gain_Q16 >> 2] | 0) > 65536) break L5;
    HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
   }
  }
 } while (0);
 $$sink = 0;
 $$sink1 = HEAP32[$psPLC >> 2] | 0;
 $last_frame_lost50 = $$sink1 + 48 | 0;
 HEAP32[$last_frame_lost50 >> 2] = $$sink;
 STACKTOP = sp;
 return;
}

function _kf_bfly2($Fout, $m, $N) {
 $Fout = $Fout | 0;
 $m = $m | 0;
 $N = $N | 0;
 var $13 = 0, $3 = 0, $Fout$addr = 0, $Fout2 = 0, $N$addr = 0, $arrayidx119 = 0, $arrayidx49 = 0, $arrayidx80 = 0, $i = 0, $i124 = 0, $i17 = 0, $i54 = 0, $i85 = 0, $t = 0, $tw = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $Fout$addr = sp + 28 | 0;
 $N$addr = sp + 20 | 0;
 $Fout2 = sp + 16 | 0;
 $i = sp + 12 | 0;
 $tw = sp + 8 | 0;
 $t = sp;
 HEAP32[$Fout$addr >> 2] = $Fout;
 HEAP32[sp + 24 >> 2] = $m;
 HEAP32[$N$addr >> 2] = $N;
 HEAPF32[$tw >> 2] = .7071067690849304;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAP32[$Fout2 >> 2] = (HEAP32[$Fout$addr >> 2] | 0) + 32;
  $3 = HEAP32[$Fout2 >> 2] | 0;
  HEAP32[$t >> 2] = HEAP32[$3 >> 2];
  HEAP32[$t + 4 >> 2] = HEAP32[$3 + 4 >> 2];
  HEAPF32[HEAP32[$Fout2 >> 2] >> 2] = +HEAPF32[HEAP32[$Fout$addr >> 2] >> 2] - +HEAPF32[$t >> 2];
  HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 4 >> 2] - +HEAPF32[$t + 4 >> 2];
  $13 = HEAP32[$Fout$addr >> 2] | 0;
  HEAPF32[$13 >> 2] = +HEAPF32[$13 >> 2] + +HEAPF32[$t >> 2];
  $i17 = (HEAP32[$Fout$addr >> 2] | 0) + 4 | 0;
  HEAPF32[$i17 >> 2] = +HEAPF32[$i17 >> 2] + +HEAPF32[$t + 4 >> 2];
  HEAPF32[$t >> 2] = (+HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 8 >> 2] + +HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 8 + 4 >> 2]) * +HEAPF32[$tw >> 2];
  HEAPF32[$t + 4 >> 2] = (+HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 8 + 4 >> 2] - +HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 8 >> 2]) * +HEAPF32[$tw >> 2];
  HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 8 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 8 >> 2] - +HEAPF32[$t >> 2];
  HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 8 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 8 + 4 >> 2] - +HEAPF32[$t + 4 >> 2];
  $arrayidx49 = (HEAP32[$Fout$addr >> 2] | 0) + 8 | 0;
  HEAPF32[$arrayidx49 >> 2] = +HEAPF32[$arrayidx49 >> 2] + +HEAPF32[$t >> 2];
  $i54 = (HEAP32[$Fout$addr >> 2] | 0) + 8 + 4 | 0;
  HEAPF32[$i54 >> 2] = +HEAPF32[$i54 >> 2] + +HEAPF32[$t + 4 >> 2];
  HEAPF32[$t >> 2] = +HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 16 + 4 >> 2];
  HEAPF32[$t + 4 >> 2] = -+HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 16 >> 2];
  HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 16 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 16 >> 2] - +HEAPF32[$t >> 2];
  HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 16 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 16 + 4 >> 2] - +HEAPF32[$t + 4 >> 2];
  $arrayidx80 = (HEAP32[$Fout$addr >> 2] | 0) + 16 | 0;
  HEAPF32[$arrayidx80 >> 2] = +HEAPF32[$arrayidx80 >> 2] + +HEAPF32[$t >> 2];
  $i85 = (HEAP32[$Fout$addr >> 2] | 0) + 16 + 4 | 0;
  HEAPF32[$i85 >> 2] = +HEAPF32[$i85 >> 2] + +HEAPF32[$t + 4 >> 2];
  HEAPF32[$t >> 2] = (+HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 24 + 4 >> 2] - +HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 24 >> 2]) * +HEAPF32[$tw >> 2];
  HEAPF32[$t + 4 >> 2] = -(+HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 24 + 4 >> 2] + +HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 24 >> 2]) * +HEAPF32[$tw >> 2];
  HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 24 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 24 >> 2] - +HEAPF32[$t >> 2];
  HEAPF32[(HEAP32[$Fout2 >> 2] | 0) + 24 + 4 >> 2] = +HEAPF32[(HEAP32[$Fout$addr >> 2] | 0) + 24 + 4 >> 2] - +HEAPF32[$t + 4 >> 2];
  $arrayidx119 = (HEAP32[$Fout$addr >> 2] | 0) + 24 | 0;
  HEAPF32[$arrayidx119 >> 2] = +HEAPF32[$arrayidx119 >> 2] + +HEAPF32[$t >> 2];
  $i124 = (HEAP32[$Fout$addr >> 2] | 0) + 24 + 4 | 0;
  HEAPF32[$i124 >> 2] = +HEAPF32[$i124 >> 2] + +HEAPF32[$t + 4 >> 2];
  HEAP32[$Fout$addr >> 2] = (HEAP32[$Fout$addr >> 2] | 0) + 64;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _hp_cutoff($in, $cutoff_Hz, $out, $hp_mem, $len, $channels, $Fs, $arch) {
 $in = $in | 0;
 $cutoff_Hz = $cutoff_Hz | 0;
 $out = $out | 0;
 $hp_mem = $hp_mem | 0;
 $len = $len | 0;
 $channels = $channels | 0;
 $Fs = $Fs | 0;
 $arch = $arch | 0;
 var $A_Q28 = 0, $B_Q28 = 0, $Fc_Q19 = 0, $Fs$addr = 0, $add = 0, $add35 = 0, $add46 = 0, $add56 = 0, $add78 = 0, $channels$addr = 0, $cutoff_Hz$addr = 0, $hp_mem$addr = 0, $in$addr = 0, $len$addr = 0, $mul11 = 0, $mul24 = 0, $mul29 = 0, $mul50 = 0, $mul72 = 0, $out$addr = 0, $r_Q22 = 0, $r_Q28 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $in$addr = sp + 64 | 0;
 $cutoff_Hz$addr = sp + 60 | 0;
 $out$addr = sp + 56 | 0;
 $hp_mem$addr = sp + 52 | 0;
 $len$addr = sp + 48 | 0;
 $channels$addr = sp + 44 | 0;
 $Fs$addr = sp + 40 | 0;
 $B_Q28 = sp + 24 | 0;
 $A_Q28 = sp + 16 | 0;
 $Fc_Q19 = sp + 8 | 0;
 $r_Q28 = sp + 4 | 0;
 $r_Q22 = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$cutoff_Hz$addr >> 2] = $cutoff_Hz;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$hp_mem$addr >> 2] = $hp_mem;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[sp + 36 >> 2] = $arch;
 HEAP32[$Fc_Q19 >> 2] = (((HEAP32[$cutoff_Hz$addr >> 2] & 65535) << 16 >> 16) * 2471 | 0) / ((HEAP32[$Fs$addr >> 2] | 0) / 1e3 | 0 | 0) | 0;
 HEAP32[$r_Q28 >> 2] = 268435456 - ((HEAP32[$Fc_Q19 >> 2] | 0) * 471 | 0);
 HEAP32[$B_Q28 >> 2] = HEAP32[$r_Q28 >> 2];
 HEAP32[$B_Q28 + 4 >> 2] = 0 - (HEAP32[$r_Q28 >> 2] | 0) << 1;
 HEAP32[$B_Q28 + 8 >> 2] = HEAP32[$r_Q28 >> 2];
 HEAP32[$r_Q22 >> 2] = HEAP32[$r_Q28 >> 2] >> 6;
 $mul11 = Math_imul(HEAP32[$Fc_Q19 >> 2] >> 16, (HEAP32[$Fc_Q19 >> 2] & 65535) << 16 >> 16) | 0;
 $add = $mul11 + ((Math_imul(HEAP32[$Fc_Q19 >> 2] & 65535, (HEAP32[$Fc_Q19 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
 $mul24 = Math_imul(HEAP32[$r_Q22 >> 2] >> 16, ($add + (Math_imul(HEAP32[$Fc_Q19 >> 2] | 0, (HEAP32[$Fc_Q19 >> 2] >> 15) + 1 >> 1) | 0) - 8388608 & 65535) << 16 >> 16) | 0;
 $mul29 = Math_imul(HEAP32[$Fc_Q19 >> 2] >> 16, (HEAP32[$Fc_Q19 >> 2] & 65535) << 16 >> 16) | 0;
 $add35 = $mul29 + ((Math_imul(HEAP32[$Fc_Q19 >> 2] & 65535, (HEAP32[$Fc_Q19 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
 $add46 = $mul24 + ((Math_imul(HEAP32[$r_Q22 >> 2] & 65535, ($add35 + (Math_imul(HEAP32[$Fc_Q19 >> 2] | 0, (HEAP32[$Fc_Q19 >> 2] >> 15) + 1 >> 1) | 0) - 8388608 & 65535) << 16 >> 16) | 0) >> 16) | 0;
 $mul50 = Math_imul(HEAP32[$Fc_Q19 >> 2] >> 16, (HEAP32[$Fc_Q19 >> 2] & 65535) << 16 >> 16) | 0;
 $add56 = $mul50 + ((Math_imul(HEAP32[$Fc_Q19 >> 2] & 65535, (HEAP32[$Fc_Q19 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
 HEAP32[$A_Q28 >> 2] = $add46 + (Math_imul(HEAP32[$r_Q22 >> 2] | 0, ($add56 + (Math_imul(HEAP32[$Fc_Q19 >> 2] | 0, (HEAP32[$Fc_Q19 >> 2] >> 15) + 1 >> 1) | 0) - 8388608 >> 15) + 1 >> 1) | 0);
 $mul72 = Math_imul(HEAP32[$r_Q22 >> 2] >> 16, (HEAP32[$r_Q22 >> 2] & 65535) << 16 >> 16) | 0;
 $add78 = $mul72 + ((Math_imul(HEAP32[$r_Q22 >> 2] & 65535, (HEAP32[$r_Q22 >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
 HEAP32[$A_Q28 + 4 >> 2] = $add78 + (Math_imul(HEAP32[$r_Q22 >> 2] | 0, (HEAP32[$r_Q22 >> 2] >> 15) + 1 >> 1) | 0);
 _silk_biquad_float(HEAP32[$in$addr >> 2] | 0, $B_Q28, $A_Q28, HEAP32[$hp_mem$addr >> 2] | 0, HEAP32[$out$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0);
 if ((HEAP32[$channels$addr >> 2] | 0) != 2) {
  STACKTOP = sp;
  return;
 }
 _silk_biquad_float((HEAP32[$in$addr >> 2] | 0) + 4 | 0, $B_Q28, $A_Q28, (HEAP32[$hp_mem$addr >> 2] | 0) + 8 | 0, (HEAP32[$out$addr >> 2] | 0) + 4 | 0, HEAP32[$len$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_resampler_private_IIR_FIR($SS, $out, $in, $inLen) {
 $SS = $SS | 0;
 $out = $out | 0;
 $in = $in | 0;
 $inLen = $inLen | 0;
 var $S = 0, $SS$addr = 0, $add = 0, $arrayidx11 = 0, $arrayidx6 = 0, $cond = 0, $in$addr = 0, $inLen$addr = 0, $index_increment_Q16 = 0, $max_index_Q16 = 0, $nSamplesIn = 0, $out$addr = 0, $sFIR = 0, $sFIR7 = 0, $saved_stack = 0, $vla = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $SS$addr = sp + 32 | 0;
 $out$addr = sp + 28 | 0;
 $in$addr = sp + 24 | 0;
 $inLen$addr = sp + 20 | 0;
 $S = sp + 16 | 0;
 $nSamplesIn = sp + 12 | 0;
 $max_index_Q16 = sp + 8 | 0;
 $index_increment_Q16 = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$SS$addr >> 2] = $SS;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$inLen$addr >> 2] = $inLen;
 HEAP32[$S >> 2] = HEAP32[$SS$addr >> 2];
 $add = (HEAP32[(HEAP32[$S >> 2] | 0) + 268 >> 2] << 1) + 8 | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add << 1) | 0) + 15 & -16) | 0;
 $sFIR = (HEAP32[$S >> 2] | 0) + 24 | 0;
 HEAP16[$vla >> 1] = HEAP16[$sFIR >> 1] | 0;
 HEAP16[$vla + 2 >> 1] = HEAP16[$sFIR + 2 >> 1] | 0;
 HEAP16[$vla + 4 >> 1] = HEAP16[$sFIR + 4 >> 1] | 0;
 HEAP16[$vla + 6 >> 1] = HEAP16[$sFIR + 6 >> 1] | 0;
 HEAP16[$vla + 8 >> 1] = HEAP16[$sFIR + 8 >> 1] | 0;
 HEAP16[$vla + 10 >> 1] = HEAP16[$sFIR + 10 >> 1] | 0;
 HEAP16[$vla + 12 >> 1] = HEAP16[$sFIR + 12 >> 1] | 0;
 HEAP16[$vla + 14 >> 1] = HEAP16[$sFIR + 14 >> 1] | 0;
 HEAP32[$index_increment_Q16 >> 2] = HEAP32[(HEAP32[$S >> 2] | 0) + 272 >> 2];
 while (1) {
  if ((HEAP32[$inLen$addr >> 2] | 0) < (HEAP32[(HEAP32[$S >> 2] | 0) + 268 >> 2] | 0)) $cond = HEAP32[$inLen$addr >> 2] | 0; else $cond = HEAP32[(HEAP32[$S >> 2] | 0) + 268 >> 2] | 0;
  HEAP32[$nSamplesIn >> 2] = $cond;
  _silk_resampler_private_up2_HQ(HEAP32[$S >> 2] | 0, $vla + 16 | 0, HEAP32[$in$addr >> 2] | 0, HEAP32[$nSamplesIn >> 2] | 0);
  HEAP32[$max_index_Q16 >> 2] = HEAP32[$nSamplesIn >> 2] << 17;
  HEAP32[$out$addr >> 2] = _silk_resampler_private_IIR_FIR_INTERPOL(HEAP32[$out$addr >> 2] | 0, $vla, HEAP32[$max_index_Q16 >> 2] | 0, HEAP32[$index_increment_Q16 >> 2] | 0) | 0;
  HEAP32[$in$addr >> 2] = (HEAP32[$in$addr >> 2] | 0) + (HEAP32[$nSamplesIn >> 2] << 1);
  HEAP32[$inLen$addr >> 2] = (HEAP32[$inLen$addr >> 2] | 0) - (HEAP32[$nSamplesIn >> 2] | 0);
  if ((HEAP32[$inLen$addr >> 2] | 0) <= 0) break;
  $arrayidx6 = $vla + (HEAP32[$nSamplesIn >> 2] << 1 << 1) | 0;
  HEAP16[$vla >> 1] = HEAP16[$arrayidx6 >> 1] | 0;
  HEAP16[$vla + 2 >> 1] = HEAP16[$arrayidx6 + 2 >> 1] | 0;
  HEAP16[$vla + 4 >> 1] = HEAP16[$arrayidx6 + 4 >> 1] | 0;
  HEAP16[$vla + 6 >> 1] = HEAP16[$arrayidx6 + 6 >> 1] | 0;
  HEAP16[$vla + 8 >> 1] = HEAP16[$arrayidx6 + 8 >> 1] | 0;
  HEAP16[$vla + 10 >> 1] = HEAP16[$arrayidx6 + 10 >> 1] | 0;
  HEAP16[$vla + 12 >> 1] = HEAP16[$arrayidx6 + 12 >> 1] | 0;
  HEAP16[$vla + 14 >> 1] = HEAP16[$arrayidx6 + 14 >> 1] | 0;
 }
 $sFIR7 = (HEAP32[$S >> 2] | 0) + 24 | 0;
 $arrayidx11 = $vla + (HEAP32[$nSamplesIn >> 2] << 1 << 1) | 0;
 HEAP16[$sFIR7 >> 1] = HEAP16[$arrayidx11 >> 1] | 0;
 HEAP16[$sFIR7 + 2 >> 1] = HEAP16[$arrayidx11 + 2 >> 1] | 0;
 HEAP16[$sFIR7 + 4 >> 1] = HEAP16[$arrayidx11 + 4 >> 1] | 0;
 HEAP16[$sFIR7 + 6 >> 1] = HEAP16[$arrayidx11 + 6 >> 1] | 0;
 HEAP16[$sFIR7 + 8 >> 1] = HEAP16[$arrayidx11 + 8 >> 1] | 0;
 HEAP16[$sFIR7 + 10 >> 1] = HEAP16[$arrayidx11 + 10 >> 1] | 0;
 HEAP16[$sFIR7 + 12 >> 1] = HEAP16[$arrayidx11 + 12 >> 1] | 0;
 HEAP16[$sFIR7 + 14 >> 1] = HEAP16[$arrayidx11 + 14 >> 1] | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_DIV32_varQ_558($a32, $b32, $Qres) {
 $a32 = $a32 | 0;
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $13 = 0, $14 = 0, $17 = 0, $20 = 0, $22 = 0, $33 = 0, $35 = 0, $5 = 0, $50 = 0, $Qres$addr = 0, $a32$addr = 0, $a32_nrm = 0, $a_headrm = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond89 = 0, $lshift = 0, $mul = 0, $mul27 = 0, $result = 0, $retval = 0, $sub47 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 40 | 0;
 $a32$addr = sp + 36 | 0;
 $b32$addr = sp + 32 | 0;
 $Qres$addr = sp + 28 | 0;
 $a_headrm = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $a32_nrm = sp + 8 | 0;
 $b32_nrm = sp + 4 | 0;
 $result = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$a32$addr >> 2] | 0;
 HEAP32[$a_headrm >> 2] = (_silk_CLZ32_559((HEAP32[$a32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$a32_nrm >> 2] = HEAP32[$a32$addr >> 2] << HEAP32[$a_headrm >> 2];
 $5 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_559((HEAP32[$b32$addr >> 2] | 0) > 0 ? $5 : 0 - $5 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 $mul = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = $mul + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 $13 = HEAP32[$a32_nrm >> 2] | 0;
 $14 = HEAP32[$b32_nrm >> 2] | 0;
 $17 = HEAP32[$result >> 2] | 0;
 $20 = ___muldi3($14 | 0, (($14 | 0) < 0) << 31 >> 31 | 0, $17 | 0, (($17 | 0) < 0) << 31 >> 31 | 0) | 0;
 $22 = _bitshift64Ashr($20 | 0, tempRet0 | 0, 32) | 0;
 HEAP32[$a32_nrm >> 2] = $13 - ($22 << 3);
 $mul27 = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = (HEAP32[$result >> 2] | 0) + ($mul27 + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$lshift >> 2] = 29 + (HEAP32[$a_headrm >> 2] | 0) - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $33 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) >= 0) if (($33 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 }
 $35 = HEAP32[$result >> 2] | 0;
 $sub47 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $33 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($35 | 0) > (-2147483648 >> $sub47 | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($35 | 0) > (2147483647 >> $sub47 | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond89 << 0 - (HEAP32[$lshift >> 2] | 0);
 $50 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $50 | 0;
}

function _silk_DIV32_varQ_552($a32, $b32, $Qres) {
 $a32 = $a32 | 0;
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $13 = 0, $14 = 0, $17 = 0, $20 = 0, $22 = 0, $33 = 0, $35 = 0, $5 = 0, $50 = 0, $Qres$addr = 0, $a32$addr = 0, $a32_nrm = 0, $a_headrm = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond89 = 0, $lshift = 0, $mul = 0, $mul27 = 0, $result = 0, $retval = 0, $sub47 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 40 | 0;
 $a32$addr = sp + 36 | 0;
 $b32$addr = sp + 32 | 0;
 $Qres$addr = sp + 28 | 0;
 $a_headrm = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $a32_nrm = sp + 8 | 0;
 $b32_nrm = sp + 4 | 0;
 $result = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$a32$addr >> 2] | 0;
 HEAP32[$a_headrm >> 2] = (_silk_CLZ32_553((HEAP32[$a32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$a32_nrm >> 2] = HEAP32[$a32$addr >> 2] << HEAP32[$a_headrm >> 2];
 $5 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_553((HEAP32[$b32$addr >> 2] | 0) > 0 ? $5 : 0 - $5 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 $mul = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = $mul + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 $13 = HEAP32[$a32_nrm >> 2] | 0;
 $14 = HEAP32[$b32_nrm >> 2] | 0;
 $17 = HEAP32[$result >> 2] | 0;
 $20 = ___muldi3($14 | 0, (($14 | 0) < 0) << 31 >> 31 | 0, $17 | 0, (($17 | 0) < 0) << 31 >> 31 | 0) | 0;
 $22 = _bitshift64Ashr($20 | 0, tempRet0 | 0, 32) | 0;
 HEAP32[$a32_nrm >> 2] = $13 - ($22 << 3);
 $mul27 = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = (HEAP32[$result >> 2] | 0) + ($mul27 + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$lshift >> 2] = 29 + (HEAP32[$a_headrm >> 2] | 0) - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $33 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) >= 0) if (($33 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 }
 $35 = HEAP32[$result >> 2] | 0;
 $sub47 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $33 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($35 | 0) > (-2147483648 >> $sub47 | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($35 | 0) > (2147483647 >> $sub47 | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond89 << 0 - (HEAP32[$lshift >> 2] | 0);
 $50 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $50 | 0;
}

function _silk_DIV32_varQ_426($a32, $b32, $Qres) {
 $a32 = $a32 | 0;
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $13 = 0, $14 = 0, $17 = 0, $20 = 0, $22 = 0, $33 = 0, $35 = 0, $5 = 0, $50 = 0, $Qres$addr = 0, $a32$addr = 0, $a32_nrm = 0, $a_headrm = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond89 = 0, $lshift = 0, $mul = 0, $mul27 = 0, $result = 0, $retval = 0, $sub47 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 40 | 0;
 $a32$addr = sp + 36 | 0;
 $b32$addr = sp + 32 | 0;
 $Qres$addr = sp + 28 | 0;
 $a_headrm = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $a32_nrm = sp + 8 | 0;
 $b32_nrm = sp + 4 | 0;
 $result = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$a32$addr >> 2] | 0;
 HEAP32[$a_headrm >> 2] = (_silk_CLZ32_427((HEAP32[$a32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$a32_nrm >> 2] = HEAP32[$a32$addr >> 2] << HEAP32[$a_headrm >> 2];
 $5 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_427((HEAP32[$b32$addr >> 2] | 0) > 0 ? $5 : 0 - $5 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 $mul = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = $mul + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 $13 = HEAP32[$a32_nrm >> 2] | 0;
 $14 = HEAP32[$b32_nrm >> 2] | 0;
 $17 = HEAP32[$result >> 2] | 0;
 $20 = ___muldi3($14 | 0, (($14 | 0) < 0) << 31 >> 31 | 0, $17 | 0, (($17 | 0) < 0) << 31 >> 31 | 0) | 0;
 $22 = _bitshift64Ashr($20 | 0, tempRet0 | 0, 32) | 0;
 HEAP32[$a32_nrm >> 2] = $13 - ($22 << 3);
 $mul27 = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = (HEAP32[$result >> 2] | 0) + ($mul27 + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$lshift >> 2] = 29 + (HEAP32[$a_headrm >> 2] | 0) - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $33 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) >= 0) if (($33 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 }
 $35 = HEAP32[$result >> 2] | 0;
 $sub47 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $33 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($35 | 0) > (-2147483648 >> $sub47 | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($35 | 0) > (2147483647 >> $sub47 | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond89 << 0 - (HEAP32[$lshift >> 2] | 0);
 $50 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $50 | 0;
}

function _silk_DIV32_varQ_419($a32, $b32, $Qres) {
 $a32 = $a32 | 0;
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $13 = 0, $14 = 0, $17 = 0, $20 = 0, $22 = 0, $33 = 0, $35 = 0, $5 = 0, $50 = 0, $Qres$addr = 0, $a32$addr = 0, $a32_nrm = 0, $a_headrm = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond89 = 0, $lshift = 0, $mul = 0, $mul27 = 0, $result = 0, $retval = 0, $sub47 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 40 | 0;
 $a32$addr = sp + 36 | 0;
 $b32$addr = sp + 32 | 0;
 $Qres$addr = sp + 28 | 0;
 $a_headrm = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $a32_nrm = sp + 8 | 0;
 $b32_nrm = sp + 4 | 0;
 $result = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$a32$addr >> 2] | 0;
 HEAP32[$a_headrm >> 2] = (_silk_CLZ32_420((HEAP32[$a32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$a32_nrm >> 2] = HEAP32[$a32$addr >> 2] << HEAP32[$a_headrm >> 2];
 $5 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_420((HEAP32[$b32$addr >> 2] | 0) > 0 ? $5 : 0 - $5 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 $mul = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = $mul + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 $13 = HEAP32[$a32_nrm >> 2] | 0;
 $14 = HEAP32[$b32_nrm >> 2] | 0;
 $17 = HEAP32[$result >> 2] | 0;
 $20 = ___muldi3($14 | 0, (($14 | 0) < 0) << 31 >> 31 | 0, $17 | 0, (($17 | 0) < 0) << 31 >> 31 | 0) | 0;
 $22 = _bitshift64Ashr($20 | 0, tempRet0 | 0, 32) | 0;
 HEAP32[$a32_nrm >> 2] = $13 - ($22 << 3);
 $mul27 = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = (HEAP32[$result >> 2] | 0) + ($mul27 + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$lshift >> 2] = 29 + (HEAP32[$a_headrm >> 2] | 0) - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $33 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) >= 0) if (($33 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 }
 $35 = HEAP32[$result >> 2] | 0;
 $sub47 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $33 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($35 | 0) > (-2147483648 >> $sub47 | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($35 | 0) > (2147483647 >> $sub47 | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond89 << 0 - (HEAP32[$lshift >> 2] | 0);
 $50 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $50 | 0;
}

function _silk_DIV32_varQ_275($a32, $b32, $Qres) {
 $a32 = $a32 | 0;
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $13 = 0, $14 = 0, $17 = 0, $20 = 0, $22 = 0, $33 = 0, $35 = 0, $5 = 0, $50 = 0, $Qres$addr = 0, $a32$addr = 0, $a32_nrm = 0, $a_headrm = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond89 = 0, $lshift = 0, $mul = 0, $mul27 = 0, $result = 0, $retval = 0, $sub47 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 40 | 0;
 $a32$addr = sp + 36 | 0;
 $b32$addr = sp + 32 | 0;
 $Qres$addr = sp + 28 | 0;
 $a_headrm = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $a32_nrm = sp + 8 | 0;
 $b32_nrm = sp + 4 | 0;
 $result = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$a32$addr >> 2] | 0;
 HEAP32[$a_headrm >> 2] = (_silk_CLZ32_277((HEAP32[$a32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$a32_nrm >> 2] = HEAP32[$a32$addr >> 2] << HEAP32[$a_headrm >> 2];
 $5 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_277((HEAP32[$b32$addr >> 2] | 0) > 0 ? $5 : 0 - $5 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 $mul = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = $mul + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 $13 = HEAP32[$a32_nrm >> 2] | 0;
 $14 = HEAP32[$b32_nrm >> 2] | 0;
 $17 = HEAP32[$result >> 2] | 0;
 $20 = ___muldi3($14 | 0, (($14 | 0) < 0) << 31 >> 31 | 0, $17 | 0, (($17 | 0) < 0) << 31 >> 31 | 0) | 0;
 $22 = _bitshift64Ashr($20 | 0, tempRet0 | 0, 32) | 0;
 HEAP32[$a32_nrm >> 2] = $13 - ($22 << 3);
 $mul27 = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = (HEAP32[$result >> 2] | 0) + ($mul27 + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$lshift >> 2] = 29 + (HEAP32[$a_headrm >> 2] | 0) - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $33 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) >= 0) if (($33 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 }
 $35 = HEAP32[$result >> 2] | 0;
 $sub47 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $33 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($35 | 0) > (-2147483648 >> $sub47 | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($35 | 0) > (2147483647 >> $sub47 | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond89 << 0 - (HEAP32[$lshift >> 2] | 0);
 $50 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $50 | 0;
}

function _silk_DIV32_varQ($a32, $b32, $Qres) {
 $a32 = $a32 | 0;
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $13 = 0, $14 = 0, $17 = 0, $20 = 0, $22 = 0, $33 = 0, $35 = 0, $5 = 0, $50 = 0, $Qres$addr = 0, $a32$addr = 0, $a32_nrm = 0, $a_headrm = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond89 = 0, $lshift = 0, $mul = 0, $mul27 = 0, $result = 0, $retval = 0, $sub47 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 40 | 0;
 $a32$addr = sp + 36 | 0;
 $b32$addr = sp + 32 | 0;
 $Qres$addr = sp + 28 | 0;
 $a_headrm = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $a32_nrm = sp + 8 | 0;
 $b32_nrm = sp + 4 | 0;
 $result = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$a32$addr >> 2] | 0;
 HEAP32[$a_headrm >> 2] = (_silk_CLZ32((HEAP32[$a32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$a32_nrm >> 2] = HEAP32[$a32$addr >> 2] << HEAP32[$a_headrm >> 2];
 $5 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32((HEAP32[$b32$addr >> 2] | 0) > 0 ? $5 : 0 - $5 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 $mul = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = $mul + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16);
 $13 = HEAP32[$a32_nrm >> 2] | 0;
 $14 = HEAP32[$b32_nrm >> 2] | 0;
 $17 = HEAP32[$result >> 2] | 0;
 $20 = ___muldi3($14 | 0, (($14 | 0) < 0) << 31 >> 31 | 0, $17 | 0, (($17 | 0) < 0) << 31 >> 31 | 0) | 0;
 $22 = _bitshift64Ashr($20 | 0, tempRet0 | 0, 32) | 0;
 HEAP32[$a32_nrm >> 2] = $13 - ($22 << 3);
 $mul27 = Math_imul(HEAP32[$a32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$result >> 2] = (HEAP32[$result >> 2] | 0) + ($mul27 + ((Math_imul(HEAP32[$a32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$lshift >> 2] = 29 + (HEAP32[$a_headrm >> 2] | 0) - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $33 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) >= 0) if (($33 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $50 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $50 | 0;
 }
 $35 = HEAP32[$result >> 2] | 0;
 $sub47 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $33 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($35 | 0) > (-2147483648 >> $sub47 | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($35 | 0) > (2147483647 >> $sub47 | 0)) {
   $cond89 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond89 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond89 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond89 << 0 - (HEAP32[$lshift >> 2] | 0);
 $50 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $50 | 0;
}

function _silk_VAD_GetNoiseLevels($pX, $psSilk_VAD) {
 $pX = $pX | 0;
 $psSilk_VAD = $psSilk_VAD | 0;
 var $5 = 0, $add24 = 0, $add41 = 0, $add69 = 0, $coef = 0, $cond = 0, $counter83 = 0, $inv_nrg = 0, $k = 0, $min_coef = 0, $mul = 0, $mul31 = 0, $mul35 = 0, $mul59 = 0, $nl = 0, $nrg = 0, $pX$addr = 0, $psSilk_VAD$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $pX$addr = sp + 28 | 0;
 $psSilk_VAD$addr = sp + 24 | 0;
 $k = sp + 20 | 0;
 $nl = sp + 16 | 0;
 $nrg = sp + 12 | 0;
 $inv_nrg = sp + 8 | 0;
 $coef = sp + 4 | 0;
 $min_coef = sp;
 HEAP32[$pX$addr >> 2] = $pX;
 HEAP32[$psSilk_VAD$addr >> 2] = $psSilk_VAD;
 if ((HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 108 >> 2] | 0) < 1e3) HEAP32[$min_coef >> 2] = 32767 / ((HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 108 >> 2] >> 4) + 1 | 0) | 0; else HEAP32[$min_coef >> 2] = 0;
 HEAP32[$k >> 2] = 0;
 while (1) {
  $5 = HEAP32[$psSilk_VAD$addr >> 2] | 0;
  if ((HEAP32[$k >> 2] | 0) >= 4) break;
  HEAP32[$nl >> 2] = HEAP32[$5 + 60 + (HEAP32[$k >> 2] << 2) >> 2];
  if ((HEAP32[(HEAP32[$pX$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) + (HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 92 + (HEAP32[$k >> 2] << 2) >> 2] | 0) & -2147483648 | 0) $cond = 2147483647; else $cond = (HEAP32[(HEAP32[$pX$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) + (HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 92 + (HEAP32[$k >> 2] << 2) >> 2] | 0) | 0;
  HEAP32[$nrg >> 2] = $cond;
  HEAP32[$inv_nrg >> 2] = 2147483647 / (HEAP32[$nrg >> 2] | 0) | 0;
  do if ((HEAP32[$nrg >> 2] | 0) > (HEAP32[$nl >> 2] << 3 | 0)) HEAP32[$coef >> 2] = 128; else if ((HEAP32[$nrg >> 2] | 0) < (HEAP32[$nl >> 2] | 0)) {
   HEAP32[$coef >> 2] = 1024;
   break;
  } else {
   $mul = Math_imul(HEAP32[$inv_nrg >> 2] >> 16, (HEAP32[$nl >> 2] & 65535) << 16 >> 16) | 0;
   $add24 = $mul + ((Math_imul(HEAP32[$inv_nrg >> 2] & 65535, (HEAP32[$nl >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   $mul31 = $add24 + (Math_imul(HEAP32[$inv_nrg >> 2] | 0, (HEAP32[$nl >> 2] >> 15) + 1 >> 1) | 0) >> 16 << 11;
   $mul35 = Math_imul(HEAP32[$inv_nrg >> 2] >> 16, (HEAP32[$nl >> 2] & 65535) << 16 >> 16) | 0;
   $add41 = $mul35 + ((Math_imul(HEAP32[$inv_nrg >> 2] & 65535, (HEAP32[$nl >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
   HEAP32[$coef >> 2] = $mul31 + (($add41 + (Math_imul(HEAP32[$inv_nrg >> 2] | 0, (HEAP32[$nl >> 2] >> 15) + 1 >> 1) | 0) & 65535) << 11 >> 16);
   break;
  } while (0);
  HEAP32[$coef >> 2] = _silk_max_int_459(HEAP32[$coef >> 2] | 0, HEAP32[$min_coef >> 2] | 0) | 0;
  $mul59 = Math_imul((HEAP32[$inv_nrg >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 76 + (HEAP32[$k >> 2] << 2) >> 2] | 0) >> 16, (HEAP32[$coef >> 2] & 65535) << 16 >> 16) | 0;
  $add69 = (HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 76 + (HEAP32[$k >> 2] << 2) >> 2] | 0) + ($mul59 + ((Math_imul((HEAP32[$inv_nrg >> 2] | 0) - (HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 76 + (HEAP32[$k >> 2] << 2) >> 2] | 0) & 65535, (HEAP32[$coef >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
  HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 76 + (HEAP32[$k >> 2] << 2) >> 2] = $add69;
  HEAP32[$nl >> 2] = 2147483647 / (HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 76 + (HEAP32[$k >> 2] << 2) >> 2] | 0) | 0;
  HEAP32[$nl >> 2] = (HEAP32[$nl >> 2] | 0) < 16777215 ? HEAP32[$nl >> 2] | 0 : 16777215;
  HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 60 + (HEAP32[$k >> 2] << 2) >> 2] = HEAP32[$nl >> 2];
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 $counter83 = $5 + 108 | 0;
 HEAP32[$counter83 >> 2] = (HEAP32[$counter83 >> 2] | 0) + 1;
 STACKTOP = sp;
 return;
}

function _tf_encode($start, $end, $isTransient, $tf_res, $LM, $tf_select, $enc) {
 $start = $start | 0;
 $end = $end | 0;
 $isTransient = $isTransient | 0;
 $tf_res = $tf_res | 0;
 $LM = $LM | 0;
 $tf_select = $tf_select | 0;
 $enc = $enc | 0;
 var $8 = 0, $LM$addr = 0, $budget = 0, $curr = 0, $enc$addr = 0, $end$addr = 0, $i = 0, $isTransient$addr = 0, $logp = 0, $start$addr = 0, $tell = 0, $tf_changed = 0, $tf_res$addr = 0, $tf_select$addr = 0, $tf_select_rsv = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $start$addr = sp + 52 | 0;
 $end$addr = sp + 48 | 0;
 $isTransient$addr = sp + 44 | 0;
 $tf_res$addr = sp + 40 | 0;
 $LM$addr = sp + 36 | 0;
 $tf_select$addr = sp + 32 | 0;
 $enc$addr = sp + 28 | 0;
 $curr = sp + 24 | 0;
 $i = sp + 20 | 0;
 $tf_select_rsv = sp + 16 | 0;
 $tf_changed = sp + 12 | 0;
 $logp = sp + 8 | 0;
 $budget = sp + 4 | 0;
 $tell = sp;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$isTransient$addr >> 2] = $isTransient;
 HEAP32[$tf_res$addr >> 2] = $tf_res;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$tf_select$addr >> 2] = $tf_select;
 HEAP32[$enc$addr >> 2] = $enc;
 HEAP32[$budget >> 2] = HEAP32[(HEAP32[$enc$addr >> 2] | 0) + 4 >> 2] << 3;
 HEAP32[$tell >> 2] = _ec_tell_54(HEAP32[$enc$addr >> 2] | 0) | 0;
 HEAP32[$logp >> 2] = HEAP32[$isTransient$addr >> 2] | 0 ? 2 : 4;
 if ((HEAP32[$LM$addr >> 2] | 0) > 0) $8 = ((HEAP32[$tell >> 2] | 0) + (HEAP32[$logp >> 2] | 0) + 1 | 0) >>> 0 <= (HEAP32[$budget >> 2] | 0) >>> 0; else $8 = 0;
 HEAP32[$tf_select_rsv >> 2] = $8 & 1;
 HEAP32[$budget >> 2] = (HEAP32[$budget >> 2] | 0) - (HEAP32[$tf_select_rsv >> 2] | 0);
 HEAP32[$tf_changed >> 2] = 0;
 HEAP32[$curr >> 2] = 0;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  if (((HEAP32[$tell >> 2] | 0) + (HEAP32[$logp >> 2] | 0) | 0) >>> 0 <= (HEAP32[$budget >> 2] | 0) >>> 0) {
   _ec_enc_bit_logp(HEAP32[$enc$addr >> 2] | 0, HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] ^ HEAP32[$curr >> 2], HEAP32[$logp >> 2] | 0);
   HEAP32[$tell >> 2] = _ec_tell_54(HEAP32[$enc$addr >> 2] | 0) | 0;
   HEAP32[$curr >> 2] = HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$tf_changed >> 2] = HEAP32[$tf_changed >> 2] | HEAP32[$curr >> 2];
  } else HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$curr >> 2];
  HEAP32[$logp >> 2] = HEAP32[$isTransient$addr >> 2] | 0 ? 4 : 5;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if (HEAP32[$tf_select_rsv >> 2] | 0) if ((HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + 0 + (HEAP32[$tf_changed >> 2] | 0)) >> 0] | 0) != (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + 2 + (HEAP32[$tf_changed >> 2] | 0)) >> 0] | 0)) _ec_enc_bit_logp(HEAP32[$enc$addr >> 2] | 0, HEAP32[$tf_select$addr >> 2] | 0, 1); else label = 12; else label = 12;
 if ((label | 0) == 12) HEAP32[$tf_select$addr >> 2] = 0;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$tf_select$addr >> 2] << 1) + (HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0)) >> 0];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _exp_rotation($X, $len, $dir, $stride, $K, $spread) {
 $X = $X | 0;
 $len = $len | 0;
 $dir = $dir | 0;
 $stride = $stride | 0;
 $K = $K | 0;
 $spread = $spread | 0;
 var $K$addr = 0, $X$addr = 0, $add$ptr = 0, $add$ptr36 = 0, $add$ptr38 = 0, $add$ptr43 = 0, $c = 0, $dir$addr = 0, $factor = 0, $gain = 0, $i = 0, $len$addr = 0, $mul19 = 0, $mul21 = 0, $s = 0, $spread$addr = 0, $stride$addr = 0, $stride2 = 0, $theta = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $X$addr = sp + 48 | 0;
 $len$addr = sp + 44 | 0;
 $dir$addr = sp + 40 | 0;
 $stride$addr = sp + 36 | 0;
 $K$addr = sp + 32 | 0;
 $spread$addr = sp + 28 | 0;
 $i = sp + 24 | 0;
 $c = sp + 20 | 0;
 $s = sp + 16 | 0;
 $gain = sp + 12 | 0;
 $theta = sp + 8 | 0;
 $stride2 = sp + 4 | 0;
 $factor = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$dir$addr >> 2] = $dir;
 HEAP32[$stride$addr >> 2] = $stride;
 HEAP32[$K$addr >> 2] = $K;
 HEAP32[$spread$addr >> 2] = $spread;
 HEAP32[$stride2 >> 2] = 0;
 if ((HEAP32[$spread$addr >> 2] | 0) == 0 ? 1 : (HEAP32[$K$addr >> 2] << 1 | 0) >= (HEAP32[$len$addr >> 2] | 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$factor >> 2] = HEAP32[15032 + ((HEAP32[$spread$addr >> 2] | 0) - 1 << 2) >> 2];
 HEAPF32[$gain >> 2] = +(HEAP32[$len$addr >> 2] | 0) * 1.0 / +((HEAP32[$len$addr >> 2] | 0) + (Math_imul(HEAP32[$factor >> 2] | 0, HEAP32[$K$addr >> 2] | 0) | 0) | 0);
 HEAPF32[$theta >> 2] = +HEAPF32[$gain >> 2] * +HEAPF32[$gain >> 2] * .5;
 HEAPF32[$c >> 2] = +Math_cos(+(+HEAPF32[$theta >> 2] * 1.5707963705062866));
 HEAPF32[$s >> 2] = +Math_cos(+((1.0 - +HEAPF32[$theta >> 2]) * 1.5707963705062866));
 L4 : do if ((HEAP32[$len$addr >> 2] | 0) >= (HEAP32[$stride$addr >> 2] << 3 | 0)) {
  HEAP32[$stride2 >> 2] = 1;
  while (1) {
   $mul19 = Math_imul(HEAP32[$stride2 >> 2] | 0, HEAP32[$stride2 >> 2] | 0) | 0;
   $mul21 = Math_imul($mul19 + (HEAP32[$stride2 >> 2] | 0) | 0, HEAP32[$stride$addr >> 2] | 0) | 0;
   if (($mul21 + (HEAP32[$stride$addr >> 2] >> 2) | 0) >= (HEAP32[$len$addr >> 2] | 0)) break L4;
   HEAP32[$stride2 >> 2] = (HEAP32[$stride2 >> 2] | 0) + 1;
  }
 } while (0);
 HEAP32[$len$addr >> 2] = _celt_udiv_139(HEAP32[$len$addr >> 2] | 0, HEAP32[$stride$addr >> 2] | 0) | 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$stride$addr >> 2] | 0)) break;
  if ((HEAP32[$dir$addr >> 2] | 0) < 0) {
   if (HEAP32[$stride2 >> 2] | 0) {
    $add$ptr = (HEAP32[$X$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$len$addr >> 2] | 0) | 0) << 2) | 0;
    _exp_rotation1($add$ptr, HEAP32[$len$addr >> 2] | 0, HEAP32[$stride2 >> 2] | 0, +HEAPF32[$s >> 2], +HEAPF32[$c >> 2]);
   }
   $add$ptr36 = (HEAP32[$X$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$len$addr >> 2] | 0) | 0) << 2) | 0;
   _exp_rotation1($add$ptr36, HEAP32[$len$addr >> 2] | 0, 1, +HEAPF32[$c >> 2], +HEAPF32[$s >> 2]);
  } else {
   $add$ptr38 = (HEAP32[$X$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$len$addr >> 2] | 0) | 0) << 2) | 0;
   _exp_rotation1($add$ptr38, HEAP32[$len$addr >> 2] | 0, 1, +HEAPF32[$c >> 2], -+HEAPF32[$s >> 2]);
   if (HEAP32[$stride2 >> 2] | 0) {
    $add$ptr43 = (HEAP32[$X$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$len$addr >> 2] | 0) | 0) << 2) | 0;
    _exp_rotation1($add$ptr43, HEAP32[$len$addr >> 2] | 0, HEAP32[$stride2 >> 2] | 0, +HEAPF32[$s >> 2], -+HEAPF32[$c >> 2]);
   }
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _deinterleave_hadamard($X, $N0, $stride, $hadamard) {
 $X = $X | 0;
 $N0 = $N0 | 0;
 $stride = $stride | 0;
 $hadamard = $hadamard | 0;
 var $2 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $N = 0, $N0$addr = 0, $X$addr = 0, $add33 = 0, $hadamard$addr = 0, $i = 0, $j = 0, $mul19 = 0, $mul22 = 0, $mul31 = 0, $mul32 = 0, $mul5 = 0, $mul7 = 0, $ordery = 0, $saved_stack = 0, $stride$addr = 0, $sub$ptr$div = 0, $sub$ptr$lhs$cast = 0, $sub$ptr$rhs$cast = 0, $sub$ptr$sub = 0, $vla = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $X$addr = sp + 32 | 0;
 $N0$addr = sp + 28 | 0;
 $stride$addr = sp + 24 | 0;
 $hadamard$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $j = sp + 12 | 0;
 $N = sp + 8 | 0;
 $saved_stack = sp + 4 | 0;
 $ordery = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N0$addr >> 2] = $N0;
 HEAP32[$stride$addr >> 2] = $stride;
 HEAP32[$hadamard$addr >> 2] = $hadamard;
 HEAP32[$N >> 2] = Math_imul(HEAP32[$N0$addr >> 2] | 0, HEAP32[$stride$addr >> 2] | 0) | 0;
 $2 = HEAP32[$N >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($2 << 2) | 0) + 15 & -16) | 0;
 if (HEAP32[$hadamard$addr >> 2] | 0) {
  HEAP32[$ordery >> 2] = 15340 + (HEAP32[$stride$addr >> 2] << 2) + -8;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$stride$addr >> 2] | 0)) break;
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N0$addr >> 2] | 0)) break;
    $mul5 = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride$addr >> 2] | 0) | 0;
    $mul7 = Math_imul(HEAP32[(HEAP32[$ordery >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0, HEAP32[$N0$addr >> 2] | 0) | 0;
    HEAPF32[$vla + ($mul7 + (HEAP32[$j >> 2] | 0) << 2) >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ($mul5 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $36 = HEAP32[$X$addr >> 2] | 0;
  $37 = HEAP32[$N >> 2] | 0;
  $mul31 = $37 << 2;
  $38 = HEAP32[$X$addr >> 2] | 0;
  $sub$ptr$lhs$cast = $38;
  $sub$ptr$rhs$cast = $vla;
  $sub$ptr$sub = $sub$ptr$lhs$cast - $sub$ptr$rhs$cast | 0;
  $sub$ptr$div = ($sub$ptr$sub | 0) / 4 | 0;
  $mul32 = 0;
  $add33 = $mul31 + $mul32 | 0;
  _memcpy($36 | 0, $vla | 0, $add33 | 0) | 0;
  $39 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($39 | 0);
  STACKTOP = sp;
  return;
 } else {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$stride$addr >> 2] | 0)) break;
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N0$addr >> 2] | 0)) break;
    $mul19 = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride$addr >> 2] | 0) | 0;
    $mul22 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$N0$addr >> 2] | 0) | 0;
    HEAPF32[$vla + ($mul22 + (HEAP32[$j >> 2] | 0) << 2) >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ($mul19 + (HEAP32[$i >> 2] | 0) << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $36 = HEAP32[$X$addr >> 2] | 0;
  $37 = HEAP32[$N >> 2] | 0;
  $mul31 = $37 << 2;
  $38 = HEAP32[$X$addr >> 2] | 0;
  $sub$ptr$lhs$cast = $38;
  $sub$ptr$rhs$cast = $vla;
  $sub$ptr$sub = $sub$ptr$lhs$cast - $sub$ptr$rhs$cast | 0;
  $sub$ptr$div = ($sub$ptr$sub | 0) / 4 | 0;
  $mul32 = 0;
  $add33 = $mul31 + $mul32 | 0;
  _memcpy($36 | 0, $vla | 0, $add33 | 0) | 0;
  $39 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($39 | 0);
  STACKTOP = sp;
  return;
 }
}

function _interleave_hadamard($X, $N0, $stride, $hadamard) {
 $X = $X | 0;
 $N0 = $N0 | 0;
 $stride = $stride | 0;
 $hadamard = $hadamard | 0;
 var $2 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $N = 0, $N0$addr = 0, $X$addr = 0, $add33 = 0, $hadamard$addr = 0, $i = 0, $j = 0, $mul19 = 0, $mul22 = 0, $mul31 = 0, $mul32 = 0, $mul5 = 0, $mul7 = 0, $ordery = 0, $saved_stack = 0, $stride$addr = 0, $sub$ptr$div = 0, $sub$ptr$lhs$cast = 0, $sub$ptr$rhs$cast = 0, $sub$ptr$sub = 0, $vla = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $X$addr = sp + 32 | 0;
 $N0$addr = sp + 28 | 0;
 $stride$addr = sp + 24 | 0;
 $hadamard$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $j = sp + 12 | 0;
 $N = sp + 8 | 0;
 $saved_stack = sp + 4 | 0;
 $ordery = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N0$addr >> 2] = $N0;
 HEAP32[$stride$addr >> 2] = $stride;
 HEAP32[$hadamard$addr >> 2] = $hadamard;
 HEAP32[$N >> 2] = Math_imul(HEAP32[$N0$addr >> 2] | 0, HEAP32[$stride$addr >> 2] | 0) | 0;
 $2 = HEAP32[$N >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($2 << 2) | 0) + 15 & -16) | 0;
 if (HEAP32[$hadamard$addr >> 2] | 0) {
  HEAP32[$ordery >> 2] = 15340 + (HEAP32[$stride$addr >> 2] << 2) + -8;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$stride$addr >> 2] | 0)) break;
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N0$addr >> 2] | 0)) break;
    $mul5 = Math_imul(HEAP32[(HEAP32[$ordery >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0, HEAP32[$N0$addr >> 2] | 0) | 0;
    $mul7 = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride$addr >> 2] | 0) | 0;
    HEAPF32[$vla + ($mul7 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ($mul5 + (HEAP32[$j >> 2] | 0) << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $36 = HEAP32[$X$addr >> 2] | 0;
  $37 = HEAP32[$N >> 2] | 0;
  $mul31 = $37 << 2;
  $38 = HEAP32[$X$addr >> 2] | 0;
  $sub$ptr$lhs$cast = $38;
  $sub$ptr$rhs$cast = $vla;
  $sub$ptr$sub = $sub$ptr$lhs$cast - $sub$ptr$rhs$cast | 0;
  $sub$ptr$div = ($sub$ptr$sub | 0) / 4 | 0;
  $mul32 = 0;
  $add33 = $mul31 + $mul32 | 0;
  _memcpy($36 | 0, $vla | 0, $add33 | 0) | 0;
  $39 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($39 | 0);
  STACKTOP = sp;
  return;
 } else {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$stride$addr >> 2] | 0)) break;
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N0$addr >> 2] | 0)) break;
    $mul19 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$N0$addr >> 2] | 0) | 0;
    $mul22 = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride$addr >> 2] | 0) | 0;
    HEAPF32[$vla + ($mul22 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ($mul19 + (HEAP32[$j >> 2] | 0) << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $36 = HEAP32[$X$addr >> 2] | 0;
  $37 = HEAP32[$N >> 2] | 0;
  $mul31 = $37 << 2;
  $38 = HEAP32[$X$addr >> 2] | 0;
  $sub$ptr$lhs$cast = $38;
  $sub$ptr$rhs$cast = $vla;
  $sub$ptr$sub = $sub$ptr$lhs$cast - $sub$ptr$rhs$cast | 0;
  $sub$ptr$div = ($sub$ptr$sub | 0) / 4 | 0;
  $mul32 = 0;
  $add33 = $mul31 + $mul32 | 0;
  _memcpy($36 | 0, $vla | 0, $add33 | 0) | 0;
  $39 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($39 | 0);
  STACKTOP = sp;
  return;
 }
}

function _silk_sum_sqr_shift($energy, $shift, $x, $len) {
 $energy = $energy | 0;
 $shift = $shift | 0;
 $x = $x | 0;
 $len = $len | 0;
 var $64 = 0, $65 = 0, $66 = 0, $67 = 0, $add22 = 0, $energy$addr = 0, $i = 0, $len$addr = 0, $nrg = 0, $nrg_tmp = 0, $shft = 0, $shift$addr = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $energy$addr = sp + 28 | 0;
 $shift$addr = sp + 24 | 0;
 $x$addr = sp + 20 | 0;
 $len$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $shft = sp + 8 | 0;
 $nrg_tmp = sp + 4 | 0;
 $nrg = sp;
 HEAP32[$energy$addr >> 2] = $energy;
 HEAP32[$shift$addr >> 2] = $shift;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$shft >> 2] = 31 - (_silk_CLZ32_527(HEAP32[$len$addr >> 2] | 0) | 0);
 HEAP32[$nrg >> 2] = HEAP32[$len$addr >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$len$addr >> 2] | 0) - 1 | 0)) break;
  HEAP32[$nrg_tmp >> 2] = Math_imul(HEAP16[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, HEAP16[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
  HEAP32[$nrg_tmp >> 2] = (HEAP32[$nrg_tmp >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0, HEAP16[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) | 0);
  HEAP32[$nrg >> 2] = (HEAP32[$nrg >> 2] | 0) + ((HEAP32[$nrg_tmp >> 2] | 0) >>> (HEAP32[$shft >> 2] | 0));
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 2;
 }
 if ((HEAP32[$i >> 2] | 0) < (HEAP32[$len$addr >> 2] | 0)) {
  HEAP32[$nrg_tmp >> 2] = Math_imul(HEAP16[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, HEAP16[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
  HEAP32[$nrg >> 2] = (HEAP32[$nrg >> 2] | 0) + ((HEAP32[$nrg_tmp >> 2] | 0) >>> (HEAP32[$shft >> 2] | 0));
 }
 $add22 = (HEAP32[$shft >> 2] | 0) + 3 | 0;
 HEAP32[$shft >> 2] = _silk_max_32_528(0, $add22 - (_silk_CLZ32_527(HEAP32[$nrg >> 2] | 0) | 0) | 0) | 0;
 HEAP32[$nrg >> 2] = 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$len$addr >> 2] | 0) - 1 | 0)) break;
  HEAP32[$nrg_tmp >> 2] = Math_imul(HEAP16[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, HEAP16[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
  HEAP32[$nrg_tmp >> 2] = (HEAP32[$nrg_tmp >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0, HEAP16[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) | 0);
  HEAP32[$nrg >> 2] = (HEAP32[$nrg >> 2] | 0) + ((HEAP32[$nrg_tmp >> 2] | 0) >>> (HEAP32[$shft >> 2] | 0));
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 2;
 }
 if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) {
  $64 = HEAP32[$shft >> 2] | 0;
  $65 = HEAP32[$shift$addr >> 2] | 0;
  HEAP32[$65 >> 2] = $64;
  $66 = HEAP32[$nrg >> 2] | 0;
  $67 = HEAP32[$energy$addr >> 2] | 0;
  HEAP32[$67 >> 2] = $66;
  STACKTOP = sp;
  return;
 }
 HEAP32[$nrg_tmp >> 2] = Math_imul(HEAP16[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, HEAP16[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
 HEAP32[$nrg >> 2] = (HEAP32[$nrg >> 2] | 0) + ((HEAP32[$nrg_tmp >> 2] | 0) >>> (HEAP32[$shft >> 2] | 0));
 $64 = HEAP32[$shft >> 2] | 0;
 $65 = HEAP32[$shift$addr >> 2] | 0;
 HEAP32[$65 >> 2] = $64;
 $66 = HEAP32[$nrg >> 2] | 0;
 $67 = HEAP32[$energy$addr >> 2] | 0;
 HEAP32[$67 >> 2] = $66;
 STACKTOP = sp;
 return;
}

function _ec_enc_done($_this) {
 $_this = $_this | 0;
 var $21 = 0, $34 = 0, $_this$addr = 0, $arrayidx = 0, $call = 0, $end = 0, $error = 0, $l = 0, $msk = 0, $used = 0, $window = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 20 | 0;
 $window = sp + 16 | 0;
 $used = sp + 12 | 0;
 $msk = sp + 8 | 0;
 $end = sp + 4 | 0;
 $l = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$l >> 2] = 32 - (32 - (Math_clz32(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0));
 HEAP32[$msk >> 2] = 2147483647 >>> (HEAP32[$l >> 2] | 0);
 HEAP32[$end >> 2] = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$msk >> 2] | 0) & ~HEAP32[$msk >> 2];
 if ((HEAP32[$end >> 2] | HEAP32[$msk >> 2]) >>> 0 >= ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0) >>> 0) {
  HEAP32[$l >> 2] = (HEAP32[$l >> 2] | 0) + 1;
  HEAP32[$msk >> 2] = (HEAP32[$msk >> 2] | 0) >>> 1;
  HEAP32[$end >> 2] = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$msk >> 2] | 0) & ~HEAP32[$msk >> 2];
 }
 while (1) {
  $21 = HEAP32[$_this$addr >> 2] | 0;
  if ((HEAP32[$l >> 2] | 0) <= 0) break;
  _ec_enc_carry_out($21, (HEAP32[$end >> 2] | 0) >>> 23);
  HEAP32[$end >> 2] = HEAP32[$end >> 2] << 8 & 2147483647;
  HEAP32[$l >> 2] = (HEAP32[$l >> 2] | 0) - 8;
 }
 if ((HEAP32[$21 + 40 >> 2] | 0) >= 0) label = 7; else if ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 36 >> 2] | 0) >>> 0 > 0) label = 7;
 if ((label | 0) == 7) _ec_enc_carry_out(HEAP32[$_this$addr >> 2] | 0, 0);
 HEAP32[$window >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 12 >> 2];
 HEAP32[$used >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 16 >> 2];
 while (1) {
  $34 = HEAP32[$_this$addr >> 2] | 0;
  if ((HEAP32[$used >> 2] | 0) < 8) break;
  $call = _ec_write_byte_at_end($34, HEAP32[$window >> 2] & 255) | 0;
  $error = (HEAP32[$_this$addr >> 2] | 0) + 44 | 0;
  HEAP32[$error >> 2] = HEAP32[$error >> 2] | $call;
  HEAP32[$window >> 2] = (HEAP32[$window >> 2] | 0) >>> 8;
  HEAP32[$used >> 2] = (HEAP32[$used >> 2] | 0) - 8;
 }
 if (HEAP32[$34 + 44 >> 2] | 0) {
  STACKTOP = sp;
  return;
 }
 _memset((HEAP32[HEAP32[$_this$addr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] | 0) | 0, 0, (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0) - (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] | 0) - (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0) | 0) | 0;
 if ((HEAP32[$used >> 2] | 0) <= 0) {
  STACKTOP = sp;
  return;
 }
 if ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0) >>> 0 >= (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0) >>> 0) {
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 44 >> 2] = -1;
  STACKTOP = sp;
  return;
 }
 HEAP32[$l >> 2] = 0 - (HEAP32[$l >> 2] | 0);
 if (((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] | 0) + (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0) | 0) >>> 0 >= (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0) >>> 0) if ((HEAP32[$l >> 2] | 0) < (HEAP32[$used >> 2] | 0)) {
  HEAP32[$window >> 2] = HEAP32[$window >> 2] & (1 << HEAP32[$l >> 2]) - 1;
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 44 >> 2] = -1;
 }
 $arrayidx = (HEAP32[HEAP32[$_this$addr >> 2] >> 2] | 0) + ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0) - (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0) - 1) | 0;
 HEAP8[$arrayidx >> 0] = HEAPU8[$arrayidx >> 0] | 0 | HEAP32[$window >> 2] & 255;
 STACKTOP = sp;
 return;
}

function _find_best_pitch($xcorr, $y, $len, $max_pitch, $best_pitch) {
 $xcorr = $xcorr | 0;
 $y = $y | 0;
 $len = $len | 0;
 $max_pitch = $max_pitch | 0;
 $best_pitch = $best_pitch | 0;
 var $$sink = 0, $Syy = 0, $arrayidx39$sink = 0, $best_den = 0, $best_num = 0, $best_pitch$addr = 0, $i = 0, $j = 0, $len$addr = 0, $max_pitch$addr = 0, $num = 0, $xcorr$addr = 0, $xcorr16 = 0, $y$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $xcorr$addr = sp + 52 | 0;
 $y$addr = sp + 48 | 0;
 $len$addr = sp + 44 | 0;
 $max_pitch$addr = sp + 40 | 0;
 $best_pitch$addr = sp + 36 | 0;
 $i = sp + 32 | 0;
 $j = sp + 28 | 0;
 $Syy = sp + 24 | 0;
 $best_num = sp + 16 | 0;
 $best_den = sp + 8 | 0;
 $num = sp + 4 | 0;
 $xcorr16 = sp;
 HEAP32[$xcorr$addr >> 2] = $xcorr;
 HEAP32[$y$addr >> 2] = $y;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$max_pitch$addr >> 2] = $max_pitch;
 HEAP32[$best_pitch$addr >> 2] = $best_pitch;
 HEAPF32[$Syy >> 2] = 1.0;
 HEAPF32[$best_num >> 2] = -1.0;
 HEAPF32[$best_num + 4 >> 2] = -1.0;
 HEAPF32[$best_den >> 2] = 0.0;
 HEAPF32[$best_den + 4 >> 2] = 0.0;
 HEAP32[HEAP32[$best_pitch$addr >> 2] >> 2] = 0;
 HEAP32[(HEAP32[$best_pitch$addr >> 2] | 0) + 4 >> 2] = 1;
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  HEAPF32[$Syy >> 2] = +HEAPF32[$Syy >> 2] + +HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$max_pitch$addr >> 2] | 0)) break;
  if (+HEAPF32[(HEAP32[$xcorr$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] > 0.0) {
   HEAPF32[$xcorr16 >> 2] = +HEAPF32[(HEAP32[$xcorr$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$xcorr16 >> 2] = +HEAPF32[$xcorr16 >> 2] * 9.999999960041972e-13;
   HEAPF32[$num >> 2] = +HEAPF32[$xcorr16 >> 2] * +HEAPF32[$xcorr16 >> 2];
   if (+HEAPF32[$num >> 2] * +HEAPF32[$best_den + 4 >> 2] > +HEAPF32[$best_num + 4 >> 2] * +HEAPF32[$Syy >> 2]) {
    if (+HEAPF32[$num >> 2] * +HEAPF32[$best_den >> 2] > +HEAPF32[$best_num >> 2] * +HEAPF32[$Syy >> 2]) {
     HEAPF32[$best_num + 4 >> 2] = +HEAPF32[$best_num >> 2];
     HEAPF32[$best_den + 4 >> 2] = +HEAPF32[$best_den >> 2];
     HEAP32[(HEAP32[$best_pitch$addr >> 2] | 0) + 4 >> 2] = HEAP32[HEAP32[$best_pitch$addr >> 2] >> 2];
     HEAPF32[$best_num >> 2] = +HEAPF32[$num >> 2];
     HEAPF32[$best_den >> 2] = +HEAPF32[$Syy >> 2];
     $$sink = HEAP32[$i >> 2] | 0;
     $arrayidx39$sink = HEAP32[$best_pitch$addr >> 2] | 0;
    } else {
     HEAPF32[$best_num + 4 >> 2] = +HEAPF32[$num >> 2];
     HEAPF32[$best_den + 4 >> 2] = +HEAPF32[$Syy >> 2];
     $$sink = HEAP32[$i >> 2] | 0;
     $arrayidx39$sink = (HEAP32[$best_pitch$addr >> 2] | 0) + 4 | 0;
    }
    HEAP32[$arrayidx39$sink >> 2] = $$sink;
   }
  }
  HEAPF32[$Syy >> 2] = +HEAPF32[$Syy >> 2] + (+HEAPF32[(HEAP32[$y$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (HEAP32[$len$addr >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$y$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (HEAP32[$len$addr >> 2] | 0) << 2) >> 2] - +HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]);
  HEAPF32[$Syy >> 2] = 1.0 > +HEAPF32[$Syy >> 2] ? 1.0 : +HEAPF32[$Syy >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_LTP_analysis_filter_FLP($LTP_res, $x, $B, $pitchL, $invGains, $subfr_length, $nb_subfr, $pre_length) {
 $LTP_res = $LTP_res | 0;
 $x = $x | 0;
 $B = $B | 0;
 $pitchL = $pitchL | 0;
 $invGains = $invGains | 0;
 $subfr_length = $subfr_length | 0;
 $nb_subfr = $nb_subfr | 0;
 $pre_length = $pre_length | 0;
 var $B$addr = 0, $Btmp = 0, $LTP_res$addr = 0, $LTP_res_ptr = 0, $arrayidx19 = 0, $arrayidx24 = 0, $i = 0, $invGains$addr = 0, $inv_gain = 0, $j = 0, $k = 0, $nb_subfr$addr = 0, $pitchL$addr = 0, $pre_length$addr = 0, $subfr_length$addr = 0, $x$addr = 0, $x_lag_ptr = 0, $x_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $LTP_res$addr = sp + 76 | 0;
 $x$addr = sp + 72 | 0;
 $B$addr = sp + 68 | 0;
 $pitchL$addr = sp + 64 | 0;
 $invGains$addr = sp + 60 | 0;
 $subfr_length$addr = sp + 56 | 0;
 $nb_subfr$addr = sp + 52 | 0;
 $pre_length$addr = sp + 48 | 0;
 $x_ptr = sp + 44 | 0;
 $x_lag_ptr = sp + 40 | 0;
 $Btmp = sp + 20 | 0;
 $LTP_res_ptr = sp + 16 | 0;
 $inv_gain = sp + 12 | 0;
 $k = sp + 8 | 0;
 $i = sp + 4 | 0;
 $j = sp;
 HEAP32[$LTP_res$addr >> 2] = $LTP_res;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$B$addr >> 2] = $B;
 HEAP32[$pitchL$addr >> 2] = $pitchL;
 HEAP32[$invGains$addr >> 2] = $invGains;
 HEAP32[$subfr_length$addr >> 2] = $subfr_length;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$pre_length$addr >> 2] = $pre_length;
 HEAP32[$x_ptr >> 2] = HEAP32[$x$addr >> 2];
 HEAP32[$LTP_res_ptr >> 2] = HEAP32[$LTP_res$addr >> 2];
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  HEAP32[$x_lag_ptr >> 2] = (HEAP32[$x_ptr >> 2] | 0) + (0 - (HEAP32[(HEAP32[$pitchL$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) << 2);
  HEAPF32[$inv_gain >> 2] = +HEAPF32[(HEAP32[$invGains$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 5) break;
   HEAPF32[$Btmp + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$B$addr >> 2] | 0) + (((HEAP32[$k >> 2] | 0) * 5 | 0) + (HEAP32[$i >> 2] | 0) << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$subfr_length$addr >> 2] | 0) + (HEAP32[$pre_length$addr >> 2] | 0) | 0)) break;
   HEAPF32[(HEAP32[$LTP_res_ptr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$x_ptr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= 5) break;
    $arrayidx19 = (HEAP32[$LTP_res_ptr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
    HEAPF32[$arrayidx19 >> 2] = +HEAPF32[$arrayidx19 >> 2] - +HEAPF32[$Btmp + (HEAP32[$j >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$x_lag_ptr >> 2] | 0) + (2 - (HEAP32[$j >> 2] | 0) << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   $arrayidx24 = (HEAP32[$LTP_res_ptr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
   HEAPF32[$arrayidx24 >> 2] = +HEAPF32[$arrayidx24 >> 2] * +HEAPF32[$inv_gain >> 2];
   HEAP32[$x_lag_ptr >> 2] = (HEAP32[$x_lag_ptr >> 2] | 0) + 4;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$LTP_res_ptr >> 2] = (HEAP32[$LTP_res_ptr >> 2] | 0) + ((HEAP32[$subfr_length$addr >> 2] | 0) + (HEAP32[$pre_length$addr >> 2] | 0) << 2);
  HEAP32[$x_ptr >> 2] = (HEAP32[$x_ptr >> 2] | 0) + (HEAP32[$subfr_length$addr >> 2] << 2);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_corrMatrix_FLP($x, $L, $Order, $XX) {
 $x = $x | 0;
 $L = $L | 0;
 $Order = $Order | 0;
 $XX = $XX | 0;
 var $L$addr = 0, $Order$addr = 0, $XX$addr = 0, $energy = 0, $j = 0, $lag = 0, $mul16 = 0, $mul54 = 0, $mul58 = 0, $ptr1 = 0, $ptr2 = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $x$addr = sp + 36 | 0;
 $L$addr = sp + 32 | 0;
 $Order$addr = sp + 28 | 0;
 $XX$addr = sp + 24 | 0;
 $j = sp + 20 | 0;
 $lag = sp + 16 | 0;
 $energy = sp;
 $ptr1 = sp + 12 | 0;
 $ptr2 = sp + 8 | 0;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$L$addr >> 2] = $L;
 HEAP32[$Order$addr >> 2] = $Order;
 HEAP32[$XX$addr >> 2] = $XX;
 HEAP32[$ptr1 >> 2] = (HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$Order$addr >> 2] | 0) - 1 << 2);
 HEAPF64[$energy >> 3] = +_silk_energy_FLP(HEAP32[$ptr1 >> 2] | 0, HEAP32[$L$addr >> 2] | 0);
 HEAPF32[(HEAP32[$XX$addr >> 2] | 0) + (0 << 2) >> 2] = +HEAPF64[$energy >> 3];
 HEAP32[$j >> 2] = 1;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$Order$addr >> 2] | 0)) break;
  HEAPF64[$energy >> 3] = +HEAPF64[$energy >> 3] + (+HEAPF32[(HEAP32[$ptr1 >> 2] | 0) + (0 - (HEAP32[$j >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$ptr1 >> 2] | 0) + (0 - (HEAP32[$j >> 2] | 0) << 2) >> 2] - +HEAPF32[(HEAP32[$ptr1 >> 2] | 0) + ((HEAP32[$L$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$ptr1 >> 2] | 0) + ((HEAP32[$L$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) << 2) >> 2]);
  $mul16 = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$Order$addr >> 2] | 0) | 0;
  HEAPF32[(HEAP32[$XX$addr >> 2] | 0) + ($mul16 + (HEAP32[$j >> 2] | 0) << 2) >> 2] = +HEAPF64[$energy >> 3];
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAP32[$ptr2 >> 2] = (HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$Order$addr >> 2] | 0) - 2 << 2);
 HEAP32[$lag >> 2] = 1;
 while (1) {
  if ((HEAP32[$lag >> 2] | 0) >= (HEAP32[$Order$addr >> 2] | 0)) break;
  HEAPF64[$energy >> 3] = +_silk_inner_product_FLP(HEAP32[$ptr1 >> 2] | 0, HEAP32[$ptr2 >> 2] | 0, HEAP32[$L$addr >> 2] | 0);
  HEAPF32[(HEAP32[$XX$addr >> 2] | 0) + ((Math_imul(HEAP32[$lag >> 2] | 0, HEAP32[$Order$addr >> 2] | 0) | 0) + 0 << 2) >> 2] = +HEAPF64[$energy >> 3];
  HEAPF32[(HEAP32[$XX$addr >> 2] | 0) + (0 + (HEAP32[$lag >> 2] | 0) << 2) >> 2] = +HEAPF64[$energy >> 3];
  HEAP32[$j >> 2] = 1;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= ((HEAP32[$Order$addr >> 2] | 0) - (HEAP32[$lag >> 2] | 0) | 0)) break;
   HEAPF64[$energy >> 3] = +HEAPF64[$energy >> 3] + (+HEAPF32[(HEAP32[$ptr1 >> 2] | 0) + (0 - (HEAP32[$j >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$ptr2 >> 2] | 0) + (0 - (HEAP32[$j >> 2] | 0) << 2) >> 2] - +HEAPF32[(HEAP32[$ptr1 >> 2] | 0) + ((HEAP32[$L$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) << 2) >> 2] * +HEAPF32[(HEAP32[$ptr2 >> 2] | 0) + ((HEAP32[$L$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) << 2) >> 2]);
   $mul54 = Math_imul((HEAP32[$lag >> 2] | 0) + (HEAP32[$j >> 2] | 0) | 0, HEAP32[$Order$addr >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$XX$addr >> 2] | 0) + ($mul54 + (HEAP32[$j >> 2] | 0) << 2) >> 2] = +HEAPF64[$energy >> 3];
   $mul58 = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$Order$addr >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$XX$addr >> 2] | 0) + ($mul58 + ((HEAP32[$lag >> 2] | 0) + (HEAP32[$j >> 2] | 0)) << 2) >> 2] = +HEAPF64[$energy >> 3];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$ptr2 >> 2] = (HEAP32[$ptr2 >> 2] | 0) + -4;
  HEAP32[$lag >> 2] = (HEAP32[$lag >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_NLSF2A($a_Q12, $NLSF, $d, $arch) {
 $a_Q12 = $a_Q12 | 0;
 $NLSF = $NLSF | 0;
 $d = $d | 0;
 $arch = $arch | 0;
 var $NLSF$addr = 0, $P = 0, $Ptmp = 0, $Q = 0, $Qtmp = 0, $a32_QA1 = 0, $a_Q12$addr = 0, $cmp44 = 0, $cos_LSF_QA = 0, $cos_val = 0, $d$addr = 0, $dd = 0, $delta = 0, $f_frac = 0, $f_int = 0, $i = 0, $k = 0, $ordering = 0, $shr13 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 352 | 0;
 $a_Q12$addr = sp + 348 | 0;
 $NLSF$addr = sp + 344 | 0;
 $d$addr = sp + 340 | 0;
 $ordering = sp + 332 | 0;
 $k = sp + 328 | 0;
 $i = sp + 324 | 0;
 $dd = sp + 320 | 0;
 $cos_LSF_QA = sp + 224 | 0;
 $P = sp + 172 | 0;
 $Q = sp + 120 | 0;
 $Ptmp = sp + 116 | 0;
 $Qtmp = sp + 112 | 0;
 $f_int = sp + 108 | 0;
 $f_frac = sp + 104 | 0;
 $cos_val = sp + 100 | 0;
 $delta = sp + 96 | 0;
 $a32_QA1 = sp;
 HEAP32[$a_Q12$addr >> 2] = $a_Q12;
 HEAP32[$NLSF$addr >> 2] = $NLSF;
 HEAP32[$d$addr >> 2] = $d;
 HEAP32[sp + 336 >> 2] = $arch;
 HEAP32[$ordering >> 2] = (HEAP32[$d$addr >> 2] | 0) == 16 ? 35233 : 35249;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$d$addr >> 2] | 0)) break;
  HEAP32[$f_int >> 2] = HEAP16[(HEAP32[$NLSF$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] >> 8;
  HEAP32[$f_frac >> 2] = (HEAP16[(HEAP32[$NLSF$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] | 0) - (HEAP32[$f_int >> 2] << 8);
  HEAP32[$cos_val >> 2] = HEAP16[25084 + (HEAP32[$f_int >> 2] << 1) >> 1];
  HEAP32[$delta >> 2] = (HEAP16[25084 + ((HEAP32[$f_int >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP32[$cos_val >> 2] | 0);
  $shr13 = ((HEAP32[$cos_val >> 2] << 8) + (Math_imul(HEAP32[$delta >> 2] | 0, HEAP32[$f_frac >> 2] | 0) | 0) >> 3) + 1 >> 1;
  HEAP32[$cos_LSF_QA + (HEAPU8[(HEAP32[$ordering >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] << 2) >> 2] = $shr13;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$dd >> 2] = HEAP32[$d$addr >> 2] >> 1;
 _silk_NLSF2A_find_poly($P, $cos_LSF_QA, HEAP32[$dd >> 2] | 0);
 _silk_NLSF2A_find_poly($Q, $cos_LSF_QA + 4 | 0, HEAP32[$dd >> 2] | 0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$dd >> 2] | 0)) break;
  HEAP32[$Ptmp >> 2] = (HEAP32[$P + ((HEAP32[$k >> 2] | 0) + 1 << 2) >> 2] | 0) + (HEAP32[$P + (HEAP32[$k >> 2] << 2) >> 2] | 0);
  HEAP32[$Qtmp >> 2] = (HEAP32[$Q + ((HEAP32[$k >> 2] | 0) + 1 << 2) >> 2] | 0) - (HEAP32[$Q + (HEAP32[$k >> 2] << 2) >> 2] | 0);
  HEAP32[$a32_QA1 + (HEAP32[$k >> 2] << 2) >> 2] = 0 - (HEAP32[$Qtmp >> 2] | 0) - (HEAP32[$Ptmp >> 2] | 0);
  HEAP32[$a32_QA1 + ((HEAP32[$d$addr >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1 << 2) >> 2] = (HEAP32[$Qtmp >> 2] | 0) - (HEAP32[$Ptmp >> 2] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 _silk_LPC_fit(HEAP32[$a_Q12$addr >> 2] | 0, $a32_QA1, 12, 17, HEAP32[$d$addr >> 2] | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  $cmp44 = (_silk_LPC_inverse_pred_gain_c(HEAP32[$a_Q12$addr >> 2] | 0, HEAP32[$d$addr >> 2] | 0) | 0) == 0;
  if (!($cmp44 ? (HEAP32[$i >> 2] | 0) < 16 : 0)) break;
  _silk_bwexpander_32($a32_QA1, HEAP32[$d$addr >> 2] | 0, 65536 - (2 << HEAP32[$i >> 2]) | 0);
  HEAP32[$k >> 2] = 0;
  while (1) {
   if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$d$addr >> 2] | 0)) break;
   HEAP16[(HEAP32[$a_Q12$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = (HEAP32[$a32_QA1 + (HEAP32[$k >> 2] << 2) >> 2] >> 4) + 1 >> 1;
   HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_LBRR_encode_FLP($psEnc, $psEncCtrl, $xfw, $condCoding) {
 $psEnc = $psEnc | 0;
 $psEncCtrl = $psEncCtrl | 0;
 $xfw = $xfw | 0;
 $condCoding = $condCoding | 0;
 var $27 = 0, $Gains_Q16 = 0, $TempGains = 0, $condCoding$addr = 0, $conv29 = 0, $k = 0, $psEnc$addr = 0, $psEncCtrl$addr = 0, $psIndices_LBRR = 0, $sNSQ_LBRR = 0, $xfw$addr = 0, dest = 0, label = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 4416 | 0;
 $psEnc$addr = sp + 4408 | 0;
 $psEncCtrl$addr = sp + 4404 | 0;
 $xfw$addr = sp + 4400 | 0;
 $condCoding$addr = sp + 4396 | 0;
 $k = sp + 4392 | 0;
 $Gains_Q16 = sp + 4376 | 0;
 $TempGains = sp + 4360 | 0;
 $psIndices_LBRR = sp + 4352 | 0;
 $sNSQ_LBRR = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$psEncCtrl$addr >> 2] = $psEncCtrl;
 HEAP32[$xfw$addr >> 2] = $xfw;
 HEAP32[$condCoding$addr >> 2] = $condCoding;
 HEAP32[$psIndices_LBRR >> 2] = (HEAP32[$psEnc$addr >> 2] | 0) + 6096 + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5744 >> 2] | 0) * 36 | 0);
 if (!(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 6088 >> 2] | 0)) {
  STACKTOP = sp;
  return;
 }
 if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4528 >> 2] | 0) <= 77) {
  STACKTOP = sp;
  return;
 }
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4720 + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5744 >> 2] << 2) >> 2] = 1;
 _memcpy($sNSQ_LBRR | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 144 | 0, 4352) | 0;
 dest = HEAP32[$psIndices_LBRR >> 2] | 0;
 src = (HEAP32[$psEnc$addr >> 2] | 0) + 4732 | 0;
 stop = dest + 36 | 0;
 do {
  HEAP16[dest >> 1] = HEAP16[src >> 1] | 0;
  dest = dest + 2 | 0;
  src = src + 2 | 0;
 } while ((dest | 0) < (stop | 0));
 _memcpy($TempGains | 0, HEAP32[$psEncCtrl$addr >> 2] | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] << 2 | 0) | 0;
 if (!(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5744 >> 2] | 0)) label = 5; else if (!(HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4720 + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5744 >> 2] | 0) - 1 << 2) >> 2] | 0)) label = 5;
 if ((label | 0) == 5) {
  HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4536 >> 0] = HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 7164 >> 0] | 0;
  $27 = HEAP32[$psIndices_LBRR >> 2] | 0;
  HEAP8[$27 >> 0] = (HEAP8[$27 >> 0] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 6092 >> 2] | 0);
  $conv29 = (_silk_min_int_287(HEAP8[HEAP32[$psIndices_LBRR >> 2] >> 0] | 0, 63) | 0) & 255;
  HEAP8[HEAP32[$psIndices_LBRR >> 2] >> 0] = $conv29;
 }
 _silk_gains_dequant($Gains_Q16, HEAP32[$psIndices_LBRR >> 2] | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 4536 | 0, (HEAP32[$condCoding$addr >> 2] | 0) == 2 & 1, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] | 0)) break;
  HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = +(HEAP32[$Gains_Q16 + (HEAP32[$k >> 2] << 2) >> 2] | 0) * .0000152587890625;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 _silk_NSQ_wrapper_FLP(HEAP32[$psEnc$addr >> 2] | 0, HEAP32[$psEncCtrl$addr >> 2] | 0, HEAP32[$psIndices_LBRR >> 2] | 0, $sNSQ_LBRR, (HEAP32[$psEnc$addr >> 2] | 0) + 6204 + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5744 >> 2] | 0) * 320 | 0) | 0, HEAP32[$xfw$addr >> 2] | 0);
 _memcpy(HEAP32[$psEncCtrl$addr >> 2] | 0, $TempGains | 0, HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4576 >> 2] << 2 | 0) | 0;
 STACKTOP = sp;
 return;
}

function __celt_autocorr($x, $ac, $window, $overlap, $lag, $n, $arch) {
 $x = $x | 0;
 $ac = $ac | 0;
 $window = $window | 0;
 $overlap = $overlap | 0;
 $lag = $lag | 0;
 $n = $n | 0;
 $arch = $arch | 0;
 var $2 = 0, $44 = 0.0, $57 = 0, $ac$addr = 0, $arch$addr = 0, $arrayidx35 = 0, $d = 0, $fastN = 0, $i = 0, $k = 0, $lag$addr = 0, $n$addr = 0, $overlap$addr = 0, $saved_stack = 0, $shift = 0, $vla = 0, $window$addr = 0, $x$addr = 0, $xptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $x$addr = sp + 52 | 0;
 $ac$addr = sp + 48 | 0;
 $window$addr = sp + 44 | 0;
 $overlap$addr = sp + 40 | 0;
 $lag$addr = sp + 36 | 0;
 $n$addr = sp + 32 | 0;
 $arch$addr = sp + 28 | 0;
 $d = sp + 24 | 0;
 $i = sp + 20 | 0;
 $k = sp + 16 | 0;
 $fastN = sp + 12 | 0;
 $shift = sp + 8 | 0;
 $xptr = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$ac$addr >> 2] = $ac;
 HEAP32[$window$addr >> 2] = $window;
 HEAP32[$overlap$addr >> 2] = $overlap;
 HEAP32[$lag$addr >> 2] = $lag;
 HEAP32[$n$addr >> 2] = $n;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$fastN >> 2] = (HEAP32[$n$addr >> 2] | 0) - (HEAP32[$lag$addr >> 2] | 0);
 $2 = HEAP32[$n$addr >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($2 << 2) | 0) + 15 & -16) | 0;
 if (!(HEAP32[$overlap$addr >> 2] | 0)) HEAP32[$xptr >> 2] = HEAP32[$x$addr >> 2]; else {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$n$addr >> 2] | 0)) break;
   HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$overlap$addr >> 2] | 0)) break;
   HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$vla + ((HEAP32[$n$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$n$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2] * +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$xptr >> 2] = $vla;
 }
 HEAP32[$shift >> 2] = 0;
 _celt_pitch_xcorr_c(HEAP32[$xptr >> 2] | 0, HEAP32[$xptr >> 2] | 0, HEAP32[$ac$addr >> 2] | 0, HEAP32[$fastN >> 2] | 0, (HEAP32[$lag$addr >> 2] | 0) + 1 | 0, HEAP32[$arch$addr >> 2] | 0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) > (HEAP32[$lag$addr >> 2] | 0)) break;
  HEAP32[$i >> 2] = (HEAP32[$k >> 2] | 0) + (HEAP32[$fastN >> 2] | 0);
  HEAPF32[$d >> 2] = 0.0;
  while (1) {
   $44 = +HEAPF32[$d >> 2];
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$n$addr >> 2] | 0)) break;
   HEAPF32[$d >> 2] = $44 + +HEAPF32[(HEAP32[$xptr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$xptr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$k >> 2] | 0) << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $arrayidx35 = (HEAP32[$ac$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) | 0;
  HEAPF32[$arrayidx35 >> 2] = +HEAPF32[$arrayidx35 >> 2] + $44;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 $57 = HEAP32[$shift >> 2] | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return $57 | 0;
}

function _quant_energy_finalise($m, $start, $end, $oldEBands, $error, $fine_quant, $fine_priority, $bits_left, $enc, $C) {
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $oldEBands = $oldEBands | 0;
 $error = $error | 0;
 $fine_quant = $fine_quant | 0;
 $fine_priority = $fine_priority | 0;
 $bits_left = $bits_left | 0;
 $enc = $enc | 0;
 $C = $C | 0;
 var $C$addr = 0, $arrayidx19 = 0, $arrayidx24 = 0, $bits_left$addr = 0, $c = 0, $cmp9 = 0, $enc$addr = 0, $end$addr = 0, $error$addr = 0, $fine_priority$addr = 0, $fine_quant$addr = 0, $i = 0, $inc = 0, $m$addr = 0, $offset = 0, $oldEBands$addr = 0, $prio = 0, $q2 = 0, $start$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $m$addr = sp + 56 | 0;
 $start$addr = sp + 52 | 0;
 $end$addr = sp + 48 | 0;
 $oldEBands$addr = sp + 44 | 0;
 $error$addr = sp + 40 | 0;
 $fine_quant$addr = sp + 36 | 0;
 $fine_priority$addr = sp + 32 | 0;
 $bits_left$addr = sp + 28 | 0;
 $enc$addr = sp + 24 | 0;
 $C$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $prio = sp + 12 | 0;
 $c = sp + 8 | 0;
 $q2 = sp + 4 | 0;
 $offset = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$oldEBands$addr >> 2] = $oldEBands;
 HEAP32[$error$addr >> 2] = $error;
 HEAP32[$fine_quant$addr >> 2] = $fine_quant;
 HEAP32[$fine_priority$addr >> 2] = $fine_priority;
 HEAP32[$bits_left$addr >> 2] = $bits_left;
 HEAP32[$enc$addr >> 2] = $enc;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$prio >> 2] = 0;
 while (1) {
  if ((HEAP32[$prio >> 2] | 0) >= 2) break;
  HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   if ((HEAP32[$bits_left$addr >> 2] | 0) < (HEAP32[$C$addr >> 2] | 0)) break;
   if ((HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) < 8) if ((HEAP32[(HEAP32[$fine_priority$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) == (HEAP32[$prio >> 2] | 0)) {
    HEAP32[$c >> 2] = 0;
    do {
     $cmp9 = +HEAPF32[(HEAP32[$error$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2] < 0.0;
     HEAP32[$q2 >> 2] = $cmp9 ? 0 : 1;
     _ec_enc_bits(HEAP32[$enc$addr >> 2] | 0, HEAP32[$q2 >> 2] | 0, 1);
     HEAPF32[$offset >> 2] = (+(HEAP32[$q2 >> 2] | 0) - .5) * +(1 << 14 - (HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) - 1 | 0) * .00006103515625;
     $arrayidx19 = (HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) | 0;
     HEAPF32[$arrayidx19 >> 2] = +HEAPF32[$arrayidx19 >> 2] + +HEAPF32[$offset >> 2];
     $arrayidx24 = (HEAP32[$error$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) | 0;
     HEAPF32[$arrayidx24 >> 2] = +HEAPF32[$arrayidx24 >> 2] - +HEAPF32[$offset >> 2];
     HEAP32[$bits_left$addr >> 2] = (HEAP32[$bits_left$addr >> 2] | 0) + -1;
     $inc = (HEAP32[$c >> 2] | 0) + 1 | 0;
     HEAP32[$c >> 2] = $inc;
    } while (($inc | 0) < (HEAP32[$C$addr >> 2] | 0));
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$prio >> 2] = (HEAP32[$prio >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _opus_decoder_init($st, $Fs, $channels) {
 $st = $st | 0;
 $Fs = $Fs | 0;
 $channels = $channels | 0;
 var $22 = 0, $39 = 0, $44 = 0, $7 = 0, $Fs$addr = 0, $call15 = 0, $call34 = 0, $celt_dec = 0, $channels$addr = 0, $ret = 0, $retval = 0, $silkDecSizeBytes = 0, $silk_dec = 0, $st$addr = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer = sp;
 $retval = sp + 32 | 0;
 $st$addr = sp + 28 | 0;
 $Fs$addr = sp + 24 | 0;
 $channels$addr = sp + 20 | 0;
 $silk_dec = sp + 16 | 0;
 $celt_dec = sp + 12 | 0;
 $ret = sp + 8 | 0;
 $silkDecSizeBytes = sp + 4 | 0;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$channels$addr >> 2] = $channels;
 if (!((HEAP32[$Fs$addr >> 2] | 0) != 48e3 & (HEAP32[$Fs$addr >> 2] | 0) != 24e3 & (HEAP32[$Fs$addr >> 2] | 0) != 16e3 & (HEAP32[$Fs$addr >> 2] | 0) != 12e3 & (HEAP32[$Fs$addr >> 2] | 0) != 8e3)) if (!((HEAP32[$channels$addr >> 2] | 0) != 1 & (HEAP32[$channels$addr >> 2] | 0) != 2)) {
  $7 = HEAP32[$st$addr >> 2] | 0;
  _memset($7 | 0, 0, _opus_decoder_get_size(HEAP32[$channels$addr >> 2] | 0) | 0) | 0;
  HEAP32[$ret >> 2] = _silk_Get_Decoder_Size($silkDecSizeBytes) | 0;
  if (HEAP32[$ret >> 2] | 0) {
   HEAP32[$retval >> 2] = -3;
   $44 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $44 | 0;
  }
  HEAP32[$silkDecSizeBytes >> 2] = _align(HEAP32[$silkDecSizeBytes >> 2] | 0) | 0;
  $call15 = _align(88) | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] = $call15;
  HEAP32[HEAP32[$st$addr >> 2] >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[$silkDecSizeBytes >> 2] | 0);
  HEAP32[$silk_dec >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] | 0);
  HEAP32[$celt_dec >> 2] = (HEAP32[$st$addr >> 2] | 0) + (HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0);
  $22 = HEAP32[$channels$addr >> 2] | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] = $22;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] = $22;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] = HEAP32[$Fs$addr >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 + 8 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2];
  HEAP32[$ret >> 2] = _silk_InitDecoder(HEAP32[$silk_dec >> 2] | 0) | 0;
  if (HEAP32[$ret >> 2] | 0) {
   HEAP32[$retval >> 2] = -3;
   $44 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $44 | 0;
  }
  HEAP32[$ret >> 2] = _celt_decoder_init(HEAP32[$celt_dec >> 2] | 0, HEAP32[$Fs$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
  if (HEAP32[$ret >> 2] | 0) {
   HEAP32[$retval >> 2] = -3;
   $44 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $44 | 0;
  } else {
   $39 = HEAP32[$celt_dec >> 2] | 0;
   HEAP32[$vararg_buffer >> 2] = 0;
   _opus_custom_decoder_ctl($39, 10016, $vararg_buffer) | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] = 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 64 >> 2] = (HEAP32[$Fs$addr >> 2] | 0) / 400 | 0;
   $call34 = _opus_select_arch() | 0;
   HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] = $call34;
   HEAP32[$retval >> 2] = 0;
   $44 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $44 | 0;
  }
 }
 HEAP32[$retval >> 2] = -1;
 $44 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $44 | 0;
}

function _decide_fec($useInBandFEC, $PacketLoss_perc, $last_fec, $mode, $bandwidth, $rate) {
 $useInBandFEC = $useInBandFEC | 0;
 $PacketLoss_perc = $PacketLoss_perc | 0;
 $last_fec = $last_fec | 0;
 $mode = $mode | 0;
 $bandwidth = $bandwidth | 0;
 $rate = $rate | 0;
 var $28 = 0, $32 = 0, $LBRR_rate_thres_bps = 0, $PacketLoss_perc$addr = 0, $bandwidth$addr = 0, $hysteresis = 0, $last_fec$addr = 0, $mode$addr = 0, $mul17 = 0, $orig_bandwidth = 0, $rate$addr = 0, $retval = 0, $useInBandFEC$addr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 36 | 0;
 $useInBandFEC$addr = sp + 32 | 0;
 $PacketLoss_perc$addr = sp + 28 | 0;
 $last_fec$addr = sp + 24 | 0;
 $mode$addr = sp + 20 | 0;
 $bandwidth$addr = sp + 16 | 0;
 $rate$addr = sp + 12 | 0;
 $orig_bandwidth = sp + 8 | 0;
 $hysteresis = sp + 4 | 0;
 $LBRR_rate_thres_bps = sp;
 HEAP32[$useInBandFEC$addr >> 2] = $useInBandFEC;
 HEAP32[$PacketLoss_perc$addr >> 2] = $PacketLoss_perc;
 HEAP32[$last_fec$addr >> 2] = $last_fec;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$bandwidth$addr >> 2] = $bandwidth;
 HEAP32[$rate$addr >> 2] = $rate;
 if ((HEAP32[$useInBandFEC$addr >> 2] | 0) == 0 | (HEAP32[$PacketLoss_perc$addr >> 2] | 0) == 0 | (HEAP32[$mode$addr >> 2] | 0) == 1002) {
  HEAP32[$retval >> 2] = 0;
  $32 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $32 | 0;
 }
 HEAP32[$orig_bandwidth >> 2] = HEAP32[HEAP32[$bandwidth$addr >> 2] >> 2];
 while (1) {
  HEAP32[$LBRR_rate_thres_bps >> 2] = HEAP32[292 + ((HEAP32[HEAP32[$bandwidth$addr >> 2] >> 2] | 0) - 1101 << 1 << 2) >> 2];
  HEAP32[$hysteresis >> 2] = HEAP32[292 + (((HEAP32[HEAP32[$bandwidth$addr >> 2] >> 2] | 0) - 1101 << 1) + 1 << 2) >> 2];
  if ((HEAP32[$last_fec$addr >> 2] | 0) == 1) HEAP32[$LBRR_rate_thres_bps >> 2] = (HEAP32[$LBRR_rate_thres_bps >> 2] | 0) - (HEAP32[$hysteresis >> 2] | 0);
  if (!(HEAP32[$last_fec$addr >> 2] | 0)) HEAP32[$LBRR_rate_thres_bps >> 2] = (HEAP32[$LBRR_rate_thres_bps >> 2] | 0) + (HEAP32[$hysteresis >> 2] | 0);
  $mul17 = ((Math_imul(HEAP32[$LBRR_rate_thres_bps >> 2] | 0, 125 - ((HEAP32[$PacketLoss_perc$addr >> 2] | 0) < 25 ? HEAP32[$PacketLoss_perc$addr >> 2] | 0 : 25) | 0) | 0) >> 16) * 655 | 0;
  HEAP32[$LBRR_rate_thres_bps >> 2] = $mul17 + (((Math_imul(HEAP32[$LBRR_rate_thres_bps >> 2] | 0, 125 - ((HEAP32[$PacketLoss_perc$addr >> 2] | 0) < 25 ? HEAP32[$PacketLoss_perc$addr >> 2] | 0 : 25) | 0) | 0) & 65535) * 655 >> 16);
  if ((HEAP32[$rate$addr >> 2] | 0) > (HEAP32[$LBRR_rate_thres_bps >> 2] | 0)) {
   label = 9;
   break;
  }
  if ((HEAP32[$PacketLoss_perc$addr >> 2] | 0) <= 5) {
   label = 11;
   break;
  }
  if ((HEAP32[HEAP32[$bandwidth$addr >> 2] >> 2] | 0) <= 1101) {
   label = 14;
   break;
  }
  $28 = HEAP32[$bandwidth$addr >> 2] | 0;
  HEAP32[$28 >> 2] = (HEAP32[$28 >> 2] | 0) + -1;
 }
 if ((label | 0) == 9) {
  HEAP32[$retval >> 2] = 1;
  $32 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $32 | 0;
 } else if ((label | 0) == 11) {
  HEAP32[$retval >> 2] = 0;
  $32 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $32 | 0;
 } else if ((label | 0) == 14) {
  HEAP32[HEAP32[$bandwidth$addr >> 2] >> 2] = HEAP32[$orig_bandwidth >> 2];
  HEAP32[$retval >> 2] = 0;
  $32 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $32 | 0;
 }
 return 0;
}

function _celt_fir_c($x, $num, $y, $N, $ord, $arch) {
 $x = $x | 0;
 $num = $num | 0;
 $y = $y | 0;
 $N = $N | 0;
 $ord = $ord | 0;
 $arch = $arch | 0;
 var $0 = 0, $50 = 0.0, $N$addr = 0, $arch$addr = 0, $i = 0, $j = 0, $num$addr = 0, $ord$addr = 0, $saved_stack = 0, $sum = 0, $sum36 = 0, $vla = 0, $x$addr = 0, $y$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $x$addr = sp + 56 | 0;
 $num$addr = sp + 52 | 0;
 $y$addr = sp + 48 | 0;
 $N$addr = sp + 44 | 0;
 $ord$addr = sp + 40 | 0;
 $arch$addr = sp + 36 | 0;
 $i = sp + 32 | 0;
 $j = sp + 28 | 0;
 $saved_stack = sp + 24 | 0;
 $sum = sp + 8 | 0;
 $sum36 = sp;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$num$addr >> 2] = $num;
 HEAP32[$y$addr >> 2] = $y;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$ord$addr >> 2] = $ord;
 HEAP32[$arch$addr >> 2] = $arch;
 $0 = HEAP32[$ord$addr >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($0 << 2) | 0) + 15 & -16) | 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$ord$addr >> 2] | 0)) break;
  HEAPF32[$vla + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$num$addr >> 2] | 0) + ((HEAP32[$ord$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) - 1 << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$N$addr >> 2] | 0) - 3 | 0)) break;
  HEAPF32[$sum >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$sum + 4 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2];
  HEAPF32[$sum + 8 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2];
  HEAPF32[$sum + 12 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2];
  FUNCTION_TABLE_viiii[HEAP32[_XCORR_KERNEL_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]($vla, (HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) + (0 - (HEAP32[$ord$addr >> 2] | 0) << 2) | 0, $sum, HEAP32[$ord$addr >> 2] | 0);
  HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$sum >> 2];
  HEAPF32[(HEAP32[$y$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] = +HEAPF32[$sum + 4 >> 2];
  HEAPF32[(HEAP32[$y$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2] = +HEAPF32[$sum + 8 >> 2];
  HEAPF32[(HEAP32[$y$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2] = +HEAPF32[$sum + 12 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAPF32[$sum36 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$j >> 2] = 0;
  while (1) {
   $50 = +HEAPF32[$sum36 >> 2];
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$ord$addr >> 2] | 0)) break;
   HEAPF32[$sum36 >> 2] = $50 + +HEAPF32[$vla + (HEAP32[$j >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (HEAP32[$j >> 2] | 0) - (HEAP32[$ord$addr >> 2] | 0) << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $50;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_decode_pitch($lagIndex, $contourIndex, $pitch_lags, $Fs_kHz, $nb_subfr) {
 $lagIndex = $lagIndex | 0;
 $contourIndex = $contourIndex | 0;
 $pitch_lags = $pitch_lags | 0;
 $Fs_kHz = $Fs_kHz | 0;
 $nb_subfr = $nb_subfr | 0;
 var $20 = 0, $Fs_kHz$addr = 0, $Lag_CB_ptr = 0, $cbk_size = 0, $cmp1 = 0, $cond52 = 0, $contourIndex$addr = 0, $k = 0, $lag = 0, $lagIndex$addr = 0, $max_lag = 0, $min_lag = 0, $mul16 = 0, $nb_subfr$addr = 0, $pitch_lags$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $lagIndex$addr = sp + 36 | 0;
 $contourIndex$addr = sp + 38 | 0;
 $pitch_lags$addr = sp + 32 | 0;
 $Fs_kHz$addr = sp + 28 | 0;
 $nb_subfr$addr = sp + 24 | 0;
 $lag = sp + 20 | 0;
 $k = sp + 16 | 0;
 $min_lag = sp + 12 | 0;
 $max_lag = sp + 8 | 0;
 $cbk_size = sp + 4 | 0;
 $Lag_CB_ptr = sp;
 HEAP16[$lagIndex$addr >> 1] = $lagIndex;
 HEAP8[$contourIndex$addr >> 0] = $contourIndex;
 HEAP32[$pitch_lags$addr >> 2] = $pitch_lags;
 HEAP32[$Fs_kHz$addr >> 2] = $Fs_kHz;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 $cmp1 = (HEAP32[$nb_subfr$addr >> 2] | 0) == 4;
 do if ((HEAP32[$Fs_kHz$addr >> 2] | 0) == 8) if ($cmp1) {
  HEAP32[$Lag_CB_ptr >> 2] = 35293;
  HEAP32[$cbk_size >> 2] = 11;
  break;
 } else {
  HEAP32[$Lag_CB_ptr >> 2] = 35259;
  HEAP32[$cbk_size >> 2] = 3;
  break;
 } else if ($cmp1) {
  HEAP32[$Lag_CB_ptr >> 2] = 35337;
  HEAP32[$cbk_size >> 2] = 34;
  break;
 } else {
  HEAP32[$Lag_CB_ptr >> 2] = 35265;
  HEAP32[$cbk_size >> 2] = 12;
  break;
 } while (0);
 HEAP32[$min_lag >> 2] = (HEAP32[$Fs_kHz$addr >> 2] & 65535) << 16 >> 16 << 1;
 HEAP32[$max_lag >> 2] = ((HEAP32[$Fs_kHz$addr >> 2] & 65535) << 16 >> 16) * 18;
 HEAP32[$lag >> 2] = (HEAP32[$min_lag >> 2] | 0) + (HEAP16[$lagIndex$addr >> 1] | 0);
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  $mul16 = Math_imul(HEAP32[$k >> 2] | 0, HEAP32[$cbk_size >> 2] | 0) | 0;
  HEAP32[(HEAP32[$pitch_lags$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = (HEAP32[$lag >> 2] | 0) + (HEAP8[(HEAP32[$Lag_CB_ptr >> 2] | 0) + ($mul16 + (HEAP8[$contourIndex$addr >> 0] | 0)) >> 0] | 0);
  $20 = HEAP32[(HEAP32[$pitch_lags$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
  do if ((HEAP32[$min_lag >> 2] | 0) > (HEAP32[$max_lag >> 2] | 0)) {
   if (($20 | 0) > (HEAP32[$min_lag >> 2] | 0)) {
    $cond52 = HEAP32[$min_lag >> 2] | 0;
    break;
   }
   if ((HEAP32[(HEAP32[$pitch_lags$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) < (HEAP32[$max_lag >> 2] | 0)) {
    $cond52 = HEAP32[$max_lag >> 2] | 0;
    break;
   } else {
    $cond52 = HEAP32[(HEAP32[$pitch_lags$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
    break;
   }
  } else {
   if (($20 | 0) > (HEAP32[$max_lag >> 2] | 0)) {
    $cond52 = HEAP32[$max_lag >> 2] | 0;
    break;
   }
   if ((HEAP32[(HEAP32[$pitch_lags$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) < (HEAP32[$min_lag >> 2] | 0)) {
    $cond52 = HEAP32[$min_lag >> 2] | 0;
    break;
   } else {
    $cond52 = HEAP32[(HEAP32[$pitch_lags$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
    break;
   }
  } while (0);
  HEAP32[(HEAP32[$pitch_lags$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = $cond52;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_NLSF_VQ($err_Q24, $in_Q15, $pCB_Q8, $pWght_Q9, $K, $LPC_order) {
 $err_Q24 = $err_Q24 | 0;
 $in_Q15 = $in_Q15 | 0;
 $pCB_Q8 = $pCB_Q8 | 0;
 $pWght_Q9 = $pWght_Q9 | 0;
 $K = $K | 0;
 $LPC_order = $LPC_order | 0;
 var $K$addr = 0, $LPC_order$addr = 0, $cb_Q8_ptr = 0, $diff_Q15 = 0, $diffw_Q24 = 0, $err_Q24$addr = 0, $i = 0, $in_Q15$addr = 0, $m = 0, $pCB_Q8$addr = 0, $pWght_Q9$addr = 0, $pred_Q24 = 0, $sub17 = 0, $sub39 = 0, $sum_error_Q24 = 0, $w_Q9_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $err_Q24$addr = sp + 52 | 0;
 $in_Q15$addr = sp + 48 | 0;
 $pCB_Q8$addr = sp + 44 | 0;
 $pWght_Q9$addr = sp + 40 | 0;
 $K$addr = sp + 36 | 0;
 $LPC_order$addr = sp + 32 | 0;
 $i = sp + 28 | 0;
 $m = sp + 24 | 0;
 $diff_Q15 = sp + 20 | 0;
 $diffw_Q24 = sp + 16 | 0;
 $sum_error_Q24 = sp + 12 | 0;
 $pred_Q24 = sp + 8 | 0;
 $w_Q9_ptr = sp + 4 | 0;
 $cb_Q8_ptr = sp;
 HEAP32[$err_Q24$addr >> 2] = $err_Q24;
 HEAP32[$in_Q15$addr >> 2] = $in_Q15;
 HEAP32[$pCB_Q8$addr >> 2] = $pCB_Q8;
 HEAP32[$pWght_Q9$addr >> 2] = $pWght_Q9;
 HEAP32[$K$addr >> 2] = $K;
 HEAP32[$LPC_order$addr >> 2] = $LPC_order;
 HEAP32[$cb_Q8_ptr >> 2] = HEAP32[$pCB_Q8$addr >> 2];
 HEAP32[$w_Q9_ptr >> 2] = HEAP32[$pWght_Q9$addr >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$K$addr >> 2] | 0)) break;
  HEAP32[$sum_error_Q24 >> 2] = 0;
  HEAP32[$pred_Q24 >> 2] = 0;
  HEAP32[$m >> 2] = (HEAP32[$LPC_order$addr >> 2] | 0) - 2;
  while (1) {
   if ((HEAP32[$m >> 2] | 0) < 0) break;
   HEAP32[$diff_Q15 >> 2] = (HEAP16[(HEAP32[$in_Q15$addr >> 2] | 0) + ((HEAP32[$m >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAPU8[(HEAP32[$cb_Q8_ptr >> 2] | 0) + ((HEAP32[$m >> 2] | 0) + 1) >> 0] << 7);
   HEAP32[$diffw_Q24 >> 2] = Math_imul((HEAP32[$diff_Q15 >> 2] & 65535) << 16 >> 16, HEAP16[(HEAP32[$w_Q9_ptr >> 2] | 0) + ((HEAP32[$m >> 2] | 0) + 1 << 1) >> 1] | 0) | 0;
   $sub17 = (HEAP32[$diffw_Q24 >> 2] | 0) - (HEAP32[$pred_Q24 >> 2] >> 1) | 0;
   HEAP32[$sum_error_Q24 >> 2] = (HEAP32[$sum_error_Q24 >> 2] | 0) + (((HEAP32[$diffw_Q24 >> 2] | 0) - (HEAP32[$pred_Q24 >> 2] >> 1) | 0) > 0 ? $sub17 : 0 - $sub17 | 0);
   HEAP32[$pred_Q24 >> 2] = HEAP32[$diffw_Q24 >> 2];
   HEAP32[$diff_Q15 >> 2] = (HEAP16[(HEAP32[$in_Q15$addr >> 2] | 0) + (HEAP32[$m >> 2] << 1) >> 1] | 0) - (HEAPU8[(HEAP32[$cb_Q8_ptr >> 2] | 0) + (HEAP32[$m >> 2] | 0) >> 0] << 7);
   HEAP32[$diffw_Q24 >> 2] = Math_imul((HEAP32[$diff_Q15 >> 2] & 65535) << 16 >> 16, HEAP16[(HEAP32[$w_Q9_ptr >> 2] | 0) + (HEAP32[$m >> 2] << 1) >> 1] | 0) | 0;
   $sub39 = (HEAP32[$diffw_Q24 >> 2] | 0) - (HEAP32[$pred_Q24 >> 2] >> 1) | 0;
   HEAP32[$sum_error_Q24 >> 2] = (HEAP32[$sum_error_Q24 >> 2] | 0) + (((HEAP32[$diffw_Q24 >> 2] | 0) - (HEAP32[$pred_Q24 >> 2] >> 1) | 0) > 0 ? $sub39 : 0 - $sub39 | 0);
   HEAP32[$pred_Q24 >> 2] = HEAP32[$diffw_Q24 >> 2];
   HEAP32[$m >> 2] = (HEAP32[$m >> 2] | 0) - 2;
  }
  HEAP32[(HEAP32[$err_Q24$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$sum_error_Q24 >> 2];
  HEAP32[$cb_Q8_ptr >> 2] = (HEAP32[$cb_Q8_ptr >> 2] | 0) + (HEAP32[$LPC_order$addr >> 2] | 0);
  HEAP32[$w_Q9_ptr >> 2] = (HEAP32[$w_Q9_ptr >> 2] | 0) + (HEAP32[$LPC_order$addr >> 2] << 1);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _tf_decode($start, $end, $isTransient, $tf_res, $LM, $dec) {
 $start = $start | 0;
 $end = $end | 0;
 $isTransient = $isTransient | 0;
 $tf_res = $tf_res | 0;
 $LM = $LM | 0;
 $dec = $dec | 0;
 var $8 = 0, $LM$addr = 0, $budget = 0, $call6 = 0, $curr = 0, $dec$addr = 0, $end$addr = 0, $i = 0, $isTransient$addr = 0, $logp = 0, $start$addr = 0, $tell = 0, $tf_changed = 0, $tf_res$addr = 0, $tf_select = 0, $tf_select_rsv = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $start$addr = sp + 52 | 0;
 $end$addr = sp + 48 | 0;
 $isTransient$addr = sp + 44 | 0;
 $tf_res$addr = sp + 40 | 0;
 $LM$addr = sp + 36 | 0;
 $dec$addr = sp + 32 | 0;
 $i = sp + 28 | 0;
 $curr = sp + 24 | 0;
 $tf_select = sp + 20 | 0;
 $tf_select_rsv = sp + 16 | 0;
 $tf_changed = sp + 12 | 0;
 $logp = sp + 8 | 0;
 $budget = sp + 4 | 0;
 $tell = sp;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$isTransient$addr >> 2] = $isTransient;
 HEAP32[$tf_res$addr >> 2] = $tf_res;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$dec$addr >> 2] = $dec;
 HEAP32[$budget >> 2] = HEAP32[(HEAP32[$dec$addr >> 2] | 0) + 4 >> 2] << 3;
 HEAP32[$tell >> 2] = _ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0;
 HEAP32[$logp >> 2] = HEAP32[$isTransient$addr >> 2] | 0 ? 2 : 4;
 if ((HEAP32[$LM$addr >> 2] | 0) > 0) $8 = ((HEAP32[$tell >> 2] | 0) + (HEAP32[$logp >> 2] | 0) + 1 | 0) >>> 0 <= (HEAP32[$budget >> 2] | 0) >>> 0; else $8 = 0;
 HEAP32[$tf_select_rsv >> 2] = $8 & 1;
 HEAP32[$budget >> 2] = (HEAP32[$budget >> 2] | 0) - (HEAP32[$tf_select_rsv >> 2] | 0);
 HEAP32[$curr >> 2] = 0;
 HEAP32[$tf_changed >> 2] = 0;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  if (((HEAP32[$tell >> 2] | 0) + (HEAP32[$logp >> 2] | 0) | 0) >>> 0 <= (HEAP32[$budget >> 2] | 0) >>> 0) {
   $call6 = _ec_dec_bit_logp(HEAP32[$dec$addr >> 2] | 0, HEAP32[$logp >> 2] | 0) | 0;
   HEAP32[$curr >> 2] = HEAP32[$curr >> 2] ^ $call6;
   HEAP32[$tell >> 2] = _ec_tell_64(HEAP32[$dec$addr >> 2] | 0) | 0;
   HEAP32[$tf_changed >> 2] = HEAP32[$tf_changed >> 2] | HEAP32[$curr >> 2];
  }
  HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$curr >> 2];
  HEAP32[$logp >> 2] = HEAP32[$isTransient$addr >> 2] | 0 ? 4 : 5;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$tf_select >> 2] = 0;
 if (HEAP32[$tf_select_rsv >> 2] | 0) if ((HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + 0 + (HEAP32[$tf_changed >> 2] | 0)) >> 0] | 0) != (HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + 2 + (HEAP32[$tf_changed >> 2] | 0)) >> 0] | 0)) HEAP32[$tf_select >> 2] = _ec_dec_bit_logp(HEAP32[$dec$addr >> 2] | 0, 1) | 0;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP8[33489 + (HEAP32[$LM$addr >> 2] << 3) + ((HEAP32[$isTransient$addr >> 2] << 2) + (HEAP32[$tf_select >> 2] << 1) + (HEAP32[(HEAP32[$tf_res$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0)) >> 0];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _ec_laplace_encode($enc, $value, $fs, $decay) {
 $enc = $enc | 0;
 $value = $value | 0;
 $fs = $fs | 0;
 $decay = $decay | 0;
 var $13 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $add41 = 0, $cond = 0, $decay$addr = 0, $di = 0, $enc$addr = 0, $fl = 0, $fs$addr = 0, $i = 0, $ndi_max = 0, $s = 0, $val = 0, $value$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $enc$addr = sp + 36 | 0;
 $value$addr = sp + 32 | 0;
 $fs$addr = sp + 28 | 0;
 $decay$addr = sp + 24 | 0;
 $fl = sp + 20 | 0;
 $val = sp + 16 | 0;
 $s = sp + 12 | 0;
 $i = sp + 8 | 0;
 $di = sp + 4 | 0;
 $ndi_max = sp;
 HEAP32[$enc$addr >> 2] = $enc;
 HEAP32[$value$addr >> 2] = $value;
 HEAP32[$fs$addr >> 2] = $fs;
 HEAP32[$decay$addr >> 2] = $decay;
 HEAP32[$val >> 2] = HEAP32[HEAP32[$value$addr >> 2] >> 2];
 HEAP32[$fl >> 2] = 0;
 if (!(HEAP32[$val >> 2] | 0)) {
  $42 = HEAP32[$enc$addr >> 2] | 0;
  $43 = HEAP32[$fl >> 2] | 0;
  $44 = HEAP32[$fl >> 2] | 0;
  $45 = HEAP32[$fs$addr >> 2] | 0;
  $add41 = $44 + $45 | 0;
  _ec_encode_bin($42, $43, $add41, 15);
  STACKTOP = sp;
  return;
 }
 HEAP32[$s >> 2] = 0 - ((HEAP32[$val >> 2] | 0) < 0 & 1);
 HEAP32[$val >> 2] = (HEAP32[$val >> 2] | 0) + (HEAP32[$s >> 2] | 0) ^ HEAP32[$s >> 2];
 HEAP32[$fl >> 2] = HEAP32[$fs$addr >> 2];
 HEAP32[$fs$addr >> 2] = _ec_laplace_get_freq1(HEAP32[$fs$addr >> 2] | 0, HEAP32[$decay$addr >> 2] | 0) | 0;
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$fs$addr >> 2] | 0) >>> 0 > 0) $46 = (HEAP32[$i >> 2] | 0) < (HEAP32[$val >> 2] | 0); else $46 = 0;
  $13 = HEAP32[$fs$addr >> 2] | 0;
  if (!$46) break;
  HEAP32[$fs$addr >> 2] = $13 << 1;
  HEAP32[$fl >> 2] = (HEAP32[$fl >> 2] | 0) + ((HEAP32[$fs$addr >> 2] | 0) + 2);
  HEAP32[$fs$addr >> 2] = (Math_imul(HEAP32[$fs$addr >> 2] | 0, HEAP32[$decay$addr >> 2] | 0) | 0) >>> 15;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ($13 | 0) {
  HEAP32[$fs$addr >> 2] = (HEAP32[$fs$addr >> 2] | 0) + 1;
  HEAP32[$fl >> 2] = (HEAP32[$fl >> 2] | 0) + (HEAP32[$fs$addr >> 2] & ~HEAP32[$s >> 2]);
  $42 = HEAP32[$enc$addr >> 2] | 0;
  $43 = HEAP32[$fl >> 2] | 0;
  $44 = HEAP32[$fl >> 2] | 0;
  $45 = HEAP32[$fs$addr >> 2] | 0;
  $add41 = $44 + $45 | 0;
  _ec_encode_bin($42, $43, $add41, 15);
  STACKTOP = sp;
  return;
 }
 HEAP32[$ndi_max >> 2] = (32768 - (HEAP32[$fl >> 2] | 0) + 1 - 1 | 0) >>> 0;
 HEAP32[$ndi_max >> 2] = (HEAP32[$ndi_max >> 2] | 0) - (HEAP32[$s >> 2] | 0) >> 1;
 if (((HEAP32[$val >> 2] | 0) - (HEAP32[$i >> 2] | 0) | 0) < ((HEAP32[$ndi_max >> 2] | 0) - 1 | 0)) $cond = (HEAP32[$val >> 2] | 0) - (HEAP32[$i >> 2] | 0) | 0; else $cond = (HEAP32[$ndi_max >> 2] | 0) - 1 | 0;
 HEAP32[$di >> 2] = $cond;
 HEAP32[$fl >> 2] = (HEAP32[$fl >> 2] | 0) + ((HEAP32[$di >> 2] << 1) + 1 + (HEAP32[$s >> 2] | 0));
 HEAP32[$fs$addr >> 2] = 1 < (32768 - (HEAP32[$fl >> 2] | 0) | 0) >>> 0 ? 1 : 32768 - (HEAP32[$fl >> 2] | 0) | 0;
 HEAP32[HEAP32[$value$addr >> 2] >> 2] = (HEAP32[$i >> 2] | 0) + (HEAP32[$di >> 2] | 0) + (HEAP32[$s >> 2] | 0) ^ HEAP32[$s >> 2];
 $42 = HEAP32[$enc$addr >> 2] | 0;
 $43 = HEAP32[$fl >> 2] | 0;
 $44 = HEAP32[$fl >> 2] | 0;
 $45 = HEAP32[$fs$addr >> 2] | 0;
 $add41 = $44 + $45 | 0;
 _ec_encode_bin($42, $43, $add41, 15);
 STACKTOP = sp;
 return;
}

function _silk_resampler_private_IIR_FIR_INTERPOL($out, $buf, $max_index_Q16, $index_increment_Q16) {
 $out = $out | 0;
 $buf = $buf | 0;
 $max_index_Q16 = $max_index_Q16 | 0;
 $index_increment_Q16 = $index_increment_Q16 | 0;
 var $48 = 0, $buf$addr = 0, $buf_ptr = 0, $cond79 = 0, $index_Q16 = 0, $index_increment_Q16$addr = 0, $max_index_Q16$addr = 0, $out$addr = 0, $res_Q15 = 0, $table_index = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $out$addr = sp + 28 | 0;
 $buf$addr = sp + 24 | 0;
 $max_index_Q16$addr = sp + 20 | 0;
 $index_increment_Q16$addr = sp + 16 | 0;
 $index_Q16 = sp + 12 | 0;
 $res_Q15 = sp + 8 | 0;
 $buf_ptr = sp + 4 | 0;
 $table_index = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$buf$addr >> 2] = $buf;
 HEAP32[$max_index_Q16$addr >> 2] = $max_index_Q16;
 HEAP32[$index_increment_Q16$addr >> 2] = $index_increment_Q16;
 HEAP32[$index_Q16 >> 2] = 0;
 while (1) {
  if ((HEAP32[$index_Q16 >> 2] | 0) >= (HEAP32[$max_index_Q16$addr >> 2] | 0)) break;
  HEAP32[$table_index >> 2] = (((HEAP32[$index_Q16 >> 2] & 65535) >> 16) * 12 | 0) + ((HEAP32[$index_Q16 >> 2] & 65535) * 12 >> 16);
  HEAP32[$buf_ptr >> 2] = (HEAP32[$buf$addr >> 2] | 0) + (HEAP32[$index_Q16 >> 2] >> 16 << 1);
  HEAP32[$res_Q15 >> 2] = Math_imul(HEAP16[HEAP32[$buf_ptr >> 2] >> 1] | 0, HEAP16[23240 + (HEAP32[$table_index >> 2] << 3) >> 1] | 0) | 0;
  HEAP32[$res_Q15 >> 2] = (HEAP32[$res_Q15 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$buf_ptr >> 2] | 0) + 2 >> 1] | 0, HEAP16[23240 + (HEAP32[$table_index >> 2] << 3) + 2 >> 1] | 0) | 0);
  HEAP32[$res_Q15 >> 2] = (HEAP32[$res_Q15 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$buf_ptr >> 2] | 0) + 4 >> 1] | 0, HEAP16[23240 + (HEAP32[$table_index >> 2] << 3) + 4 >> 1] | 0) | 0);
  HEAP32[$res_Q15 >> 2] = (HEAP32[$res_Q15 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$buf_ptr >> 2] | 0) + 6 >> 1] | 0, HEAP16[23240 + (HEAP32[$table_index >> 2] << 3) + 6 >> 1] | 0) | 0);
  HEAP32[$res_Q15 >> 2] = (HEAP32[$res_Q15 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$buf_ptr >> 2] | 0) + 8 >> 1] | 0, HEAP16[23240 + (11 - (HEAP32[$table_index >> 2] | 0) << 3) + 6 >> 1] | 0) | 0);
  HEAP32[$res_Q15 >> 2] = (HEAP32[$res_Q15 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$buf_ptr >> 2] | 0) + 10 >> 1] | 0, HEAP16[23240 + (11 - (HEAP32[$table_index >> 2] | 0) << 3) + 4 >> 1] | 0) | 0);
  HEAP32[$res_Q15 >> 2] = (HEAP32[$res_Q15 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$buf_ptr >> 2] | 0) + 12 >> 1] | 0, HEAP16[23240 + (11 - (HEAP32[$table_index >> 2] | 0) << 3) + 2 >> 1] | 0) | 0);
  HEAP32[$res_Q15 >> 2] = (HEAP32[$res_Q15 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$buf_ptr >> 2] | 0) + 14 >> 1] | 0, HEAP16[23240 + (11 - (HEAP32[$table_index >> 2] | 0) << 3) >> 1] | 0) | 0);
  if (((HEAP32[$res_Q15 >> 2] >> 14) + 1 >> 1 | 0) > 32767) $cond79 = 32767; else if (((HEAP32[$res_Q15 >> 2] >> 14) + 1 >> 1 | 0) < -32768) $cond79 = -32768; else $cond79 = (HEAP32[$res_Q15 >> 2] >> 14) + 1 >> 1;
  $48 = HEAP32[$out$addr >> 2] | 0;
  HEAP32[$out$addr >> 2] = $48 + 2;
  HEAP16[$48 >> 1] = $cond79;
  HEAP32[$index_Q16 >> 2] = (HEAP32[$index_Q16 >> 2] | 0) + (HEAP32[$index_increment_Q16$addr >> 2] | 0);
 }
 STACKTOP = sp;
 return HEAP32[$out$addr >> 2] | 0;
}

function _silk_LPC_analysis_filter($out, $in, $B, $len, $d, $arch) {
 $out = $out | 0;
 $in = $in | 0;
 $B = $B | 0;
 $len = $len | 0;
 $d = $d | 0;
 $arch = $arch | 0;
 var $B$addr = 0, $cond66 = 0, $d$addr = 0, $in$addr = 0, $in_ptr = 0, $ix = 0, $j = 0, $len$addr = 0, $out$addr = 0, $out32 = 0, $out32_Q12 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $out$addr = sp + 40 | 0;
 $in$addr = sp + 36 | 0;
 $B$addr = sp + 32 | 0;
 $len$addr = sp + 28 | 0;
 $d$addr = sp + 24 | 0;
 $j = sp + 16 | 0;
 $ix = sp + 12 | 0;
 $out32_Q12 = sp + 8 | 0;
 $out32 = sp + 4 | 0;
 $in_ptr = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$B$addr >> 2] = $B;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$d$addr >> 2] = $d;
 HEAP32[sp + 20 >> 2] = $arch;
 HEAP32[$ix >> 2] = HEAP32[$d$addr >> 2];
 while (1) {
  if ((HEAP32[$ix >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  HEAP32[$in_ptr >> 2] = (HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$ix >> 2] | 0) - 1 << 1);
  HEAP32[$out32_Q12 >> 2] = Math_imul(HEAP16[HEAP32[$in_ptr >> 2] >> 1] | 0, HEAP16[HEAP32[$B$addr >> 2] >> 1] | 0) | 0;
  HEAP32[$out32_Q12 >> 2] = (HEAP32[$out32_Q12 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$in_ptr >> 2] | 0) + -2 >> 1] | 0, HEAP16[(HEAP32[$B$addr >> 2] | 0) + 2 >> 1] | 0) | 0);
  HEAP32[$out32_Q12 >> 2] = (HEAP32[$out32_Q12 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$in_ptr >> 2] | 0) + -4 >> 1] | 0, HEAP16[(HEAP32[$B$addr >> 2] | 0) + 4 >> 1] | 0) | 0);
  HEAP32[$out32_Q12 >> 2] = (HEAP32[$out32_Q12 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$in_ptr >> 2] | 0) + -6 >> 1] | 0, HEAP16[(HEAP32[$B$addr >> 2] | 0) + 6 >> 1] | 0) | 0);
  HEAP32[$out32_Q12 >> 2] = (HEAP32[$out32_Q12 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$in_ptr >> 2] | 0) + -8 >> 1] | 0, HEAP16[(HEAP32[$B$addr >> 2] | 0) + 8 >> 1] | 0) | 0);
  HEAP32[$out32_Q12 >> 2] = (HEAP32[$out32_Q12 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$in_ptr >> 2] | 0) + -10 >> 1] | 0, HEAP16[(HEAP32[$B$addr >> 2] | 0) + 10 >> 1] | 0) | 0);
  HEAP32[$j >> 2] = 6;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$d$addr >> 2] | 0)) break;
   HEAP32[$out32_Q12 >> 2] = (HEAP32[$out32_Q12 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$in_ptr >> 2] | 0) + (0 - (HEAP32[$j >> 2] | 0) << 1) >> 1] | 0, HEAP16[(HEAP32[$B$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0);
   HEAP32[$out32_Q12 >> 2] = (HEAP32[$out32_Q12 >> 2] | 0) + (Math_imul(HEAP16[(HEAP32[$in_ptr >> 2] | 0) + (0 - (HEAP32[$j >> 2] | 0) - 1 << 1) >> 1] | 0, HEAP16[(HEAP32[$B$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] | 0) | 0);
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 2;
  }
  HEAP32[$out32_Q12 >> 2] = (HEAP16[(HEAP32[$in_ptr >> 2] | 0) + 2 >> 1] << 12) - (HEAP32[$out32_Q12 >> 2] | 0);
  HEAP32[$out32 >> 2] = (HEAP32[$out32_Q12 >> 2] >> 11) + 1 >> 1;
  if ((HEAP32[$out32 >> 2] | 0) > 32767) $cond66 = 32767; else $cond66 = (HEAP32[$out32 >> 2] | 0) < -32768 ? -32768 : HEAP32[$out32 >> 2] | 0;
  HEAP16[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$ix >> 2] << 1) >> 1] = $cond66;
  HEAP32[$ix >> 2] = (HEAP32[$ix >> 2] | 0) + 1;
 }
 _memset(HEAP32[$out$addr >> 2] | 0, 0, HEAP32[$d$addr >> 2] << 1 | 0) | 0;
 STACKTOP = sp;
 return;
}

function _compute_silk_rate_for_hybrid($rate, $bandwidth, $frame20ms, $vbr, $fec, $channels) {
 $rate = $rate | 0;
 $bandwidth = $bandwidth | 0;
 $frame20ms = $frame20ms | 0;
 $vbr = $vbr | 0;
 $fec = $fec | 0;
 $channels = $channels | 0;
 var $14 = 0, $43 = 0, $N = 0, $add29 = 0, $bandwidth$addr = 0, $channels$addr = 0, $entry1 = 0, $fec$addr = 0, $frame20ms$addr = 0, $hi = 0, $i = 0, $lo = 0, $mul26 = 0, $rate$addr = 0, $silk_rate = 0, $vbr$addr = 0, $x0 = 0, $x1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $rate$addr = sp + 52 | 0;
 $bandwidth$addr = sp + 48 | 0;
 $frame20ms$addr = sp + 44 | 0;
 $vbr$addr = sp + 40 | 0;
 $fec$addr = sp + 36 | 0;
 $channels$addr = sp + 32 | 0;
 $entry1 = sp + 28 | 0;
 $i = sp + 24 | 0;
 $N = sp + 20 | 0;
 $silk_rate = sp + 16 | 0;
 $lo = sp + 12 | 0;
 $hi = sp + 8 | 0;
 $x0 = sp + 4 | 0;
 $x1 = sp;
 HEAP32[$rate$addr >> 2] = $rate;
 HEAP32[$bandwidth$addr >> 2] = $bandwidth;
 HEAP32[$frame20ms$addr >> 2] = $frame20ms;
 HEAP32[$vbr$addr >> 2] = $vbr;
 HEAP32[$fec$addr >> 2] = $fec;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$rate$addr >> 2] = (HEAP32[$rate$addr >> 2] | 0) / (HEAP32[$channels$addr >> 2] | 0) | 0;
 HEAP32[$entry1 >> 2] = 1 + (HEAP32[$frame20ms$addr >> 2] | 0) + (HEAP32[$fec$addr >> 2] << 1);
 HEAP32[$N >> 2] = 7;
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
  if ((HEAP32[152 + ((HEAP32[$i >> 2] | 0) * 20 | 0) >> 2] | 0) > (HEAP32[$rate$addr >> 2] | 0)) break;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 $14 = HEAP32[152 + (((HEAP32[$i >> 2] | 0) - 1 | 0) * 20 | 0) + (HEAP32[$entry1 >> 2] << 2) >> 2] | 0;
 if ((HEAP32[$i >> 2] | 0) == (HEAP32[$N >> 2] | 0)) {
  HEAP32[$silk_rate >> 2] = $14;
  HEAP32[$silk_rate >> 2] = (HEAP32[$silk_rate >> 2] | 0) + (((HEAP32[$rate$addr >> 2] | 0) - (HEAP32[152 + (((HEAP32[$i >> 2] | 0) - 1 | 0) * 20 | 0) >> 2] | 0) | 0) / 2 | 0);
 } else {
  HEAP32[$lo >> 2] = $14;
  HEAP32[$hi >> 2] = HEAP32[152 + ((HEAP32[$i >> 2] | 0) * 20 | 0) + (HEAP32[$entry1 >> 2] << 2) >> 2];
  HEAP32[$x0 >> 2] = HEAP32[152 + (((HEAP32[$i >> 2] | 0) - 1 | 0) * 20 | 0) >> 2];
  HEAP32[$x1 >> 2] = HEAP32[152 + ((HEAP32[$i >> 2] | 0) * 20 | 0) >> 2];
  $mul26 = Math_imul(HEAP32[$lo >> 2] | 0, (HEAP32[$x1 >> 2] | 0) - (HEAP32[$rate$addr >> 2] | 0) | 0) | 0;
  $add29 = $mul26 + (Math_imul(HEAP32[$hi >> 2] | 0, (HEAP32[$rate$addr >> 2] | 0) - (HEAP32[$x0 >> 2] | 0) | 0) | 0) | 0;
  HEAP32[$silk_rate >> 2] = ($add29 | 0) / ((HEAP32[$x1 >> 2] | 0) - (HEAP32[$x0 >> 2] | 0) | 0) | 0;
 }
 if (!(HEAP32[$vbr$addr >> 2] | 0)) HEAP32[$silk_rate >> 2] = (HEAP32[$silk_rate >> 2] | 0) + 100;
 if ((HEAP32[$bandwidth$addr >> 2] | 0) == 1104) HEAP32[$silk_rate >> 2] = (HEAP32[$silk_rate >> 2] | 0) + 300;
 HEAP32[$silk_rate >> 2] = Math_imul(HEAP32[$silk_rate >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
 if (!((HEAP32[$channels$addr >> 2] | 0) == 2 & (HEAP32[$rate$addr >> 2] | 0) >= 12e3)) {
  $43 = HEAP32[$silk_rate >> 2] | 0;
  STACKTOP = sp;
  return $43 | 0;
 }
 HEAP32[$silk_rate >> 2] = (HEAP32[$silk_rate >> 2] | 0) - 1e3;
 $43 = HEAP32[$silk_rate >> 2] | 0;
 STACKTOP = sp;
 return $43 | 0;
}

function _silk_resampler($S, $out, $in, $inLen) {
 $S = $S | 0;
 $out = $out | 0;
 $in = $in | 0;
 $inLen = $inLen | 0;
 var $S$addr = 0, $in$addr = 0, $inLen$addr = 0, $nSamples = 0, $out$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $S$addr = sp + 16 | 0;
 $out$addr = sp + 12 | 0;
 $in$addr = sp + 8 | 0;
 $inLen$addr = sp + 4 | 0;
 $nSamples = sp;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$inLen$addr >> 2] = $inLen;
 HEAP32[$nSamples >> 2] = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 292 >> 2] | 0);
 _memcpy((HEAP32[$S$addr >> 2] | 0) + 168 + (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 292 >> 2] << 1) | 0, HEAP32[$in$addr >> 2] | 0, HEAP32[$nSamples >> 2] << 1 | 0) | 0;
 switch (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 264 >> 2] | 0) {
 case 1:
  {
   _silk_resampler_private_up2_HQ_wrapper(HEAP32[$S$addr >> 2] | 0, HEAP32[$out$addr >> 2] | 0, (HEAP32[$S$addr >> 2] | 0) + 168 | 0, HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] | 0);
   _silk_resampler_private_up2_HQ_wrapper(HEAP32[$S$addr >> 2] | 0, (HEAP32[$out$addr >> 2] | 0) + (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 288 >> 2] << 1) | 0, (HEAP32[$in$addr >> 2] | 0) + (HEAP32[$nSamples >> 2] << 1) | 0, (HEAP32[$inLen$addr >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] | 0) | 0);
   break;
  }
 case 2:
  {
   _silk_resampler_private_IIR_FIR(HEAP32[$S$addr >> 2] | 0, HEAP32[$out$addr >> 2] | 0, (HEAP32[$S$addr >> 2] | 0) + 168 | 0, HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] | 0);
   _silk_resampler_private_IIR_FIR(HEAP32[$S$addr >> 2] | 0, (HEAP32[$out$addr >> 2] | 0) + (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 288 >> 2] << 1) | 0, (HEAP32[$in$addr >> 2] | 0) + (HEAP32[$nSamples >> 2] << 1) | 0, (HEAP32[$inLen$addr >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] | 0) | 0);
   break;
  }
 case 3:
  {
   _silk_resampler_private_down_FIR(HEAP32[$S$addr >> 2] | 0, HEAP32[$out$addr >> 2] | 0, (HEAP32[$S$addr >> 2] | 0) + 168 | 0, HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] | 0);
   _silk_resampler_private_down_FIR(HEAP32[$S$addr >> 2] | 0, (HEAP32[$out$addr >> 2] | 0) + (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 288 >> 2] << 1) | 0, (HEAP32[$in$addr >> 2] | 0) + (HEAP32[$nSamples >> 2] << 1) | 0, (HEAP32[$inLen$addr >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] | 0) | 0);
   break;
  }
 default:
  {
   _memcpy(HEAP32[$out$addr >> 2] | 0, (HEAP32[$S$addr >> 2] | 0) + 168 | 0, HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] << 1 | 0) | 0;
   _memcpy((HEAP32[$out$addr >> 2] | 0) + (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 288 >> 2] << 1) | 0, (HEAP32[$in$addr >> 2] | 0) + (HEAP32[$nSamples >> 2] << 1) | 0, (HEAP32[$inLen$addr >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 284 >> 2] | 0) << 1 | 0) | 0;
  }
 }
 _memcpy((HEAP32[$S$addr >> 2] | 0) + 168 | 0, (HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$inLen$addr >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 292 >> 2] | 0) << 1) | 0, HEAP32[(HEAP32[$S$addr >> 2] | 0) + 292 >> 2] << 1 | 0) | 0;
 STACKTOP = sp;
 return 0;
}

function _silk_INVERSE32_varQ_551($b32, $Qres) {
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $20 = 0, $22 = 0, $37 = 0, $Qres$addr = 0, $add21 = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond80 = 0, $err_Q32 = 0, $lshift = 0, $mul = 0, $mul14 = 0, $result = 0, $retval = 0, $sub38 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 32 | 0;
 $b32$addr = sp + 28 | 0;
 $Qres$addr = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $b32_nrm = sp + 8 | 0;
 $err_Q32 = sp + 4 | 0;
 $result = sp;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_553((HEAP32[$b32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 HEAP32[$result >> 2] = HEAP32[$b32_inv >> 2] << 16;
 $mul = Math_imul(HEAP32[$b32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$err_Q32 >> 2] = 536870912 - ($mul + ((Math_imul(HEAP32[$b32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) << 3;
 $mul14 = Math_imul(HEAP32[$err_Q32 >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 $add21 = (HEAP32[$result >> 2] | 0) + ($mul14 + ((Math_imul(HEAP32[$err_Q32 >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
 HEAP32[$result >> 2] = $add21 + (Math_imul(HEAP32[$err_Q32 >> 2] | 0, (HEAP32[$b32_inv >> 2] >> 15) + 1 >> 1) | 0);
 HEAP32[$lshift >> 2] = 61 - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $20 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) > 0) if (($20 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 }
 $22 = HEAP32[$result >> 2] | 0;
 $sub38 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $20 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($22 | 0) > (-2147483648 >> $sub38 | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($22 | 0) > (2147483647 >> $sub38 | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond80 << 0 - (HEAP32[$lshift >> 2] | 0);
 $37 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $37 | 0;
}

function _silk_INVERSE32_varQ_488($b32, $Qres) {
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $20 = 0, $22 = 0, $37 = 0, $Qres$addr = 0, $add21 = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond80 = 0, $err_Q32 = 0, $lshift = 0, $mul = 0, $mul14 = 0, $result = 0, $retval = 0, $sub38 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 32 | 0;
 $b32$addr = sp + 28 | 0;
 $Qres$addr = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $b32_nrm = sp + 8 | 0;
 $err_Q32 = sp + 4 | 0;
 $result = sp;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_487((HEAP32[$b32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 HEAP32[$result >> 2] = HEAP32[$b32_inv >> 2] << 16;
 $mul = Math_imul(HEAP32[$b32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$err_Q32 >> 2] = 536870912 - ($mul + ((Math_imul(HEAP32[$b32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) << 3;
 $mul14 = Math_imul(HEAP32[$err_Q32 >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 $add21 = (HEAP32[$result >> 2] | 0) + ($mul14 + ((Math_imul(HEAP32[$err_Q32 >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
 HEAP32[$result >> 2] = $add21 + (Math_imul(HEAP32[$err_Q32 >> 2] | 0, (HEAP32[$b32_inv >> 2] >> 15) + 1 >> 1) | 0);
 HEAP32[$lshift >> 2] = 61 - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $20 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) > 0) if (($20 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 }
 $22 = HEAP32[$result >> 2] | 0;
 $sub38 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $20 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($22 | 0) > (-2147483648 >> $sub38 | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($22 | 0) > (2147483647 >> $sub38 | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond80 << 0 - (HEAP32[$lshift >> 2] | 0);
 $37 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $37 | 0;
}

function _silk_INVERSE32_varQ_435($b32, $Qres) {
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $20 = 0, $22 = 0, $37 = 0, $Qres$addr = 0, $add21 = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond80 = 0, $err_Q32 = 0, $lshift = 0, $mul = 0, $mul14 = 0, $result = 0, $retval = 0, $sub38 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 32 | 0;
 $b32$addr = sp + 28 | 0;
 $Qres$addr = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $b32_nrm = sp + 8 | 0;
 $err_Q32 = sp + 4 | 0;
 $result = sp;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_436((HEAP32[$b32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 HEAP32[$result >> 2] = HEAP32[$b32_inv >> 2] << 16;
 $mul = Math_imul(HEAP32[$b32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$err_Q32 >> 2] = 536870912 - ($mul + ((Math_imul(HEAP32[$b32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) << 3;
 $mul14 = Math_imul(HEAP32[$err_Q32 >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 $add21 = (HEAP32[$result >> 2] | 0) + ($mul14 + ((Math_imul(HEAP32[$err_Q32 >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
 HEAP32[$result >> 2] = $add21 + (Math_imul(HEAP32[$err_Q32 >> 2] | 0, (HEAP32[$b32_inv >> 2] >> 15) + 1 >> 1) | 0);
 HEAP32[$lshift >> 2] = 61 - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $20 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) > 0) if (($20 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 }
 $22 = HEAP32[$result >> 2] | 0;
 $sub38 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $20 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($22 | 0) > (-2147483648 >> $sub38 | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($22 | 0) > (2147483647 >> $sub38 | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond80 << 0 - (HEAP32[$lshift >> 2] | 0);
 $37 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $37 | 0;
}

function _silk_INVERSE32_varQ_425($b32, $Qres) {
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $20 = 0, $22 = 0, $37 = 0, $Qres$addr = 0, $add21 = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond80 = 0, $err_Q32 = 0, $lshift = 0, $mul = 0, $mul14 = 0, $result = 0, $retval = 0, $sub38 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 32 | 0;
 $b32$addr = sp + 28 | 0;
 $Qres$addr = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $b32_nrm = sp + 8 | 0;
 $err_Q32 = sp + 4 | 0;
 $result = sp;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_427((HEAP32[$b32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 HEAP32[$result >> 2] = HEAP32[$b32_inv >> 2] << 16;
 $mul = Math_imul(HEAP32[$b32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$err_Q32 >> 2] = 536870912 - ($mul + ((Math_imul(HEAP32[$b32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) << 3;
 $mul14 = Math_imul(HEAP32[$err_Q32 >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 $add21 = (HEAP32[$result >> 2] | 0) + ($mul14 + ((Math_imul(HEAP32[$err_Q32 >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
 HEAP32[$result >> 2] = $add21 + (Math_imul(HEAP32[$err_Q32 >> 2] | 0, (HEAP32[$b32_inv >> 2] >> 15) + 1 >> 1) | 0);
 HEAP32[$lshift >> 2] = 61 - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $20 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) > 0) if (($20 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 }
 $22 = HEAP32[$result >> 2] | 0;
 $sub38 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $20 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($22 | 0) > (-2147483648 >> $sub38 | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($22 | 0) > (2147483647 >> $sub38 | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond80 << 0 - (HEAP32[$lshift >> 2] | 0);
 $37 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $37 | 0;
}

function _silk_INVERSE32_varQ($b32, $Qres) {
 $b32 = $b32 | 0;
 $Qres = $Qres | 0;
 var $1 = 0, $20 = 0, $22 = 0, $37 = 0, $Qres$addr = 0, $add21 = 0, $b32$addr = 0, $b32_inv = 0, $b32_nrm = 0, $b_headrm = 0, $cond80 = 0, $err_Q32 = 0, $lshift = 0, $mul = 0, $mul14 = 0, $result = 0, $retval = 0, $sub38 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 32 | 0;
 $b32$addr = sp + 28 | 0;
 $Qres$addr = sp + 24 | 0;
 $b_headrm = sp + 20 | 0;
 $lshift = sp + 16 | 0;
 $b32_inv = sp + 12 | 0;
 $b32_nrm = sp + 8 | 0;
 $err_Q32 = sp + 4 | 0;
 $result = sp;
 HEAP32[$b32$addr >> 2] = $b32;
 HEAP32[$Qres$addr >> 2] = $Qres;
 $1 = HEAP32[$b32$addr >> 2] | 0;
 HEAP32[$b_headrm >> 2] = (_silk_CLZ32_420((HEAP32[$b32$addr >> 2] | 0) > 0 ? $1 : 0 - $1 | 0) | 0) - 1;
 HEAP32[$b32_nrm >> 2] = HEAP32[$b32$addr >> 2] << HEAP32[$b_headrm >> 2];
 HEAP32[$b32_inv >> 2] = 536870911 / (HEAP32[$b32_nrm >> 2] >> 16 | 0) | 0;
 HEAP32[$result >> 2] = HEAP32[$b32_inv >> 2] << 16;
 $mul = Math_imul(HEAP32[$b32_nrm >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 HEAP32[$err_Q32 >> 2] = 536870912 - ($mul + ((Math_imul(HEAP32[$b32_nrm >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) << 3;
 $mul14 = Math_imul(HEAP32[$err_Q32 >> 2] >> 16, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0;
 $add21 = (HEAP32[$result >> 2] | 0) + ($mul14 + ((Math_imul(HEAP32[$err_Q32 >> 2] & 65535, (HEAP32[$b32_inv >> 2] & 65535) << 16 >> 16) | 0) >> 16)) | 0;
 HEAP32[$result >> 2] = $add21 + (Math_imul(HEAP32[$err_Q32 >> 2] | 0, (HEAP32[$b32_inv >> 2] >> 15) + 1 >> 1) | 0);
 HEAP32[$lshift >> 2] = 61 - (HEAP32[$b_headrm >> 2] | 0) - (HEAP32[$Qres$addr >> 2] | 0);
 $20 = HEAP32[$lshift >> 2] | 0;
 if ((HEAP32[$lshift >> 2] | 0) > 0) if (($20 | 0) < 32) {
  HEAP32[$retval >> 2] = HEAP32[$result >> 2] >> HEAP32[$lshift >> 2];
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $37 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $37 | 0;
 }
 $22 = HEAP32[$result >> 2] | 0;
 $sub38 = 0 - (HEAP32[$lshift >> 2] | 0) | 0;
 do if ((-2147483648 >> 0 - $20 | 0) > (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
  if (($22 | 0) > (-2147483648 >> $sub38 | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } else {
  if (($22 | 0) > (2147483647 >> $sub38 | 0)) {
   $cond80 = 2147483647 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  }
  if ((HEAP32[$result >> 2] | 0) < (-2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0) | 0)) {
   $cond80 = -2147483648 >> 0 - (HEAP32[$lshift >> 2] | 0);
   break;
  } else {
   $cond80 = HEAP32[$result >> 2] | 0;
   break;
  }
 } while (0);
 HEAP32[$retval >> 2] = $cond80 << 0 - (HEAP32[$lshift >> 2] | 0);
 $37 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $37 | 0;
}

function _silk_stereo_quant_pred($pred_Q13, $ix) {
 $pred_Q13 = $pred_Q13 | 0;
 $ix = $ix | 0;
 var $51 = 0, $arrayidx55 = 0, $err_Q13 = 0, $err_min_Q13 = 0, $i = 0, $ix$addr = 0, $j = 0, $low_Q13 = 0, $lvl_Q13 = 0, $n = 0, $pred_Q13$addr = 0, $quant_pred_Q13 = 0, $step_Q13 = 0, $sub30 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $pred_Q13$addr = sp + 40 | 0;
 $ix$addr = sp + 36 | 0;
 $i = sp + 32 | 0;
 $j = sp + 28 | 0;
 $n = sp + 24 | 0;
 $low_Q13 = sp + 20 | 0;
 $step_Q13 = sp + 16 | 0;
 $lvl_Q13 = sp + 12 | 0;
 $err_min_Q13 = sp + 8 | 0;
 $err_Q13 = sp + 4 | 0;
 $quant_pred_Q13 = sp;
 HEAP32[$pred_Q13$addr >> 2] = $pred_Q13;
 HEAP32[$ix$addr >> 2] = $ix;
 HEAP32[$quant_pred_Q13 >> 2] = 0;
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= 2) break;
  HEAP32[$err_min_Q13 >> 2] = 2147483647;
  HEAP32[$i >> 2] = 0;
  L4 : while (1) {
   if ((HEAP32[$i >> 2] | 0) >= 15) break;
   HEAP32[$low_Q13 >> 2] = HEAP16[22924 + (HEAP32[$i >> 2] << 1) >> 1];
   HEAP32[$step_Q13 >> 2] = (((HEAP16[22924 + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP32[$low_Q13 >> 2] | 0) >> 16) * 6554 | 0) + (((HEAP16[22924 + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP32[$low_Q13 >> 2] | 0) & 65535) * 6554 >> 16);
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= 5) break;
    HEAP32[$lvl_Q13 >> 2] = (HEAP32[$low_Q13 >> 2] | 0) + (Math_imul((HEAP32[$step_Q13 >> 2] & 65535) << 16 >> 16, ((HEAP32[$j >> 2] << 1) + 1 & 65535) << 16 >> 16) | 0);
    $sub30 = (HEAP32[(HEAP32[$pred_Q13$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2] | 0) - (HEAP32[$lvl_Q13 >> 2] | 0) | 0;
    HEAP32[$err_Q13 >> 2] = ((HEAP32[(HEAP32[$pred_Q13$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2] | 0) - (HEAP32[$lvl_Q13 >> 2] | 0) | 0) > 0 ? $sub30 : 0 - $sub30 | 0;
    if ((HEAP32[$err_Q13 >> 2] | 0) >= (HEAP32[$err_min_Q13 >> 2] | 0)) break L4;
    HEAP32[$err_min_Q13 >> 2] = HEAP32[$err_Q13 >> 2];
    HEAP32[$quant_pred_Q13 >> 2] = HEAP32[$lvl_Q13 >> 2];
    HEAP8[(HEAP32[$ix$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 3 | 0) >> 0] = HEAP32[$i >> 2];
    HEAP8[(HEAP32[$ix$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 3 | 0) + 1 >> 0] = HEAP32[$j >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP8[(HEAP32[$ix$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 3 | 0) + 2 >> 0] = (HEAP8[(HEAP32[$ix$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 3 | 0) >> 0] | 0) / 3 | 0;
  $arrayidx55 = (HEAP32[$ix$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 3 | 0) | 0;
  HEAP8[$arrayidx55 >> 0] = (HEAP8[$arrayidx55 >> 0] | 0) - ((HEAP8[(HEAP32[$ix$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 3 | 0) + 2 >> 0] | 0) * 3 | 0);
  HEAP32[(HEAP32[$pred_Q13$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2] = HEAP32[$quant_pred_Q13 >> 2];
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 $51 = HEAP32[$pred_Q13$addr >> 2] | 0;
 HEAP32[$51 >> 2] = (HEAP32[$51 >> 2] | 0) - (HEAP32[(HEAP32[$pred_Q13$addr >> 2] | 0) + 4 >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_quant_LTP_gains_FLP($B, $cbk_index, $periodicity_index, $sum_log_gain_Q7, $pred_gain_dB, $XX, $xX, $subfr_len, $nb_subfr, $arch) {
 $B = $B | 0;
 $cbk_index = $cbk_index | 0;
 $periodicity_index = $periodicity_index | 0;
 $sum_log_gain_Q7 = $sum_log_gain_Q7 | 0;
 $pred_gain_dB = $pred_gain_dB | 0;
 $XX = $XX | 0;
 $xX = $xX | 0;
 $subfr_len = $subfr_len | 0;
 $nb_subfr = $nb_subfr | 0;
 $arch = $arch | 0;
 var $B$addr = 0, $B_Q14 = 0, $XX$addr = 0, $XX_Q17 = 0, $arch$addr = 0, $call = 0, $call10 = 0, $cbk_index$addr = 0, $i = 0, $nb_subfr$addr = 0, $periodicity_index$addr = 0, $pred_gain_dB$addr = 0, $pred_gain_dB_Q7 = 0, $subfr_len$addr = 0, $sum_log_gain_Q7$addr = 0, $xX$addr = 0, $xX_Q17 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 576 | 0;
 $B$addr = sp + 524 | 0;
 $cbk_index$addr = sp + 520 | 0;
 $periodicity_index$addr = sp + 516 | 0;
 $sum_log_gain_Q7$addr = sp + 512 | 0;
 $pred_gain_dB$addr = sp + 508 | 0;
 $XX$addr = sp + 504 | 0;
 $xX$addr = sp + 500 | 0;
 $subfr_len$addr = sp + 496 | 0;
 $nb_subfr$addr = sp + 492 | 0;
 $arch$addr = sp + 488 | 0;
 $i = sp + 484 | 0;
 $pred_gain_dB_Q7 = sp + 480 | 0;
 $B_Q14 = sp + 528 | 0;
 $XX_Q17 = sp + 80 | 0;
 $xX_Q17 = sp;
 HEAP32[$B$addr >> 2] = $B;
 HEAP32[$cbk_index$addr >> 2] = $cbk_index;
 HEAP32[$periodicity_index$addr >> 2] = $periodicity_index;
 HEAP32[$sum_log_gain_Q7$addr >> 2] = $sum_log_gain_Q7;
 HEAP32[$pred_gain_dB$addr >> 2] = $pred_gain_dB;
 HEAP32[$XX$addr >> 2] = $XX;
 HEAP32[$xX$addr >> 2] = $xX;
 HEAP32[$subfr_len$addr >> 2] = $subfr_len;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (((HEAP32[$nb_subfr$addr >> 2] | 0) * 5 | 0) * 5 | 0)) break;
  $call = _silk_float2int(+HEAPF32[(HEAP32[$XX$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * 131072.0) | 0;
  HEAP32[$XX_Q17 + (HEAP32[$i >> 2] << 2) >> 2] = $call;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$nb_subfr$addr >> 2] | 0) * 5 | 0)) break;
  $call10 = _silk_float2int(+HEAPF32[(HEAP32[$xX$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * 131072.0) | 0;
  HEAP32[$xX_Q17 + (HEAP32[$i >> 2] << 2) >> 2] = $call10;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _silk_quant_LTP_gains($B_Q14, HEAP32[$cbk_index$addr >> 2] | 0, HEAP32[$periodicity_index$addr >> 2] | 0, HEAP32[$sum_log_gain_Q7$addr >> 2] | 0, $pred_gain_dB_Q7, $XX_Q17, $xX_Q17, HEAP32[$subfr_len$addr >> 2] | 0, HEAP32[$nb_subfr$addr >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$nb_subfr$addr >> 2] | 0) * 5 | 0)) break;
  HEAPF32[(HEAP32[$B$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +(HEAP16[$B_Q14 + (HEAP32[$i >> 2] << 1) >> 1] | 0) * .00006103515625;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[HEAP32[$pred_gain_dB$addr >> 2] >> 2] = +(HEAP32[$pred_gain_dB_Q7 >> 2] | 0) * .0078125;
 STACKTOP = sp;
 return;
}

function _silk_residual_energy_FLP($nrgs, $x, $a, $gains, $subfr_length, $nb_subfr, $LPC_order) {
 $nrgs = $nrgs | 0;
 $x = $x | 0;
 $a = $a | 0;
 $gains = $gains | 0;
 $subfr_length = $subfr_length | 0;
 $nb_subfr = $nb_subfr | 0;
 $LPC_order = $LPC_order | 0;
 var $LPC_order$addr = 0, $LPC_res = 0, $LPC_res_ptr = 0, $a$addr = 0, $conv = 0.0, $conv11 = 0.0, $conv16 = 0.0, $conv21 = 0.0, $conv33 = 0.0, $conv38 = 0.0, $conv43 = 0.0, $conv48 = 0.0, $gains$addr = 0, $nb_subfr$addr = 0, $nrgs$addr = 0, $shift = 0, $subfr_length$addr = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 816 | 0;
 $nrgs$addr = sp + 800 | 0;
 $x$addr = sp + 796 | 0;
 $a$addr = sp + 792 | 0;
 $gains$addr = sp + 788 | 0;
 $subfr_length$addr = sp + 784 | 0;
 $nb_subfr$addr = sp + 780 | 0;
 $LPC_order$addr = sp + 776 | 0;
 $shift = sp + 772 | 0;
 $LPC_res_ptr = sp + 768 | 0;
 $LPC_res = sp;
 HEAP32[$nrgs$addr >> 2] = $nrgs;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$gains$addr >> 2] = $gains;
 HEAP32[$subfr_length$addr >> 2] = $subfr_length;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$LPC_order$addr >> 2] = $LPC_order;
 HEAP32[$LPC_res_ptr >> 2] = $LPC_res + (HEAP32[$LPC_order$addr >> 2] << 2);
 HEAP32[$shift >> 2] = (HEAP32[$LPC_order$addr >> 2] | 0) + (HEAP32[$subfr_length$addr >> 2] | 0);
 _silk_LPC_analysis_filter_FLP($LPC_res, HEAP32[$a$addr >> 2] | 0, (HEAP32[$x$addr >> 2] | 0) + (0 << 2) | 0, HEAP32[$shift >> 2] << 1, HEAP32[$LPC_order$addr >> 2] | 0);
 $conv = +HEAPF32[HEAP32[$gains$addr >> 2] >> 2] * +HEAPF32[HEAP32[$gains$addr >> 2] >> 2];
 $conv11 = $conv * +_silk_energy_FLP((HEAP32[$LPC_res_ptr >> 2] | 0) + (0 << 2) | 0, HEAP32[$subfr_length$addr >> 2] | 0);
 HEAPF32[HEAP32[$nrgs$addr >> 2] >> 2] = $conv11;
 $conv16 = +HEAPF32[(HEAP32[$gains$addr >> 2] | 0) + 4 >> 2] * +HEAPF32[(HEAP32[$gains$addr >> 2] | 0) + 4 >> 2];
 $conv21 = $conv16 * +_silk_energy_FLP((HEAP32[$LPC_res_ptr >> 2] | 0) + (HEAP32[$shift >> 2] << 2) | 0, HEAP32[$subfr_length$addr >> 2] | 0);
 HEAPF32[(HEAP32[$nrgs$addr >> 2] | 0) + 4 >> 2] = $conv21;
 if ((HEAP32[$nb_subfr$addr >> 2] | 0) != 4) {
  STACKTOP = sp;
  return;
 }
 _silk_LPC_analysis_filter_FLP($LPC_res, (HEAP32[$a$addr >> 2] | 0) + 64 | 0, (HEAP32[$x$addr >> 2] | 0) + (HEAP32[$shift >> 2] << 1 << 2) | 0, HEAP32[$shift >> 2] << 1, HEAP32[$LPC_order$addr >> 2] | 0);
 $conv33 = +HEAPF32[(HEAP32[$gains$addr >> 2] | 0) + 8 >> 2] * +HEAPF32[(HEAP32[$gains$addr >> 2] | 0) + 8 >> 2];
 $conv38 = $conv33 * +_silk_energy_FLP((HEAP32[$LPC_res_ptr >> 2] | 0) + (0 << 2) | 0, HEAP32[$subfr_length$addr >> 2] | 0);
 HEAPF32[(HEAP32[$nrgs$addr >> 2] | 0) + 8 >> 2] = $conv38;
 $conv43 = +HEAPF32[(HEAP32[$gains$addr >> 2] | 0) + 12 >> 2] * +HEAPF32[(HEAP32[$gains$addr >> 2] | 0) + 12 >> 2];
 $conv48 = $conv43 * +_silk_energy_FLP((HEAP32[$LPC_res_ptr >> 2] | 0) + (HEAP32[$shift >> 2] << 2) | 0, HEAP32[$subfr_length$addr >> 2] | 0);
 HEAPF32[(HEAP32[$nrgs$addr >> 2] | 0) + 12 >> 2] = $conv48;
 STACKTOP = sp;
 return;
}

function _quant_fine_energy($m, $start, $end, $oldEBands, $error, $fine_quant, $enc, $C) {
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $oldEBands = $oldEBands | 0;
 $error = $error | 0;
 $fine_quant = $fine_quant | 0;
 $enc = $enc | 0;
 $C = $C | 0;
 var $C$addr = 0, $add5 = 0.0, $arrayidx35 = 0, $arrayidx40 = 0, $c = 0, $enc$addr = 0, $end$addr = 0, $error$addr = 0, $fine_quant$addr = 0, $frac = 0, $i = 0, $inc = 0, $m$addr = 0, $offset = 0, $oldEBands$addr = 0, $q2 = 0, $start$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $m$addr = sp + 44 | 0;
 $start$addr = sp + 40 | 0;
 $end$addr = sp + 36 | 0;
 $oldEBands$addr = sp + 32 | 0;
 $error$addr = sp + 28 | 0;
 $fine_quant$addr = sp + 24 | 0;
 $enc$addr = sp + 20 | 0;
 $C$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $c = sp + 8 | 0;
 $frac = sp + 48 | 0;
 $q2 = sp + 4 | 0;
 $offset = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$oldEBands$addr >> 2] = $oldEBands;
 HEAP32[$error$addr >> 2] = $error;
 HEAP32[$fine_quant$addr >> 2] = $fine_quant;
 HEAP32[$enc$addr >> 2] = $enc;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  HEAP16[$frac >> 1] = 1 << HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  if ((HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) > 0) {
   HEAP32[$c >> 2] = 0;
   do {
    $add5 = +HEAPF32[(HEAP32[$error$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2] + .5;
    HEAP32[$q2 >> 2] = ~~+Math_floor(+($add5 * +(HEAP16[$frac >> 1] | 0)));
    if ((HEAP32[$q2 >> 2] | 0) > ((HEAP16[$frac >> 1] | 0) - 1 | 0)) HEAP32[$q2 >> 2] = (HEAP16[$frac >> 1] | 0) - 1;
    if ((HEAP32[$q2 >> 2] | 0) < 0) HEAP32[$q2 >> 2] = 0;
    _ec_enc_bits(HEAP32[$enc$addr >> 2] | 0, HEAP32[$q2 >> 2] | 0, HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0);
    HEAPF32[$offset >> 2] = (+(HEAP32[$q2 >> 2] | 0) + .5) * +(1 << 14 - (HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) | 0) * .00006103515625 - .5;
    $arrayidx35 = (HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) | 0;
    HEAPF32[$arrayidx35 >> 2] = +HEAPF32[$arrayidx35 >> 2] + +HEAPF32[$offset >> 2];
    $arrayidx40 = (HEAP32[$error$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) | 0;
    HEAPF32[$arrayidx40 >> 2] = +HEAPF32[$arrayidx40 >> 2] - +HEAPF32[$offset >> 2];
    $inc = (HEAP32[$c >> 2] | 0) + 1 | 0;
    HEAP32[$c >> 2] = $inc;
   } while (($inc | 0) < (HEAP32[$C$addr >> 2] | 0));
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_insertion_sort_decreasing_FLP($a, $idx, $L, $K) {
 $a = $a | 0;
 $idx = $idx | 0;
 $L = $L | 0;
 $K = $K | 0;
 var $K$addr = 0, $L$addr = 0, $a$addr = 0, $i = 0, $idx$addr = 0, $j = 0, $value = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $a$addr = sp + 24 | 0;
 $idx$addr = sp + 20 | 0;
 $L$addr = sp + 16 | 0;
 $K$addr = sp + 12 | 0;
 $value = sp + 8 | 0;
 $i = sp + 4 | 0;
 $j = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$idx$addr >> 2] = $idx;
 HEAP32[$L$addr >> 2] = $L;
 HEAP32[$K$addr >> 2] = $K;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$K$addr >> 2] | 0)) break;
  HEAP32[(HEAP32[$idx$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$i >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$K$addr >> 2] | 0)) break;
  HEAPF32[$value >> 2] = +HEAPF32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$j >> 2] = (HEAP32[$i >> 2] | 0) - 1;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) < 0) break;
   if (!(+HEAPF32[$value >> 2] > +HEAPF32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2])) break;
   HEAPF32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = +HEAPF32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[(HEAP32[$idx$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[(HEAP32[$idx$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + -1;
  }
  HEAPF32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = +HEAPF32[$value >> 2];
  HEAP32[(HEAP32[$idx$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[$i >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = HEAP32[$K$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$L$addr >> 2] | 0)) break;
  HEAPF32[$value >> 2] = +HEAPF32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  if (+HEAPF32[$value >> 2] > +HEAPF32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$K$addr >> 2] | 0) - 1 << 2) >> 2]) {
   HEAP32[$j >> 2] = (HEAP32[$K$addr >> 2] | 0) - 2;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) < 0) break;
    if (!(+HEAPF32[$value >> 2] > +HEAPF32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2])) break;
    HEAPF32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = +HEAPF32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
    HEAP32[(HEAP32[$idx$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[(HEAP32[$idx$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + -1;
   }
   HEAPF32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = +HEAPF32[$value >> 2];
   HEAP32[(HEAP32[$idx$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[$i >> 2];
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_insertion_sort_increasing($a, $idx, $L, $K) {
 $a = $a | 0;
 $idx = $idx | 0;
 $L = $L | 0;
 $K = $K | 0;
 var $K$addr = 0, $L$addr = 0, $a$addr = 0, $i = 0, $idx$addr = 0, $j = 0, $value = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $a$addr = sp + 24 | 0;
 $idx$addr = sp + 20 | 0;
 $L$addr = sp + 16 | 0;
 $K$addr = sp + 12 | 0;
 $value = sp + 8 | 0;
 $i = sp + 4 | 0;
 $j = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$idx$addr >> 2] = $idx;
 HEAP32[$L$addr >> 2] = $L;
 HEAP32[$K$addr >> 2] = $K;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$K$addr >> 2] | 0)) break;
  HEAP32[(HEAP32[$idx$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[$i >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$K$addr >> 2] | 0)) break;
  HEAP32[$value >> 2] = HEAP32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$j >> 2] = (HEAP32[$i >> 2] | 0) - 1;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) < 0) break;
   if ((HEAP32[$value >> 2] | 0) >= (HEAP32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0)) break;
   HEAP32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[(HEAP32[$idx$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[(HEAP32[$idx$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + -1;
  }
  HEAP32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[$value >> 2];
  HEAP32[(HEAP32[$idx$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[$i >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = HEAP32[$K$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$L$addr >> 2] | 0)) break;
  HEAP32[$value >> 2] = HEAP32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  if ((HEAP32[$value >> 2] | 0) < (HEAP32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$K$addr >> 2] | 0) - 1 << 2) >> 2] | 0)) {
   HEAP32[$j >> 2] = (HEAP32[$K$addr >> 2] | 0) - 2;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) < 0) break;
    if ((HEAP32[$value >> 2] | 0) >= (HEAP32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0)) break;
    HEAP32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
    HEAP32[(HEAP32[$idx$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[(HEAP32[$idx$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + -1;
   }
   HEAP32[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[$value >> 2];
   HEAP32[(HEAP32[$idx$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 2) >> 2] = HEAP32[$i >> 2];
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_NSQ_noise_shape_feedback_loop_c($data0, $data1, $coef, $order) {
 $data0 = $data0 | 0;
 $data1 = $data1 | 0;
 $coef = $coef | 0;
 $order = $order | 0;
 var $coef$addr = 0, $data0$addr = 0, $data1$addr = 0, $j = 0, $mul = 0, $mul18 = 0, $mul34 = 0, $mul49 = 0, $order$addr = 0, $out = 0, $tmp1 = 0, $tmp2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $data0$addr = sp + 28 | 0;
 $data1$addr = sp + 24 | 0;
 $coef$addr = sp + 20 | 0;
 $order$addr = sp + 16 | 0;
 $out = sp + 12 | 0;
 $tmp1 = sp + 8 | 0;
 $tmp2 = sp + 4 | 0;
 $j = sp;
 HEAP32[$data0$addr >> 2] = $data0;
 HEAP32[$data1$addr >> 2] = $data1;
 HEAP32[$coef$addr >> 2] = $coef;
 HEAP32[$order$addr >> 2] = $order;
 HEAP32[$tmp2 >> 2] = HEAP32[HEAP32[$data0$addr >> 2] >> 2];
 HEAP32[$tmp1 >> 2] = HEAP32[HEAP32[$data1$addr >> 2] >> 2];
 HEAP32[HEAP32[$data1$addr >> 2] >> 2] = HEAP32[$tmp2 >> 2];
 HEAP32[$out >> 2] = HEAP32[$order$addr >> 2] >> 1;
 $mul = Math_imul(HEAP32[$tmp2 >> 2] >> 16, HEAP16[HEAP32[$coef$addr >> 2] >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul + ((Math_imul(HEAP32[$tmp2 >> 2] & 65535, HEAP16[HEAP32[$coef$addr >> 2] >> 1] | 0) | 0) >> 16));
 HEAP32[$j >> 2] = 2;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
  HEAP32[$tmp2 >> 2] = HEAP32[(HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) - 1 << 2) >> 2];
  HEAP32[(HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) - 1 << 2) >> 2] = HEAP32[$tmp1 >> 2];
  $mul18 = Math_imul(HEAP32[$tmp1 >> 2] >> 16, HEAP16[(HEAP32[$coef$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) - 1 << 1) >> 1] | 0) | 0;
  HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul18 + ((Math_imul(HEAP32[$tmp1 >> 2] & 65535, HEAP16[(HEAP32[$coef$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) >> 16));
  HEAP32[$tmp1 >> 2] = HEAP32[(HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 0 << 2) >> 2];
  HEAP32[(HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 0 << 2) >> 2] = HEAP32[$tmp2 >> 2];
  $mul34 = Math_imul(HEAP32[$tmp2 >> 2] >> 16, HEAP16[(HEAP32[$coef$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0;
  HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul34 + ((Math_imul(HEAP32[$tmp2 >> 2] & 65535, HEAP16[(HEAP32[$coef$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) | 0) >> 16));
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 2;
 }
 HEAP32[(HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$order$addr >> 2] | 0) - 1 << 2) >> 2] = HEAP32[$tmp1 >> 2];
 $mul49 = Math_imul(HEAP32[$tmp1 >> 2] >> 16, HEAP16[(HEAP32[$coef$addr >> 2] | 0) + ((HEAP32[$order$addr >> 2] | 0) - 1 << 1) >> 1] | 0) | 0;
 HEAP32[$out >> 2] = (HEAP32[$out >> 2] | 0) + ($mul49 + ((Math_imul(HEAP32[$tmp1 >> 2] & 65535, HEAP16[(HEAP32[$coef$addr >> 2] | 0) + ((HEAP32[$order$addr >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) >> 16));
 HEAP32[$out >> 2] = HEAP32[$out >> 2] << 1;
 STACKTOP = sp;
 return HEAP32[$out >> 2] | 0;
}

function _silk_ana_filt_bank_1($in, $S, $outL, $outH, $N) {
 $in = $in | 0;
 $S = $S | 0;
 $outL = $outL | 0;
 $outH = $outH | 0;
 $N = $N | 0;
 var $N$addr = 0, $N2 = 0, $S$addr = 0, $X = 0, $Y = 0, $cond51 = 0, $cond77 = 0, $in$addr = 0, $in32 = 0, $k = 0, $mul22 = 0, $mul4 = 0, $outH$addr = 0, $outL$addr = 0, $out_1 = 0, $out_2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $in$addr = sp + 44 | 0;
 $S$addr = sp + 40 | 0;
 $outL$addr = sp + 36 | 0;
 $outH$addr = sp + 32 | 0;
 $N$addr = sp + 28 | 0;
 $k = sp + 24 | 0;
 $N2 = sp + 20 | 0;
 $in32 = sp + 16 | 0;
 $X = sp + 12 | 0;
 $Y = sp + 8 | 0;
 $out_1 = sp + 4 | 0;
 $out_2 = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$outL$addr >> 2] = $outL;
 HEAP32[$outH$addr >> 2] = $outH;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$N2 >> 2] = HEAP32[$N$addr >> 2] >> 1;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$N2 >> 2] | 0)) break;
  HEAP32[$in32 >> 2] = HEAP16[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1 << 1) >> 1] << 10;
  HEAP32[$Y >> 2] = (HEAP32[$in32 >> 2] | 0) - (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0);
  $mul4 = Math_imul(HEAP32[$Y >> 2] >> 16, -24290 << 16 >> 16) | 0;
  HEAP32[$X >> 2] = (HEAP32[$Y >> 2] | 0) + ($mul4 + ((Math_imul(HEAP32[$Y >> 2] & 65535, -24290 << 16 >> 16) | 0) >> 16));
  HEAP32[$out_1 >> 2] = (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[HEAP32[$S$addr >> 2] >> 2] = (HEAP32[$in32 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[$in32 >> 2] = HEAP16[(HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 1 << 1) >> 1] << 10;
  HEAP32[$Y >> 2] = (HEAP32[$in32 >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0);
  $mul22 = Math_imul(HEAP32[$Y >> 2] >> 16, 10788 << 16 >> 16) | 0;
  HEAP32[$X >> 2] = $mul22 + ((Math_imul(HEAP32[$Y >> 2] & 65535, 10788 << 16 >> 16) | 0) >> 16);
  HEAP32[$out_2 >> 2] = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] = (HEAP32[$in32 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  if ((((HEAP32[$out_2 >> 2] | 0) + (HEAP32[$out_1 >> 2] | 0) >> 10) + 1 >> 1 | 0) > 32767) $cond51 = 32767; else if ((((HEAP32[$out_2 >> 2] | 0) + (HEAP32[$out_1 >> 2] | 0) >> 10) + 1 >> 1 | 0) < -32768) $cond51 = -32768; else $cond51 = ((HEAP32[$out_2 >> 2] | 0) + (HEAP32[$out_1 >> 2] | 0) >> 10) + 1 >> 1;
  HEAP16[(HEAP32[$outL$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $cond51;
  if ((((HEAP32[$out_2 >> 2] | 0) - (HEAP32[$out_1 >> 2] | 0) >> 10) + 1 >> 1 | 0) > 32767) $cond77 = 32767; else if ((((HEAP32[$out_2 >> 2] | 0) - (HEAP32[$out_1 >> 2] | 0) >> 10) + 1 >> 1 | 0) < -32768) $cond77 = -32768; else $cond77 = ((HEAP32[$out_2 >> 2] | 0) - (HEAP32[$out_1 >> 2] | 0) >> 10) + 1 >> 1;
  HEAP16[(HEAP32[$outH$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $cond77;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_QueryEncoder($encState, $encStatus) {
 $encState = $encState | 0;
 $encStatus = $encStatus | 0;
 var $51 = 0, $52 = 0, $53 = 0, $encState$addr = 0, $encStatus$addr = 0, $inWBmodeWithoutVariableLP = 0, $land$ext = 0, $psEnc = 0, $ret = 0, $state_Fxx = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $encState$addr = sp + 16 | 0;
 $encStatus$addr = sp + 12 | 0;
 $ret = sp + 8 | 0;
 $state_Fxx = sp + 4 | 0;
 $psEnc = sp;
 HEAP32[$encState$addr >> 2] = $encState;
 HEAP32[$encStatus$addr >> 2] = $encStatus;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$psEnc >> 2] = HEAP32[$encState$addr >> 2];
 HEAP32[$state_Fxx >> 2] = HEAP32[$psEnc >> 2];
 HEAP32[HEAP32[$encStatus$addr >> 2] >> 2] = HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20184 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 4 >> 2] = HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20188 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 8 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4552 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 12 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4560 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 16 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4564 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 20 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4568 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 24 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4608 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 28 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4604 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 32 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4612 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 36 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4620 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 40 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 6084 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 48 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 6072 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 52 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4672 >> 2];
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 72 >> 2] = ((HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4572 >> 2] & 65535) << 16 >> 16) * 1e3;
 HEAP32[(HEAP32[$encStatus$addr >> 2] | 0) + 76 >> 2] = HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4532 >> 2];
 if ((HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 4572 >> 2] | 0) != 16) {
  $51 = 0;
  $land$ext = $51 & 1;
  $52 = HEAP32[$encStatus$addr >> 2] | 0;
  $inWBmodeWithoutVariableLP = $52 + 80 | 0;
  HEAP32[$inWBmodeWithoutVariableLP >> 2] = $land$ext;
  $53 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $53 | 0;
 }
 $51 = (HEAP32[(HEAP32[$state_Fxx >> 2] | 0) + 16 + 12 >> 2] | 0) == 0;
 $land$ext = $51 & 1;
 $52 = HEAP32[$encStatus$addr >> 2] | 0;
 $inWBmodeWithoutVariableLP = $52 + 80 | 0;
 HEAP32[$inWBmodeWithoutVariableLP >> 2] = $land$ext;
 $53 = HEAP32[$ret >> 2] | 0;
 STACKTOP = sp;
 return $53 | 0;
}

function _silk_NLSF_VQ_weights_laroia($pNLSFW_Q_OUT, $pNLSF_Q15, $D) {
 $pNLSFW_Q_OUT = $pNLSFW_Q_OUT | 0;
 $pNLSF_Q15 = $pNLSF_Q15 | 0;
 $D = $D | 0;
 var $13 = 0, $D$addr = 0, $conv22 = 0, $conv35 = 0, $conv47 = 0, $conv8 = 0, $k = 0, $pNLSFW_Q_OUT$addr = 0, $pNLSF_Q15$addr = 0, $tmp1_int = 0, $tmp2_int = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $pNLSFW_Q_OUT$addr = sp + 20 | 0;
 $pNLSF_Q15$addr = sp + 16 | 0;
 $D$addr = sp + 12 | 0;
 $k = sp + 8 | 0;
 $tmp1_int = sp + 4 | 0;
 $tmp2_int = sp;
 HEAP32[$pNLSFW_Q_OUT$addr >> 2] = $pNLSFW_Q_OUT;
 HEAP32[$pNLSF_Q15$addr >> 2] = $pNLSF_Q15;
 HEAP32[$D$addr >> 2] = $D;
 HEAP32[$tmp1_int >> 2] = _silk_max_int_499(HEAP16[HEAP32[$pNLSF_Q15$addr >> 2] >> 1] | 0, 1) | 0;
 HEAP32[$tmp1_int >> 2] = 131072 / (HEAP32[$tmp1_int >> 2] | 0) | 0;
 HEAP32[$tmp2_int >> 2] = _silk_max_int_499((HEAP16[(HEAP32[$pNLSF_Q15$addr >> 2] | 0) + 2 >> 1] | 0) - (HEAP16[HEAP32[$pNLSF_Q15$addr >> 2] >> 1] | 0) | 0, 1) | 0;
 HEAP32[$tmp2_int >> 2] = 131072 / (HEAP32[$tmp2_int >> 2] | 0) | 0;
 $conv8 = (_silk_min_int_500((HEAP32[$tmp1_int >> 2] | 0) + (HEAP32[$tmp2_int >> 2] | 0) | 0, 32767) | 0) & 65535;
 HEAP16[HEAP32[$pNLSFW_Q_OUT$addr >> 2] >> 1] = $conv8;
 HEAP32[$k >> 2] = 1;
 while (1) {
  $13 = HEAP32[$pNLSF_Q15$addr >> 2] | 0;
  if ((HEAP32[$k >> 2] | 0) >= ((HEAP32[$D$addr >> 2] | 0) - 1 | 0)) break;
  HEAP32[$tmp1_int >> 2] = _silk_max_int_499((HEAP16[$13 + ((HEAP32[$k >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$pNLSF_Q15$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] | 0) | 0, 1) | 0;
  HEAP32[$tmp1_int >> 2] = 131072 / (HEAP32[$tmp1_int >> 2] | 0) | 0;
  $conv22 = (_silk_min_int_500((HEAP32[$tmp1_int >> 2] | 0) + (HEAP32[$tmp2_int >> 2] | 0) | 0, 32767) | 0) & 65535;
  HEAP16[(HEAP32[$pNLSFW_Q_OUT$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $conv22;
  HEAP32[$tmp2_int >> 2] = _silk_max_int_499((HEAP16[(HEAP32[$pNLSF_Q15$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 2 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$pNLSF_Q15$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 1 << 1) >> 1] | 0) | 0, 1) | 0;
  HEAP32[$tmp2_int >> 2] = 131072 / (HEAP32[$tmp2_int >> 2] | 0) | 0;
  $conv35 = (_silk_min_int_500((HEAP32[$tmp1_int >> 2] | 0) + (HEAP32[$tmp2_int >> 2] | 0) | 0, 32767) | 0) & 65535;
  HEAP16[(HEAP32[$pNLSFW_Q_OUT$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 1 << 1) >> 1] = $conv35;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 2;
 }
 HEAP32[$tmp1_int >> 2] = _silk_max_int_499(32768 - (HEAP16[$13 + ((HEAP32[$D$addr >> 2] | 0) - 1 << 1) >> 1] | 0) | 0, 1) | 0;
 HEAP32[$tmp1_int >> 2] = 131072 / (HEAP32[$tmp1_int >> 2] | 0) | 0;
 $conv47 = (_silk_min_int_500((HEAP32[$tmp1_int >> 2] | 0) + (HEAP32[$tmp2_int >> 2] | 0) | 0, 32767) | 0) & 65535;
 HEAP16[(HEAP32[$pNLSFW_Q_OUT$addr >> 2] | 0) + ((HEAP32[$D$addr >> 2] | 0) - 1 << 1) >> 1] = $conv47;
 STACKTOP = sp;
 return;
}

function _silk_shell_decoder($pulses0, $psRangeDec, $pulses4) {
 $pulses0 = $pulses0 | 0;
 $psRangeDec = $psRangeDec | 0;
 $pulses4 = $pulses4 | 0;
 var $psRangeDec$addr = 0, $pulses0$addr = 0, $pulses1 = 0, $pulses2 = 0, $pulses3 = 0, $pulses4$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $pulses0$addr = sp + 8 | 0;
 $psRangeDec$addr = sp + 4 | 0;
 $pulses4$addr = sp;
 $pulses3 = sp + 40 | 0;
 $pulses2 = sp + 32 | 0;
 $pulses1 = sp + 16 | 0;
 HEAP32[$pulses0$addr >> 2] = $pulses0;
 HEAP32[$psRangeDec$addr >> 2] = $psRangeDec;
 HEAP32[$pulses4$addr >> 2] = $pulses4;
 _decode_split($pulses3, $pulses3 + 2 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP32[$pulses4$addr >> 2] | 0, 33216);
 _decode_split($pulses2, $pulses2 + 2 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses3 >> 1] | 0, 33064);
 _decode_split($pulses1, $pulses1 + 2 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses2 >> 1] | 0, 32912);
 _decode_split(HEAP32[$pulses0$addr >> 2] | 0, (HEAP32[$pulses0$addr >> 2] | 0) + 2 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses1 >> 1] | 0, 32760);
 _decode_split((HEAP32[$pulses0$addr >> 2] | 0) + 4 | 0, (HEAP32[$pulses0$addr >> 2] | 0) + 6 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses1 + 2 >> 1] | 0, 32760);
 _decode_split($pulses1 + 4 | 0, $pulses1 + 6 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses2 + 2 >> 1] | 0, 32912);
 _decode_split((HEAP32[$pulses0$addr >> 2] | 0) + 8 | 0, (HEAP32[$pulses0$addr >> 2] | 0) + 10 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses1 + 4 >> 1] | 0, 32760);
 _decode_split((HEAP32[$pulses0$addr >> 2] | 0) + 12 | 0, (HEAP32[$pulses0$addr >> 2] | 0) + 14 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses1 + 6 >> 1] | 0, 32760);
 _decode_split($pulses2 + 4 | 0, $pulses2 + 6 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses3 + 2 >> 1] | 0, 33064);
 _decode_split($pulses1 + 8 | 0, $pulses1 + 10 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses2 + 4 >> 1] | 0, 32912);
 _decode_split((HEAP32[$pulses0$addr >> 2] | 0) + 16 | 0, (HEAP32[$pulses0$addr >> 2] | 0) + 18 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses1 + 8 >> 1] | 0, 32760);
 _decode_split((HEAP32[$pulses0$addr >> 2] | 0) + 20 | 0, (HEAP32[$pulses0$addr >> 2] | 0) + 22 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses1 + 10 >> 1] | 0, 32760);
 _decode_split($pulses1 + 12 | 0, $pulses1 + 14 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses2 + 6 >> 1] | 0, 32912);
 _decode_split((HEAP32[$pulses0$addr >> 2] | 0) + 24 | 0, (HEAP32[$pulses0$addr >> 2] | 0) + 26 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses1 + 12 >> 1] | 0, 32760);
 _decode_split((HEAP32[$pulses0$addr >> 2] | 0) + 28 | 0, (HEAP32[$pulses0$addr >> 2] | 0) + 30 | 0, HEAP32[$psRangeDec$addr >> 2] | 0, HEAP16[$pulses1 + 14 >> 1] | 0, 32760);
 STACKTOP = sp;
 return;
}

function _silk_warped_autocorrelation_FLP($corr, $input, $warping, $length, $order) {
 $corr = $corr | 0;
 $input = $input | 0;
 $warping = +$warping;
 $length = $length | 0;
 $order = $order | 0;
 var $C = 0, $arrayidx12 = 0, $arrayidx27 = 0, $arrayidx33 = 0, $corr$addr = 0, $i = 0, $input$addr = 0, $length$addr = 0, $n = 0, $order$addr = 0, $state = 0, $tmp1 = 0, $tmp2 = 0, $warping$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 448 | 0;
 $corr$addr = sp + 440 | 0;
 $input$addr = sp + 436 | 0;
 $warping$addr = sp + 432 | 0;
 $length$addr = sp + 428 | 0;
 $order$addr = sp + 424 | 0;
 $n = sp + 420 | 0;
 $i = sp + 416 | 0;
 $tmp1 = sp + 408 | 0;
 $tmp2 = sp + 400 | 0;
 $state = sp + 200 | 0;
 $C = sp;
 HEAP32[$corr$addr >> 2] = $corr;
 HEAP32[$input$addr >> 2] = $input;
 HEAPF32[$warping$addr >> 2] = $warping;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$order$addr >> 2] = $order;
 _memset($state | 0, 0, 200) | 0;
 _memset($C | 0, 0, 200) | 0;
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAPF64[$tmp1 >> 3] = +HEAPF32[(HEAP32[$input$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
   HEAPF64[$tmp2 >> 3] = +HEAPF64[$state + (HEAP32[$i >> 2] << 3) >> 3] + +HEAPF32[$warping$addr >> 2] * (+HEAPF64[$state + ((HEAP32[$i >> 2] | 0) + 1 << 3) >> 3] - +HEAPF64[$tmp1 >> 3]);
   HEAPF64[$state + (HEAP32[$i >> 2] << 3) >> 3] = +HEAPF64[$tmp1 >> 3];
   $arrayidx12 = $C + (HEAP32[$i >> 2] << 3) | 0;
   HEAPF64[$arrayidx12 >> 3] = +HEAPF64[$arrayidx12 >> 3] + +HEAPF64[$state >> 3] * +HEAPF64[$tmp1 >> 3];
   HEAPF64[$tmp1 >> 3] = +HEAPF64[$state + ((HEAP32[$i >> 2] | 0) + 1 << 3) >> 3] + +HEAPF32[$warping$addr >> 2] * (+HEAPF64[$state + ((HEAP32[$i >> 2] | 0) + 2 << 3) >> 3] - +HEAPF64[$tmp2 >> 3]);
   HEAPF64[$state + ((HEAP32[$i >> 2] | 0) + 1 << 3) >> 3] = +HEAPF64[$tmp2 >> 3];
   $arrayidx27 = $C + ((HEAP32[$i >> 2] | 0) + 1 << 3) | 0;
   HEAPF64[$arrayidx27 >> 3] = +HEAPF64[$arrayidx27 >> 3] + +HEAPF64[$state >> 3] * +HEAPF64[$tmp2 >> 3];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 2;
  }
  HEAPF64[$state + (HEAP32[$order$addr >> 2] << 3) >> 3] = +HEAPF64[$tmp1 >> 3];
  $arrayidx33 = $C + (HEAP32[$order$addr >> 2] << 3) | 0;
  HEAPF64[$arrayidx33 >> 3] = +HEAPF64[$arrayidx33 >> 3] + +HEAPF64[$state >> 3] * +HEAPF64[$tmp1 >> 3];
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$order$addr >> 2] | 0) + 1 | 0)) break;
  HEAPF32[(HEAP32[$corr$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF64[$C + (HEAP32[$i >> 2] << 3) >> 3];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _alg_quant($X, $N, $K, $spread, $B, $enc, $gain, $resynth, $arch) {
 $X = $X | 0;
 $N = $N | 0;
 $K = $K | 0;
 $spread = $spread | 0;
 $B = $B | 0;
 $enc = $enc | 0;
 $gain = +$gain;
 $resynth = $resynth | 0;
 $arch = $arch | 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $B$addr = 0, $K$addr = 0, $N$addr = 0, $X$addr = 0, $add = 0, $arch$addr = 0, $call1 = 0, $collapse_mask = 0, $enc$addr = 0, $gain$addr = 0, $resynth$addr = 0, $saved_stack = 0, $spread$addr = 0, $vla = 0, $yy = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $X$addr = sp + 44 | 0;
 $N$addr = sp + 40 | 0;
 $K$addr = sp + 36 | 0;
 $spread$addr = sp + 32 | 0;
 $B$addr = sp + 28 | 0;
 $enc$addr = sp + 24 | 0;
 $gain$addr = sp + 20 | 0;
 $resynth$addr = sp + 16 | 0;
 $arch$addr = sp + 12 | 0;
 $yy = sp + 8 | 0;
 $collapse_mask = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$K$addr >> 2] = $K;
 HEAP32[$spread$addr >> 2] = $spread;
 HEAP32[$B$addr >> 2] = $B;
 HEAP32[$enc$addr >> 2] = $enc;
 HEAPF32[$gain$addr >> 2] = $gain;
 HEAP32[$resynth$addr >> 2] = $resynth;
 HEAP32[$arch$addr >> 2] = $arch;
 $add = (HEAP32[$N$addr >> 2] | 0) + 3 | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add << 2) | 0) + 15 & -16) | 0;
 _exp_rotation(HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, 1, HEAP32[$B$addr >> 2] | 0, HEAP32[$K$addr >> 2] | 0, HEAP32[$spread$addr >> 2] | 0);
 HEAPF32[$yy >> 2] = +FUNCTION_TABLE_diiiii[HEAP32[_OP_PVQ_SEARCH_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$X$addr >> 2] | 0, $vla, HEAP32[$K$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
 _encode_pulses($vla, HEAP32[$N$addr >> 2] | 0, HEAP32[$K$addr >> 2] | 0, HEAP32[$enc$addr >> 2] | 0);
 if (!(HEAP32[$resynth$addr >> 2] | 0)) {
  $26 = HEAP32[$N$addr >> 2] | 0;
  $27 = HEAP32[$B$addr >> 2] | 0;
  $call1 = _extract_collapse_mask($vla, $26, $27) | 0;
  HEAP32[$collapse_mask >> 2] = $call1;
  $28 = HEAP32[$collapse_mask >> 2] | 0;
  $29 = HEAP32[$saved_stack >> 2] | 0;
  _llvm_stackrestore($29 | 0);
  STACKTOP = sp;
  return $28 | 0;
 }
 _normalise_residual($vla, HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, +HEAPF32[$yy >> 2], +HEAPF32[$gain$addr >> 2]);
 _exp_rotation(HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, -1, HEAP32[$B$addr >> 2] | 0, HEAP32[$K$addr >> 2] | 0, HEAP32[$spread$addr >> 2] | 0);
 $26 = HEAP32[$N$addr >> 2] | 0;
 $27 = HEAP32[$B$addr >> 2] | 0;
 $call1 = _extract_collapse_mask($vla, $26, $27) | 0;
 HEAP32[$collapse_mask >> 2] = $call1;
 $28 = HEAP32[$collapse_mask >> 2] | 0;
 $29 = HEAP32[$saved_stack >> 2] | 0;
 _llvm_stackrestore($29 | 0);
 STACKTOP = sp;
 return $28 | 0;
}

function _silk_LPC_analysis_filter16_FLP($r_LPC, $PredCoef, $s, $length) {
 $r_LPC = $r_LPC | 0;
 $PredCoef = $PredCoef | 0;
 $s = $s | 0;
 $length = $length | 0;
 var $LPC_pred = 0, $PredCoef$addr = 0, $ix = 0, $length$addr = 0, $r_LPC$addr = 0, $s$addr = 0, $s_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $r_LPC$addr = sp + 24 | 0;
 $PredCoef$addr = sp + 20 | 0;
 $s$addr = sp + 16 | 0;
 $length$addr = sp + 12 | 0;
 $ix = sp + 8 | 0;
 $LPC_pred = sp + 4 | 0;
 $s_ptr = sp;
 HEAP32[$r_LPC$addr >> 2] = $r_LPC;
 HEAP32[$PredCoef$addr >> 2] = $PredCoef;
 HEAP32[$s$addr >> 2] = $s;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$ix >> 2] = 16;
 while (1) {
  if ((HEAP32[$ix >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$s_ptr >> 2] = (HEAP32[$s$addr >> 2] | 0) + ((HEAP32[$ix >> 2] | 0) - 1 << 2);
  HEAPF32[$LPC_pred >> 2] = +HEAPF32[HEAP32[$s_ptr >> 2] >> 2] * +HEAPF32[HEAP32[$PredCoef$addr >> 2] >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -4 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -8 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 8 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -12 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 12 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -16 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 16 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -20 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 20 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -24 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 24 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -28 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 28 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -32 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 32 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -36 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 36 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -40 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 40 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -44 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 44 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -48 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 48 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -52 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 52 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -56 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 56 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -60 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 60 >> 2];
  HEAPF32[(HEAP32[$r_LPC$addr >> 2] | 0) + (HEAP32[$ix >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + 4 >> 2] - +HEAPF32[$LPC_pred >> 2];
  HEAP32[$ix >> 2] = (HEAP32[$ix >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_resampler_private_down_FIR($SS, $out, $in, $inLen) {
 $SS = $SS | 0;
 $out = $out | 0;
 $in = $in | 0;
 $inLen = $inLen | 0;
 var $FIR_Coefs = 0, $S = 0, $SS$addr = 0, $add = 0, $cond = 0, $in$addr = 0, $inLen$addr = 0, $index_increment_Q16 = 0, $max_index_Q16 = 0, $nSamplesIn = 0, $out$addr = 0, $saved_stack = 0, $vla = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $SS$addr = sp + 36 | 0;
 $out$addr = sp + 32 | 0;
 $in$addr = sp + 28 | 0;
 $inLen$addr = sp + 24 | 0;
 $S = sp + 20 | 0;
 $nSamplesIn = sp + 16 | 0;
 $max_index_Q16 = sp + 12 | 0;
 $index_increment_Q16 = sp + 8 | 0;
 $FIR_Coefs = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$SS$addr >> 2] = $SS;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$inLen$addr >> 2] = $inLen;
 HEAP32[$S >> 2] = HEAP32[$SS$addr >> 2];
 $add = (HEAP32[(HEAP32[$S >> 2] | 0) + 268 >> 2] | 0) + (HEAP32[(HEAP32[$S >> 2] | 0) + 276 >> 2] | 0) | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($add << 2) | 0) + 15 & -16) | 0;
 _memcpy($vla | 0, (HEAP32[$S >> 2] | 0) + 24 | 0, HEAP32[(HEAP32[$S >> 2] | 0) + 276 >> 2] << 2 | 0) | 0;
 HEAP32[$FIR_Coefs >> 2] = (HEAP32[(HEAP32[$S >> 2] | 0) + 296 >> 2] | 0) + 4;
 HEAP32[$index_increment_Q16 >> 2] = HEAP32[(HEAP32[$S >> 2] | 0) + 272 >> 2];
 while (1) {
  if ((HEAP32[$inLen$addr >> 2] | 0) < (HEAP32[(HEAP32[$S >> 2] | 0) + 268 >> 2] | 0)) $cond = HEAP32[$inLen$addr >> 2] | 0; else $cond = HEAP32[(HEAP32[$S >> 2] | 0) + 268 >> 2] | 0;
  HEAP32[$nSamplesIn >> 2] = $cond;
  _silk_resampler_private_AR2(HEAP32[$S >> 2] | 0, $vla + (HEAP32[(HEAP32[$S >> 2] | 0) + 276 >> 2] << 2) | 0, HEAP32[$in$addr >> 2] | 0, HEAP32[(HEAP32[$S >> 2] | 0) + 296 >> 2] | 0, HEAP32[$nSamplesIn >> 2] | 0);
  HEAP32[$max_index_Q16 >> 2] = HEAP32[$nSamplesIn >> 2] << 16;
  HEAP32[$out$addr >> 2] = _silk_resampler_private_down_FIR_INTERPOL(HEAP32[$out$addr >> 2] | 0, $vla, HEAP32[$FIR_Coefs >> 2] | 0, HEAP32[(HEAP32[$S >> 2] | 0) + 276 >> 2] | 0, HEAP32[(HEAP32[$S >> 2] | 0) + 280 >> 2] | 0, HEAP32[$max_index_Q16 >> 2] | 0, HEAP32[$index_increment_Q16 >> 2] | 0) | 0;
  HEAP32[$in$addr >> 2] = (HEAP32[$in$addr >> 2] | 0) + (HEAP32[$nSamplesIn >> 2] << 1);
  HEAP32[$inLen$addr >> 2] = (HEAP32[$inLen$addr >> 2] | 0) - (HEAP32[$nSamplesIn >> 2] | 0);
  if ((HEAP32[$inLen$addr >> 2] | 0) <= 1) break;
  _memcpy($vla | 0, $vla + (HEAP32[$nSamplesIn >> 2] << 2) | 0, HEAP32[(HEAP32[$S >> 2] | 0) + 276 >> 2] << 2 | 0) | 0;
 }
 _memcpy((HEAP32[$S >> 2] | 0) + 24 | 0, $vla + (HEAP32[$nSamplesIn >> 2] << 2) | 0, HEAP32[(HEAP32[$S >> 2] | 0) + 276 >> 2] << 2 | 0) | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _unquant_energy_finalise($m, $start, $end, $oldEBands, $fine_quant, $fine_priority, $bits_left, $dec, $C) {
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $oldEBands = $oldEBands | 0;
 $fine_quant = $fine_quant | 0;
 $fine_priority = $fine_priority | 0;
 $bits_left = $bits_left | 0;
 $dec = $dec | 0;
 $C = $C | 0;
 var $C$addr = 0, $arrayidx14 = 0, $bits_left$addr = 0, $c = 0, $dec$addr = 0, $end$addr = 0, $fine_priority$addr = 0, $fine_quant$addr = 0, $i = 0, $inc = 0, $m$addr = 0, $offset = 0, $oldEBands$addr = 0, $prio = 0, $q2 = 0, $start$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $m$addr = sp + 52 | 0;
 $start$addr = sp + 48 | 0;
 $end$addr = sp + 44 | 0;
 $oldEBands$addr = sp + 40 | 0;
 $fine_quant$addr = sp + 36 | 0;
 $fine_priority$addr = sp + 32 | 0;
 $bits_left$addr = sp + 28 | 0;
 $dec$addr = sp + 24 | 0;
 $C$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $prio = sp + 12 | 0;
 $c = sp + 8 | 0;
 $q2 = sp + 4 | 0;
 $offset = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$oldEBands$addr >> 2] = $oldEBands;
 HEAP32[$fine_quant$addr >> 2] = $fine_quant;
 HEAP32[$fine_priority$addr >> 2] = $fine_priority;
 HEAP32[$bits_left$addr >> 2] = $bits_left;
 HEAP32[$dec$addr >> 2] = $dec;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$prio >> 2] = 0;
 while (1) {
  if ((HEAP32[$prio >> 2] | 0) >= 2) break;
  HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   if ((HEAP32[$bits_left$addr >> 2] | 0) < (HEAP32[$C$addr >> 2] | 0)) break;
   if ((HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) < 8) if ((HEAP32[(HEAP32[$fine_priority$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) == (HEAP32[$prio >> 2] | 0)) {
    HEAP32[$c >> 2] = 0;
    do {
     HEAP32[$q2 >> 2] = _ec_dec_bits(HEAP32[$dec$addr >> 2] | 0, 1) | 0;
     HEAPF32[$offset >> 2] = (+(HEAP32[$q2 >> 2] | 0) - .5) * +(1 << 14 - (HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) - 1 | 0) * .00006103515625;
     $arrayidx14 = (HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) | 0;
     HEAPF32[$arrayidx14 >> 2] = +HEAPF32[$arrayidx14 >> 2] + +HEAPF32[$offset >> 2];
     HEAP32[$bits_left$addr >> 2] = (HEAP32[$bits_left$addr >> 2] | 0) + -1;
     $inc = (HEAP32[$c >> 2] | 0) + 1 | 0;
     HEAP32[$c >> 2] = $inc;
    } while (($inc | 0) < (HEAP32[$C$addr >> 2] | 0));
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$prio >> 2] = (HEAP32[$prio >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _opus_repacketizer_cat_impl($rp, $data, $len, $self_delimited) {
 $rp = $rp | 0;
 $data = $data | 0;
 $len = $len | 0;
 $self_delimited = $self_delimited | 0;
 var $34 = 0, $call = 0, $curr_nb_frames = 0, $data$addr = 0, $len$addr = 0, $nb_frames33 = 0, $ret = 0, $retval = 0, $rp$addr = 0, $self_delimited$addr = 0, $tmp_toc = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 24 | 0;
 $rp$addr = sp + 20 | 0;
 $data$addr = sp + 16 | 0;
 $len$addr = sp + 12 | 0;
 $self_delimited$addr = sp + 8 | 0;
 $tmp_toc = sp + 28 | 0;
 $curr_nb_frames = sp + 4 | 0;
 $ret = sp;
 HEAP32[$rp$addr >> 2] = $rp;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$self_delimited$addr >> 2] = $self_delimited;
 if ((HEAP32[$len$addr >> 2] | 0) < 1) {
  HEAP32[$retval >> 2] = -4;
  $34 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $34 | 0;
 }
 if (!(HEAP32[(HEAP32[$rp$addr >> 2] | 0) + 4 >> 2] | 0)) {
  HEAP8[HEAP32[$rp$addr >> 2] >> 0] = HEAP8[HEAP32[$data$addr >> 2] >> 0] | 0;
  $call = _opus_packet_get_samples_per_frame(HEAP32[$data$addr >> 2] | 0, 8e3) | 0;
  HEAP32[(HEAP32[$rp$addr >> 2] | 0) + 296 >> 2] = $call;
 } else if (((HEAPU8[HEAP32[$rp$addr >> 2] >> 0] | 0) & 252 | 0) != ((HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0) & 252 | 0)) {
  HEAP32[$retval >> 2] = -4;
  $34 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $34 | 0;
 }
 HEAP32[$curr_nb_frames >> 2] = _opus_packet_get_nb_frames(HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0) | 0;
 if ((HEAP32[$curr_nb_frames >> 2] | 0) < 1) {
  HEAP32[$retval >> 2] = -4;
  $34 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $34 | 0;
 }
 if ((Math_imul((HEAP32[$curr_nb_frames >> 2] | 0) + (HEAP32[(HEAP32[$rp$addr >> 2] | 0) + 4 >> 2] | 0) | 0, HEAP32[(HEAP32[$rp$addr >> 2] | 0) + 296 >> 2] | 0) | 0) > 960) {
  HEAP32[$retval >> 2] = -4;
  $34 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $34 | 0;
 }
 HEAP32[$ret >> 2] = _opus_packet_parse_impl(HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0, HEAP32[$self_delimited$addr >> 2] | 0, $tmp_toc, (HEAP32[$rp$addr >> 2] | 0) + 8 + (HEAP32[(HEAP32[$rp$addr >> 2] | 0) + 4 >> 2] << 2) | 0, (HEAP32[$rp$addr >> 2] | 0) + 200 + (HEAP32[(HEAP32[$rp$addr >> 2] | 0) + 4 >> 2] << 1) | 0, 0, 0) | 0;
 if ((HEAP32[$ret >> 2] | 0) < 1) {
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $34 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $34 | 0;
 } else {
  $nb_frames33 = (HEAP32[$rp$addr >> 2] | 0) + 4 | 0;
  HEAP32[$nb_frames33 >> 2] = (HEAP32[$nb_frames33 >> 2] | 0) + (HEAP32[$curr_nb_frames >> 2] | 0);
  HEAP32[$retval >> 2] = 0;
  $34 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $34 | 0;
 }
 return 0;
}

function _opus_fft_impl($st, $fout) {
 $st = $st | 0;
 $fout = $fout | 0;
 var $L = 0, $cond = 0, $fout$addr = 0, $fstride = 0, $i = 0, $m = 0, $m2 = 0, $mul9 = 0, $p = 0, $shift = 0, $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $st$addr = sp + 60 | 0;
 $fout$addr = sp + 56 | 0;
 $m2 = sp + 52 | 0;
 $m = sp + 48 | 0;
 $p = sp + 44 | 0;
 $L = sp + 40 | 0;
 $fstride = sp + 8 | 0;
 $i = sp + 4 | 0;
 $shift = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$fout$addr >> 2] = $fout;
 if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0) > 0) $cond = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] | 0; else $cond = 0;
 HEAP32[$shift >> 2] = $cond;
 HEAP32[$fstride >> 2] = 1;
 HEAP32[$L >> 2] = 0;
 do {
  HEAP32[$p >> 2] = HEAP16[(HEAP32[$st$addr >> 2] | 0) + 12 + (HEAP32[$L >> 2] << 1 << 1) >> 1];
  HEAP32[$m >> 2] = HEAP16[(HEAP32[$st$addr >> 2] | 0) + 12 + ((HEAP32[$L >> 2] << 1) + 1 << 1) >> 1];
  $mul9 = Math_imul(HEAP32[$fstride + (HEAP32[$L >> 2] << 2) >> 2] | 0, HEAP32[$p >> 2] | 0) | 0;
  HEAP32[$fstride + ((HEAP32[$L >> 2] | 0) + 1 << 2) >> 2] = $mul9;
  HEAP32[$L >> 2] = (HEAP32[$L >> 2] | 0) + 1;
 } while ((HEAP32[$m >> 2] | 0) != 1);
 HEAP32[$m >> 2] = HEAP16[(HEAP32[$st$addr >> 2] | 0) + 12 + ((HEAP32[$L >> 2] << 1) - 1 << 1) >> 1];
 HEAP32[$i >> 2] = (HEAP32[$L >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < 0) break;
  if (HEAP32[$i >> 2] | 0) HEAP32[$m2 >> 2] = HEAP16[(HEAP32[$st$addr >> 2] | 0) + 12 + ((HEAP32[$i >> 2] << 1) - 1 << 1) >> 1]; else HEAP32[$m2 >> 2] = 1;
  switch (HEAP16[(HEAP32[$st$addr >> 2] | 0) + 12 + (HEAP32[$i >> 2] << 1 << 1) >> 1] | 0) {
  case 2:
   {
    _kf_bfly2(HEAP32[$fout$addr >> 2] | 0, HEAP32[$m >> 2] | 0, HEAP32[$fstride + (HEAP32[$i >> 2] << 2) >> 2] | 0);
    break;
   }
  case 4:
   {
    _kf_bfly4(HEAP32[$fout$addr >> 2] | 0, HEAP32[$fstride + (HEAP32[$i >> 2] << 2) >> 2] << HEAP32[$shift >> 2], HEAP32[$st$addr >> 2] | 0, HEAP32[$m >> 2] | 0, HEAP32[$fstride + (HEAP32[$i >> 2] << 2) >> 2] | 0, HEAP32[$m2 >> 2] | 0);
    break;
   }
  case 3:
   {
    _kf_bfly3(HEAP32[$fout$addr >> 2] | 0, HEAP32[$fstride + (HEAP32[$i >> 2] << 2) >> 2] << HEAP32[$shift >> 2], HEAP32[$st$addr >> 2] | 0, HEAP32[$m >> 2] | 0, HEAP32[$fstride + (HEAP32[$i >> 2] << 2) >> 2] | 0, HEAP32[$m2 >> 2] | 0);
    break;
   }
  case 5:
   {
    _kf_bfly5(HEAP32[$fout$addr >> 2] | 0, HEAP32[$fstride + (HEAP32[$i >> 2] << 2) >> 2] << HEAP32[$shift >> 2], HEAP32[$st$addr >> 2] | 0, HEAP32[$m >> 2] | 0, HEAP32[$fstride + (HEAP32[$i >> 2] << 2) >> 2] | 0, HEAP32[$m2 >> 2] | 0);
    break;
   }
  default:
   {}
  }
  HEAP32[$m >> 2] = HEAP32[$m2 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return;
}

function _downmix_float($_x, $y, $subframe, $offset, $c1, $c2, $C) {
 $_x = $_x | 0;
 $y = $y | 0;
 $subframe = $subframe | 0;
 $offset = $offset | 0;
 $c1 = $c1 | 0;
 $c2 = $c2 | 0;
 $C = $C | 0;
 var $C$addr = 0, $_x$addr = 0, $arrayidx13 = 0, $arrayidx31 = 0, $c = 0, $c1$addr = 0, $c2$addr = 0, $j = 0, $mul = 0, $mul27 = 0, $mul9 = 0, $offset$addr = 0, $subframe$addr = 0, $x = 0, $y$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $_x$addr = sp + 36 | 0;
 $y$addr = sp + 32 | 0;
 $subframe$addr = sp + 28 | 0;
 $offset$addr = sp + 24 | 0;
 $c1$addr = sp + 20 | 0;
 $c2$addr = sp + 16 | 0;
 $C$addr = sp + 12 | 0;
 $x = sp + 8 | 0;
 $j = sp + 4 | 0;
 $c = sp;
 HEAP32[$_x$addr >> 2] = $_x;
 HEAP32[$y$addr >> 2] = $y;
 HEAP32[$subframe$addr >> 2] = $subframe;
 HEAP32[$offset$addr >> 2] = $offset;
 HEAP32[$c1$addr >> 2] = $c1;
 HEAP32[$c2$addr >> 2] = $c2;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$x >> 2] = HEAP32[$_x$addr >> 2];
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$subframe$addr >> 2] | 0)) break;
  $mul = Math_imul((HEAP32[$j >> 2] | 0) + (HEAP32[$offset$addr >> 2] | 0) | 0, HEAP32[$C$addr >> 2] | 0) | 0;
  HEAPF32[(HEAP32[$y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$x >> 2] | 0) + ($mul + (HEAP32[$c1$addr >> 2] | 0) << 2) >> 2] * 32768.0;
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 if ((HEAP32[$c2$addr >> 2] | 0) > -1) {
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$subframe$addr >> 2] | 0)) break;
   $mul9 = Math_imul((HEAP32[$j >> 2] | 0) + (HEAP32[$offset$addr >> 2] | 0) | 0, HEAP32[$C$addr >> 2] | 0) | 0;
   $arrayidx13 = (HEAP32[$y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) | 0;
   HEAPF32[$arrayidx13 >> 2] = +HEAPF32[$arrayidx13 >> 2] + +HEAPF32[(HEAP32[$x >> 2] | 0) + ($mul9 + (HEAP32[$c2$addr >> 2] | 0) << 2) >> 2] * 32768.0;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  STACKTOP = sp;
  return;
 }
 if ((HEAP32[$c2$addr >> 2] | 0) != -2) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$c >> 2] = 1;
 while (1) {
  if ((HEAP32[$c >> 2] | 0) >= (HEAP32[$C$addr >> 2] | 0)) break;
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$subframe$addr >> 2] | 0)) break;
   $mul27 = Math_imul((HEAP32[$j >> 2] | 0) + (HEAP32[$offset$addr >> 2] | 0) | 0, HEAP32[$C$addr >> 2] | 0) | 0;
   $arrayidx31 = (HEAP32[$y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) | 0;
   HEAPF32[$arrayidx31 >> 2] = +HEAPF32[$arrayidx31 >> 2] + +HEAPF32[(HEAP32[$x >> 2] | 0) + ($mul27 + (HEAP32[$c >> 2] | 0) << 2) >> 2] * 32768.0;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$c >> 2] = (HEAP32[$c >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_shell_encoder($psRangeEnc, $pulses0) {
 $psRangeEnc = $psRangeEnc | 0;
 $pulses0 = $pulses0 | 0;
 var $psRangeEnc$addr = 0, $pulses0$addr = 0, $pulses1 = 0, $pulses2 = 0, $pulses3 = 0, $pulses4 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $psRangeEnc$addr = sp + 68 | 0;
 $pulses0$addr = sp + 64 | 0;
 $pulses1 = sp + 32 | 0;
 $pulses2 = sp + 16 | 0;
 $pulses3 = sp + 8 | 0;
 $pulses4 = sp;
 HEAP32[$psRangeEnc$addr >> 2] = $psRangeEnc;
 HEAP32[$pulses0$addr >> 2] = $pulses0;
 _combine_pulses($pulses1, HEAP32[$pulses0$addr >> 2] | 0, 8);
 _combine_pulses($pulses2, $pulses1, 4);
 _combine_pulses($pulses3, $pulses2, 2);
 _combine_pulses($pulses4, $pulses3, 1);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pulses3 >> 2] | 0, HEAP32[$pulses4 >> 2] | 0, 33216);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pulses2 >> 2] | 0, HEAP32[$pulses3 >> 2] | 0, 33064);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pulses1 >> 2] | 0, HEAP32[$pulses2 >> 2] | 0, 32912);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[HEAP32[$pulses0$addr >> 2] >> 2] | 0, HEAP32[$pulses1 >> 2] | 0, 32760);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[(HEAP32[$pulses0$addr >> 2] | 0) + 8 >> 2] | 0, HEAP32[$pulses1 + 4 >> 2] | 0, 32760);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pulses1 + 8 >> 2] | 0, HEAP32[$pulses2 + 4 >> 2] | 0, 32912);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[(HEAP32[$pulses0$addr >> 2] | 0) + 16 >> 2] | 0, HEAP32[$pulses1 + 8 >> 2] | 0, 32760);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[(HEAP32[$pulses0$addr >> 2] | 0) + 24 >> 2] | 0, HEAP32[$pulses1 + 12 >> 2] | 0, 32760);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pulses2 + 8 >> 2] | 0, HEAP32[$pulses3 + 4 >> 2] | 0, 33064);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pulses1 + 16 >> 2] | 0, HEAP32[$pulses2 + 8 >> 2] | 0, 32912);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[(HEAP32[$pulses0$addr >> 2] | 0) + 32 >> 2] | 0, HEAP32[$pulses1 + 16 >> 2] | 0, 32760);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[(HEAP32[$pulses0$addr >> 2] | 0) + 40 >> 2] | 0, HEAP32[$pulses1 + 20 >> 2] | 0, 32760);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$pulses1 + 24 >> 2] | 0, HEAP32[$pulses2 + 12 >> 2] | 0, 32912);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[(HEAP32[$pulses0$addr >> 2] | 0) + 48 >> 2] | 0, HEAP32[$pulses1 + 24 >> 2] | 0, 32760);
 _encode_split(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[(HEAP32[$pulses0$addr >> 2] | 0) + 56 >> 2] | 0, HEAP32[$pulses1 + 28 >> 2] | 0, 32760);
 STACKTOP = sp;
 return;
}

function __celt_lpc($_lpc, $ac, $p) {
 $_lpc = $_lpc | 0;
 $ac = $ac | 0;
 $p = $p | 0;
 var $_lpc$addr = 0, $ac$addr = 0, $error = 0, $i = 0, $j = 0, $lpc = 0, $p$addr = 0, $r = 0, $rr = 0, $tmp1 = 0, $tmp2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $_lpc$addr = sp + 40 | 0;
 $ac$addr = sp + 36 | 0;
 $p$addr = sp + 32 | 0;
 $i = sp + 28 | 0;
 $j = sp + 24 | 0;
 $r = sp + 20 | 0;
 $error = sp + 16 | 0;
 $lpc = sp + 12 | 0;
 $rr = sp + 8 | 0;
 $tmp1 = sp + 4 | 0;
 $tmp2 = sp;
 HEAP32[$_lpc$addr >> 2] = $_lpc;
 HEAP32[$ac$addr >> 2] = $ac;
 HEAP32[$p$addr >> 2] = $p;
 HEAPF32[$error >> 2] = +HEAPF32[HEAP32[$ac$addr >> 2] >> 2];
 HEAP32[$lpc >> 2] = HEAP32[$_lpc$addr >> 2];
 _memset(HEAP32[$lpc >> 2] | 0, 0, HEAP32[$p$addr >> 2] << 2 | 0) | 0;
 if (!(+HEAPF32[HEAP32[$ac$addr >> 2] >> 2] != 0.0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$p$addr >> 2] | 0)) {
   label = 12;
   break;
  }
  HEAPF32[$rr >> 2] = 0.0;
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$i >> 2] | 0)) break;
   HEAPF32[$rr >> 2] = +HEAPF32[$rr >> 2] + +HEAPF32[(HEAP32[$lpc >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$ac$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - (HEAP32[$j >> 2] | 0) << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAPF32[$rr >> 2] = +HEAPF32[$rr >> 2] + +HEAPF32[(HEAP32[$ac$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2];
  HEAPF32[$r >> 2] = -(+HEAPF32[$rr >> 2] / +HEAPF32[$error >> 2]);
  HEAPF32[(HEAP32[$lpc >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$r >> 2];
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= ((HEAP32[$i >> 2] | 0) + 1 >> 1 | 0)) break;
   HEAPF32[$tmp1 >> 2] = +HEAPF32[(HEAP32[$lpc >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAPF32[$tmp2 >> 2] = +HEAPF32[(HEAP32[$lpc >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 - (HEAP32[$j >> 2] | 0) << 2) >> 2];
   HEAPF32[(HEAP32[$lpc >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$tmp1 >> 2] + +HEAPF32[$r >> 2] * +HEAPF32[$tmp2 >> 2];
   HEAPF32[(HEAP32[$lpc >> 2] | 0) + ((HEAP32[$i >> 2] | 0) - 1 - (HEAP32[$j >> 2] | 0) << 2) >> 2] = +HEAPF32[$tmp2 >> 2] + +HEAPF32[$r >> 2] * +HEAPF32[$tmp1 >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAPF32[$error >> 2] = +HEAPF32[$error >> 2] - +HEAPF32[$r >> 2] * +HEAPF32[$r >> 2] * +HEAPF32[$error >> 2];
  if (+HEAPF32[$error >> 2] < +HEAPF32[HEAP32[$ac$addr >> 2] >> 2] * 1.0000000474974513e-03) {
   label = 12;
   break;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((label | 0) == 12) {
  STACKTOP = sp;
  return;
 }
}

function _frame_size_select($frame_size, $variable_duration, $Fs) {
 $frame_size = $frame_size | 0;
 $variable_duration = $variable_duration | 0;
 $Fs = $Fs | 0;
 var $32 = 0, $Fs$addr = 0, $frame_size$addr = 0, $new_size = 0, $retval = 0, $variable_duration$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $frame_size$addr = sp + 12 | 0;
 $variable_duration$addr = sp + 8 | 0;
 $Fs$addr = sp + 4 | 0;
 $new_size = sp;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$variable_duration$addr >> 2] = $variable_duration;
 HEAP32[$Fs$addr >> 2] = $Fs;
 if ((HEAP32[$frame_size$addr >> 2] | 0) < ((HEAP32[$Fs$addr >> 2] | 0) / 400 | 0 | 0)) {
  HEAP32[$retval >> 2] = -1;
  $32 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $32 | 0;
 }
 do if ((HEAP32[$variable_duration$addr >> 2] | 0) == 5e3) HEAP32[$new_size >> 2] = HEAP32[$frame_size$addr >> 2]; else {
  if (!((HEAP32[$variable_duration$addr >> 2] | 0) >= 5001 & (HEAP32[$variable_duration$addr >> 2] | 0) <= 5009)) {
   HEAP32[$retval >> 2] = -1;
   $32 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $32 | 0;
  }
  if ((HEAP32[$variable_duration$addr >> 2] | 0) <= 5005) {
   HEAP32[$new_size >> 2] = ((HEAP32[$Fs$addr >> 2] | 0) / 400 | 0) << (HEAP32[$variable_duration$addr >> 2] | 0) - 5001;
   break;
  } else {
   HEAP32[$new_size >> 2] = (Math_imul((HEAP32[$variable_duration$addr >> 2] | 0) - 5001 - 2 | 0, HEAP32[$Fs$addr >> 2] | 0) | 0) / 50 | 0;
   break;
  }
 } while (0);
 if ((HEAP32[$new_size >> 2] | 0) > (HEAP32[$frame_size$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = -1;
  $32 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $32 | 0;
 }
 if (((HEAP32[$new_size >> 2] | 0) * 400 | 0) != (HEAP32[$Fs$addr >> 2] | 0)) if (((HEAP32[$new_size >> 2] | 0) * 200 | 0) != (HEAP32[$Fs$addr >> 2] | 0)) if (((HEAP32[$new_size >> 2] | 0) * 100 | 0) != (HEAP32[$Fs$addr >> 2] | 0)) if (((HEAP32[$new_size >> 2] | 0) * 50 | 0) != (HEAP32[$Fs$addr >> 2] | 0)) if (((HEAP32[$new_size >> 2] | 0) * 25 | 0) != (HEAP32[$Fs$addr >> 2] | 0)) if (((HEAP32[$new_size >> 2] | 0) * 50 | 0) != ((HEAP32[$Fs$addr >> 2] | 0) * 3 | 0)) if (((HEAP32[$new_size >> 2] | 0) * 50 | 0) != (HEAP32[$Fs$addr >> 2] << 2 | 0)) if (((HEAP32[$new_size >> 2] | 0) * 50 | 0) != ((HEAP32[$Fs$addr >> 2] | 0) * 5 | 0)) if (((HEAP32[$new_size >> 2] | 0) * 50 | 0) != ((HEAP32[$Fs$addr >> 2] | 0) * 6 | 0)) {
  HEAP32[$retval >> 2] = -1;
  $32 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $32 | 0;
 }
 HEAP32[$retval >> 2] = HEAP32[$new_size >> 2];
 $32 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $32 | 0;
}

function _silk_resampler_down2_hp($S, $out, $in, $inLen) {
 $S = $S | 0;
 $out = $out | 0;
 $in = $in | 0;
 $inLen = $inLen | 0;
 var $S$addr = 0, $X = 0, $Y = 0, $hp_ener = 0, $in$addr = 0, $in32 = 0, $inLen$addr = 0, $k = 0, $len2 = 0, $out$addr = 0, $out32 = 0, $out32_hp = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $S$addr = sp + 44 | 0;
 $out$addr = sp + 40 | 0;
 $in$addr = sp + 36 | 0;
 $inLen$addr = sp + 32 | 0;
 $k = sp + 28 | 0;
 $len2 = sp + 24 | 0;
 $in32 = sp + 20 | 0;
 $out32 = sp + 16 | 0;
 $out32_hp = sp + 12 | 0;
 $Y = sp + 8 | 0;
 $X = sp + 4 | 0;
 $hp_ener = sp;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$inLen$addr >> 2] = $inLen;
 HEAP32[$len2 >> 2] = (HEAP32[$inLen$addr >> 2] | 0) / 2 | 0;
 HEAPF32[$hp_ener >> 2] = 0.0;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$len2 >> 2] | 0)) break;
  HEAPF32[$in32 >> 2] = +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1 << 2) >> 2];
  HEAPF32[$Y >> 2] = +HEAPF32[$in32 >> 2] - +HEAPF32[HEAP32[$S$addr >> 2] >> 2];
  HEAPF32[$X >> 2] = +HEAPF32[$Y >> 2] * .6074370741844177;
  HEAPF32[$out32 >> 2] = +HEAPF32[HEAP32[$S$addr >> 2] >> 2] + +HEAPF32[$X >> 2];
  HEAPF32[HEAP32[$S$addr >> 2] >> 2] = +HEAPF32[$in32 >> 2] + +HEAPF32[$X >> 2];
  HEAPF32[$out32_hp >> 2] = +HEAPF32[$out32 >> 2];
  HEAPF32[$in32 >> 2] = +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 1 << 2) >> 2];
  HEAPF32[$Y >> 2] = +HEAPF32[$in32 >> 2] - +HEAPF32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2];
  HEAPF32[$X >> 2] = +HEAPF32[$Y >> 2] * .15062999725341797;
  HEAPF32[$out32 >> 2] = +HEAPF32[$out32 >> 2] + +HEAPF32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2];
  HEAPF32[$out32 >> 2] = +HEAPF32[$out32 >> 2] + +HEAPF32[$X >> 2];
  HEAPF32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] = +HEAPF32[$in32 >> 2] + +HEAPF32[$X >> 2];
  HEAPF32[$Y >> 2] = -+HEAPF32[$in32 >> 2] - +HEAPF32[(HEAP32[$S$addr >> 2] | 0) + 8 >> 2];
  HEAPF32[$X >> 2] = +HEAPF32[$Y >> 2] * .15062999725341797;
  HEAPF32[$out32_hp >> 2] = +HEAPF32[$out32_hp >> 2] + +HEAPF32[(HEAP32[$S$addr >> 2] | 0) + 8 >> 2];
  HEAPF32[$out32_hp >> 2] = +HEAPF32[$out32_hp >> 2] + +HEAPF32[$X >> 2];
  HEAPF32[(HEAP32[$S$addr >> 2] | 0) + 8 >> 2] = -+HEAPF32[$in32 >> 2] + +HEAPF32[$X >> 2];
  HEAPF32[$hp_ener >> 2] = +HEAPF32[$hp_ener >> 2] + +HEAPF32[$out32_hp >> 2] * +HEAPF32[$out32_hp >> 2];
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = +HEAPF32[$out32 >> 2] * .5;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return +(+HEAPF32[$hp_ener >> 2]);
}

function _silk_control_SNR($psEncC, $TargetRate_bps) {
 $psEncC = $psEncC | 0;
 $TargetRate_bps = $TargetRate_bps | 0;
 var $39 = 0, $TargetRate_bps$addr = 0, $add = 0, $cond5 = 0, $frac_Q6 = 0, $k = 0, $psEncC$addr = 0, $rateTable = 0, $ret = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $psEncC$addr = sp + 20 | 0;
 $TargetRate_bps$addr = sp + 16 | 0;
 $k = sp + 12 | 0;
 $ret = sp + 8 | 0;
 $frac_Q6 = sp + 4 | 0;
 $rateTable = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$TargetRate_bps$addr >> 2] = $TargetRate_bps;
 HEAP32[$ret >> 2] = 0;
 if ((HEAP32[$TargetRate_bps$addr >> 2] | 0) > 8e4) $cond5 = 8e4; else $cond5 = (HEAP32[$TargetRate_bps$addr >> 2] | 0) < 5e3 ? 5e3 : HEAP32[$TargetRate_bps$addr >> 2] | 0;
 HEAP32[$TargetRate_bps$addr >> 2] = $cond5;
 if ((HEAP32[$TargetRate_bps$addr >> 2] | 0) == (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4604 >> 2] | 0)) {
  $39 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $39 | 0;
 }
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4604 >> 2] = HEAP32[$TargetRate_bps$addr >> 2];
 do if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) == 8) HEAP32[$rateTable >> 2] = 15104; else if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4572 >> 2] | 0) == 12) {
  HEAP32[$rateTable >> 2] = 15136;
  break;
 } else {
  HEAP32[$rateTable >> 2] = 15168;
  break;
 } while (0);
 if ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4576 >> 2] | 0) == 2) HEAP32[$TargetRate_bps$addr >> 2] = (HEAP32[$TargetRate_bps$addr >> 2] | 0) - 2200;
 HEAP32[$k >> 2] = 1;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= 8) {
   label = 16;
   break;
  }
  if ((HEAP32[$TargetRate_bps$addr >> 2] | 0) <= (HEAP32[(HEAP32[$rateTable >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0)) break;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 if ((label | 0) == 16) {
  $39 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $39 | 0;
 }
 HEAP32[$frac_Q6 >> 2] = ((HEAP32[$TargetRate_bps$addr >> 2] | 0) - (HEAP32[(HEAP32[$rateTable >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - 1 << 2) >> 2] | 0) << 6 | 0) / ((HEAP32[(HEAP32[$rateTable >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) - (HEAP32[(HEAP32[$rateTable >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - 1 << 2) >> 2] | 0) | 0) | 0;
 $add = (HEAP16[22908 + ((HEAP32[$k >> 2] | 0) - 1 << 1) >> 1] << 6) + (Math_imul(HEAP32[$frac_Q6 >> 2] | 0, (HEAP16[22908 + (HEAP32[$k >> 2] << 1) >> 1] | 0) - (HEAP16[22908 + ((HEAP32[$k >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) | 0) | 0;
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4712 >> 2] = $add;
 $39 = HEAP32[$ret >> 2] | 0;
 STACKTOP = sp;
 return $39 | 0;
}

function _stereo_merge($X, $Y, $mid, $N, $arch) {
 $X = $X | 0;
 $Y = $Y | 0;
 $mid = +$mid;
 $N = $N | 0;
 $arch = $arch | 0;
 var $El = 0, $Er = 0, $N$addr = 0, $X$addr = 0, $Y$addr = 0, $arch$addr = 0, $j = 0, $l = 0, $lgain = 0, $mid$addr = 0, $mid2 = 0, $r = 0, $rgain = 0, $side = 0, $t = 0, $xp = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $X$addr = sp + 60 | 0;
 $Y$addr = sp + 56 | 0;
 $mid$addr = sp + 52 | 0;
 $N$addr = sp + 48 | 0;
 $arch$addr = sp + 44 | 0;
 $j = sp + 40 | 0;
 $xp = sp + 36 | 0;
 $side = sp + 32 | 0;
 $El = sp + 28 | 0;
 $Er = sp + 24 | 0;
 $mid2 = sp + 20 | 0;
 $t = sp + 16 | 0;
 $lgain = sp + 12 | 0;
 $rgain = sp + 8 | 0;
 $r = sp + 4 | 0;
 $l = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$Y$addr >> 2] = $Y;
 HEAPF32[$mid$addr >> 2] = $mid;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAPF32[$xp >> 2] = 0.0;
 HEAPF32[$side >> 2] = 0.0;
 FUNCTION_TABLE_viiiiii[HEAP32[_DUAL_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$Y$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, $xp, $side);
 HEAPF32[$xp >> 2] = +HEAPF32[$mid$addr >> 2] * +HEAPF32[$xp >> 2];
 HEAPF32[$mid2 >> 2] = +HEAPF32[$mid$addr >> 2];
 HEAPF32[$El >> 2] = +HEAPF32[$mid2 >> 2] * +HEAPF32[$mid2 >> 2] + +HEAPF32[$side >> 2] - +HEAPF32[$xp >> 2] * 2.0;
 HEAPF32[$Er >> 2] = +HEAPF32[$mid2 >> 2] * +HEAPF32[$mid2 >> 2] + +HEAPF32[$side >> 2] + +HEAPF32[$xp >> 2] * 2.0;
 if (+HEAPF32[$Er >> 2] < 6.000000284984708e-04 | +HEAPF32[$El >> 2] < 6.000000284984708e-04) {
  _memcpy(HEAP32[$Y$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, (HEAP32[$N$addr >> 2] << 2) + 0 | 0) | 0;
  STACKTOP = sp;
  return;
 }
 HEAPF32[$t >> 2] = +HEAPF32[$El >> 2];
 HEAPF32[$lgain >> 2] = 1.0 / +Math_sqrt(+(+HEAPF32[$t >> 2]));
 HEAPF32[$t >> 2] = +HEAPF32[$Er >> 2];
 HEAPF32[$rgain >> 2] = 1.0 / +Math_sqrt(+(+HEAPF32[$t >> 2]));
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAPF32[$l >> 2] = +HEAPF32[$mid$addr >> 2] * +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
  HEAPF32[$r >> 2] = +HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
  HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$lgain >> 2] * (+HEAPF32[$l >> 2] - +HEAPF32[$r >> 2]);
  HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$rgain >> 2] * (+HEAPF32[$l >> 2] + +HEAPF32[$r >> 2]);
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_gains_dequant($gain_Q16, $ind, $prev_ind, $conditional, $nb_subfr) {
 $gain_Q16 = $gain_Q16 | 0;
 $ind = $ind | 0;
 $prev_ind = $prev_ind | 0;
 $conditional = $conditional | 0;
 $nb_subfr = $nb_subfr | 0;
 var $$sink1 = 0, $$sink3 = 0, $14 = 0, $call41 = 0, $cond31 = 0, $conditional$addr = 0, $conv = 0, $conv4 = 0, $double_step_size_threshold = 0, $gain_Q16$addr = 0, $ind$addr = 0, $ind_tmp = 0, $k = 0, $nb_subfr$addr = 0, $prev_ind$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $gain_Q16$addr = sp + 28 | 0;
 $ind$addr = sp + 24 | 0;
 $prev_ind$addr = sp + 20 | 0;
 $conditional$addr = sp + 16 | 0;
 $nb_subfr$addr = sp + 12 | 0;
 $k = sp + 8 | 0;
 $ind_tmp = sp + 4 | 0;
 $double_step_size_threshold = sp;
 HEAP32[$gain_Q16$addr >> 2] = $gain_Q16;
 HEAP32[$ind$addr >> 2] = $ind;
 HEAP32[$prev_ind$addr >> 2] = $prev_ind;
 HEAP32[$conditional$addr >> 2] = $conditional;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  $conv = HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0;
  if ((HEAP32[$k >> 2] | 0) == 0 & (HEAP32[$conditional$addr >> 2] | 0) == 0) {
   $conv4 = (_silk_max_int_410($conv, (HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0) - 16 | 0) | 0) & 255;
   HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] = $conv4;
  } else {
   HEAP32[$ind_tmp >> 2] = $conv + -4;
   HEAP32[$double_step_size_threshold >> 2] = 8 + (HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0);
   $14 = HEAP32[$ind_tmp >> 2] | 0;
   if ((HEAP32[$ind_tmp >> 2] | 0) > (HEAP32[$double_step_size_threshold >> 2] | 0)) {
    $$sink1 = ($14 << 1) - (HEAP32[$double_step_size_threshold >> 2] | 0) | 0;
    $$sink3 = HEAP32[$prev_ind$addr >> 2] | 0;
   } else {
    $$sink1 = $14;
    $$sink3 = HEAP32[$prev_ind$addr >> 2] | 0;
   }
   HEAP8[$$sink3 >> 0] = (HEAP8[$$sink3 >> 0] | 0) + $$sink1;
  }
  if ((HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0) > 63) $cond31 = 63; else if ((HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0) < 0) $cond31 = 0; else $cond31 = HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] | 0;
  HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] = $cond31;
  $call41 = _silk_log2lin(_silk_min_32(((HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] << 16 >> 16) * 29 | 0) + ((HEAP8[HEAP32[$prev_ind$addr >> 2] >> 0] << 16 >> 16) * 7281 >> 16) + 2090 | 0, 3967) | 0) | 0;
  HEAP32[(HEAP32[$gain_Q16$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = $call41;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _compute_equiv_rate($bitrate, $channels, $frame_rate, $vbr, $mode, $complexity, $loss) {
 $bitrate = $bitrate | 0;
 $channels = $channels | 0;
 $frame_rate = $frame_rate | 0;
 $vbr = $vbr | 0;
 $mode = $mode | 0;
 $complexity = $complexity | 0;
 $loss = $loss | 0;
 var $24 = 0, $bitrate$addr = 0, $channels$addr = 0, $complexity$addr = 0, $equiv = 0, $frame_rate$addr = 0, $loss$addr = 0, $mode$addr = 0, $mul1 = 0, $mul14 = 0, $mul27 = 0, $vbr$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $bitrate$addr = sp + 28 | 0;
 $channels$addr = sp + 24 | 0;
 $frame_rate$addr = sp + 20 | 0;
 $vbr$addr = sp + 16 | 0;
 $mode$addr = sp + 12 | 0;
 $complexity$addr = sp + 8 | 0;
 $loss$addr = sp + 4 | 0;
 $equiv = sp;
 HEAP32[$bitrate$addr >> 2] = $bitrate;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$frame_rate$addr >> 2] = $frame_rate;
 HEAP32[$vbr$addr >> 2] = $vbr;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$complexity$addr >> 2] = $complexity;
 HEAP32[$loss$addr >> 2] = $loss;
 HEAP32[$equiv >> 2] = HEAP32[$bitrate$addr >> 2];
 $mul1 = Math_imul(((HEAP32[$channels$addr >> 2] | 0) * 40 | 0) + 20 | 0, (HEAP32[$frame_rate$addr >> 2] | 0) - 50 | 0) | 0;
 HEAP32[$equiv >> 2] = (HEAP32[$equiv >> 2] | 0) - $mul1;
 if (!(HEAP32[$vbr$addr >> 2] | 0)) HEAP32[$equiv >> 2] = (HEAP32[$equiv >> 2] | 0) - ((HEAP32[$equiv >> 2] | 0) / 12 | 0);
 HEAP32[$equiv >> 2] = (Math_imul(HEAP32[$equiv >> 2] | 0, 90 + (HEAP32[$complexity$addr >> 2] | 0) | 0) | 0) / 100 | 0;
 if ((HEAP32[$mode$addr >> 2] | 0) == 1e3 | (HEAP32[$mode$addr >> 2] | 0) == 1001) {
  if ((HEAP32[$complexity$addr >> 2] | 0) < 2) HEAP32[$equiv >> 2] = (HEAP32[$equiv >> 2] << 2 | 0) / 5 | 0;
  $mul14 = Math_imul(HEAP32[$equiv >> 2] | 0, HEAP32[$loss$addr >> 2] | 0) | 0;
  HEAP32[$equiv >> 2] = (HEAP32[$equiv >> 2] | 0) - (($mul14 | 0) / (((HEAP32[$loss$addr >> 2] | 0) * 6 | 0) + 10 | 0) | 0);
  $24 = HEAP32[$equiv >> 2] | 0;
  STACKTOP = sp;
  return $24 | 0;
 }
 if ((HEAP32[$mode$addr >> 2] | 0) != 1002) {
  $mul27 = Math_imul(HEAP32[$equiv >> 2] | 0, HEAP32[$loss$addr >> 2] | 0) | 0;
  HEAP32[$equiv >> 2] = (HEAP32[$equiv >> 2] | 0) - (($mul27 | 0) / (((HEAP32[$loss$addr >> 2] | 0) * 12 | 0) + 20 | 0) | 0);
  $24 = HEAP32[$equiv >> 2] | 0;
  STACKTOP = sp;
  return $24 | 0;
 }
 if ((HEAP32[$complexity$addr >> 2] | 0) >= 5) {
  $24 = HEAP32[$equiv >> 2] | 0;
  STACKTOP = sp;
  return $24 | 0;
 }
 HEAP32[$equiv >> 2] = ((HEAP32[$equiv >> 2] | 0) * 9 | 0) / 10 | 0;
 $24 = HEAP32[$equiv >> 2] | 0;
 STACKTOP = sp;
 return $24 | 0;
}

function _silk_NLSF2A_find_poly($out, $cLSF, $dd) {
 $out = $out | 0;
 $cLSF = $cLSF | 0;
 $dd = $dd | 0;
 var $12 = 0, $17 = 0, $20 = 0, $22 = 0, $24 = 0, $26 = 0, $34 = 0, $35 = 0, $40 = 0, $43 = 0, $45 = 0, $47 = 0, $49 = 0, $arrayidx30 = 0, $arrayidx32 = 0, $cLSF$addr = 0, $dd$addr = 0, $ftmp = 0, $k = 0, $n = 0, $out$addr = 0, $shl = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $out$addr = sp + 20 | 0;
 $cLSF$addr = sp + 16 | 0;
 $dd$addr = sp + 12 | 0;
 $k = sp + 8 | 0;
 $n = sp + 4 | 0;
 $ftmp = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$cLSF$addr >> 2] = $cLSF;
 HEAP32[$dd$addr >> 2] = $dd;
 HEAP32[HEAP32[$out$addr >> 2] >> 2] = 65536;
 HEAP32[(HEAP32[$out$addr >> 2] | 0) + 4 >> 2] = 0 - (HEAP32[HEAP32[$cLSF$addr >> 2] >> 2] | 0);
 HEAP32[$k >> 2] = 1;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$dd$addr >> 2] | 0)) break;
  HEAP32[$ftmp >> 2] = HEAP32[(HEAP32[$cLSF$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1 << 2) >> 2];
  $shl = HEAP32[(HEAP32[$out$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - 1 << 2) >> 2] << 1;
  $12 = HEAP32[$ftmp >> 2] | 0;
  $17 = HEAP32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0;
  $20 = ___muldi3($12 | 0, (($12 | 0) < 0) << 31 >> 31 | 0, $17 | 0, (($17 | 0) < 0) << 31 >> 31 | 0) | 0;
  $22 = _bitshift64Ashr($20 | 0, tempRet0 | 0, 15) | 0;
  $24 = _i64Add($22 | 0, tempRet0 | 0, 1, 0) | 0;
  $26 = _bitshift64Ashr($24 | 0, tempRet0 | 0, 1) | 0;
  HEAP32[(HEAP32[$out$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 1 << 2) >> 2] = $shl - $26;
  HEAP32[$n >> 2] = HEAP32[$k >> 2];
  while (1) {
   if ((HEAP32[$n >> 2] | 0) <= 1) break;
   $34 = HEAP32[(HEAP32[$out$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - 2 << 2) >> 2] | 0;
   $35 = HEAP32[$ftmp >> 2] | 0;
   $40 = HEAP32[(HEAP32[$out$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - 1 << 2) >> 2] | 0;
   $43 = ___muldi3($35 | 0, (($35 | 0) < 0) << 31 >> 31 | 0, $40 | 0, (($40 | 0) < 0) << 31 >> 31 | 0) | 0;
   $45 = _bitshift64Ashr($43 | 0, tempRet0 | 0, 15) | 0;
   $47 = _i64Add($45 | 0, tempRet0 | 0, 1, 0) | 0;
   $49 = _bitshift64Ashr($47 | 0, tempRet0 | 0, 1) | 0;
   $arrayidx30 = (HEAP32[$out$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) | 0;
   HEAP32[$arrayidx30 >> 2] = (HEAP32[$arrayidx30 >> 2] | 0) + ($34 - $49);
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + -1;
  }
  $arrayidx32 = (HEAP32[$out$addr >> 2] | 0) + 4 | 0;
  HEAP32[$arrayidx32 >> 2] = (HEAP32[$arrayidx32 >> 2] | 0) - (HEAP32[$ftmp >> 2] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _ec_laplace_decode($dec, $fs, $decay) {
 $dec = $dec | 0;
 $fs = $fs | 0;
 $decay = $decay | 0;
 var $11 = 0, $30 = 0, $31 = 0, $36 = 0, $37 = 0, $cond = 0, $dec$addr = 0, $decay$addr = 0, $di = 0, $fl = 0, $fm = 0, $fs$addr = 0, $val = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $dec$addr = sp + 24 | 0;
 $fs$addr = sp + 20 | 0;
 $decay$addr = sp + 16 | 0;
 $val = sp + 12 | 0;
 $fl = sp + 8 | 0;
 $fm = sp + 4 | 0;
 $di = sp;
 HEAP32[$dec$addr >> 2] = $dec;
 HEAP32[$fs$addr >> 2] = $fs;
 HEAP32[$decay$addr >> 2] = $decay;
 HEAP32[$val >> 2] = 0;
 HEAP32[$fm >> 2] = _ec_decode_bin(HEAP32[$dec$addr >> 2] | 0, 15) | 0;
 HEAP32[$fl >> 2] = 0;
 do if ((HEAP32[$fm >> 2] | 0) >>> 0 >= (HEAP32[$fs$addr >> 2] | 0) >>> 0) {
  HEAP32[$val >> 2] = (HEAP32[$val >> 2] | 0) + 1;
  HEAP32[$fl >> 2] = HEAP32[$fs$addr >> 2];
  HEAP32[$fs$addr >> 2] = (_ec_laplace_get_freq1(HEAP32[$fs$addr >> 2] | 0, HEAP32[$decay$addr >> 2] | 0) | 0) + 1;
  while (1) {
   if ((HEAP32[$fs$addr >> 2] | 0) >>> 0 > 1) $37 = (HEAP32[$fm >> 2] | 0) >>> 0 >= ((HEAP32[$fl >> 2] | 0) + (HEAP32[$fs$addr >> 2] << 1) | 0) >>> 0; else $37 = 0;
   $11 = HEAP32[$fs$addr >> 2] | 0;
   if (!$37) break;
   HEAP32[$fs$addr >> 2] = $11 << 1;
   HEAP32[$fl >> 2] = (HEAP32[$fl >> 2] | 0) + (HEAP32[$fs$addr >> 2] | 0);
   HEAP32[$fs$addr >> 2] = (Math_imul((HEAP32[$fs$addr >> 2] | 0) - 2 | 0, HEAP32[$decay$addr >> 2] | 0) | 0) >>> 15;
   HEAP32[$fs$addr >> 2] = (HEAP32[$fs$addr >> 2] | 0) + 1;
   HEAP32[$val >> 2] = (HEAP32[$val >> 2] | 0) + 1;
  }
  if ($11 >>> 0 <= 1) {
   HEAP32[$di >> 2] = ((HEAP32[$fm >> 2] | 0) - (HEAP32[$fl >> 2] | 0) | 0) >>> 1;
   HEAP32[$val >> 2] = (HEAP32[$val >> 2] | 0) + (HEAP32[$di >> 2] | 0);
   HEAP32[$fl >> 2] = (HEAP32[$fl >> 2] | 0) + (HEAP32[$di >> 2] << 1);
  }
  if ((HEAP32[$fm >> 2] | 0) >>> 0 < ((HEAP32[$fl >> 2] | 0) + (HEAP32[$fs$addr >> 2] | 0) | 0) >>> 0) {
   HEAP32[$val >> 2] = 0 - (HEAP32[$val >> 2] | 0);
   break;
  } else {
   HEAP32[$fl >> 2] = (HEAP32[$fl >> 2] | 0) + (HEAP32[$fs$addr >> 2] | 0);
   break;
  }
 } while (0);
 $30 = HEAP32[$dec$addr >> 2] | 0;
 $31 = HEAP32[$fl >> 2] | 0;
 if (((HEAP32[$fl >> 2] | 0) + (HEAP32[$fs$addr >> 2] | 0) | 0) >>> 0 >= 32768) {
  $cond = 32768;
  _ec_dec_update($30, $31, $cond, 32768);
  $36 = HEAP32[$val >> 2] | 0;
  STACKTOP = sp;
  return $36 | 0;
 }
 $cond = (HEAP32[$fl >> 2] | 0) + (HEAP32[$fs$addr >> 2] | 0) | 0;
 _ec_dec_update($30, $31, $cond, 32768);
 $36 = HEAP32[$val >> 2] | 0;
 STACKTOP = sp;
 return $36 | 0;
}

function _silk_find_LTP_FLP($XX, $xX, $r_ptr, $lag, $subfr_length, $nb_subfr) {
 $XX = $XX | 0;
 $xX = $xX | 0;
 $r_ptr = $r_ptr | 0;
 $lag = $lag | 0;
 $subfr_length = $subfr_length | 0;
 $nb_subfr = $nb_subfr | 0;
 var $XX$addr = 0, $XX_ptr = 0, $cond = 0.0, $k = 0, $lag$addr = 0, $lag_ptr = 0, $nb_subfr$addr = 0, $r_ptr$addr = 0, $subfr_length$addr = 0, $temp = 0, $xX$addr = 0, $xX_ptr = 0, $xx = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $XX$addr = sp + 44 | 0;
 $xX$addr = sp + 40 | 0;
 $r_ptr$addr = sp + 36 | 0;
 $lag$addr = sp + 32 | 0;
 $subfr_length$addr = sp + 28 | 0;
 $nb_subfr$addr = sp + 24 | 0;
 $k = sp + 20 | 0;
 $xX_ptr = sp + 16 | 0;
 $XX_ptr = sp + 12 | 0;
 $lag_ptr = sp + 8 | 0;
 $xx = sp + 4 | 0;
 $temp = sp;
 HEAP32[$XX$addr >> 2] = $XX;
 HEAP32[$xX$addr >> 2] = $xX;
 HEAP32[$r_ptr$addr >> 2] = $r_ptr;
 HEAP32[$lag$addr >> 2] = $lag;
 HEAP32[$subfr_length$addr >> 2] = $subfr_length;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$xX_ptr >> 2] = HEAP32[$xX$addr >> 2];
 HEAP32[$XX_ptr >> 2] = HEAP32[$XX$addr >> 2];
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  HEAP32[$lag_ptr >> 2] = (HEAP32[$r_ptr$addr >> 2] | 0) + (0 - ((HEAP32[(HEAP32[$lag$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0) + 2) << 2);
  _silk_corrMatrix_FLP(HEAP32[$lag_ptr >> 2] | 0, HEAP32[$subfr_length$addr >> 2] | 0, 5, HEAP32[$XX_ptr >> 2] | 0);
  _silk_corrVector_FLP(HEAP32[$lag_ptr >> 2] | 0, HEAP32[$r_ptr$addr >> 2] | 0, HEAP32[$subfr_length$addr >> 2] | 0, 5, HEAP32[$xX_ptr >> 2] | 0);
  HEAPF32[$xx >> 2] = +_silk_energy_FLP(HEAP32[$r_ptr$addr >> 2] | 0, (HEAP32[$subfr_length$addr >> 2] | 0) + 5 | 0);
  if (+HEAPF32[$xx >> 2] > (+HEAPF32[HEAP32[$XX_ptr >> 2] >> 2] + +HEAPF32[(HEAP32[$XX_ptr >> 2] | 0) + 96 >> 2]) * .014999999664723873 + 1.0) $cond = +HEAPF32[$xx >> 2]; else $cond = (+HEAPF32[HEAP32[$XX_ptr >> 2] >> 2] + +HEAPF32[(HEAP32[$XX_ptr >> 2] | 0) + 96 >> 2]) * .014999999664723873 + 1.0;
  HEAPF32[$temp >> 2] = 1.0 / $cond;
  _silk_scale_vector_FLP(HEAP32[$XX_ptr >> 2] | 0, +HEAPF32[$temp >> 2], 25);
  _silk_scale_vector_FLP(HEAP32[$xX_ptr >> 2] | 0, +HEAPF32[$temp >> 2], 5);
  HEAP32[$r_ptr$addr >> 2] = (HEAP32[$r_ptr$addr >> 2] | 0) + (HEAP32[$subfr_length$addr >> 2] << 2);
  HEAP32[$XX_ptr >> 2] = (HEAP32[$XX_ptr >> 2] | 0) + 100;
  HEAP32[$xX_ptr >> 2] = (HEAP32[$xX_ptr >> 2] | 0) + 20;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_decode_signs($psRangeDec, $pulses, $length, $signalType, $quantOffsetType, $sum_pulses) {
 $psRangeDec = $psRangeDec | 0;
 $pulses = $pulses | 0;
 $length = $length | 0;
 $signalType = $signalType | 0;
 $quantOffsetType = $quantOffsetType | 0;
 $sum_pulses = $sum_pulses | 0;
 var $arrayidx23 = 0, $i = 0, $icdf = 0, $icdf_ptr = 0, $j = 0, $length$addr = 0, $p = 0, $psRangeDec$addr = 0, $pulses$addr = 0, $q_ptr = 0, $quantOffsetType$addr = 0, $signalType$addr = 0, $sub = 0, $sum_pulses$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $psRangeDec$addr = sp + 40 | 0;
 $pulses$addr = sp + 36 | 0;
 $length$addr = sp + 32 | 0;
 $signalType$addr = sp + 28 | 0;
 $quantOffsetType$addr = sp + 24 | 0;
 $sum_pulses$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $j = sp + 12 | 0;
 $p = sp + 8 | 0;
 $icdf = sp + 44 | 0;
 $q_ptr = sp + 4 | 0;
 $icdf_ptr = sp;
 HEAP32[$psRangeDec$addr >> 2] = $psRangeDec;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$signalType$addr >> 2] = $signalType;
 HEAP32[$quantOffsetType$addr >> 2] = $quantOffsetType;
 HEAP32[$sum_pulses$addr >> 2] = $sum_pulses;
 HEAP8[$icdf + 1 >> 0] = 0;
 HEAP32[$q_ptr >> 2] = HEAP32[$pulses$addr >> 2];
 HEAP32[$i >> 2] = (((HEAP32[$quantOffsetType$addr >> 2] | 0) + (HEAP32[$signalType$addr >> 2] << 1) & 65535) << 16 >> 16) * 7;
 HEAP32[$icdf_ptr >> 2] = 33385 + (HEAP32[$i >> 2] | 0);
 HEAP32[$length$addr >> 2] = (HEAP32[$length$addr >> 2] | 0) + 8 >> 4;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$p >> 2] = HEAP32[(HEAP32[$sum_pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  L4 : do if ((HEAP32[$p >> 2] | 0) > 0) {
   HEAP8[$icdf >> 0] = HEAP8[(HEAP32[$icdf_ptr >> 2] | 0) + ((HEAP32[$p >> 2] & 31 | 0) < 6 ? HEAP32[$p >> 2] & 31 : 6) >> 0] | 0;
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= 16) break L4;
    if ((HEAP16[(HEAP32[$q_ptr >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0) > 0) {
     $sub = ((_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, $icdf, 8) | 0) << 1) - 1 | 0;
     $arrayidx23 = (HEAP32[$q_ptr >> 2] | 0) + (HEAP32[$j >> 2] << 1) | 0;
     HEAP16[$arrayidx23 >> 1] = Math_imul(HEAP16[$arrayidx23 >> 1] | 0, $sub) | 0;
    }
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
  } while (0);
  HEAP32[$q_ptr >> 2] = (HEAP32[$q_ptr >> 2] | 0) + 32;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _decide_dtx_mode($activity_probability, $nb_no_activity_frames, $peak_signal_energy, $pcm, $frame_size, $channels, $is_silence, $arch) {
 $activity_probability = +$activity_probability;
 $nb_no_activity_frames = $nb_no_activity_frames | 0;
 $peak_signal_energy = +$peak_signal_energy;
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $channels = $channels | 0;
 $is_silence = $is_silence | 0;
 $arch = $arch | 0;
 var $16 = 0, $9 = 0, $activity_probability$addr = 0, $arch$addr = 0, $channels$addr = 0, $frame_size$addr = 0, $is_silence$addr = 0, $nb_no_activity_frames$addr = 0, $noise_energy = 0, $pcm$addr = 0, $peak_signal_energy$addr = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 36 | 0;
 $activity_probability$addr = sp + 32 | 0;
 $nb_no_activity_frames$addr = sp + 28 | 0;
 $peak_signal_energy$addr = sp + 24 | 0;
 $pcm$addr = sp + 20 | 0;
 $frame_size$addr = sp + 16 | 0;
 $channels$addr = sp + 12 | 0;
 $is_silence$addr = sp + 8 | 0;
 $arch$addr = sp + 4 | 0;
 $noise_energy = sp;
 HEAPF32[$activity_probability$addr >> 2] = $activity_probability;
 HEAP32[$nb_no_activity_frames$addr >> 2] = $nb_no_activity_frames;
 HEAPF32[$peak_signal_energy$addr >> 2] = $peak_signal_energy;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$is_silence$addr >> 2] = $is_silence;
 HEAP32[$arch$addr >> 2] = $arch;
 if ((HEAP32[$is_silence$addr >> 2] | 0) == 0 & +HEAPF32[$activity_probability$addr >> 2] < .10000000149011612) {
  HEAPF32[$noise_energy >> 2] = +_compute_frame_energy(HEAP32[$pcm$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
  HEAP32[$is_silence$addr >> 2] = +HEAPF32[$peak_signal_energy$addr >> 2] >= +HEAPF32[$noise_energy >> 2] * 316.2300109863281 & 1;
 }
 $9 = HEAP32[$nb_no_activity_frames$addr >> 2] | 0;
 do if (HEAP32[$is_silence$addr >> 2] | 0) {
  HEAP32[$9 >> 2] = (HEAP32[$9 >> 2] | 0) + 1;
  if ((HEAP32[HEAP32[$nb_no_activity_frames$addr >> 2] >> 2] | 0) > 10) {
   if ((HEAP32[HEAP32[$nb_no_activity_frames$addr >> 2] >> 2] | 0) > 30) {
    HEAP32[HEAP32[$nb_no_activity_frames$addr >> 2] >> 2] = 10;
    break;
   }
   HEAP32[$retval >> 2] = 1;
   $16 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $16 | 0;
  }
 } else HEAP32[$9 >> 2] = 0; while (0);
 HEAP32[$retval >> 2] = 0;
 $16 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $16 | 0;
}

function _exp_rotation1($X, $len, $stride, $c, $s) {
 $X = $X | 0;
 $len = $len | 0;
 $stride = $stride | 0;
 $c = +$c;
 $s = +$s;
 var $20 = 0, $43 = 0, $X$addr = 0, $Xptr = 0, $add28 = 0.0, $add7 = 0.0, $c$addr = 0, $i = 0, $len$addr = 0, $ms = 0, $s$addr = 0, $stride$addr = 0, $x1 = 0, $x118 = 0, $x2 = 0, $x219 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $X$addr = sp + 44 | 0;
 $len$addr = sp + 40 | 0;
 $stride$addr = sp + 36 | 0;
 $c$addr = sp + 32 | 0;
 $s$addr = sp + 28 | 0;
 $i = sp + 24 | 0;
 $ms = sp + 20 | 0;
 $Xptr = sp + 16 | 0;
 $x1 = sp + 12 | 0;
 $x2 = sp + 8 | 0;
 $x118 = sp + 4 | 0;
 $x219 = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$stride$addr >> 2] = $stride;
 HEAPF32[$c$addr >> 2] = $c;
 HEAPF32[$s$addr >> 2] = $s;
 HEAP32[$Xptr >> 2] = HEAP32[$X$addr >> 2];
 HEAPF32[$ms >> 2] = -+HEAPF32[$s$addr >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$len$addr >> 2] | 0) - (HEAP32[$stride$addr >> 2] | 0) | 0)) break;
  HEAPF32[$x1 >> 2] = +HEAPF32[HEAP32[$Xptr >> 2] >> 2];
  HEAPF32[$x2 >> 2] = +HEAPF32[(HEAP32[$Xptr >> 2] | 0) + (HEAP32[$stride$addr >> 2] << 2) >> 2];
  HEAPF32[(HEAP32[$Xptr >> 2] | 0) + (HEAP32[$stride$addr >> 2] << 2) >> 2] = +HEAPF32[$c$addr >> 2] * +HEAPF32[$x2 >> 2] + +HEAPF32[$s$addr >> 2] * +HEAPF32[$x1 >> 2];
  $add7 = +HEAPF32[$c$addr >> 2] * +HEAPF32[$x1 >> 2] + +HEAPF32[$ms >> 2] * +HEAPF32[$x2 >> 2];
  $20 = HEAP32[$Xptr >> 2] | 0;
  HEAP32[$Xptr >> 2] = $20 + 4;
  HEAPF32[$20 >> 2] = $add7;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[$Xptr >> 2] = (HEAP32[$X$addr >> 2] | 0) + ((HEAP32[$len$addr >> 2] | 0) - (HEAP32[$stride$addr >> 2] << 1) - 1 << 2);
 HEAP32[$i >> 2] = (HEAP32[$len$addr >> 2] | 0) - (HEAP32[$stride$addr >> 2] << 1) - 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < 0) break;
  HEAPF32[$x118 >> 2] = +HEAPF32[HEAP32[$Xptr >> 2] >> 2];
  HEAPF32[$x219 >> 2] = +HEAPF32[(HEAP32[$Xptr >> 2] | 0) + (HEAP32[$stride$addr >> 2] << 2) >> 2];
  HEAPF32[(HEAP32[$Xptr >> 2] | 0) + (HEAP32[$stride$addr >> 2] << 2) >> 2] = +HEAPF32[$c$addr >> 2] * +HEAPF32[$x219 >> 2] + +HEAPF32[$s$addr >> 2] * +HEAPF32[$x118 >> 2];
  $add28 = +HEAPF32[$c$addr >> 2] * +HEAPF32[$x118 >> 2] + +HEAPF32[$ms >> 2] * +HEAPF32[$x219 >> 2];
  $43 = HEAP32[$Xptr >> 2] | 0;
  HEAP32[$Xptr >> 2] = $43 + -4;
  HEAPF32[$43 >> 2] = $add28;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return;
}

function _stereo_analysis($m, $X, $LM, $N0) {
 $m = $m | 0;
 $X = $X | 0;
 $LM = $LM | 0;
 $N0 = $N0 | 0;
 var $L = 0, $LM$addr = 0, $M = 0, $N0$addr = 0, $R = 0, $S = 0, $X$addr = 0, $conv14 = 0.0, $conv22 = 0.0, $i = 0, $j = 0, $m$addr = 0, $sumLR = 0, $sumMS = 0, $thetas = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $m$addr = sp + 48 | 0;
 $X$addr = sp + 44 | 0;
 $LM$addr = sp + 40 | 0;
 $N0$addr = sp + 36 | 0;
 $i = sp + 32 | 0;
 $thetas = sp + 28 | 0;
 $sumLR = sp + 24 | 0;
 $sumMS = sp + 20 | 0;
 $j = sp + 16 | 0;
 $L = sp + 12 | 0;
 $R = sp + 8 | 0;
 $M = sp + 4 | 0;
 $S = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$N0$addr >> 2] = $N0;
 HEAPF32[$sumLR >> 2] = 1.0000000036274937e-15;
 HEAPF32[$sumMS >> 2] = 1.0000000036274937e-15;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 13) break;
  HEAP32[$j >> 2] = HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2];
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] << HEAP32[$LM$addr >> 2] | 0)) break;
   HEAPF32[$L >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAPF32[$R >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ((HEAP32[$N0$addr >> 2] | 0) + (HEAP32[$j >> 2] | 0) << 2) >> 2];
   HEAPF32[$M >> 2] = +HEAPF32[$L >> 2] + +HEAPF32[$R >> 2];
   HEAPF32[$S >> 2] = +HEAPF32[$L >> 2] - +HEAPF32[$R >> 2];
   $conv14 = +Math_abs(+(+HEAPF32[$L >> 2]));
   HEAPF32[$sumLR >> 2] = +HEAPF32[$sumLR >> 2] + ($conv14 + +Math_abs(+(+HEAPF32[$R >> 2])));
   $conv22 = +Math_abs(+(+HEAPF32[$M >> 2]));
   HEAPF32[$sumMS >> 2] = +HEAPF32[$sumMS >> 2] + ($conv22 + +Math_abs(+(+HEAPF32[$S >> 2])));
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[$sumMS >> 2] = +HEAPF32[$sumMS >> 2] * .7071070075035095;
 HEAP32[$thetas >> 2] = 13;
 if ((HEAP32[$LM$addr >> 2] | 0) <= 1) HEAP32[$thetas >> 2] = (HEAP32[$thetas >> 2] | 0) - 8;
 STACKTOP = sp;
 return +((HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + 26 >> 1] << (HEAP32[$LM$addr >> 2] | 0) + 1) + (HEAP32[$thetas >> 2] | 0) | 0) * +HEAPF32[$sumMS >> 2] > +(HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + 26 >> 1] << (HEAP32[$LM$addr >> 2] | 0) + 1 | 0) * +HEAPF32[$sumLR >> 2] | 0;
}

function _compute_dense($layer, $output, $input) {
 $layer = $layer | 0;
 $output = $output | 0;
 $input = $input | 0;
 var $7 = 0, $M = 0, $N = 0, $call = 0.0, $call30 = 0.0, $i = 0, $input$addr = 0, $j = 0, $layer$addr = 0, $mul = 0, $output$addr = 0, $stride = 0, $sum = 0, $tobool = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $layer$addr = sp + 32 | 0;
 $output$addr = sp + 28 | 0;
 $input$addr = sp + 24 | 0;
 $i = sp + 20 | 0;
 $j = sp + 16 | 0;
 $N = sp + 12 | 0;
 $M = sp + 8 | 0;
 $stride = sp + 4 | 0;
 $sum = sp;
 HEAP32[$layer$addr >> 2] = $layer;
 HEAP32[$output$addr >> 2] = $output;
 HEAP32[$input$addr >> 2] = $input;
 HEAP32[$M >> 2] = HEAP32[(HEAP32[$layer$addr >> 2] | 0) + 8 >> 2];
 HEAP32[$N >> 2] = HEAP32[(HEAP32[$layer$addr >> 2] | 0) + 12 >> 2];
 HEAP32[$stride >> 2] = HEAP32[$N >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  $7 = HEAP32[$layer$addr >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
  HEAPF32[$sum >> 2] = +(HEAP8[(HEAP32[$7 >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] | 0);
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$M >> 2] | 0)) break;
   $mul = Math_imul(HEAP32[$j >> 2] | 0, HEAP32[$stride >> 2] | 0) | 0;
   HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +(HEAP8[(HEAP32[(HEAP32[$layer$addr >> 2] | 0) + 4 >> 2] | 0) + ($mul + (HEAP32[$i >> 2] | 0)) >> 0] | 0) * +HEAPF32[(HEAP32[$input$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAPF32[(HEAP32[$output$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$sum >> 2] * .0078125;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 $tobool = (HEAP32[$7 + 16 >> 2] | 0) != 0;
 HEAP32[$i >> 2] = 0;
 if ($tobool) {
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
   $call = +_sigmoid_approx(+HEAPF32[(HEAP32[$output$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]);
   HEAPF32[(HEAP32[$output$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $call;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  STACKTOP = sp;
  return;
 } else {
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N >> 2] | 0)) break;
   $call30 = +_tansig_approx(+HEAPF32[(HEAP32[$output$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]);
   HEAPF32[(HEAP32[$output$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $call30;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  STACKTOP = sp;
  return;
 }
}

function _stereo_itheta($X, $Y, $stereo, $N, $arch) {
 $X = $X | 0;
 $Y = $Y | 0;
 $stereo = $stereo | 0;
 $N = $N | 0;
 $arch = $arch | 0;
 var $Emid = 0, $Eside = 0, $N$addr = 0, $X$addr = 0, $Y$addr = 0, $arch$addr = 0, $call = 0.0, $call11 = 0.0, $i = 0, $itheta = 0, $m = 0, $mid = 0, $s = 0, $side = 0, $stereo$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $X$addr = sp + 48 | 0;
 $Y$addr = sp + 44 | 0;
 $stereo$addr = sp + 40 | 0;
 $N$addr = sp + 36 | 0;
 $arch$addr = sp + 32 | 0;
 $i = sp + 28 | 0;
 $itheta = sp + 24 | 0;
 $mid = sp + 20 | 0;
 $side = sp + 16 | 0;
 $Emid = sp + 12 | 0;
 $Eside = sp + 8 | 0;
 $m = sp + 4 | 0;
 $s = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$Y$addr >> 2] = $Y;
 HEAP32[$stereo$addr >> 2] = $stereo;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAPF32[$Eside >> 2] = 1.0000000036274937e-15;
 HEAPF32[$Emid >> 2] = 1.0000000036274937e-15;
 L1 : do if (HEAP32[$stereo$addr >> 2] | 0) {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break L1;
   HEAPF32[$m >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] + +HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$s >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] - +HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
   HEAPF32[$Emid >> 2] = +HEAPF32[$Emid >> 2] + +HEAPF32[$m >> 2] * +HEAPF32[$m >> 2];
   HEAPF32[$Eside >> 2] = +HEAPF32[$Eside >> 2] + +HEAPF32[$s >> 2] * +HEAPF32[$s >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
 } else {
  $call = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$X$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0);
  HEAPF32[$Emid >> 2] = +HEAPF32[$Emid >> 2] + $call;
  $call11 = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$Y$addr >> 2] | 0, HEAP32[$Y$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0);
  HEAPF32[$Eside >> 2] = +HEAPF32[$Eside >> 2] + $call11;
 } while (0);
 HEAPF32[$mid >> 2] = +Math_sqrt(+(+HEAPF32[$Emid >> 2]));
 HEAPF32[$side >> 2] = +Math_sqrt(+(+HEAPF32[$Eside >> 2]));
 HEAP32[$itheta >> 2] = ~~+Math_floor(+(+_fast_atan2f_142(+HEAPF32[$side >> 2], +HEAPF32[$mid >> 2]) * 10430.3818359375 + .5));
 STACKTOP = sp;
 return HEAP32[$itheta >> 2] | 0;
}
function _median_of_5($x) {
 $x = $x | 0;
 var $17 = 0, $54 = 0.0, $6 = 0, $retval = 0, $t0 = 0, $t1 = 0, $t2 = 0, $t3 = 0, $t4 = 0, $tmp = 0, $tmp20 = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 32 | 0;
 $x$addr = sp + 28 | 0;
 $t0 = sp + 24 | 0;
 $t1 = sp + 20 | 0;
 $t2 = sp + 16 | 0;
 $t3 = sp + 12 | 0;
 $t4 = sp + 8 | 0;
 $tmp = sp + 4 | 0;
 $tmp20 = sp;
 HEAP32[$x$addr >> 2] = $x;
 HEAPF32[$t2 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 8 >> 2];
 $6 = HEAP32[$x$addr >> 2] | 0;
 if (+HEAPF32[HEAP32[$x$addr >> 2] >> 2] > +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 4 >> 2]) {
  HEAPF32[$t0 >> 2] = +HEAPF32[$6 + 4 >> 2];
  HEAPF32[$t1 >> 2] = +HEAPF32[HEAP32[$x$addr >> 2] >> 2];
 } else {
  HEAPF32[$t0 >> 2] = +HEAPF32[$6 >> 2];
  HEAPF32[$t1 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 4 >> 2];
 }
 $17 = HEAP32[$x$addr >> 2] | 0;
 if (+HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 12 >> 2] > +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 16 >> 2]) {
  HEAPF32[$t3 >> 2] = +HEAPF32[$17 + 16 >> 2];
  HEAPF32[$t4 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 12 >> 2];
 } else {
  HEAPF32[$t3 >> 2] = +HEAPF32[$17 + 12 >> 2];
  HEAPF32[$t4 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 16 >> 2];
 }
 if (+HEAPF32[$t0 >> 2] > +HEAPF32[$t3 >> 2]) {
  HEAPF32[$tmp >> 2] = +HEAPF32[$t0 >> 2];
  HEAPF32[$t0 >> 2] = +HEAPF32[$t3 >> 2];
  HEAPF32[$t3 >> 2] = +HEAPF32[$tmp >> 2];
  HEAPF32[$tmp20 >> 2] = +HEAPF32[$t1 >> 2];
  HEAPF32[$t1 >> 2] = +HEAPF32[$t4 >> 2];
  HEAPF32[$t4 >> 2] = +HEAPF32[$tmp20 >> 2];
 }
 if (+HEAPF32[$t2 >> 2] > +HEAPF32[$t1 >> 2]) if (+HEAPF32[$t1 >> 2] < +HEAPF32[$t3 >> 2]) {
  HEAPF32[$retval >> 2] = +HEAPF32[$t2 >> 2] < +HEAPF32[$t3 >> 2] ? +HEAPF32[$t2 >> 2] : +HEAPF32[$t3 >> 2];
  $54 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$54;
 } else {
  HEAPF32[$retval >> 2] = +HEAPF32[$t4 >> 2] < +HEAPF32[$t1 >> 2] ? +HEAPF32[$t4 >> 2] : +HEAPF32[$t1 >> 2];
  $54 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$54;
 } else if (+HEAPF32[$t2 >> 2] < +HEAPF32[$t3 >> 2]) {
  HEAPF32[$retval >> 2] = +HEAPF32[$t1 >> 2] < +HEAPF32[$t3 >> 2] ? +HEAPF32[$t1 >> 2] : +HEAPF32[$t3 >> 2];
  $54 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$54;
 } else {
  HEAPF32[$retval >> 2] = +HEAPF32[$t2 >> 2] < +HEAPF32[$t4 >> 2] ? +HEAPF32[$t2 >> 2] : +HEAPF32[$t4 >> 2];
  $54 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$54;
 }
 return +(0.0);
}

function _silk_NLSF_decode($pNLSF_Q15, $NLSFIndices, $psNLSF_CB) {
 $pNLSF_Q15 = $pNLSF_Q15 | 0;
 $NLSFIndices = $NLSFIndices | 0;
 $psNLSF_CB = $psNLSF_CB | 0;
 var $NLSFIndices$addr = 0, $NLSF_Q15_tmp = 0, $cond35 = 0, $i = 0, $pCB_Wght_Q9 = 0, $pCB_element = 0, $pNLSF_Q15$addr = 0, $pred_Q8 = 0, $psNLSF_CB$addr = 0, $res_Q10 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $pNLSF_Q15$addr = sp + 24 | 0;
 $NLSFIndices$addr = sp + 20 | 0;
 $psNLSF_CB$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $pred_Q8 = sp + 96 | 0;
 $res_Q10 = sp + 32 | 0;
 $NLSF_Q15_tmp = sp + 8 | 0;
 $pCB_element = sp + 4 | 0;
 $pCB_Wght_Q9 = sp;
 HEAP32[$pNLSF_Q15$addr >> 2] = $pNLSF_Q15;
 HEAP32[$NLSFIndices$addr >> 2] = $NLSFIndices;
 HEAP32[$psNLSF_CB$addr >> 2] = $psNLSF_CB;
 _silk_NLSF_unpack(sp + 64 | 0, $pred_Q8, HEAP32[$psNLSF_CB$addr >> 2] | 0, HEAP8[HEAP32[$NLSFIndices$addr >> 2] >> 0] | 0);
 _silk_NLSF_residual_dequant($res_Q10, (HEAP32[$NLSFIndices$addr >> 2] | 0) + 1 | 0, $pred_Q8, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 4 >> 1] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0);
 HEAP32[$pCB_element >> 2] = (HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 8 >> 2] | 0) + (Math_imul(HEAP8[HEAP32[$NLSFIndices$addr >> 2] >> 0] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0) | 0);
 HEAP32[$pCB_Wght_Q9 >> 2] = (HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 12 >> 2] | 0) + ((Math_imul(HEAP8[HEAP32[$NLSFIndices$addr >> 2] >> 0] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0) | 0) << 1);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0)) break;
  HEAP32[$NLSF_Q15_tmp >> 2] = ((HEAP16[$res_Q10 + (HEAP32[$i >> 2] << 1) >> 1] << 14 | 0) / (HEAP16[(HEAP32[$pCB_Wght_Q9 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) + (HEAPU8[(HEAP32[$pCB_element >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] << 7);
  if ((HEAP32[$NLSF_Q15_tmp >> 2] | 0) > 32767) $cond35 = 32767; else $cond35 = (HEAP32[$NLSF_Q15_tmp >> 2] | 0) < 0 ? 0 : HEAP32[$NLSF_Q15_tmp >> 2] | 0;
  HEAP16[(HEAP32[$pNLSF_Q15$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $cond35;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _silk_NLSF_stabilize(HEAP32[$pNLSF_Q15$addr >> 2] | 0, HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 36 >> 2] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0);
 STACKTOP = sp;
 return;
}

function _silk_stereo_decode_pred($psRangeDec, $pred_Q13) {
 $psRangeDec = $psRangeDec | 0;
 $pred_Q13 = $pred_Q13 | 0;
 var $35 = 0, $add48 = 0, $arrayidx18 = 0, $call6 = 0, $call9 = 0, $ix = 0, $low_Q13 = 0, $n = 0, $pred_Q13$addr = 0, $psRangeDec$addr = 0, $step_Q13 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $psRangeDec$addr = sp + 40 | 0;
 $pred_Q13$addr = sp + 36 | 0;
 $n = sp + 32 | 0;
 $ix = sp + 8 | 0;
 $low_Q13 = sp + 4 | 0;
 $step_Q13 = sp;
 HEAP32[$psRangeDec$addr >> 2] = $psRangeDec;
 HEAP32[$pred_Q13$addr >> 2] = $pred_Q13;
 HEAP32[$n >> 2] = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32179, 8) | 0;
 HEAP32[$ix + 8 >> 2] = (HEAP32[$n >> 2] | 0) / 5 | 0;
 HEAP32[$ix + 12 + 8 >> 2] = (HEAP32[$n >> 2] | 0) - ((HEAP32[$ix + 8 >> 2] | 0) * 5 | 0);
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= 2) break;
  $call6 = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32232, 8) | 0;
  HEAP32[$ix + ((HEAP32[$n >> 2] | 0) * 12 | 0) >> 2] = $call6;
  $call9 = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32239, 8) | 0;
  HEAP32[$ix + ((HEAP32[$n >> 2] | 0) * 12 | 0) + 4 >> 2] = $call9;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= 2) break;
  $arrayidx18 = $ix + ((HEAP32[$n >> 2] | 0) * 12 | 0) | 0;
  HEAP32[$arrayidx18 >> 2] = (HEAP32[$arrayidx18 >> 2] | 0) + ((HEAP32[$ix + ((HEAP32[$n >> 2] | 0) * 12 | 0) + 8 >> 2] | 0) * 3 | 0);
  HEAP32[$low_Q13 >> 2] = HEAP16[22924 + (HEAP32[$ix + ((HEAP32[$n >> 2] | 0) * 12 | 0) >> 2] << 1) >> 1];
  HEAP32[$step_Q13 >> 2] = (((HEAP16[22924 + ((HEAP32[$ix + ((HEAP32[$n >> 2] | 0) * 12 | 0) >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP32[$low_Q13 >> 2] | 0) >> 16) * 6554 | 0) + (((HEAP16[22924 + ((HEAP32[$ix + ((HEAP32[$n >> 2] | 0) * 12 | 0) >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP32[$low_Q13 >> 2] | 0) & 65535) * 6554 >> 16);
  $add48 = (HEAP32[$low_Q13 >> 2] | 0) + (Math_imul((HEAP32[$step_Q13 >> 2] & 65535) << 16 >> 16, ((HEAP32[$ix + ((HEAP32[$n >> 2] | 0) * 12 | 0) + 4 >> 2] << 1) + 1 & 65535) << 16 >> 16) | 0) | 0;
  HEAP32[(HEAP32[$pred_Q13$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2] = $add48;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 $35 = HEAP32[$pred_Q13$addr >> 2] | 0;
 HEAP32[$35 >> 2] = (HEAP32[$35 >> 2] | 0) - (HEAP32[(HEAP32[$pred_Q13$addr >> 2] | 0) + 4 >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _compute_band_energies($m, $X, $bandE, $end, $C, $LM, $arch) {
 $m = $m | 0;
 $X = $X | 0;
 $bandE = $bandE | 0;
 $end = $end | 0;
 $C = $C | 0;
 $LM = $LM | 0;
 $arch = $arch | 0;
 var $C$addr = 0, $LM$addr = 0, $N = 0, $X$addr = 0, $arch$addr = 0, $bandE$addr = 0, $c = 0, $conv20 = 0.0, $eBands = 0, $end$addr = 0, $i = 0, $inc24 = 0, $m$addr = 0, $mul = 0, $mul5 = 0, $sum = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $m$addr = sp + 44 | 0;
 $X$addr = sp + 40 | 0;
 $bandE$addr = sp + 36 | 0;
 $end$addr = sp + 32 | 0;
 $C$addr = sp + 28 | 0;
 $LM$addr = sp + 24 | 0;
 $arch$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $c = sp + 12 | 0;
 $N = sp + 8 | 0;
 $eBands = sp + 4 | 0;
 $sum = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$bandE$addr >> 2] = $bandE;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$N >> 2] = HEAP32[(HEAP32[$m$addr >> 2] | 0) + 44 >> 2] << HEAP32[$LM$addr >> 2];
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   $mul = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
   $mul5 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$N >> 2] | 0) | 0;
   HEAPF32[$sum >> 2] = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0]((HEAP32[$X$addr >> 2] | 0) + ($mul + (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2]) << 2) | 0, (HEAP32[$X$addr >> 2] | 0) + ($mul5 + (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << HEAP32[$LM$addr >> 2]) << 2) | 0, (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) << HEAP32[$LM$addr >> 2]) + 1.0000000272452012e-27;
   $conv20 = +Math_sqrt(+(+HEAPF32[$sum >> 2]));
   HEAPF32[(HEAP32[$bandE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2] = $conv20;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc24 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc24;
 } while (($inc24 | 0) < (HEAP32[$C$addr >> 2] | 0));
 STACKTOP = sp;
 return;
}

function _silk_biquad_float($in, $B_Q28, $A_Q28, $S, $out, $len, $stride) {
 $in = $in | 0;
 $B_Q28 = $B_Q28 | 0;
 $A_Q28 = $A_Q28 | 0;
 $S = $S | 0;
 $out = $out | 0;
 $len = $len | 0;
 $stride = $stride | 0;
 var $A = 0, $A_Q28$addr = 0, $B = 0, $B_Q28$addr = 0, $S$addr = 0, $in$addr = 0, $inval = 0, $k = 0, $len$addr = 0, $out$addr = 0, $stride$addr = 0, $vout = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $in$addr = sp + 60 | 0;
 $B_Q28$addr = sp + 56 | 0;
 $A_Q28$addr = sp + 52 | 0;
 $S$addr = sp + 48 | 0;
 $out$addr = sp + 44 | 0;
 $len$addr = sp + 40 | 0;
 $stride$addr = sp + 36 | 0;
 $k = sp + 32 | 0;
 $vout = sp + 28 | 0;
 $inval = sp + 24 | 0;
 $A = sp + 16 | 0;
 $B = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$B_Q28$addr >> 2] = $B_Q28;
 HEAP32[$A_Q28$addr >> 2] = $A_Q28;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$stride$addr >> 2] = $stride;
 HEAPF32[$A >> 2] = +(HEAP32[HEAP32[$A_Q28$addr >> 2] >> 2] | 0) * 3.725290298461914e-09;
 HEAPF32[$A + 4 >> 2] = +(HEAP32[(HEAP32[$A_Q28$addr >> 2] | 0) + 4 >> 2] | 0) * 3.725290298461914e-09;
 HEAPF32[$B >> 2] = +(HEAP32[HEAP32[$B_Q28$addr >> 2] >> 2] | 0) * 3.725290298461914e-09;
 HEAPF32[$B + 4 >> 2] = +(HEAP32[(HEAP32[$B_Q28$addr >> 2] | 0) + 4 >> 2] | 0) * 3.725290298461914e-09;
 HEAPF32[$B + 8 >> 2] = +(HEAP32[(HEAP32[$B_Q28$addr >> 2] | 0) + 8 >> 2] | 0) * 3.725290298461914e-09;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  HEAPF32[$inval >> 2] = +HEAPF32[(HEAP32[$in$addr >> 2] | 0) + ((Math_imul(HEAP32[$k >> 2] | 0, HEAP32[$stride$addr >> 2] | 0) | 0) << 2) >> 2];
  HEAPF32[$vout >> 2] = +HEAPF32[HEAP32[$S$addr >> 2] >> 2] + +HEAPF32[$B >> 2] * +HEAPF32[$inval >> 2];
  HEAPF32[HEAP32[$S$addr >> 2] >> 2] = +HEAPF32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] - +HEAPF32[$vout >> 2] * +HEAPF32[$A >> 2] + +HEAPF32[$B + 4 >> 2] * +HEAPF32[$inval >> 2];
  HEAPF32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] = -+HEAPF32[$vout >> 2] * +HEAPF32[$A + 4 >> 2] + +HEAPF32[$B + 8 >> 2] * +HEAPF32[$inval >> 2] + 1.0000000031710769e-30;
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ((Math_imul(HEAP32[$k >> 2] | 0, HEAP32[$stride$addr >> 2] | 0) | 0) << 2) >> 2] = +HEAPF32[$vout >> 2];
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_encode_signs($psRangeEnc, $pulses, $length, $signalType, $quantOffsetType, $sum_pulses) {
 $psRangeEnc = $psRangeEnc | 0;
 $pulses = $pulses | 0;
 $length = $length | 0;
 $signalType = $signalType | 0;
 $quantOffsetType = $quantOffsetType | 0;
 $sum_pulses = $sum_pulses | 0;
 var $i = 0, $icdf = 0, $icdf_ptr = 0, $j = 0, $length$addr = 0, $p = 0, $psRangeEnc$addr = 0, $pulses$addr = 0, $q_ptr = 0, $quantOffsetType$addr = 0, $signalType$addr = 0, $sum_pulses$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $psRangeEnc$addr = sp + 40 | 0;
 $pulses$addr = sp + 36 | 0;
 $length$addr = sp + 32 | 0;
 $signalType$addr = sp + 28 | 0;
 $quantOffsetType$addr = sp + 24 | 0;
 $sum_pulses$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $j = sp + 12 | 0;
 $p = sp + 8 | 0;
 $icdf = sp + 44 | 0;
 $q_ptr = sp + 4 | 0;
 $icdf_ptr = sp;
 HEAP32[$psRangeEnc$addr >> 2] = $psRangeEnc;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$signalType$addr >> 2] = $signalType;
 HEAP32[$quantOffsetType$addr >> 2] = $quantOffsetType;
 HEAP32[$sum_pulses$addr >> 2] = $sum_pulses;
 HEAP8[$icdf + 1 >> 0] = 0;
 HEAP32[$q_ptr >> 2] = HEAP32[$pulses$addr >> 2];
 HEAP32[$i >> 2] = (((HEAP32[$quantOffsetType$addr >> 2] | 0) + (HEAP32[$signalType$addr >> 2] << 1) & 65535) << 16 >> 16) * 7;
 HEAP32[$icdf_ptr >> 2] = 33385 + (HEAP32[$i >> 2] | 0);
 HEAP32[$length$addr >> 2] = (HEAP32[$length$addr >> 2] | 0) + 8 >> 4;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$p >> 2] = HEAP32[(HEAP32[$sum_pulses$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  L4 : do if ((HEAP32[$p >> 2] | 0) > 0) {
   HEAP8[$icdf >> 0] = HEAP8[(HEAP32[$icdf_ptr >> 2] | 0) + ((HEAP32[$p >> 2] & 31 | 0) < 6 ? HEAP32[$p >> 2] & 31 : 6) >> 0] | 0;
   HEAP32[$j >> 2] = 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= 16) break L4;
    if (HEAP8[(HEAP32[$q_ptr >> 2] | 0) + (HEAP32[$j >> 2] | 0) >> 0] | 0) _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, (HEAP8[(HEAP32[$q_ptr >> 2] | 0) + (HEAP32[$j >> 2] | 0) >> 0] >> 15) + 1 | 0, $icdf, 8);
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
  } while (0);
  HEAP32[$q_ptr >> 2] = (HEAP32[$q_ptr >> 2] | 0) + 16;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}
function _normalise_bands($m, $freq, $X, $bandE, $end, $C, $M) {
 $m = $m | 0;
 $freq = $freq | 0;
 $X = $X | 0;
 $bandE = $bandE | 0;
 $end = $end | 0;
 $C = $C | 0;
 $M = $M | 0;
 var $26 = 0.0, $C$addr = 0, $M$addr = 0, $N = 0, $X$addr = 0, $bandE$addr = 0, $c = 0, $eBands = 0, $end$addr = 0, $freq$addr = 0, $g = 0, $i = 0, $inc24 = 0, $j = 0, $m$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $m$addr = sp + 48 | 0;
 $freq$addr = sp + 44 | 0;
 $X$addr = sp + 40 | 0;
 $bandE$addr = sp + 36 | 0;
 $end$addr = sp + 32 | 0;
 $C$addr = sp + 28 | 0;
 $M$addr = sp + 24 | 0;
 $i = sp + 20 | 0;
 $c = sp + 16 | 0;
 $N = sp + 12 | 0;
 $eBands = sp + 8 | 0;
 $j = sp + 4 | 0;
 $g = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$freq$addr >> 2] = $freq;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$bandE$addr >> 2] = $bandE;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$M$addr >> 2] = $M;
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$N >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 44 >> 2] | 0) | 0;
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   HEAPF32[$g >> 2] = 1.0 / (+HEAPF32[(HEAP32[$bandE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2] + 1.0000000272452012e-27);
   HEAP32[$j >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
   while (1) {
    if ((HEAP32[$j >> 2] | 0) >= (Math_imul(HEAP32[$M$addr >> 2] | 0, HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) | 0)) break;
    $26 = +HEAPF32[(HEAP32[$freq$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$N >> 2] | 0) | 0) << 2) >> 2];
    HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$N >> 2] | 0) | 0) << 2) >> 2] = $26 * +HEAPF32[$g >> 2];
    HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc24 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc24;
 } while (($inc24 | 0) < (HEAP32[$C$addr >> 2] | 0));
 STACKTOP = sp;
 return;
}

function _silk_LPC_analysis_filter12_FLP($r_LPC, $PredCoef, $s, $length) {
 $r_LPC = $r_LPC | 0;
 $PredCoef = $PredCoef | 0;
 $s = $s | 0;
 $length = $length | 0;
 var $LPC_pred = 0, $PredCoef$addr = 0, $ix = 0, $length$addr = 0, $r_LPC$addr = 0, $s$addr = 0, $s_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $r_LPC$addr = sp + 24 | 0;
 $PredCoef$addr = sp + 20 | 0;
 $s$addr = sp + 16 | 0;
 $length$addr = sp + 12 | 0;
 $ix = sp + 8 | 0;
 $LPC_pred = sp + 4 | 0;
 $s_ptr = sp;
 HEAP32[$r_LPC$addr >> 2] = $r_LPC;
 HEAP32[$PredCoef$addr >> 2] = $PredCoef;
 HEAP32[$s$addr >> 2] = $s;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$ix >> 2] = 12;
 while (1) {
  if ((HEAP32[$ix >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$s_ptr >> 2] = (HEAP32[$s$addr >> 2] | 0) + ((HEAP32[$ix >> 2] | 0) - 1 << 2);
  HEAPF32[$LPC_pred >> 2] = +HEAPF32[HEAP32[$s_ptr >> 2] >> 2] * +HEAPF32[HEAP32[$PredCoef$addr >> 2] >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -4 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -8 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 8 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -12 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 12 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -16 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 16 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -20 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 20 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -24 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 24 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -28 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 28 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -32 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 32 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -36 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 36 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -40 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 40 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -44 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 44 >> 2];
  HEAPF32[(HEAP32[$r_LPC$addr >> 2] | 0) + (HEAP32[$ix >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + 4 >> 2] - +HEAPF32[$LPC_pred >> 2];
  HEAP32[$ix >> 2] = (HEAP32[$ix >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _compute_redundancy_bytes($max_data_bytes, $bitrate_bps, $frame_rate, $channels) {
 $max_data_bytes = $max_data_bytes | 0;
 $bitrate_bps = $bitrate_bps | 0;
 $frame_rate = $frame_rate | 0;
 $channels = $channels | 0;
 var $19 = 0, $available_bits = 0, $base_bits = 0, $bitrate_bps$addr = 0, $channels$addr = 0, $frame_rate$addr = 0, $max_data_bytes$addr = 0, $redundancy_bytes = 0, $redundancy_bytes_cap = 0, $redundancy_rate = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $max_data_bytes$addr = sp + 32 | 0;
 $bitrate_bps$addr = sp + 28 | 0;
 $frame_rate$addr = sp + 24 | 0;
 $channels$addr = sp + 20 | 0;
 $redundancy_bytes_cap = sp + 16 | 0;
 $redundancy_bytes = sp + 12 | 0;
 $redundancy_rate = sp + 8 | 0;
 $base_bits = sp + 4 | 0;
 $available_bits = sp;
 HEAP32[$max_data_bytes$addr >> 2] = $max_data_bytes;
 HEAP32[$bitrate_bps$addr >> 2] = $bitrate_bps;
 HEAP32[$frame_rate$addr >> 2] = $frame_rate;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$base_bits >> 2] = ((HEAP32[$channels$addr >> 2] | 0) * 40 | 0) + 20;
 HEAP32[$redundancy_rate >> 2] = (HEAP32[$bitrate_bps$addr >> 2] | 0) + (Math_imul(HEAP32[$base_bits >> 2] | 0, 200 - (HEAP32[$frame_rate$addr >> 2] | 0) | 0) | 0);
 HEAP32[$redundancy_rate >> 2] = ((HEAP32[$redundancy_rate >> 2] | 0) * 3 | 0) / 2 | 0;
 HEAP32[$redundancy_bytes >> 2] = (HEAP32[$redundancy_rate >> 2] | 0) / 1600 | 0;
 HEAP32[$available_bits >> 2] = (HEAP32[$max_data_bytes$addr >> 2] << 3) - (HEAP32[$base_bits >> 2] << 1);
 HEAP32[$redundancy_bytes_cap >> 2] = ((((HEAP32[$available_bits >> 2] | 0) * 240 | 0) / (240 + (48e3 / (HEAP32[$frame_rate$addr >> 2] | 0) | 0) | 0) | 0) + (HEAP32[$base_bits >> 2] | 0) | 0) / 8 | 0;
 HEAP32[$redundancy_bytes >> 2] = (HEAP32[$redundancy_bytes >> 2] | 0) < (HEAP32[$redundancy_bytes_cap >> 2] | 0) ? HEAP32[$redundancy_bytes >> 2] | 0 : HEAP32[$redundancy_bytes_cap >> 2] | 0;
 if ((HEAP32[$redundancy_bytes >> 2] | 0) > (4 + (HEAP32[$channels$addr >> 2] << 3) | 0)) {
  HEAP32[$redundancy_bytes >> 2] = 257 < (HEAP32[$redundancy_bytes >> 2] | 0) ? 257 : HEAP32[$redundancy_bytes >> 2] | 0;
  $19 = HEAP32[$redundancy_bytes >> 2] | 0;
  STACKTOP = sp;
  return $19 | 0;
 } else {
  HEAP32[$redundancy_bytes >> 2] = 0;
  $19 = HEAP32[$redundancy_bytes >> 2] | 0;
  STACKTOP = sp;
  return $19 | 0;
 }
 return 0;
}

function _silk_resampler_down2($S, $out, $in, $inLen) {
 $S = $S | 0;
 $out = $out | 0;
 $in = $in | 0;
 $inLen = $inLen | 0;
 var $S$addr = 0, $X = 0, $Y = 0, $cond45 = 0, $in$addr = 0, $in32 = 0, $inLen$addr = 0, $k = 0, $len2 = 0, $mul3 = 0, $out$addr = 0, $out32 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $S$addr = sp + 36 | 0;
 $out$addr = sp + 32 | 0;
 $in$addr = sp + 28 | 0;
 $inLen$addr = sp + 24 | 0;
 $k = sp + 20 | 0;
 $len2 = sp + 16 | 0;
 $in32 = sp + 12 | 0;
 $out32 = sp + 8 | 0;
 $Y = sp + 4 | 0;
 $X = sp;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$inLen$addr >> 2] = $inLen;
 HEAP32[$len2 >> 2] = HEAP32[$inLen$addr >> 2] >> 1;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$len2 >> 2] | 0)) break;
  HEAP32[$in32 >> 2] = HEAP16[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1 << 1) >> 1] << 10;
  HEAP32[$Y >> 2] = (HEAP32[$in32 >> 2] | 0) - (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0);
  $mul3 = Math_imul(HEAP32[$Y >> 2] >> 16, -25727) | 0;
  HEAP32[$X >> 2] = (HEAP32[$Y >> 2] | 0) + ($mul3 + ((Math_imul(HEAP32[$Y >> 2] & 65535, -25727) | 0) >> 16));
  HEAP32[$out32 >> 2] = (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[HEAP32[$S$addr >> 2] >> 2] = (HEAP32[$in32 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[$in32 >> 2] = HEAP16[(HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 1 << 1) >> 1] << 10;
  HEAP32[$Y >> 2] = (HEAP32[$in32 >> 2] | 0) - (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0);
  HEAP32[$X >> 2] = ((HEAP32[$Y >> 2] >> 16) * 9872 | 0) + ((HEAP32[$Y >> 2] & 65535) * 9872 >> 16);
  HEAP32[$out32 >> 2] = (HEAP32[$out32 >> 2] | 0) + (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0);
  HEAP32[$out32 >> 2] = (HEAP32[$out32 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] = (HEAP32[$in32 >> 2] | 0) + (HEAP32[$X >> 2] | 0);
  if (((HEAP32[$out32 >> 2] >> 10) + 1 >> 1 | 0) > 32767) $cond45 = 32767; else if (((HEAP32[$out32 >> 2] >> 10) + 1 >> 1 | 0) < -32768) $cond45 = -32768; else $cond45 = (HEAP32[$out32 >> 2] >> 10) + 1 >> 1;
  HEAP16[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $cond45;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _celt_fir5($x, $num, $N) {
 $x = $x | 0;
 $num = $num | 0;
 $N = $N | 0;
 var $N$addr = 0, $i = 0, $mem0 = 0, $mem1 = 0, $mem2 = 0, $mem3 = 0, $mem4 = 0, $num$addr = 0, $num0 = 0, $num1 = 0, $num2 = 0, $num3 = 0, $num4 = 0, $sum = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $x$addr = sp + 56 | 0;
 $num$addr = sp + 52 | 0;
 $N$addr = sp + 48 | 0;
 $i = sp + 44 | 0;
 $num0 = sp + 40 | 0;
 $num1 = sp + 36 | 0;
 $num2 = sp + 32 | 0;
 $num3 = sp + 28 | 0;
 $num4 = sp + 24 | 0;
 $mem0 = sp + 20 | 0;
 $mem1 = sp + 16 | 0;
 $mem2 = sp + 12 | 0;
 $mem3 = sp + 8 | 0;
 $mem4 = sp + 4 | 0;
 $sum = sp;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$num$addr >> 2] = $num;
 HEAP32[$N$addr >> 2] = $N;
 HEAPF32[$num0 >> 2] = +HEAPF32[HEAP32[$num$addr >> 2] >> 2];
 HEAPF32[$num1 >> 2] = +HEAPF32[(HEAP32[$num$addr >> 2] | 0) + 4 >> 2];
 HEAPF32[$num2 >> 2] = +HEAPF32[(HEAP32[$num$addr >> 2] | 0) + 8 >> 2];
 HEAPF32[$num3 >> 2] = +HEAPF32[(HEAP32[$num$addr >> 2] | 0) + 12 >> 2];
 HEAPF32[$num4 >> 2] = +HEAPF32[(HEAP32[$num$addr >> 2] | 0) + 16 >> 2];
 HEAPF32[$mem0 >> 2] = 0.0;
 HEAPF32[$mem1 >> 2] = 0.0;
 HEAPF32[$mem2 >> 2] = 0.0;
 HEAPF32[$mem3 >> 2] = 0.0;
 HEAPF32[$mem4 >> 2] = 0.0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAPF32[$sum >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +HEAPF32[$num0 >> 2] * +HEAPF32[$mem0 >> 2];
  HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +HEAPF32[$num1 >> 2] * +HEAPF32[$mem1 >> 2];
  HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +HEAPF32[$num2 >> 2] * +HEAPF32[$mem2 >> 2];
  HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +HEAPF32[$num3 >> 2] * +HEAPF32[$mem3 >> 2];
  HEAPF32[$sum >> 2] = +HEAPF32[$sum >> 2] + +HEAPF32[$num4 >> 2] * +HEAPF32[$mem4 >> 2];
  HEAPF32[$mem4 >> 2] = +HEAPF32[$mem3 >> 2];
  HEAPF32[$mem3 >> 2] = +HEAPF32[$mem2 >> 2];
  HEAPF32[$mem2 >> 2] = +HEAPF32[$mem1 >> 2];
  HEAPF32[$mem1 >> 2] = +HEAPF32[$mem0 >> 2];
  HEAPF32[$mem0 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$sum >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _opus_custom_encoder_init_arch($st, $mode, $channels, $arch) {
 $st = $st | 0;
 $mode = $mode | 0;
 $channels = $channels | 0;
 $arch = $arch | 0;
 var $29 = 0, $4 = 0, $9 = 0, $arch$addr = 0, $channels$addr = 0, $mode$addr = 0, $retval = 0, $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $st$addr = sp + 16 | 0;
 $mode$addr = sp + 12 | 0;
 $channels$addr = sp + 8 | 0;
 $arch$addr = sp + 4 | 0;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$arch$addr >> 2] = $arch;
 if ((HEAP32[$channels$addr >> 2] | 0) < 0 | (HEAP32[$channels$addr >> 2] | 0) > 2) {
  HEAP32[$retval >> 2] = -1;
  $29 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $29 | 0;
 }
 if ((HEAP32[$st$addr >> 2] | 0) == 0 | (HEAP32[$mode$addr >> 2] | 0) == 0) {
  HEAP32[$retval >> 2] = -7;
  $29 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $29 | 0;
 } else {
  $4 = HEAP32[$st$addr >> 2] | 0;
  _memset($4 | 0, 0, _opus_custom_encoder_get_size(HEAP32[$mode$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) | 0;
  HEAP32[HEAP32[$st$addr >> 2] >> 2] = HEAP32[$mode$addr >> 2];
  $9 = HEAP32[$channels$addr >> 2] | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] = $9;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] = $9;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] = 1;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 32 >> 2] = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] = HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 12 >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 48 >> 2] = 1;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 72 >> 2] = HEAP32[$arch$addr >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 52 >> 2] = 1;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] = 1;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 40 >> 2] = -1;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] = 5;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 60 >> 2] = 24;
  _opus_custom_encoder_ctl(HEAP32[$st$addr >> 2] | 0, 4028, sp) | 0;
  HEAP32[$retval >> 2] = 0;
  $29 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $29 | 0;
 }
 return 0;
}

function _celt_pitch_xcorr_c($_x, $_y, $xcorr, $len, $max_pitch, $arch) {
 $_x = $_x | 0;
 $_y = $_y | 0;
 $xcorr = $xcorr | 0;
 $len = $len | 0;
 $max_pitch = $max_pitch | 0;
 $arch = $arch | 0;
 var $_x$addr = 0, $_y$addr = 0, $arch$addr = 0, $i = 0, $len$addr = 0, $max_pitch$addr = 0, $sum = 0, $sum15 = 0, $xcorr$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $_x$addr = sp + 48 | 0;
 $_y$addr = sp + 44 | 0;
 $xcorr$addr = sp + 40 | 0;
 $len$addr = sp + 36 | 0;
 $max_pitch$addr = sp + 32 | 0;
 $arch$addr = sp + 28 | 0;
 $i = sp + 24 | 0;
 $sum = sp + 8 | 0;
 $sum15 = sp;
 HEAP32[$_x$addr >> 2] = $_x;
 HEAP32[$_y$addr >> 2] = $_y;
 HEAP32[$xcorr$addr >> 2] = $xcorr;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$max_pitch$addr >> 2] = $max_pitch;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$max_pitch$addr >> 2] | 0) - 3 | 0)) break;
  HEAP32[$sum >> 2] = 0;
  HEAP32[$sum + 4 >> 2] = 0;
  HEAP32[$sum + 8 >> 2] = 0;
  HEAP32[$sum + 12 >> 2] = 0;
  FUNCTION_TABLE_viiii[HEAP32[_XCORR_KERNEL_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$_x$addr >> 2] | 0, (HEAP32[$_y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0, $sum, HEAP32[$len$addr >> 2] | 0);
  HEAPF32[(HEAP32[$xcorr$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$sum >> 2];
  HEAPF32[(HEAP32[$xcorr$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] = +HEAPF32[$sum + 4 >> 2];
  HEAPF32[(HEAP32[$xcorr$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2] = +HEAPF32[$sum + 8 >> 2];
  HEAPF32[(HEAP32[$xcorr$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2] = +HEAPF32[$sum + 12 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$max_pitch$addr >> 2] | 0)) break;
  HEAPF32[$sum15 >> 2] = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$_x$addr >> 2] | 0, (HEAP32[$_y$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0, HEAP32[$len$addr >> 2] | 0);
  HEAPF32[(HEAP32[$xcorr$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$sum15 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _log10($x) {
 $x = +$x;
 var $0 = 0, $1 = 0, $13 = 0, $15 = 0, $16 = 0.0, $17 = 0, $2 = 0, $8 = 0, $add = 0, $add72 = 0.0, $add82 = 0.0, $conv74 = 0.0, $div47 = 0.0, $hx$0 = 0, $k$0 = 0, $mul45 = 0.0, $mul48 = 0.0, $mul49 = 0.0, $mul73 = 0.0, $mul75 = 0.0, $retval$0 = 0.0, $sub43 = 0.0, label = 0;
 HEAPF64[tempDoublePtr >> 3] = $x;
 $0 = HEAP32[tempDoublePtr >> 2] | 0;
 $1 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $2 = ($1 | 0) < 0;
 do if ($2 | $1 >>> 0 < 1048576) {
  if (($0 | 0) == 0 & ($1 & 2147483647 | 0) == 0) {
   $retval$0 = -1.0 / ($x * $x);
   break;
  }
  if ($2) {
   $retval$0 = ($x - $x) / 0.0;
   break;
  } else {
   HEAPF64[tempDoublePtr >> 3] = $x * 18014398509481984.0;
   $8 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
   $13 = HEAP32[tempDoublePtr >> 2] | 0;
   $17 = $8;
   $hx$0 = $8;
   $k$0 = -1077;
   label = 9;
   break;
  }
 } else if ($1 >>> 0 > 2146435071) $retval$0 = $x; else if (($0 | 0) == 0 & 0 == 0 & ($1 | 0) == 1072693248) $retval$0 = 0.0; else {
  $13 = $0;
  $17 = $1;
  $hx$0 = $1;
  $k$0 = -1023;
  label = 9;
 } while (0);
 if ((label | 0) == 9) {
  $add = $hx$0 + 614242 | 0;
  HEAP32[tempDoublePtr >> 2] = $13;
  HEAP32[tempDoublePtr + 4 >> 2] = ($add & 1048575) + 1072079006;
  $sub43 = +HEAPF64[tempDoublePtr >> 3] + -1.0;
  $mul45 = $sub43 * ($sub43 * .5);
  $div47 = $sub43 / ($sub43 + 2.0);
  $mul48 = $div47 * $div47;
  $mul49 = $mul48 * $mul48;
  HEAPF64[tempDoublePtr >> 3] = $sub43 - $mul45;
  $15 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  HEAP32[tempDoublePtr >> 2] = 0;
  HEAP32[tempDoublePtr + 4 >> 2] = $15;
  $16 = +HEAPF64[tempDoublePtr >> 3];
  $add72 = $sub43 - $16 - $mul45 + $div47 * ($mul45 + ($mul49 * ($mul49 * ($mul49 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $mul48 * ($mul49 * ($mul49 * ($mul49 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735)));
  $mul73 = $16 * .4342944818781689;
  $conv74 = +($k$0 + ($add >>> 20) | 0);
  $mul75 = $conv74 * .30102999566361177;
  $add82 = $mul75 + $mul73;
  $retval$0 = $add82 + ($mul73 + ($mul75 - $add82) + ($add72 * .4342944818781689 + ($conv74 * 3.694239077158931e-13 + ($add72 + $16) * 2.5082946711645275e-11)));
 }
 return +$retval$0;
}

function _smooth_fade($in1, $in2, $out, $overlap, $channels, $window, $Fs) {
 $in1 = $in1 | 0;
 $in2 = $in2 | 0;
 $out = $out | 0;
 $overlap = $overlap | 0;
 $channels = $channels | 0;
 $window = $window | 0;
 $Fs = $Fs | 0;
 var $8 = 0.0, $Fs$addr = 0, $c = 0, $channels$addr = 0, $i = 0, $in1$addr = 0, $in2$addr = 0, $inc = 0, $mul10 = 0, $mul15 = 0, $mul7 = 0, $out$addr = 0, $overlap$addr = 0, $w = 0, $window$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $in1$addr = sp + 40 | 0;
 $in2$addr = sp + 36 | 0;
 $out$addr = sp + 32 | 0;
 $overlap$addr = sp + 28 | 0;
 $channels$addr = sp + 24 | 0;
 $window$addr = sp + 20 | 0;
 $Fs$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $c = sp + 8 | 0;
 $inc = sp + 4 | 0;
 $w = sp;
 HEAP32[$in1$addr >> 2] = $in1;
 HEAP32[$in2$addr >> 2] = $in2;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$overlap$addr >> 2] = $overlap;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$window$addr >> 2] = $window;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$inc >> 2] = 48e3 / (HEAP32[$Fs$addr >> 2] | 0) | 0;
 HEAP32[$c >> 2] = 0;
 while (1) {
  if ((HEAP32[$c >> 2] | 0) >= (HEAP32[$channels$addr >> 2] | 0)) break;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$overlap$addr >> 2] | 0)) break;
   $8 = +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$inc >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[$w >> 2] = $8 * +HEAPF32[(HEAP32[$window$addr >> 2] | 0) + ((Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$inc >> 2] | 0) | 0) << 2) >> 2];
   $mul7 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
   $mul10 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
   $mul15 = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$out$addr >> 2] | 0) + ($mul15 + (HEAP32[$c >> 2] | 0) << 2) >> 2] = +HEAPF32[$w >> 2] * +HEAPF32[(HEAP32[$in2$addr >> 2] | 0) + ($mul7 + (HEAP32[$c >> 2] | 0) << 2) >> 2] + (1.0 - +HEAPF32[$w >> 2]) * +HEAPF32[(HEAP32[$in1$addr >> 2] | 0) + ($mul10 + (HEAP32[$c >> 2] | 0) << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$c >> 2] = (HEAP32[$c >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_apply_sine_window_FLP($px_win, $px, $win_type, $length) {
 $px_win = $px_win | 0;
 $px = $px | 0;
 $win_type = $win_type | 0;
 $length = $length | 0;
 var $S0 = 0, $S1 = 0, $c = 0, $freq = 0, $k = 0, $length$addr = 0, $px$addr = 0, $px_win$addr = 0, $win_type$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $px_win$addr = sp + 32 | 0;
 $px$addr = sp + 28 | 0;
 $win_type$addr = sp + 24 | 0;
 $length$addr = sp + 20 | 0;
 $k = sp + 16 | 0;
 $freq = sp + 12 | 0;
 $c = sp + 8 | 0;
 $S0 = sp + 4 | 0;
 $S1 = sp;
 HEAP32[$px_win$addr >> 2] = $px_win;
 HEAP32[$px$addr >> 2] = $px;
 HEAP32[$win_type$addr >> 2] = $win_type;
 HEAP32[$length$addr >> 2] = $length;
 HEAPF32[$freq >> 2] = 3.1415927410125732 / +((HEAP32[$length$addr >> 2] | 0) + 1 | 0);
 HEAPF32[$c >> 2] = 2.0 - +HEAPF32[$freq >> 2] * +HEAPF32[$freq >> 2];
 if ((HEAP32[$win_type$addr >> 2] | 0) < 2) {
  HEAPF32[$S0 >> 2] = 0.0;
  HEAPF32[$S1 >> 2] = +HEAPF32[$freq >> 2];
 } else {
  HEAPF32[$S0 >> 2] = 1.0;
  HEAPF32[$S1 >> 2] = +HEAPF32[$c >> 2] * .5;
 }
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAPF32[(HEAP32[$px_win$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 0 << 2) >> 2] = +HEAPF32[(HEAP32[$px$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 0 << 2) >> 2] * .5 * (+HEAPF32[$S0 >> 2] + +HEAPF32[$S1 >> 2]);
  HEAPF32[(HEAP32[$px_win$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 1 << 2) >> 2] = +HEAPF32[(HEAP32[$px$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 1 << 2) >> 2] * +HEAPF32[$S1 >> 2];
  HEAPF32[$S0 >> 2] = +HEAPF32[$c >> 2] * +HEAPF32[$S1 >> 2] - +HEAPF32[$S0 >> 2];
  HEAPF32[(HEAP32[$px_win$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 2 << 2) >> 2] = +HEAPF32[(HEAP32[$px$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 2 << 2) >> 2] * .5 * (+HEAPF32[$S1 >> 2] + +HEAPF32[$S0 >> 2]);
  HEAPF32[(HEAP32[$px_win$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 3 << 2) >> 2] = +HEAPF32[(HEAP32[$px$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) + 3 << 2) >> 2] * +HEAPF32[$S0 >> 2];
  HEAPF32[$S1 >> 2] = +HEAPF32[$c >> 2] * +HEAPF32[$S0 >> 2] - +HEAPF32[$S1 >> 2];
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 4;
 }
 STACKTOP = sp;
 return;
}

function _silk_bwexpander_32($ar, $d, $chirp_Q16) {
 $ar = $ar | 0;
 $d = $d | 0;
 $chirp_Q16 = $chirp_Q16 | 0;
 var $4 = 0, $add = 0, $add13 = 0, $add33 = 0, $add40 = 0, $ar$addr = 0, $chirp_Q16$addr = 0, $chirp_minus_one_Q16 = 0, $d$addr = 0, $i = 0, $mul = 0, $mul25 = 0, $shr = 0, $shr18 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $ar$addr = sp + 16 | 0;
 $d$addr = sp + 12 | 0;
 $chirp_Q16$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $chirp_minus_one_Q16 = sp;
 HEAP32[$ar$addr >> 2] = $ar;
 HEAP32[$d$addr >> 2] = $d;
 HEAP32[$chirp_Q16$addr >> 2] = $chirp_Q16;
 HEAP32[$chirp_minus_one_Q16 >> 2] = (HEAP32[$chirp_Q16$addr >> 2] | 0) - 65536;
 HEAP32[$i >> 2] = 0;
 while (1) {
  $shr = HEAP32[$chirp_Q16$addr >> 2] >> 16;
  $4 = HEAP32[$ar$addr >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$d$addr >> 2] | 0) - 1 | 0)) break;
  $mul = Math_imul($shr, (HEAP32[$4 + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0;
  $add = $mul + ((Math_imul(HEAP32[$chirp_Q16$addr >> 2] & 65535, (HEAP32[(HEAP32[$ar$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
  $add13 = $add + (Math_imul(HEAP32[$chirp_Q16$addr >> 2] | 0, (HEAP32[(HEAP32[$ar$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
  HEAP32[(HEAP32[$ar$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $add13;
  $shr18 = ((Math_imul(HEAP32[$chirp_Q16$addr >> 2] | 0, HEAP32[$chirp_minus_one_Q16 >> 2] | 0) | 0) >> 15) + 1 >> 1;
  HEAP32[$chirp_Q16$addr >> 2] = (HEAP32[$chirp_Q16$addr >> 2] | 0) + $shr18;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 $mul25 = Math_imul($shr, (HEAP32[$4 + ((HEAP32[$d$addr >> 2] | 0) - 1 << 2) >> 2] & 65535) << 16 >> 16) | 0;
 $add33 = $mul25 + ((Math_imul(HEAP32[$chirp_Q16$addr >> 2] & 65535, (HEAP32[(HEAP32[$ar$addr >> 2] | 0) + ((HEAP32[$d$addr >> 2] | 0) - 1 << 2) >> 2] & 65535) << 16 >> 16) | 0) >> 16) | 0;
 $add40 = $add33 + (Math_imul(HEAP32[$chirp_Q16$addr >> 2] | 0, (HEAP32[(HEAP32[$ar$addr >> 2] | 0) + ((HEAP32[$d$addr >> 2] | 0) - 1 << 2) >> 2] >> 15) + 1 >> 1) | 0) | 0;
 HEAP32[(HEAP32[$ar$addr >> 2] | 0) + ((HEAP32[$d$addr >> 2] | 0) - 1 << 2) >> 2] = $add40;
 STACKTOP = sp;
 return;
}

function _silk_A2NLSF_init($a_Q16, $P, $Q, $dd) {
 $a_Q16 = $a_Q16 | 0;
 $P = $P | 0;
 $Q = $Q | 0;
 $dd = $dd | 0;
 var $29 = 0, $P$addr = 0, $Q$addr = 0, $a_Q16$addr = 0, $arrayidx21 = 0, $arrayidx25 = 0, $dd$addr = 0, $k = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $a_Q16$addr = sp + 16 | 0;
 $P$addr = sp + 12 | 0;
 $Q$addr = sp + 8 | 0;
 $dd$addr = sp + 4 | 0;
 $k = sp;
 HEAP32[$a_Q16$addr >> 2] = $a_Q16;
 HEAP32[$P$addr >> 2] = $P;
 HEAP32[$Q$addr >> 2] = $Q;
 HEAP32[$dd$addr >> 2] = $dd;
 HEAP32[(HEAP32[$P$addr >> 2] | 0) + (HEAP32[$dd$addr >> 2] << 2) >> 2] = 65536;
 HEAP32[(HEAP32[$Q$addr >> 2] | 0) + (HEAP32[$dd$addr >> 2] << 2) >> 2] = 65536;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$dd$addr >> 2] | 0)) break;
  HEAP32[(HEAP32[$P$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = 0 - (HEAP32[(HEAP32[$a_Q16$addr >> 2] | 0) + ((HEAP32[$dd$addr >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1 << 2) >> 2] | 0) - (HEAP32[(HEAP32[$a_Q16$addr >> 2] | 0) + ((HEAP32[$dd$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) << 2) >> 2] | 0);
  HEAP32[(HEAP32[$Q$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = 0 - (HEAP32[(HEAP32[$a_Q16$addr >> 2] | 0) + ((HEAP32[$dd$addr >> 2] | 0) - (HEAP32[$k >> 2] | 0) - 1 << 2) >> 2] | 0) + (HEAP32[(HEAP32[$a_Q16$addr >> 2] | 0) + ((HEAP32[$dd$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) << 2) >> 2] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 HEAP32[$k >> 2] = HEAP32[$dd$addr >> 2];
 while (1) {
  $29 = HEAP32[$P$addr >> 2] | 0;
  if ((HEAP32[$k >> 2] | 0) <= 0) break;
  $arrayidx21 = (HEAP32[$P$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - 1 << 2) | 0;
  HEAP32[$arrayidx21 >> 2] = (HEAP32[$arrayidx21 >> 2] | 0) - (HEAP32[$29 + (HEAP32[$k >> 2] << 2) >> 2] | 0);
  $arrayidx25 = (HEAP32[$Q$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - 1 << 2) | 0;
  HEAP32[$arrayidx25 >> 2] = (HEAP32[$arrayidx25 >> 2] | 0) + (HEAP32[(HEAP32[$Q$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + -1;
 }
 _silk_A2NLSF_trans_poly($29, HEAP32[$dd$addr >> 2] | 0);
 _silk_A2NLSF_trans_poly(HEAP32[$Q$addr >> 2] | 0, HEAP32[$dd$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_schur_FLP($refl_coef, $auto_corr, $order) {
 $refl_coef = $refl_coef | 0;
 $auto_corr = $auto_corr | 0;
 $order = $order | 0;
 var $C = 0, $Ctmp1 = 0, $Ctmp2 = 0, $auto_corr$addr = 0, $conv = 0.0, $inc = 0, $k = 0, $n = 0, $order$addr = 0, $rc_tmp = 0, $refl_coef$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 448 | 0;
 $refl_coef$addr = sp + 440 | 0;
 $auto_corr$addr = sp + 436 | 0;
 $order$addr = sp + 432 | 0;
 $k = sp + 428 | 0;
 $n = sp + 424 | 0;
 $C = sp + 24 | 0;
 $Ctmp1 = sp + 16 | 0;
 $Ctmp2 = sp + 8 | 0;
 $rc_tmp = sp;
 HEAP32[$refl_coef$addr >> 2] = $refl_coef;
 HEAP32[$auto_corr$addr >> 2] = $auto_corr;
 HEAP32[$order$addr >> 2] = $order;
 HEAP32[$k >> 2] = 0;
 do {
  $conv = +HEAPF32[(HEAP32[$auto_corr$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2];
  HEAPF64[$C + (HEAP32[$k >> 2] << 4) + 8 >> 3] = $conv;
  HEAPF64[$C + (HEAP32[$k >> 2] << 4) >> 3] = $conv;
  $inc = (HEAP32[$k >> 2] | 0) + 1 | 0;
  HEAP32[$k >> 2] = $inc;
 } while (($inc | 0) <= (HEAP32[$order$addr >> 2] | 0));
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
  HEAPF64[$rc_tmp >> 3] = -+HEAPF64[$C + ((HEAP32[$k >> 2] | 0) + 1 << 4) >> 3] / (+HEAPF64[$C + 8 >> 3] > 9.999999717180685e-10 ? +HEAPF64[$C + 8 >> 3] : 9.999999717180685e-10);
  HEAPF32[(HEAP32[$refl_coef$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = +HEAPF64[$rc_tmp >> 3];
  HEAP32[$n >> 2] = 0;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= ((HEAP32[$order$addr >> 2] | 0) - (HEAP32[$k >> 2] | 0) | 0)) break;
   HEAPF64[$Ctmp1 >> 3] = +HEAPF64[$C + ((HEAP32[$n >> 2] | 0) + (HEAP32[$k >> 2] | 0) + 1 << 4) >> 3];
   HEAPF64[$Ctmp2 >> 3] = +HEAPF64[$C + (HEAP32[$n >> 2] << 4) + 8 >> 3];
   HEAPF64[$C + ((HEAP32[$n >> 2] | 0) + (HEAP32[$k >> 2] | 0) + 1 << 4) >> 3] = +HEAPF64[$Ctmp1 >> 3] + +HEAPF64[$Ctmp2 >> 3] * +HEAPF64[$rc_tmp >> 3];
   HEAPF64[$C + (HEAP32[$n >> 2] << 4) + 8 >> 3] = +HEAPF64[$Ctmp2 >> 3] + +HEAPF64[$Ctmp1 >> 3] * +HEAPF64[$rc_tmp >> 3];
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return +(+HEAPF64[$C + 8 >> 3]);
}

function _silk_NLSF_unpack($ec_ix, $pred_Q8, $psNLSF_CB, $CB1_index) {
 $ec_ix = $ec_ix | 0;
 $pred_Q8 = $pred_Q8 | 0;
 $psNLSF_CB = $psNLSF_CB | 0;
 $CB1_index = $CB1_index | 0;
 var $19 = 0, $31 = 0, $8 = 0, $CB1_index$addr = 0, $ec_ix$addr = 0, $ec_sel_ptr = 0, $entry1 = 0, $i = 0, $pred_Q8$addr = 0, $psNLSF_CB$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $ec_ix$addr = sp + 20 | 0;
 $pred_Q8$addr = sp + 16 | 0;
 $psNLSF_CB$addr = sp + 12 | 0;
 $CB1_index$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $entry1 = sp + 24 | 0;
 $ec_sel_ptr = sp;
 HEAP32[$ec_ix$addr >> 2] = $ec_ix;
 HEAP32[$pred_Q8$addr >> 2] = $pred_Q8;
 HEAP32[$psNLSF_CB$addr >> 2] = $psNLSF_CB;
 HEAP32[$CB1_index$addr >> 2] = $CB1_index;
 HEAP32[$ec_sel_ptr >> 2] = (HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 24 >> 2] | 0) + ((Math_imul(HEAP32[$CB1_index$addr >> 2] | 0, HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0) | 0) / 2 | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0)) break;
  $8 = HEAP32[$ec_sel_ptr >> 2] | 0;
  HEAP32[$ec_sel_ptr >> 2] = $8 + 1;
  HEAP8[$entry1 >> 0] = HEAP8[$8 >> 0] | 0;
  HEAP16[(HEAP32[$ec_ix$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = ((HEAPU8[$entry1 >> 0] >> 1 & 7) << 16 >> 16) * 9;
  $19 = HEAP8[(HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 20 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAPU8[$entry1 >> 0] & 1, (HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0) - 1 | 0) | 0)) >> 0] | 0;
  HEAP8[(HEAP32[$pred_Q8$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] = $19;
  HEAP16[(HEAP32[$ec_ix$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] = ((HEAPU8[$entry1 >> 0] >> 5 & 7) << 16 >> 16) * 9;
  $31 = HEAP8[(HEAP32[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 20 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAPU8[$entry1 >> 0] >> 4 & 1, (HEAP16[(HEAP32[$psNLSF_CB$addr >> 2] | 0) + 2 >> 1] | 0) - 1 | 0) | 0) + 1) >> 0] | 0;
  HEAP8[(HEAP32[$pred_Q8$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1) >> 0] = $31;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 2;
 }
 STACKTOP = sp;
 return;
}

function _bits2pulses($m, $band, $LM, $bits) {
 $m = $m | 0;
 $band = $band | 0;
 $LM = $LM | 0;
 $bits = $bits | 0;
 var $20 = 0, $33 = 0, $LM$addr = 0, $band$addr = 0, $bits$addr = 0, $cache = 0, $cond = 0, $hi = 0, $i = 0, $lo = 0, $m$addr = 0, $mid = 0, $mul = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 36 | 0;
 $m$addr = sp + 32 | 0;
 $band$addr = sp + 28 | 0;
 $LM$addr = sp + 24 | 0;
 $bits$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $lo = sp + 12 | 0;
 $hi = sp + 8 | 0;
 $cache = sp + 4 | 0;
 $mid = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$band$addr >> 2] = $band;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$bits$addr >> 2] = $bits;
 HEAP32[$LM$addr >> 2] = (HEAP32[$LM$addr >> 2] | 0) + 1;
 $mul = Math_imul(HEAP32[$LM$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
 HEAP32[$cache >> 2] = (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 92 + 8 >> 2] | 0) + (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 92 + 4 >> 2] | 0) + ($mul + (HEAP32[$band$addr >> 2] | 0) << 1) >> 1] | 0);
 HEAP32[$lo >> 2] = 0;
 HEAP32[$hi >> 2] = HEAPU8[HEAP32[$cache >> 2] >> 0];
 HEAP32[$bits$addr >> 2] = (HEAP32[$bits$addr >> 2] | 0) + -1;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 6) break;
  HEAP32[$mid >> 2] = (HEAP32[$lo >> 2] | 0) + (HEAP32[$hi >> 2] | 0) + 1 >> 1;
  $20 = HEAP32[$mid >> 2] | 0;
  if ((HEAPU8[(HEAP32[$cache >> 2] | 0) + (HEAP32[$mid >> 2] | 0) >> 0] | 0) >= (HEAP32[$bits$addr >> 2] | 0)) HEAP32[$hi >> 2] = $20; else HEAP32[$lo >> 2] = $20;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if (!(HEAP32[$lo >> 2] | 0)) $cond = -1; else $cond = HEAPU8[(HEAP32[$cache >> 2] | 0) + (HEAP32[$lo >> 2] | 0) >> 0] | 0;
 if (((HEAP32[$bits$addr >> 2] | 0) - $cond | 0) <= ((HEAPU8[(HEAP32[$cache >> 2] | 0) + (HEAP32[$hi >> 2] | 0) >> 0] | 0) - (HEAP32[$bits$addr >> 2] | 0) | 0)) {
  HEAP32[$retval >> 2] = HEAP32[$lo >> 2];
  $33 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $33 | 0;
 } else {
  HEAP32[$retval >> 2] = HEAP32[$hi >> 2];
  $33 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $33 | 0;
 }
 return 0;
}

function _silk_LPC_analysis_filter10_FLP($r_LPC, $PredCoef, $s, $length) {
 $r_LPC = $r_LPC | 0;
 $PredCoef = $PredCoef | 0;
 $s = $s | 0;
 $length = $length | 0;
 var $LPC_pred = 0, $PredCoef$addr = 0, $ix = 0, $length$addr = 0, $r_LPC$addr = 0, $s$addr = 0, $s_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $r_LPC$addr = sp + 24 | 0;
 $PredCoef$addr = sp + 20 | 0;
 $s$addr = sp + 16 | 0;
 $length$addr = sp + 12 | 0;
 $ix = sp + 8 | 0;
 $LPC_pred = sp + 4 | 0;
 $s_ptr = sp;
 HEAP32[$r_LPC$addr >> 2] = $r_LPC;
 HEAP32[$PredCoef$addr >> 2] = $PredCoef;
 HEAP32[$s$addr >> 2] = $s;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$ix >> 2] = 10;
 while (1) {
  if ((HEAP32[$ix >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$s_ptr >> 2] = (HEAP32[$s$addr >> 2] | 0) + ((HEAP32[$ix >> 2] | 0) - 1 << 2);
  HEAPF32[$LPC_pred >> 2] = +HEAPF32[HEAP32[$s_ptr >> 2] >> 2] * +HEAPF32[HEAP32[$PredCoef$addr >> 2] >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -4 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -8 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 8 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -12 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 12 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -16 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 16 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -20 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 20 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -24 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 24 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -28 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 28 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -32 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 32 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -36 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 36 >> 2];
  HEAPF32[(HEAP32[$r_LPC$addr >> 2] | 0) + (HEAP32[$ix >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + 4 >> 2] - +HEAPF32[$LPC_pred >> 2];
  HEAP32[$ix >> 2] = (HEAP32[$ix >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _quant_band_n1($ctx, $X, $Y, $b, $lowband_out) {
 $ctx = $ctx | 0;
 $X = $X | 0;
 $Y = $Y | 0;
 $b = $b | 0;
 $lowband_out = $lowband_out | 0;
 var $X$addr = 0, $Y$addr = 0, $b$addr = 0, $c = 0, $ctx$addr = 0, $ec = 0, $encode = 0, $inc = 0, $lowband_out$addr = 0, $remaining_bits8 = 0, $sign = 0, $stereo = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $ctx$addr = sp + 40 | 0;
 $X$addr = sp + 36 | 0;
 $Y$addr = sp + 32 | 0;
 $b$addr = sp + 28 | 0;
 $lowband_out$addr = sp + 24 | 0;
 $c = sp + 20 | 0;
 $stereo = sp + 16 | 0;
 $x = sp + 12 | 0;
 $encode = sp + 8 | 0;
 $ec = sp + 4 | 0;
 $sign = sp;
 HEAP32[$ctx$addr >> 2] = $ctx;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$Y$addr >> 2] = $Y;
 HEAP32[$b$addr >> 2] = $b;
 HEAP32[$lowband_out$addr >> 2] = $lowband_out;
 HEAP32[$x >> 2] = HEAP32[$X$addr >> 2];
 HEAP32[$encode >> 2] = HEAP32[HEAP32[$ctx$addr >> 2] >> 2];
 HEAP32[$ec >> 2] = HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 28 >> 2];
 HEAP32[$stereo >> 2] = (HEAP32[$Y$addr >> 2] | 0) != 0 & 1;
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$sign >> 2] = 0;
  if ((HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 32 >> 2] | 0) >= 8) {
   if (HEAP32[$encode >> 2] | 0) {
    HEAP32[$sign >> 2] = +HEAPF32[HEAP32[$x >> 2] >> 2] < 0.0 & 1;
    _ec_enc_bits(HEAP32[$ec >> 2] | 0, HEAP32[$sign >> 2] | 0, 1);
   } else HEAP32[$sign >> 2] = _ec_dec_bits(HEAP32[$ec >> 2] | 0, 1) | 0;
   $remaining_bits8 = (HEAP32[$ctx$addr >> 2] | 0) + 32 | 0;
   HEAP32[$remaining_bits8 >> 2] = (HEAP32[$remaining_bits8 >> 2] | 0) - 8;
   HEAP32[$b$addr >> 2] = (HEAP32[$b$addr >> 2] | 0) - 8;
  }
  if (HEAP32[(HEAP32[$ctx$addr >> 2] | 0) + 4 >> 2] | 0) HEAPF32[HEAP32[$x >> 2] >> 2] = HEAP32[$sign >> 2] | 0 ? -1.0 : 1.0;
  HEAP32[$x >> 2] = HEAP32[$Y$addr >> 2];
  $inc = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc;
 } while (($inc | 0) < (1 + (HEAP32[$stereo >> 2] | 0) | 0));
 if (!(HEAP32[$lowband_out$addr >> 2] | 0)) {
  STACKTOP = sp;
  return 1;
 }
 HEAPF32[HEAP32[$lowband_out$addr >> 2] >> 2] = +HEAPF32[HEAP32[$X$addr >> 2] >> 2];
 STACKTOP = sp;
 return 1;
}

function _icwrs($_n, $_y) {
 $_n = $_n | 0;
 $_y = $_y | 0;
 var $_n$addr = 0, $_y$addr = 0, $call17 = 0, $cond = 0, $cond14 = 0, $cond31 = 0, $cond42 = 0, $i = 0, $j = 0, $k = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_n$addr = sp + 16 | 0;
 $_y$addr = sp + 12 | 0;
 $i = sp + 8 | 0;
 $j = sp + 4 | 0;
 $k = sp;
 HEAP32[$_n$addr >> 2] = $_n;
 HEAP32[$_y$addr >> 2] = $_y;
 HEAP32[$j >> 2] = (HEAP32[$_n$addr >> 2] | 0) - 1;
 HEAP32[$i >> 2] = (HEAP32[(HEAP32[$_y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) < 0 & 1;
 HEAP32[$k >> 2] = Math_abs(HEAP32[(HEAP32[$_y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0;
 do {
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + -1;
  if (((HEAP32[$_n$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) | 0) < (HEAP32[$k >> 2] | 0)) $cond = (HEAP32[$_n$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) | 0; else $cond = HEAP32[$k >> 2] | 0;
  if (((HEAP32[$_n$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) | 0) > (HEAP32[$k >> 2] | 0)) $cond14 = (HEAP32[$_n$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) | 0; else $cond14 = HEAP32[$k >> 2] | 0;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + (HEAP32[(HEAP32[15496 + ($cond << 2) >> 2] | 0) + ($cond14 << 2) >> 2] | 0);
  $call17 = Math_abs(HEAP32[(HEAP32[$_y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) | 0;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + $call17;
  if ((HEAP32[(HEAP32[$_y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] | 0) < 0) {
   if (((HEAP32[$_n$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) | 0) < ((HEAP32[$k >> 2] | 0) + 1 | 0)) $cond31 = (HEAP32[$_n$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) | 0; else $cond31 = (HEAP32[$k >> 2] | 0) + 1 | 0;
   if (((HEAP32[$_n$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) | 0) > ((HEAP32[$k >> 2] | 0) + 1 | 0)) $cond42 = (HEAP32[$_n$addr >> 2] | 0) - (HEAP32[$j >> 2] | 0) | 0; else $cond42 = (HEAP32[$k >> 2] | 0) + 1 | 0;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + (HEAP32[(HEAP32[15496 + ($cond31 << 2) >> 2] | 0) + ($cond42 << 2) >> 2] | 0);
  }
 } while ((HEAP32[$j >> 2] | 0) > 0);
 STACKTOP = sp;
 return HEAP32[$i >> 2] | 0;
}

function _opus_encoder_create($Fs, $channels, $application, $error) {
 $Fs = $Fs | 0;
 $channels = $channels | 0;
 $application = $application | 0;
 $error = $error | 0;
 var $26 = 0, $Fs$addr = 0, $application$addr = 0, $channels$addr = 0, $error$addr = 0, $ret = 0, $retval = 0, $st = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 24 | 0;
 $Fs$addr = sp + 20 | 0;
 $channels$addr = sp + 16 | 0;
 $application$addr = sp + 12 | 0;
 $error$addr = sp + 8 | 0;
 $ret = sp + 4 | 0;
 $st = sp;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$application$addr >> 2] = $application;
 HEAP32[$error$addr >> 2] = $error;
 if (!((HEAP32[$Fs$addr >> 2] | 0) != 48e3 & (HEAP32[$Fs$addr >> 2] | 0) != 24e3 & (HEAP32[$Fs$addr >> 2] | 0) != 16e3 & (HEAP32[$Fs$addr >> 2] | 0) != 12e3 & (HEAP32[$Fs$addr >> 2] | 0) != 8e3)) if (!((HEAP32[$channels$addr >> 2] | 0) != 1 & (HEAP32[$channels$addr >> 2] | 0) != 2)) if (!((HEAP32[$application$addr >> 2] | 0) != 2048 & (HEAP32[$application$addr >> 2] | 0) != 2049 & (HEAP32[$application$addr >> 2] | 0) != 2051)) {
  HEAP32[$st >> 2] = _opus_alloc_10(_opus_encoder_get_size(HEAP32[$channels$addr >> 2] | 0) | 0) | 0;
  if (!(HEAP32[$st >> 2] | 0)) {
   if (HEAP32[$error$addr >> 2] | 0) HEAP32[HEAP32[$error$addr >> 2] >> 2] = -7;
   HEAP32[$retval >> 2] = 0;
   $26 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $26 | 0;
  }
  HEAP32[$ret >> 2] = _opus_encoder_init(HEAP32[$st >> 2] | 0, HEAP32[$Fs$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0, HEAP32[$application$addr >> 2] | 0) | 0;
  if (HEAP32[$error$addr >> 2] | 0) HEAP32[HEAP32[$error$addr >> 2] >> 2] = HEAP32[$ret >> 2];
  if (HEAP32[$ret >> 2] | 0) {
   _opus_free_11(HEAP32[$st >> 2] | 0);
   HEAP32[$st >> 2] = 0;
  }
  HEAP32[$retval >> 2] = HEAP32[$st >> 2];
  $26 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $26 | 0;
 }
 if (HEAP32[$error$addr >> 2] | 0) HEAP32[HEAP32[$error$addr >> 2] >> 2] = -1;
 HEAP32[$retval >> 2] = 0;
 $26 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $26 | 0;
}

function _unquant_fine_energy($m, $start, $end, $oldEBands, $fine_quant, $dec, $C) {
 $m = $m | 0;
 $start = $start | 0;
 $end = $end | 0;
 $oldEBands = $oldEBands | 0;
 $fine_quant = $fine_quant | 0;
 $dec = $dec | 0;
 $C = $C | 0;
 var $C$addr = 0, $arrayidx9 = 0, $c = 0, $dec$addr = 0, $end$addr = 0, $fine_quant$addr = 0, $i = 0, $inc = 0, $m$addr = 0, $offset = 0, $oldEBands$addr = 0, $q2 = 0, $start$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $m$addr = sp + 40 | 0;
 $start$addr = sp + 36 | 0;
 $end$addr = sp + 32 | 0;
 $oldEBands$addr = sp + 28 | 0;
 $fine_quant$addr = sp + 24 | 0;
 $dec$addr = sp + 20 | 0;
 $C$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $c = sp + 8 | 0;
 $q2 = sp + 4 | 0;
 $offset = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$oldEBands$addr >> 2] = $oldEBands;
 HEAP32[$fine_quant$addr >> 2] = $fine_quant;
 HEAP32[$dec$addr >> 2] = $dec;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
  if ((HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) > 0) {
   HEAP32[$c >> 2] = 0;
   do {
    HEAP32[$q2 >> 2] = _ec_dec_bits(HEAP32[$dec$addr >> 2] | 0, HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) | 0;
    HEAPF32[$offset >> 2] = (+(HEAP32[$q2 >> 2] | 0) + .5) * +(1 << 14 - (HEAP32[(HEAP32[$fine_quant$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0) | 0) * .00006103515625 - .5;
    $arrayidx9 = (HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) | 0;
    HEAPF32[$arrayidx9 >> 2] = +HEAPF32[$arrayidx9 >> 2] + +HEAPF32[$offset >> 2];
    $inc = (HEAP32[$c >> 2] | 0) + 1 | 0;
    HEAP32[$c >> 2] = $inc;
   } while (($inc | 0) < (HEAP32[$C$addr >> 2] | 0));
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _intensity_stereo($m, $X, $Y, $bandE, $bandID, $N) {
 $m = $m | 0;
 $X = $X | 0;
 $Y = $Y | 0;
 $bandE = $bandE | 0;
 $bandID = $bandID | 0;
 $N = $N | 0;
 var $N$addr = 0, $X$addr = 0, $Y$addr = 0, $a1 = 0, $a2 = 0, $bandE$addr = 0, $bandID$addr = 0, $i = 0, $j = 0, $l = 0, $left = 0, $m$addr = 0, $norm = 0, $r = 0, $right = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $m$addr = sp + 56 | 0;
 $X$addr = sp + 52 | 0;
 $Y$addr = sp + 48 | 0;
 $bandE$addr = sp + 44 | 0;
 $bandID$addr = sp + 40 | 0;
 $N$addr = sp + 36 | 0;
 $i = sp + 32 | 0;
 $j = sp + 28 | 0;
 $a1 = sp + 24 | 0;
 $a2 = sp + 20 | 0;
 $left = sp + 16 | 0;
 $right = sp + 12 | 0;
 $norm = sp + 8 | 0;
 $r = sp + 4 | 0;
 $l = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$Y$addr >> 2] = $Y;
 HEAP32[$bandE$addr >> 2] = $bandE;
 HEAP32[$bandID$addr >> 2] = $bandID;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$i >> 2] = HEAP32[$bandID$addr >> 2];
 HEAPF32[$left >> 2] = +HEAPF32[(HEAP32[$bandE$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
 HEAPF32[$right >> 2] = +HEAPF32[(HEAP32[$bandE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) << 2) >> 2];
 HEAPF32[$norm >> 2] = +Math_sqrt(+(+HEAPF32[$left >> 2] * +HEAPF32[$left >> 2] + 1.0000000036274937e-15 + +HEAPF32[$right >> 2] * +HEAPF32[$right >> 2])) + 1.0000000036274937e-15;
 HEAPF32[$a1 >> 2] = +HEAPF32[$left >> 2] / +HEAPF32[$norm >> 2];
 HEAPF32[$a2 >> 2] = +HEAPF32[$right >> 2] / +HEAPF32[$norm >> 2];
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAPF32[$l >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
  HEAPF32[$r >> 2] = +HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2];
  HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$a1 >> 2] * +HEAPF32[$l >> 2] + +HEAPF32[$a2 >> 2] * +HEAPF32[$r >> 2];
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_NLSF_residual_dequant($x_Q10, $indices, $pred_coef_Q8, $quant_step_size_Q16, $order) {
 $x_Q10 = $x_Q10 | 0;
 $indices = $indices | 0;
 $pred_coef_Q8 = $pred_coef_Q8 | 0;
 $quant_step_size_Q16 = $quant_step_size_Q16 | 0;
 $order = $order | 0;
 var $10 = 0, $i = 0, $indices$addr = 0, $mul18 = 0, $order$addr = 0, $out_Q10 = 0, $pred_Q10 = 0, $pred_coef_Q8$addr = 0, $quant_step_size_Q16$addr = 0, $x_Q10$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $x_Q10$addr = sp + 24 | 0;
 $indices$addr = sp + 20 | 0;
 $pred_coef_Q8$addr = sp + 16 | 0;
 $quant_step_size_Q16$addr = sp + 12 | 0;
 $order$addr = sp + 28 | 0;
 $i = sp + 8 | 0;
 $out_Q10 = sp + 4 | 0;
 $pred_Q10 = sp;
 HEAP32[$x_Q10$addr >> 2] = $x_Q10;
 HEAP32[$indices$addr >> 2] = $indices;
 HEAP32[$pred_coef_Q8$addr >> 2] = $pred_coef_Q8;
 HEAP32[$quant_step_size_Q16$addr >> 2] = $quant_step_size_Q16;
 HEAP16[$order$addr >> 1] = $order;
 HEAP32[$out_Q10 >> 2] = 0;
 HEAP32[$i >> 2] = (HEAP16[$order$addr >> 1] | 0) - 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) < 0) break;
  HEAP32[$pred_Q10 >> 2] = (Math_imul((HEAP32[$out_Q10 >> 2] & 65535) << 16 >> 16, HEAPU8[(HEAP32[$pred_coef_Q8$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] | 0) | 0) >> 8;
  HEAP32[$out_Q10 >> 2] = HEAP8[(HEAP32[$indices$addr >> 2] | 0) + (HEAP32[$i >> 2] | 0) >> 0] << 10;
  $10 = HEAP32[$out_Q10 >> 2] | 0;
  if ((HEAP32[$out_Q10 >> 2] | 0) > 0) HEAP32[$out_Q10 >> 2] = $10 - 102; else if (($10 | 0) < 0) HEAP32[$out_Q10 >> 2] = (HEAP32[$out_Q10 >> 2] | 0) + 102;
  $mul18 = Math_imul(HEAP32[$out_Q10 >> 2] >> 16, (HEAP32[$quant_step_size_Q16$addr >> 2] & 65535) << 16 >> 16) | 0;
  HEAP32[$out_Q10 >> 2] = (HEAP32[$pred_Q10 >> 2] | 0) + ($mul18 + ((Math_imul(HEAP32[$out_Q10 >> 2] & 65535, (HEAP32[$quant_step_size_Q16$addr >> 2] & 65535) << 16 >> 16) | 0) >> 16));
  HEAP16[(HEAP32[$x_Q10$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = HEAP32[$out_Q10 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return;
}

function _silk_scale_copy_vector_FLP($data_out, $data_in, $gain, $dataSize) {
 $data_out = $data_out | 0;
 $data_in = $data_in | 0;
 $gain = +$gain;
 $dataSize = $dataSize | 0;
 var $dataSize$addr = 0, $dataSize4 = 0, $data_in$addr = 0, $data_out$addr = 0, $gain$addr = 0, $i = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $data_out$addr = sp + 20 | 0;
 $data_in$addr = sp + 16 | 0;
 $gain$addr = sp + 12 | 0;
 $dataSize$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $dataSize4 = sp;
 HEAP32[$data_out$addr >> 2] = $data_out;
 HEAP32[$data_in$addr >> 2] = $data_in;
 HEAPF32[$gain$addr >> 2] = $gain;
 HEAP32[$dataSize$addr >> 2] = $dataSize;
 HEAP32[$dataSize4 >> 2] = HEAP32[$dataSize$addr >> 2] & 65532;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$dataSize4 >> 2] | 0)) break;
  HEAPF32[(HEAP32[$data_out$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 0 << 2) >> 2] = +HEAPF32[$gain$addr >> 2] * +HEAPF32[(HEAP32[$data_in$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 0 << 2) >> 2];
  HEAPF32[(HEAP32[$data_out$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] = +HEAPF32[$gain$addr >> 2] * +HEAPF32[(HEAP32[$data_in$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2];
  HEAPF32[(HEAP32[$data_out$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2] = +HEAPF32[$gain$addr >> 2] * +HEAPF32[(HEAP32[$data_in$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2];
  HEAPF32[(HEAP32[$data_out$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2] = +HEAPF32[$gain$addr >> 2] * +HEAPF32[(HEAP32[$data_in$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$dataSize$addr >> 2] | 0)) break;
  HEAPF32[(HEAP32[$data_out$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$gain$addr >> 2] * +HEAPF32[(HEAP32[$data_in$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _opus_packet_pad($data, $len, $new_len) {
 $data = $data | 0;
 $len = $len | 0;
 $new_len = $new_len | 0;
 var $25 = 0, $data$addr = 0, $len$addr = 0, $new_len$addr = 0, $ret = 0, $retval = 0, $rp = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 320 | 0;
 $retval = sp + 316 | 0;
 $data$addr = sp + 312 | 0;
 $len$addr = sp + 308 | 0;
 $new_len$addr = sp + 304 | 0;
 $rp = sp + 4 | 0;
 $ret = sp;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$new_len$addr >> 2] = $new_len;
 if ((HEAP32[$len$addr >> 2] | 0) < 1) {
  HEAP32[$retval >> 2] = -1;
  $25 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $25 | 0;
 }
 if ((HEAP32[$len$addr >> 2] | 0) == (HEAP32[$new_len$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = 0;
  $25 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $25 | 0;
 }
 if ((HEAP32[$len$addr >> 2] | 0) > (HEAP32[$new_len$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = -1;
  $25 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $25 | 0;
 }
 _opus_repacketizer_init($rp) | 0;
 _memmove((HEAP32[$data$addr >> 2] | 0) + (HEAP32[$new_len$addr >> 2] | 0) + (0 - (HEAP32[$len$addr >> 2] | 0)) | 0, HEAP32[$data$addr >> 2] | 0, (HEAP32[$len$addr >> 2] | 0) + 0 | 0) | 0;
 HEAP32[$ret >> 2] = _opus_repacketizer_cat($rp, (HEAP32[$data$addr >> 2] | 0) + (HEAP32[$new_len$addr >> 2] | 0) + (0 - (HEAP32[$len$addr >> 2] | 0)) | 0, HEAP32[$len$addr >> 2] | 0) | 0;
 if (HEAP32[$ret >> 2] | 0) {
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $25 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $25 | 0;
 }
 HEAP32[$ret >> 2] = _opus_repacketizer_out_range_impl($rp, 0, HEAP32[$rp + 4 >> 2] | 0, HEAP32[$data$addr >> 2] | 0, HEAP32[$new_len$addr >> 2] | 0, 0, 1) | 0;
 if ((HEAP32[$ret >> 2] | 0) > 0) {
  HEAP32[$retval >> 2] = 0;
  $25 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $25 | 0;
 } else {
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $25 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $25 | 0;
 }
 return 0;
}

function _deemphasis_stereo_simple($in, $pcm, $N, $coef0, $mem) {
 $in = $in | 0;
 $pcm = $pcm | 0;
 $N = $N | 0;
 $coef0 = +$coef0;
 $mem = $mem | 0;
 var $N$addr = 0, $coef0$addr = 0, $in$addr = 0, $j = 0, $m0 = 0, $m1 = 0, $mem$addr = 0, $pcm$addr = 0, $tmp0 = 0, $tmp1 = 0, $x0 = 0, $x1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $in$addr = sp + 44 | 0;
 $pcm$addr = sp + 40 | 0;
 $N$addr = sp + 36 | 0;
 $coef0$addr = sp + 32 | 0;
 $mem$addr = sp + 28 | 0;
 $x0 = sp + 24 | 0;
 $x1 = sp + 20 | 0;
 $m0 = sp + 16 | 0;
 $m1 = sp + 12 | 0;
 $j = sp + 8 | 0;
 $tmp0 = sp + 4 | 0;
 $tmp1 = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$N$addr >> 2] = $N;
 HEAPF32[$coef0$addr >> 2] = $coef0;
 HEAP32[$mem$addr >> 2] = $mem;
 HEAP32[$x0 >> 2] = HEAP32[HEAP32[$in$addr >> 2] >> 2];
 HEAP32[$x1 >> 2] = HEAP32[(HEAP32[$in$addr >> 2] | 0) + 4 >> 2];
 HEAPF32[$m0 >> 2] = +HEAPF32[HEAP32[$mem$addr >> 2] >> 2];
 HEAPF32[$m1 >> 2] = +HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2];
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAPF32[$tmp0 >> 2] = +HEAPF32[(HEAP32[$x0 >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] + 1.0000000031710769e-30 + +HEAPF32[$m0 >> 2];
  HEAPF32[$tmp1 >> 2] = +HEAPF32[(HEAP32[$x1 >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] + 1.0000000031710769e-30 + +HEAPF32[$m1 >> 2];
  HEAPF32[$m0 >> 2] = +HEAPF32[$coef0$addr >> 2] * +HEAPF32[$tmp0 >> 2];
  HEAPF32[$m1 >> 2] = +HEAPF32[$coef0$addr >> 2] * +HEAPF32[$tmp1 >> 2];
  HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1 << 2) >> 2] = +HEAPF32[$tmp0 >> 2] * .000030517578125;
  HEAPF32[(HEAP32[$pcm$addr >> 2] | 0) + ((HEAP32[$j >> 2] << 1) + 1 << 2) >> 2] = +HEAPF32[$tmp1 >> 2] * .000030517578125;
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 HEAPF32[HEAP32[$mem$addr >> 2] >> 2] = +HEAPF32[$m0 >> 2];
 HEAPF32[(HEAP32[$mem$addr >> 2] | 0) + 4 >> 2] = +HEAPF32[$m1 >> 2];
 STACKTOP = sp;
 return;
}

function _silk_encode_do_VAD_FLP($psEnc) {
 $psEnc = $psEnc | 0;
 var $$sink = 0, $$sink2 = 0, $12 = 0, $22 = 0, $7 = 0, $VAD_flags32$sink = 0, $arrayidx35 = 0, $nFramesEncoded34 = 0, $noSpeechCounter = 0, $psEnc$addr = 0, $sCmn17$sink = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psEnc$addr = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 FUNCTION_TABLE_iii[HEAP32[15308 + ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5088 >> 2] & 7) << 2) >> 2] & 3](HEAP32[$psEnc$addr >> 2] | 0, (HEAP32[$psEnc$addr >> 2] | 0) + 5092 + 2 | 0) | 0;
 $7 = HEAP32[$psEnc$addr >> 2] | 0;
 if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4528 >> 2] | 0) >= 13) {
  HEAP32[$7 + 6080 >> 2] = 0;
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 6076 >> 2] = 0;
  HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 29 >> 0] = 1;
  $$sink = 1;
  $$sink2 = HEAP32[$psEnc$addr >> 2] | 0;
  $VAD_flags32$sink = (HEAP32[$psEnc$addr >> 2] | 0) + 4716 | 0;
  $nFramesEncoded34 = $$sink2 + 5744 | 0;
  $22 = HEAP32[$nFramesEncoded34 >> 2] | 0;
  $arrayidx35 = $VAD_flags32$sink + $22 | 0;
  HEAP8[$arrayidx35 >> 0] = $$sink;
  STACKTOP = sp;
  return;
 }
 HEAP8[$7 + 4732 + 29 >> 0] = 0;
 $noSpeechCounter = (HEAP32[$psEnc$addr >> 2] | 0) + 6080 | 0;
 HEAP32[$noSpeechCounter >> 2] = (HEAP32[$noSpeechCounter >> 2] | 0) + 1;
 $12 = HEAP32[$psEnc$addr >> 2] | 0;
 if ((HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 6080 >> 2] | 0) <= 10) {
  $sCmn17$sink = $12;
  label = 5;
 } else if ((HEAP32[$12 + 6080 >> 2] | 0) > 30) {
  HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 6080 >> 2] = 10;
  $sCmn17$sink = HEAP32[$psEnc$addr >> 2] | 0;
  label = 5;
 }
 if ((label | 0) == 5) HEAP32[$sCmn17$sink + 6076 >> 2] = 0;
 $$sink = 0;
 $$sink2 = HEAP32[$psEnc$addr >> 2] | 0;
 $VAD_flags32$sink = (HEAP32[$psEnc$addr >> 2] | 0) + 4716 | 0;
 $nFramesEncoded34 = $$sink2 + 5744 | 0;
 $22 = HEAP32[$nFramesEncoded34 >> 2] | 0;
 $arrayidx35 = $VAD_flags32$sink + $22 | 0;
 HEAP8[$arrayidx35 >> 0] = $$sink;
 STACKTOP = sp;
 return;
}

function _special_hybrid_folding($m, $norm, $norm2, $start, $M, $dual_stereo) {
 $m = $m | 0;
 $norm = $norm | 0;
 $norm2 = $norm2 | 0;
 $start = $start | 0;
 $M = $M | 0;
 $dual_stereo = $dual_stereo | 0;
 var $M$addr = 0, $dual_stereo$addr = 0, $eBands = 0, $m$addr = 0, $n1 = 0, $n2 = 0, $norm$addr = 0, $norm2$addr = 0, $start$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $m$addr = sp + 32 | 0;
 $norm$addr = sp + 28 | 0;
 $norm2$addr = sp + 24 | 0;
 $start$addr = sp + 20 | 0;
 $M$addr = sp + 16 | 0;
 $dual_stereo$addr = sp + 12 | 0;
 $n1 = sp + 8 | 0;
 $n2 = sp + 4 | 0;
 $eBands = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$norm$addr >> 2] = $norm;
 HEAP32[$norm2$addr >> 2] = $norm2;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$M$addr >> 2] = $M;
 HEAP32[$dual_stereo$addr >> 2] = $dual_stereo;
 HEAP32[$eBands >> 2] = HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$n1 >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$start$addr >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + (HEAP32[$start$addr >> 2] << 1) >> 1] | 0) | 0) | 0;
 HEAP32[$n2 >> 2] = Math_imul(HEAP32[$M$addr >> 2] | 0, (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$start$addr >> 2] | 0) + 2 << 1) >> 1] | 0) - (HEAP16[(HEAP32[$eBands >> 2] | 0) + ((HEAP32[$start$addr >> 2] | 0) + 1 << 1) >> 1] | 0) | 0) | 0;
 _memcpy((HEAP32[$norm$addr >> 2] | 0) + (HEAP32[$n1 >> 2] << 2) | 0, (HEAP32[$norm$addr >> 2] | 0) + ((HEAP32[$n1 >> 2] << 1) - (HEAP32[$n2 >> 2] | 0) << 2) | 0, ((HEAP32[$n2 >> 2] | 0) - (HEAP32[$n1 >> 2] | 0) << 2) + 0 | 0) | 0;
 if (!(HEAP32[$dual_stereo$addr >> 2] | 0)) {
  STACKTOP = sp;
  return;
 }
 _memcpy((HEAP32[$norm2$addr >> 2] | 0) + (HEAP32[$n1 >> 2] << 2) | 0, (HEAP32[$norm2$addr >> 2] | 0) + ((HEAP32[$n1 >> 2] << 1) - (HEAP32[$n2 >> 2] | 0) << 2) | 0, ((HEAP32[$n2 >> 2] | 0) - (HEAP32[$n1 >> 2] | 0) << 2) + 0 | 0) | 0;
 STACKTOP = sp;
 return;
}

function _amp2Log2($m, $effEnd, $end, $bandE, $bandLogE, $C) {
 $m = $m | 0;
 $effEnd = $effEnd | 0;
 $end = $end | 0;
 $bandE = $bandE | 0;
 $bandLogE = $bandLogE | 0;
 $C = $C | 0;
 var $C$addr = 0, $bandE$addr = 0, $bandLogE$addr = 0, $c = 0, $conv2 = 0.0, $effEnd$addr = 0, $end$addr = 0, $i = 0, $inc19 = 0, $m$addr = 0, $mul13 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $m$addr = sp + 28 | 0;
 $effEnd$addr = sp + 24 | 0;
 $end$addr = sp + 20 | 0;
 $bandE$addr = sp + 16 | 0;
 $bandLogE$addr = sp + 12 | 0;
 $C$addr = sp + 8 | 0;
 $c = sp + 4 | 0;
 $i = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$effEnd$addr >> 2] = $effEnd;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$bandE$addr >> 2] = $bandE;
 HEAP32[$bandLogE$addr >> 2] = $bandLogE;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$effEnd$addr >> 2] | 0)) break;
   $conv2 = +Math_log(+(+HEAPF32[(HEAP32[$bandE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2])) * 1.4426950408889634;
   HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2) >> 2] = $conv2 - +HEAPF32[14900 + (HEAP32[$i >> 2] << 2) >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = HEAP32[$effEnd$addr >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   $mul13 = Math_imul(HEAP32[$c >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$bandLogE$addr >> 2] | 0) + ($mul13 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = -14.0;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc19 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc19;
 } while (($inc19 | 0) < (HEAP32[$C$addr >> 2] | 0));
 STACKTOP = sp;
 return;
}

function _opus_custom_decoder_init($st, $mode, $channels) {
 $st = $st | 0;
 $mode = $mode | 0;
 $channels = $channels | 0;
 var $11 = 0, $25 = 0, $3 = 0, $call10 = 0, $channels$addr = 0, $mode$addr = 0, $retval = 0, $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $st$addr = sp + 12 | 0;
 $mode$addr = sp + 8 | 0;
 $channels$addr = sp + 4 | 0;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$channels$addr >> 2] = $channels;
 if ((HEAP32[$channels$addr >> 2] | 0) < 0 | (HEAP32[$channels$addr >> 2] | 0) > 2) {
  HEAP32[$retval >> 2] = -1;
  $25 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $25 | 0;
 }
 if (!(HEAP32[$st$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = -7;
  $25 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $25 | 0;
 } else {
  $3 = HEAP32[$st$addr >> 2] | 0;
  _memset($3 | 0, 0, _opus_custom_decoder_get_size(HEAP32[$mode$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0) | 0;
  HEAP32[HEAP32[$st$addr >> 2] >> 2] = HEAP32[$mode$addr >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2] = HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 4 >> 2];
  $11 = HEAP32[$channels$addr >> 2] | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 8 >> 2] = $11;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 12 >> 2] = $11;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] = 1;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 20 >> 2] = 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 24 >> 2] = HEAP32[(HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0) + 12 >> 2];
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] = 1;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 32 >> 2] = (HEAP32[$channels$addr >> 2] | 0) == 1 & 1;
  $call10 = _opus_select_arch() | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 36 >> 2] = $call10;
  _opus_custom_decoder_ctl(HEAP32[$st$addr >> 2] | 0, 4028, sp) | 0;
  HEAP32[$retval >> 2] = 0;
  $25 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $25 | 0;
 }
 return 0;
}

function __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE21__grow_by_and_replaceEjjjjjjPKc($this, $__old_cap, $__delta_cap, $__old_sz, $__n_copy, $__n_del, $__n_add, $__p_new_stuff) {
 $this = $this | 0;
 $__old_cap = $__old_cap | 0;
 $__delta_cap = $__delta_cap | 0;
 $__old_sz = $__old_sz | 0;
 $__n_copy = $__n_copy | 0;
 $__n_del = $__n_del | 0;
 $__n_add = $__n_add | 0;
 $__p_new_stuff = $__p_new_stuff | 0;
 var $$sroa$speculated = 0, $add = 0, $add48 = 0, $call$i$i$i = 0, $cond$i = 0, $cond40 = 0, $mul = 0, $ref$tmp49 = 0, $sub28 = 0, $sub29 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ref$tmp49 = sp;
 if ((-18 - $__old_cap | 0) >>> 0 < $__delta_cap >>> 0) __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv($this);
 if ((HEAP8[$this + 11 >> 0] | 0) < 0) $cond$i = HEAP32[$this >> 2] | 0; else $cond$i = $this;
 if ($__old_cap >>> 0 < 2147483623) {
  $add = $__delta_cap + $__old_cap | 0;
  $mul = $__old_cap << 1;
  $$sroa$speculated = $add >>> 0 < $mul >>> 0 ? $mul : $add;
  $cond40 = $$sroa$speculated >>> 0 < 11 ? 11 : $$sroa$speculated + 16 & -16;
 } else $cond40 = -17;
 $call$i$i$i = __Znwj($cond40) | 0;
 if ($__n_copy | 0) __ZNSt3__211char_traitsIcE4copyEPcPKcj($call$i$i$i, $cond$i, $__n_copy) | 0;
 if ($__n_add | 0) __ZNSt3__211char_traitsIcE4copyEPcPKcj($call$i$i$i + $__n_copy | 0, $__p_new_stuff, $__n_add) | 0;
 $sub28 = $__old_sz - $__n_del | 0;
 $sub29 = $sub28 - $__n_copy | 0;
 if ($sub29 | 0) __ZNSt3__211char_traitsIcE4copyEPcPKcj($call$i$i$i + $__n_copy + $__n_add | 0, $cond$i + $__n_copy + $__n_del | 0, $sub29) | 0;
 if (($__old_cap | 0) != 10) __ZdlPv($cond$i);
 HEAP32[$this >> 2] = $call$i$i$i;
 HEAP32[$this + 8 >> 2] = $cond40 | -2147483648;
 $add48 = $sub28 + $__n_add | 0;
 HEAP32[$this + 4 >> 2] = $add48;
 HEAP8[$ref$tmp49 >> 0] = 0;
 __ZNSt3__211char_traitsIcE6assignERcRKc($call$i$i$i + $add48 | 0, $ref$tmp49);
 STACKTOP = sp;
 return;
}

function _silk_LPC_analysis_filter8_FLP($r_LPC, $PredCoef, $s, $length) {
 $r_LPC = $r_LPC | 0;
 $PredCoef = $PredCoef | 0;
 $s = $s | 0;
 $length = $length | 0;
 var $LPC_pred = 0, $PredCoef$addr = 0, $ix = 0, $length$addr = 0, $r_LPC$addr = 0, $s$addr = 0, $s_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $r_LPC$addr = sp + 24 | 0;
 $PredCoef$addr = sp + 20 | 0;
 $s$addr = sp + 16 | 0;
 $length$addr = sp + 12 | 0;
 $ix = sp + 8 | 0;
 $LPC_pred = sp + 4 | 0;
 $s_ptr = sp;
 HEAP32[$r_LPC$addr >> 2] = $r_LPC;
 HEAP32[$PredCoef$addr >> 2] = $PredCoef;
 HEAP32[$s$addr >> 2] = $s;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$ix >> 2] = 8;
 while (1) {
  if ((HEAP32[$ix >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$s_ptr >> 2] = (HEAP32[$s$addr >> 2] | 0) + ((HEAP32[$ix >> 2] | 0) - 1 << 2);
  HEAPF32[$LPC_pred >> 2] = +HEAPF32[HEAP32[$s_ptr >> 2] >> 2] * +HEAPF32[HEAP32[$PredCoef$addr >> 2] >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -4 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -8 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 8 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -12 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 12 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -16 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 16 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -20 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 20 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -24 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 24 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -28 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 28 >> 2];
  HEAPF32[(HEAP32[$r_LPC$addr >> 2] | 0) + (HEAP32[$ix >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + 4 >> 2] - +HEAPF32[$LPC_pred >> 2];
  HEAP32[$ix >> 2] = (HEAP32[$ix >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _ec_dec_uint($_this, $_ft) {
 $_this = $_this | 0;
 $_ft = $_ft | 0;
 var $30 = 0, $_ft$addr = 0, $_this$addr = 0, $ft = 0, $ftb = 0, $retval = 0, $s = 0, $shl = 0, $t = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 24 | 0;
 $_this$addr = sp + 20 | 0;
 $_ft$addr = sp + 16 | 0;
 $ft = sp + 12 | 0;
 $s = sp + 8 | 0;
 $ftb = sp + 4 | 0;
 $t = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_ft$addr >> 2] = $_ft;
 HEAP32[$_ft$addr >> 2] = (HEAP32[$_ft$addr >> 2] | 0) + -1;
 HEAP32[$ftb >> 2] = 32 - (Math_clz32(HEAP32[$_ft$addr >> 2] | 0) | 0);
 if ((HEAP32[$ftb >> 2] | 0) <= 8) {
  HEAP32[$_ft$addr >> 2] = (HEAP32[$_ft$addr >> 2] | 0) + 1;
  HEAP32[$s >> 2] = _ec_decode(HEAP32[$_this$addr >> 2] | 0, HEAP32[$_ft$addr >> 2] | 0) | 0;
  _ec_dec_update(HEAP32[$_this$addr >> 2] | 0, HEAP32[$s >> 2] | 0, (HEAP32[$s >> 2] | 0) + 1 | 0, HEAP32[$_ft$addr >> 2] | 0);
  HEAP32[$retval >> 2] = HEAP32[$s >> 2];
  $30 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $30 | 0;
 }
 HEAP32[$ftb >> 2] = (HEAP32[$ftb >> 2] | 0) - 8;
 HEAP32[$ft >> 2] = ((HEAP32[$_ft$addr >> 2] | 0) >>> (HEAP32[$ftb >> 2] | 0)) + 1;
 HEAP32[$s >> 2] = _ec_decode(HEAP32[$_this$addr >> 2] | 0, HEAP32[$ft >> 2] | 0) | 0;
 _ec_dec_update(HEAP32[$_this$addr >> 2] | 0, HEAP32[$s >> 2] | 0, (HEAP32[$s >> 2] | 0) + 1 | 0, HEAP32[$ft >> 2] | 0);
 $shl = HEAP32[$s >> 2] << HEAP32[$ftb >> 2];
 HEAP32[$t >> 2] = $shl | (_ec_dec_bits(HEAP32[$_this$addr >> 2] | 0, HEAP32[$ftb >> 2] | 0) | 0);
 if ((HEAP32[$t >> 2] | 0) >>> 0 <= (HEAP32[$_ft$addr >> 2] | 0) >>> 0) {
  HEAP32[$retval >> 2] = HEAP32[$t >> 2];
  $30 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $30 | 0;
 } else {
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 44 >> 2] = 1;
  HEAP32[$retval >> 2] = HEAP32[$_ft$addr >> 2];
  $30 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $30 | 0;
 }
 return 0;
}

function _gen_toc($mode, $framerate, $bandwidth, $channels) {
 $mode = $mode | 0;
 $framerate = $framerate | 0;
 $bandwidth = $bandwidth | 0;
 $channels = $channels | 0;
 var $bandwidth$addr = 0, $channels$addr = 0, $framerate$addr = 0, $mode$addr = 0, $period = 0, $sub10 = 0, $tmp = 0, $toc = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $mode$addr = sp + 20 | 0;
 $framerate$addr = sp + 16 | 0;
 $bandwidth$addr = sp + 12 | 0;
 $channels$addr = sp + 8 | 0;
 $period = sp + 4 | 0;
 $toc = sp + 24 | 0;
 $tmp = sp;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$framerate$addr >> 2] = $framerate;
 HEAP32[$bandwidth$addr >> 2] = $bandwidth;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$period >> 2] = 0;
 while (1) {
  if ((HEAP32[$framerate$addr >> 2] | 0) >= 400) break;
  HEAP32[$framerate$addr >> 2] = HEAP32[$framerate$addr >> 2] << 1;
  HEAP32[$period >> 2] = (HEAP32[$period >> 2] | 0) + 1;
 }
 do if ((HEAP32[$mode$addr >> 2] | 0) == 1e3) {
  HEAP8[$toc >> 0] = (HEAP32[$bandwidth$addr >> 2] | 0) - 1101 << 5;
  HEAP8[$toc >> 0] = HEAPU8[$toc >> 0] | 0 | (HEAP32[$period >> 2] | 0) - 2 << 3;
 } else if ((HEAP32[$mode$addr >> 2] | 0) == 1002) {
  $sub10 = (HEAP32[$bandwidth$addr >> 2] | 0) - 1102 | 0;
  HEAP32[$tmp >> 2] = $sub10;
  HEAP32[$tmp >> 2] = (HEAP32[$tmp >> 2] | 0) < 0 ? 0 : $sub10;
  HEAP8[$toc >> 0] = -128;
  HEAP8[$toc >> 0] = HEAPU8[$toc >> 0] | 0 | HEAP32[$tmp >> 2] << 5;
  HEAP8[$toc >> 0] = HEAPU8[$toc >> 0] | 0 | HEAP32[$period >> 2] << 3;
  break;
 } else {
  HEAP8[$toc >> 0] = 96;
  HEAP8[$toc >> 0] = HEAPU8[$toc >> 0] | 0 | (HEAP32[$bandwidth$addr >> 2] | 0) - 1104 << 4;
  HEAP8[$toc >> 0] = HEAPU8[$toc >> 0] | 0 | (HEAP32[$period >> 2] | 0) - 2 << 3;
  break;
 } while (0);
 HEAP8[$toc >> 0] = HEAPU8[$toc >> 0] | 0 | ((HEAP32[$channels$addr >> 2] | 0) == 2 & 1) << 2;
 STACKTOP = sp;
 return HEAP8[$toc >> 0] | 0;
}

function _silk_log2lin($inLog_Q7) {
 $inLog_Q7 = $inLog_Q7 | 0;
 var $18 = 0, $5 = 0, $6 = 0, $frac_Q7 = 0, $inLog_Q7$addr = 0, $mul10 = 0, $mul33 = 0, $out = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $retval = sp + 12 | 0;
 $inLog_Q7$addr = sp + 8 | 0;
 $out = sp + 4 | 0;
 $frac_Q7 = sp;
 HEAP32[$inLog_Q7$addr >> 2] = $inLog_Q7;
 if ((HEAP32[$inLog_Q7$addr >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = 0;
  $18 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 if ((HEAP32[$inLog_Q7$addr >> 2] | 0) >= 3967) {
  HEAP32[$retval >> 2] = 2147483647;
  $18 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 HEAP32[$out >> 2] = 1 << (HEAP32[$inLog_Q7$addr >> 2] >> 7);
 HEAP32[$frac_Q7 >> 2] = HEAP32[$inLog_Q7$addr >> 2] & 127;
 $5 = HEAP32[$out >> 2] | 0;
 $6 = HEAP32[$out >> 2] | 0;
 if ((HEAP32[$inLog_Q7$addr >> 2] | 0) < 2048) {
  $mul10 = Math_imul((Math_imul((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16, (128 - (HEAP32[$frac_Q7 >> 2] | 0) & 65535) << 16 >> 16) | 0) >> 16, -174) | 0;
  HEAP32[$out >> 2] = $5 + ((Math_imul($6, (HEAP32[$frac_Q7 >> 2] | 0) + ($mul10 + ((Math_imul((Math_imul((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16, (128 - (HEAP32[$frac_Q7 >> 2] | 0) & 65535) << 16 >> 16) | 0) & 65535, -174) | 0) >> 16)) | 0) | 0) >> 7);
 } else {
  $mul33 = Math_imul((Math_imul((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16, (128 - (HEAP32[$frac_Q7 >> 2] | 0) & 65535) << 16 >> 16) | 0) >> 16, -174) | 0;
  HEAP32[$out >> 2] = $5 + (Math_imul($6 >> 7, (HEAP32[$frac_Q7 >> 2] | 0) + ($mul33 + ((Math_imul((Math_imul((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16, (128 - (HEAP32[$frac_Q7 >> 2] | 0) & 65535) << 16 >> 16) | 0) & 65535, -174) | 0) >> 16)) | 0) | 0);
 }
 HEAP32[$retval >> 2] = HEAP32[$out >> 2];
 $18 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $18 | 0;
}

function _fast_atan2f_142($y, $x) {
 $y = +$y;
 $x = +$x;
 var $30 = 0.0, $den = 0, $den15 = 0, $retval = 0, $x$addr = 0, $x2 = 0, $y$addr = 0, $y2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 24 | 0;
 $y$addr = sp + 20 | 0;
 $x$addr = sp + 16 | 0;
 $x2 = sp + 12 | 0;
 $y2 = sp + 8 | 0;
 $den = sp + 4 | 0;
 $den15 = sp;
 HEAPF32[$y$addr >> 2] = $y;
 HEAPF32[$x$addr >> 2] = $x;
 HEAPF32[$x2 >> 2] = +HEAPF32[$x$addr >> 2] * +HEAPF32[$x$addr >> 2];
 HEAPF32[$y2 >> 2] = +HEAPF32[$y$addr >> 2] * +HEAPF32[$y$addr >> 2];
 if (+HEAPF32[$x2 >> 2] + +HEAPF32[$y2 >> 2] < 1.000000045813705e-18) {
  HEAPF32[$retval >> 2] = 0.0;
  $30 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$30;
 }
 if (+HEAPF32[$x2 >> 2] < +HEAPF32[$y2 >> 2]) {
  HEAPF32[$den >> 2] = (+HEAPF32[$y2 >> 2] + +HEAPF32[$x2 >> 2] * .6784840226173401) * (+HEAPF32[$y2 >> 2] + +HEAPF32[$x2 >> 2] * .0859554186463356);
  HEAPF32[$retval >> 2] = -+HEAPF32[$x$addr >> 2] * +HEAPF32[$y$addr >> 2] * (+HEAPF32[$y2 >> 2] + +HEAPF32[$x2 >> 2] * .43157973885536194) / +HEAPF32[$den >> 2] + (+HEAPF32[$y$addr >> 2] < 0.0 ? -1.5707963705062866 : 1.5707963705062866);
  $30 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$30;
 } else {
  HEAPF32[$den15 >> 2] = (+HEAPF32[$x2 >> 2] + +HEAPF32[$y2 >> 2] * .6784840226173401) * (+HEAPF32[$x2 >> 2] + +HEAPF32[$y2 >> 2] * .0859554186463356);
  HEAPF32[$retval >> 2] = +HEAPF32[$x$addr >> 2] * +HEAPF32[$y$addr >> 2] * (+HEAPF32[$x2 >> 2] + +HEAPF32[$y2 >> 2] * .43157973885536194) / +HEAPF32[$den15 >> 2] + (+HEAPF32[$y$addr >> 2] < 0.0 ? -1.5707963705062866 : 1.5707963705062866) - (+HEAPF32[$x$addr >> 2] * +HEAPF32[$y$addr >> 2] < 0.0 ? -1.5707963705062866 : 1.5707963705062866);
  $30 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$30;
 }
 return +(0.0);
}

function _fast_atan2f($y, $x) {
 $y = +$y;
 $x = +$x;
 var $30 = 0.0, $den = 0, $den15 = 0, $retval = 0, $x$addr = 0, $x2 = 0, $y$addr = 0, $y2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 24 | 0;
 $y$addr = sp + 20 | 0;
 $x$addr = sp + 16 | 0;
 $x2 = sp + 12 | 0;
 $y2 = sp + 8 | 0;
 $den = sp + 4 | 0;
 $den15 = sp;
 HEAPF32[$y$addr >> 2] = $y;
 HEAPF32[$x$addr >> 2] = $x;
 HEAPF32[$x2 >> 2] = +HEAPF32[$x$addr >> 2] * +HEAPF32[$x$addr >> 2];
 HEAPF32[$y2 >> 2] = +HEAPF32[$y$addr >> 2] * +HEAPF32[$y$addr >> 2];
 if (+HEAPF32[$x2 >> 2] + +HEAPF32[$y2 >> 2] < 1.000000045813705e-18) {
  HEAPF32[$retval >> 2] = 0.0;
  $30 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$30;
 }
 if (+HEAPF32[$x2 >> 2] < +HEAPF32[$y2 >> 2]) {
  HEAPF32[$den >> 2] = (+HEAPF32[$y2 >> 2] + +HEAPF32[$x2 >> 2] * .6784840226173401) * (+HEAPF32[$y2 >> 2] + +HEAPF32[$x2 >> 2] * .0859554186463356);
  HEAPF32[$retval >> 2] = -+HEAPF32[$x$addr >> 2] * +HEAPF32[$y$addr >> 2] * (+HEAPF32[$y2 >> 2] + +HEAPF32[$x2 >> 2] * .43157973885536194) / +HEAPF32[$den >> 2] + (+HEAPF32[$y$addr >> 2] < 0.0 ? -1.5707963705062866 : 1.5707963705062866);
  $30 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$30;
 } else {
  HEAPF32[$den15 >> 2] = (+HEAPF32[$x2 >> 2] + +HEAPF32[$y2 >> 2] * .6784840226173401) * (+HEAPF32[$x2 >> 2] + +HEAPF32[$y2 >> 2] * .0859554186463356);
  HEAPF32[$retval >> 2] = +HEAPF32[$x$addr >> 2] * +HEAPF32[$y$addr >> 2] * (+HEAPF32[$x2 >> 2] + +HEAPF32[$y2 >> 2] * .43157973885536194) / +HEAPF32[$den15 >> 2] + (+HEAPF32[$y$addr >> 2] < 0.0 ? -1.5707963705062866 : 1.5707963705062866) - (+HEAPF32[$x$addr >> 2] * +HEAPF32[$y$addr >> 2] < 0.0 ? -1.5707963705062866 : 1.5707963705062866);
  $30 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$30;
 }
 return +(0.0);
}

function _silk_inner_product_FLP($data1, $data2, $dataSize) {
 $data1 = $data1 | 0;
 $data2 = $data2 | 0;
 $dataSize = $dataSize | 0;
 var $data1$addr = 0, $data2$addr = 0, $dataSize$addr = 0, $i = 0, $result = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $data1$addr = sp + 20 | 0;
 $data2$addr = sp + 16 | 0;
 $dataSize$addr = sp + 12 | 0;
 $i = sp + 8 | 0;
 $result = sp;
 HEAP32[$data1$addr >> 2] = $data1;
 HEAP32[$data2$addr >> 2] = $data2;
 HEAP32[$dataSize$addr >> 2] = $dataSize;
 HEAPF64[$result >> 3] = 0.0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$dataSize$addr >> 2] | 0) - 3 | 0)) break;
  HEAPF64[$result >> 3] = +HEAPF64[$result >> 3] + (+HEAPF32[(HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 0 << 2) >> 2] * +HEAPF32[(HEAP32[$data2$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 0 << 2) >> 2] + +HEAPF32[(HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] * +HEAPF32[(HEAP32[$data2$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] + +HEAPF32[(HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2] * +HEAPF32[(HEAP32[$data2$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2] + +HEAPF32[(HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2] * +HEAPF32[(HEAP32[$data2$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2]);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$dataSize$addr >> 2] | 0)) break;
  HEAPF64[$result >> 3] = +HEAPF64[$result >> 3] + +HEAPF32[(HEAP32[$data1$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$data2$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return +(+HEAPF64[$result >> 3]);
}

function _silk_scale_vector_FLP($data1, $gain, $dataSize) {
 $data1 = $data1 | 0;
 $gain = +$gain;
 $dataSize = $dataSize | 0;
 var $arrayidx = 0, $arrayidx14 = 0, $arrayidx2 = 0, $arrayidx5 = 0, $arrayidx8 = 0, $data1$addr = 0, $dataSize$addr = 0, $dataSize4 = 0, $gain$addr = 0, $i = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $data1$addr = sp + 16 | 0;
 $gain$addr = sp + 12 | 0;
 $dataSize$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $dataSize4 = sp;
 HEAP32[$data1$addr >> 2] = $data1;
 HEAPF32[$gain$addr >> 2] = $gain;
 HEAP32[$dataSize$addr >> 2] = $dataSize;
 HEAP32[$dataSize4 >> 2] = HEAP32[$dataSize$addr >> 2] & 65532;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$dataSize4 >> 2] | 0)) break;
  $arrayidx = (HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 0 << 2) | 0;
  HEAPF32[$arrayidx >> 2] = +HEAPF32[$arrayidx >> 2] * +HEAPF32[$gain$addr >> 2];
  $arrayidx2 = (HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) | 0;
  HEAPF32[$arrayidx2 >> 2] = +HEAPF32[$arrayidx2 >> 2] * +HEAPF32[$gain$addr >> 2];
  $arrayidx5 = (HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) | 0;
  HEAPF32[$arrayidx5 >> 2] = +HEAPF32[$arrayidx5 >> 2] * +HEAPF32[$gain$addr >> 2];
  $arrayidx8 = (HEAP32[$data1$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) | 0;
  HEAPF32[$arrayidx8 >> 2] = +HEAPF32[$arrayidx8 >> 2] * +HEAPF32[$gain$addr >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$dataSize$addr >> 2] | 0)) break;
  $arrayidx14 = (HEAP32[$data1$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0;
  HEAPF32[$arrayidx14 >> 2] = +HEAPF32[$arrayidx14 >> 2] * +HEAPF32[$gain$addr >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _hysteresis_decision($val, $thresholds, $hysteresis, $N, $prev) {
 $val = +$val;
 $thresholds = $thresholds | 0;
 $hysteresis = $hysteresis | 0;
 $N = $N | 0;
 $prev = $prev | 0;
 var $27 = 0, $N$addr = 0, $hysteresis$addr = 0, $i = 0, $prev$addr = 0, $thresholds$addr = 0, $val$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $val$addr = sp + 20 | 0;
 $thresholds$addr = sp + 16 | 0;
 $hysteresis$addr = sp + 12 | 0;
 $N$addr = sp + 8 | 0;
 $prev$addr = sp + 4 | 0;
 $i = sp;
 HEAPF32[$val$addr >> 2] = $val;
 HEAP32[$thresholds$addr >> 2] = $thresholds;
 HEAP32[$hysteresis$addr >> 2] = $hysteresis;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$prev$addr >> 2] = $prev;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  if (+HEAPF32[$val$addr >> 2] < +HEAPF32[(HEAP32[$thresholds$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) break;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((HEAP32[$i >> 2] | 0) > (HEAP32[$prev$addr >> 2] | 0)) if (+HEAPF32[$val$addr >> 2] < +HEAPF32[(HEAP32[$thresholds$addr >> 2] | 0) + (HEAP32[$prev$addr >> 2] << 2) >> 2] + +HEAPF32[(HEAP32[$hysteresis$addr >> 2] | 0) + (HEAP32[$prev$addr >> 2] << 2) >> 2]) HEAP32[$i >> 2] = HEAP32[$prev$addr >> 2];
 if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$prev$addr >> 2] | 0)) {
  $27 = HEAP32[$i >> 2] | 0;
  STACKTOP = sp;
  return $27 | 0;
 }
 if (!(+HEAPF32[$val$addr >> 2] > +HEAPF32[(HEAP32[$thresholds$addr >> 2] | 0) + ((HEAP32[$prev$addr >> 2] | 0) - 1 << 2) >> 2] - +HEAPF32[(HEAP32[$hysteresis$addr >> 2] | 0) + ((HEAP32[$prev$addr >> 2] | 0) - 1 << 2) >> 2])) {
  $27 = HEAP32[$i >> 2] | 0;
  STACKTOP = sp;
  return $27 | 0;
 }
 HEAP32[$i >> 2] = HEAP32[$prev$addr >> 2];
 $27 = HEAP32[$i >> 2] | 0;
 STACKTOP = sp;
 return $27 | 0;
}

function _compute_qn($N, $b, $offset, $pulse_cap, $stereo) {
 $N = $N | 0;
 $b = $b | 0;
 $offset = $offset | 0;
 $pulse_cap = $pulse_cap | 0;
 $stereo = $stereo | 0;
 var $21 = 0, $N$addr = 0, $N2 = 0, $add = 0, $b$addr = 0, $cond = 0, $offset$addr = 0, $pulse_cap$addr = 0, $qb = 0, $qn = 0, $stereo$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $N$addr = sp + 28 | 0;
 $b$addr = sp + 24 | 0;
 $offset$addr = sp + 20 | 0;
 $pulse_cap$addr = sp + 16 | 0;
 $stereo$addr = sp + 12 | 0;
 $qn = sp + 8 | 0;
 $qb = sp + 4 | 0;
 $N2 = sp;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$b$addr >> 2] = $b;
 HEAP32[$offset$addr >> 2] = $offset;
 HEAP32[$pulse_cap$addr >> 2] = $pulse_cap;
 HEAP32[$stereo$addr >> 2] = $stereo;
 HEAP32[$N2 >> 2] = (HEAP32[$N$addr >> 2] << 1) - 1;
 if ((HEAP32[$stereo$addr >> 2] | 0) != 0 & (HEAP32[$N$addr >> 2] | 0) == 2) HEAP32[$N2 >> 2] = (HEAP32[$N2 >> 2] | 0) + -1;
 $add = (HEAP32[$b$addr >> 2] | 0) + (Math_imul(HEAP32[$N2 >> 2] | 0, HEAP32[$offset$addr >> 2] | 0) | 0) | 0;
 HEAP32[$qb >> 2] = _celt_sudiv($add, HEAP32[$N2 >> 2] | 0) | 0;
 if (((HEAP32[$b$addr >> 2] | 0) - (HEAP32[$pulse_cap$addr >> 2] | 0) - 32 | 0) < (HEAP32[$qb >> 2] | 0)) $cond = (HEAP32[$b$addr >> 2] | 0) - (HEAP32[$pulse_cap$addr >> 2] | 0) - 32 | 0; else $cond = HEAP32[$qb >> 2] | 0;
 HEAP32[$qb >> 2] = $cond;
 HEAP32[$qb >> 2] = 64 < (HEAP32[$qb >> 2] | 0) ? 64 : HEAP32[$qb >> 2] | 0;
 if ((HEAP32[$qb >> 2] | 0) < 4) {
  HEAP32[$qn >> 2] = 1;
  $21 = HEAP32[$qn >> 2] | 0;
  STACKTOP = sp;
  return $21 | 0;
 } else {
  HEAP32[$qn >> 2] = HEAP16[23336 + ((HEAP32[$qb >> 2] & 7) << 1) >> 1] >> 14 - (HEAP32[$qb >> 2] >> 3);
  HEAP32[$qn >> 2] = (HEAP32[$qn >> 2] | 0) + 1 >> 1 << 1;
  $21 = HEAP32[$qn >> 2] | 0;
  STACKTOP = sp;
  return $21 | 0;
 }
 return 0;
}

function _haar1($X, $N0, $stride) {
 $X = $X | 0;
 $N0 = $N0 | 0;
 $stride = $stride | 0;
 var $N0$addr = 0, $X$addr = 0, $i = 0, $j = 0, $mul14 = 0, $mul19 = 0, $mul4 = 0, $mul8 = 0, $stride$addr = 0, $tmp1 = 0, $tmp2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $X$addr = sp + 24 | 0;
 $N0$addr = sp + 20 | 0;
 $stride$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $j = sp + 8 | 0;
 $tmp1 = sp + 4 | 0;
 $tmp2 = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N0$addr >> 2] = $N0;
 HEAP32[$stride$addr >> 2] = $stride;
 HEAP32[$N0$addr >> 2] = HEAP32[$N0$addr >> 2] >> 1;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$stride$addr >> 2] | 0)) break;
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N0$addr >> 2] | 0)) break;
   $mul4 = Math_imul(HEAP32[$stride$addr >> 2] << 1, HEAP32[$j >> 2] | 0) | 0;
   HEAPF32[$tmp1 >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ($mul4 + (HEAP32[$i >> 2] | 0) << 2) >> 2] * .7071067690849304;
   $mul8 = Math_imul(HEAP32[$stride$addr >> 2] | 0, (HEAP32[$j >> 2] << 1) + 1 | 0) | 0;
   HEAPF32[$tmp2 >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ($mul8 + (HEAP32[$i >> 2] | 0) << 2) >> 2] * .7071067690849304;
   $mul14 = Math_imul(HEAP32[$stride$addr >> 2] << 1, HEAP32[$j >> 2] | 0) | 0;
   HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ($mul14 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = +HEAPF32[$tmp1 >> 2] + +HEAPF32[$tmp2 >> 2];
   $mul19 = Math_imul(HEAP32[$stride$addr >> 2] | 0, (HEAP32[$j >> 2] << 1) + 1 | 0) | 0;
   HEAPF32[(HEAP32[$X$addr >> 2] | 0) + ($mul19 + (HEAP32[$i >> 2] | 0) << 2) >> 2] = +HEAPF32[$tmp1 >> 2] - +HEAPF32[$tmp2 >> 2];
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_resampler_private_AR2($S, $out_Q8, $in, $A_Q14, $len) {
 $S = $S | 0;
 $out_Q8 = $out_Q8 | 0;
 $in = $in | 0;
 $A_Q14 = $A_Q14 | 0;
 $len = $len | 0;
 var $A_Q14$addr = 0, $S$addr = 0, $add12 = 0, $add23 = 0, $in$addr = 0, $k = 0, $len$addr = 0, $mul = 0, $mul17 = 0, $out32 = 0, $out_Q8$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $S$addr = sp + 24 | 0;
 $out_Q8$addr = sp + 20 | 0;
 $in$addr = sp + 16 | 0;
 $A_Q14$addr = sp + 12 | 0;
 $len$addr = sp + 8 | 0;
 $k = sp + 4 | 0;
 $out32 = sp;
 HEAP32[$S$addr >> 2] = $S;
 HEAP32[$out_Q8$addr >> 2] = $out_Q8;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$A_Q14$addr >> 2] = $A_Q14;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  HEAP32[$out32 >> 2] = (HEAP32[HEAP32[$S$addr >> 2] >> 2] | 0) + (HEAP16[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] << 8);
  HEAP32[(HEAP32[$out_Q8$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = HEAP32[$out32 >> 2];
  HEAP32[$out32 >> 2] = HEAP32[$out32 >> 2] << 2;
  $mul = Math_imul(HEAP32[$out32 >> 2] >> 16, HEAP16[HEAP32[$A_Q14$addr >> 2] >> 1] | 0) | 0;
  $add12 = (HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] | 0) + ($mul + ((Math_imul(HEAP32[$out32 >> 2] & 65535, HEAP16[HEAP32[$A_Q14$addr >> 2] >> 1] | 0) | 0) >> 16)) | 0;
  HEAP32[HEAP32[$S$addr >> 2] >> 2] = $add12;
  $mul17 = Math_imul(HEAP32[$out32 >> 2] >> 16, HEAP16[(HEAP32[$A_Q14$addr >> 2] | 0) + 2 >> 1] | 0) | 0;
  $add23 = $mul17 + ((Math_imul(HEAP32[$out32 >> 2] & 65535, HEAP16[(HEAP32[$A_Q14$addr >> 2] | 0) + 2 >> 1] | 0) | 0) >> 16) | 0;
  HEAP32[(HEAP32[$S$addr >> 2] | 0) + 4 >> 2] = $add23;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_LP_variable_cutoff($psLP, $frame, $frame_length) {
 $psLP = $psLP | 0;
 $frame = $frame | 0;
 $frame_length = $frame_length | 0;
 var $A_Q28 = 0, $B_Q28 = 0, $cond17 = 0, $fac_Q16 = 0, $frame$addr = 0, $frame_length$addr = 0, $ind = 0, $psLP$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $psLP$addr = sp + 36 | 0;
 $frame$addr = sp + 32 | 0;
 $frame_length$addr = sp + 28 | 0;
 $B_Q28 = sp + 16 | 0;
 $A_Q28 = sp + 8 | 0;
 $fac_Q16 = sp + 4 | 0;
 $ind = sp;
 HEAP32[$psLP$addr >> 2] = $psLP;
 HEAP32[$frame$addr >> 2] = $frame;
 HEAP32[$frame_length$addr >> 2] = $frame_length;
 HEAP32[$fac_Q16 >> 2] = 0;
 HEAP32[$ind >> 2] = 0;
 if (!(HEAP32[(HEAP32[$psLP$addr >> 2] | 0) + 12 >> 2] | 0)) {
  STACKTOP = sp;
  return;
 }
 HEAP32[$fac_Q16 >> 2] = 256 - (HEAP32[(HEAP32[$psLP$addr >> 2] | 0) + 8 >> 2] | 0) << 10;
 HEAP32[$ind >> 2] = HEAP32[$fac_Q16 >> 2] >> 16;
 HEAP32[$fac_Q16 >> 2] = (HEAP32[$fac_Q16 >> 2] | 0) - (HEAP32[$ind >> 2] << 16);
 _silk_LP_interpolate_filter_taps($B_Q28, $A_Q28, HEAP32[$ind >> 2] | 0, HEAP32[$fac_Q16 >> 2] | 0);
 if (((HEAP32[(HEAP32[$psLP$addr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[(HEAP32[$psLP$addr >> 2] | 0) + 12 >> 2] | 0) | 0) > 256) $cond17 = 256; else if (((HEAP32[(HEAP32[$psLP$addr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[(HEAP32[$psLP$addr >> 2] | 0) + 12 >> 2] | 0) | 0) < 0) $cond17 = 0; else $cond17 = (HEAP32[(HEAP32[$psLP$addr >> 2] | 0) + 8 >> 2] | 0) + (HEAP32[(HEAP32[$psLP$addr >> 2] | 0) + 12 >> 2] | 0) | 0;
 HEAP32[(HEAP32[$psLP$addr >> 2] | 0) + 8 >> 2] = $cond17;
 _silk_biquad_alt_stride1(HEAP32[$frame$addr >> 2] | 0, $B_Q28, $A_Q28, HEAP32[$psLP$addr >> 2] | 0, HEAP32[$frame$addr >> 2] | 0, HEAP32[$frame_length$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _ec_enc_icdf($_this, $_s, $_icdf, $_ftb) {
 $_this = $_this | 0;
 $_s = $_s | 0;
 $_icdf = $_icdf | 0;
 $_ftb = $_ftb | 0;
 var $26 = 0, $_ftb$addr = 0, $_icdf$addr = 0, $_s$addr = 0, $_this$addr = 0, $mul13 = 0, $mul9 = 0, $r = 0, $rng14 = 0, $sub2 = 0, $val = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 16 | 0;
 $_s$addr = sp + 12 | 0;
 $_icdf$addr = sp + 8 | 0;
 $_ftb$addr = sp + 4 | 0;
 $r = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_s$addr >> 2] = $_s;
 HEAP32[$_icdf$addr >> 2] = $_icdf;
 HEAP32[$_ftb$addr >> 2] = $_ftb;
 HEAP32[$r >> 2] = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) >>> (HEAP32[$_ftb$addr >> 2] | 0);
 if ((HEAP32[$_s$addr >> 2] | 0) > 0) {
  $sub2 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) - (Math_imul(HEAP32[$r >> 2] | 0, HEAPU8[(HEAP32[$_icdf$addr >> 2] | 0) + ((HEAP32[$_s$addr >> 2] | 0) - 1) >> 0] | 0) | 0) | 0;
  $val = (HEAP32[$_this$addr >> 2] | 0) + 32 | 0;
  HEAP32[$val >> 2] = (HEAP32[$val >> 2] | 0) + $sub2;
  $mul9 = Math_imul(HEAP32[$r >> 2] | 0, (HEAPU8[(HEAP32[$_icdf$addr >> 2] | 0) + ((HEAP32[$_s$addr >> 2] | 0) - 1) >> 0] | 0) - (HEAPU8[(HEAP32[$_icdf$addr >> 2] | 0) + (HEAP32[$_s$addr >> 2] | 0) >> 0] | 0) | 0) | 0;
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] = $mul9;
  $26 = HEAP32[$_this$addr >> 2] | 0;
  _ec_enc_normalize($26);
  STACKTOP = sp;
  return;
 } else {
  $mul13 = Math_imul(HEAP32[$r >> 2] | 0, HEAPU8[(HEAP32[$_icdf$addr >> 2] | 0) + (HEAP32[$_s$addr >> 2] | 0) >> 0] | 0) | 0;
  $rng14 = (HEAP32[$_this$addr >> 2] | 0) + 28 | 0;
  HEAP32[$rng14 >> 2] = (HEAP32[$rng14 >> 2] | 0) - $mul13;
  $26 = HEAP32[$_this$addr >> 2] | 0;
  _ec_enc_normalize($26);
  STACKTOP = sp;
  return;
 }
}

function _limit_coefs($coefs, $limit, $order) {
 $coefs = $coefs | 0;
 $limit = +$limit;
 $order = $order | 0;
 var $chirp = 0, $coefs$addr = 0, $i = 0, $ind = 0, $iter = 0, $limit$addr = 0, $maxabs = 0, $order$addr = 0, $tmp = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $coefs$addr = sp + 32 | 0;
 $limit$addr = sp + 28 | 0;
 $order$addr = sp + 24 | 0;
 $i = sp + 20 | 0;
 $iter = sp + 16 | 0;
 $ind = sp + 12 | 0;
 $tmp = sp + 8 | 0;
 $maxabs = sp + 4 | 0;
 $chirp = sp;
 HEAP32[$coefs$addr >> 2] = $coefs;
 HEAPF32[$limit$addr >> 2] = $limit;
 HEAP32[$order$addr >> 2] = $order;
 HEAP32[$ind >> 2] = 0;
 HEAP32[$iter >> 2] = 0;
 while (1) {
  if ((HEAP32[$iter >> 2] | 0) >= 10) {
   label = 10;
   break;
  }
  HEAPF32[$maxabs >> 2] = -1.0;
  HEAP32[$i >> 2] = 0;
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
   HEAPF32[$tmp >> 2] = +Math_abs(+(+HEAPF32[(HEAP32[$coefs$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]));
   if (+HEAPF32[$tmp >> 2] > +HEAPF32[$maxabs >> 2]) {
    HEAPF32[$maxabs >> 2] = +HEAPF32[$tmp >> 2];
    HEAP32[$ind >> 2] = HEAP32[$i >> 2];
   }
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  if (+HEAPF32[$maxabs >> 2] <= +HEAPF32[$limit$addr >> 2]) {
   label = 10;
   break;
  }
  HEAPF32[$chirp >> 2] = .9900000095367432 - (+(HEAP32[$iter >> 2] | 0) * .10000000149011612 + .800000011920929) * (+HEAPF32[$maxabs >> 2] - +HEAPF32[$limit$addr >> 2]) / (+HEAPF32[$maxabs >> 2] * +((HEAP32[$ind >> 2] | 0) + 1 | 0));
  _silk_bwexpander_FLP(HEAP32[$coefs$addr >> 2] | 0, HEAP32[$order$addr >> 2] | 0, +HEAPF32[$chirp >> 2]);
  HEAP32[$iter >> 2] = (HEAP32[$iter >> 2] | 0) + 1;
 }
 if ((label | 0) == 10) {
  STACKTOP = sp;
  return;
 }
}

function _opus_decoder_create($Fs, $channels, $error) {
 $Fs = $Fs | 0;
 $channels = $channels | 0;
 $error = $error | 0;
 var $22 = 0, $Fs$addr = 0, $channels$addr = 0, $error$addr = 0, $ret = 0, $retval = 0, $st = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $Fs$addr = sp + 16 | 0;
 $channels$addr = sp + 12 | 0;
 $error$addr = sp + 8 | 0;
 $ret = sp + 4 | 0;
 $st = sp;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$error$addr >> 2] = $error;
 if (!((HEAP32[$Fs$addr >> 2] | 0) != 48e3 & (HEAP32[$Fs$addr >> 2] | 0) != 24e3 & (HEAP32[$Fs$addr >> 2] | 0) != 16e3 & (HEAP32[$Fs$addr >> 2] | 0) != 12e3 & (HEAP32[$Fs$addr >> 2] | 0) != 8e3)) if (!((HEAP32[$channels$addr >> 2] | 0) != 1 & (HEAP32[$channels$addr >> 2] | 0) != 2)) {
  HEAP32[$st >> 2] = _opus_alloc(_opus_decoder_get_size(HEAP32[$channels$addr >> 2] | 0) | 0) | 0;
  if (!(HEAP32[$st >> 2] | 0)) {
   if (HEAP32[$error$addr >> 2] | 0) HEAP32[HEAP32[$error$addr >> 2] >> 2] = -7;
   HEAP32[$retval >> 2] = 0;
   $22 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $22 | 0;
  }
  HEAP32[$ret >> 2] = _opus_decoder_init(HEAP32[$st >> 2] | 0, HEAP32[$Fs$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
  if (HEAP32[$error$addr >> 2] | 0) HEAP32[HEAP32[$error$addr >> 2] >> 2] = HEAP32[$ret >> 2];
  if (HEAP32[$ret >> 2] | 0) {
   _opus_free(HEAP32[$st >> 2] | 0);
   HEAP32[$st >> 2] = 0;
  }
  HEAP32[$retval >> 2] = HEAP32[$st >> 2];
  $22 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $22 | 0;
 }
 if (HEAP32[$error$addr >> 2] | 0) HEAP32[HEAP32[$error$addr >> 2] >> 2] = -1;
 HEAP32[$retval >> 2] = 0;
 $22 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $22 | 0;
}

function _silk_LPC_analysis_filter_FLP($r_LPC, $PredCoef, $s, $length, $Order) {
 $r_LPC = $r_LPC | 0;
 $PredCoef = $PredCoef | 0;
 $s = $s | 0;
 $length = $length | 0;
 $Order = $Order | 0;
 var $Order$addr = 0, $PredCoef$addr = 0, $length$addr = 0, $r_LPC$addr = 0, $s$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $r_LPC$addr = sp + 16 | 0;
 $PredCoef$addr = sp + 12 | 0;
 $s$addr = sp + 8 | 0;
 $length$addr = sp + 4 | 0;
 $Order$addr = sp;
 HEAP32[$r_LPC$addr >> 2] = $r_LPC;
 HEAP32[$PredCoef$addr >> 2] = $PredCoef;
 HEAP32[$s$addr >> 2] = $s;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$Order$addr >> 2] = $Order;
 switch (HEAP32[$Order$addr >> 2] | 0) {
 case 6:
  {
   _silk_LPC_analysis_filter6_FLP(HEAP32[$r_LPC$addr >> 2] | 0, HEAP32[$PredCoef$addr >> 2] | 0, HEAP32[$s$addr >> 2] | 0, HEAP32[$length$addr >> 2] | 0);
   break;
  }
 case 8:
  {
   _silk_LPC_analysis_filter8_FLP(HEAP32[$r_LPC$addr >> 2] | 0, HEAP32[$PredCoef$addr >> 2] | 0, HEAP32[$s$addr >> 2] | 0, HEAP32[$length$addr >> 2] | 0);
   break;
  }
 case 10:
  {
   _silk_LPC_analysis_filter10_FLP(HEAP32[$r_LPC$addr >> 2] | 0, HEAP32[$PredCoef$addr >> 2] | 0, HEAP32[$s$addr >> 2] | 0, HEAP32[$length$addr >> 2] | 0);
   break;
  }
 case 12:
  {
   _silk_LPC_analysis_filter12_FLP(HEAP32[$r_LPC$addr >> 2] | 0, HEAP32[$PredCoef$addr >> 2] | 0, HEAP32[$s$addr >> 2] | 0, HEAP32[$length$addr >> 2] | 0);
   break;
  }
 case 16:
  {
   _silk_LPC_analysis_filter16_FLP(HEAP32[$r_LPC$addr >> 2] | 0, HEAP32[$PredCoef$addr >> 2] | 0, HEAP32[$s$addr >> 2] | 0, HEAP32[$length$addr >> 2] | 0);
   break;
  }
 default:
  {}
 }
 _memset(HEAP32[$r_LPC$addr >> 2] | 0, 0, HEAP32[$Order$addr >> 2] << 2 | 0) | 0;
 STACKTOP = sp;
 return;
}

function _loss_distortion($eBands, $oldEBands, $start, $end, $len, $C) {
 $eBands = $eBands | 0;
 $oldEBands = $oldEBands | 0;
 $start = $start | 0;
 $end = $end | 0;
 $len = $len | 0;
 $C = $C | 0;
 var $7 = 0.0, $C$addr = 0, $c = 0, $d = 0, $dist = 0, $eBands$addr = 0, $end$addr = 0, $i = 0, $inc6 = 0, $len$addr = 0, $oldEBands$addr = 0, $start$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $eBands$addr = sp + 36 | 0;
 $oldEBands$addr = sp + 32 | 0;
 $start$addr = sp + 28 | 0;
 $end$addr = sp + 24 | 0;
 $len$addr = sp + 20 | 0;
 $C$addr = sp + 16 | 0;
 $c = sp + 12 | 0;
 $i = sp + 8 | 0;
 $dist = sp + 4 | 0;
 $d = sp;
 HEAP32[$eBands$addr >> 2] = $eBands;
 HEAP32[$oldEBands$addr >> 2] = $oldEBands;
 HEAP32[$start$addr >> 2] = $start;
 HEAP32[$end$addr >> 2] = $end;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$C$addr >> 2] = $C;
 HEAPF32[$dist >> 2] = 0.0;
 HEAP32[$c >> 2] = 0;
 do {
  HEAP32[$i >> 2] = HEAP32[$start$addr >> 2];
  while (1) {
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$end$addr >> 2] | 0)) break;
   $7 = +HEAPF32[(HEAP32[$eBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$len$addr >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[$d >> 2] = $7 - +HEAPF32[(HEAP32[$oldEBands$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + (Math_imul(HEAP32[$c >> 2] | 0, HEAP32[$len$addr >> 2] | 0) | 0) << 2) >> 2];
   HEAPF32[$dist >> 2] = +HEAPF32[$dist >> 2] + +HEAPF32[$d >> 2] * +HEAPF32[$d >> 2];
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  $inc6 = (HEAP32[$c >> 2] | 0) + 1 | 0;
  HEAP32[$c >> 2] = $inc6;
 } while (($inc6 | 0) < (HEAP32[$C$addr >> 2] | 0));
 STACKTOP = sp;
 return +(200.0 < +HEAPF32[$dist >> 2] ? 200.0 : +HEAPF32[$dist >> 2]);
}

function _silk_LPC_analysis_filter6_FLP($r_LPC, $PredCoef, $s, $length) {
 $r_LPC = $r_LPC | 0;
 $PredCoef = $PredCoef | 0;
 $s = $s | 0;
 $length = $length | 0;
 var $LPC_pred = 0, $PredCoef$addr = 0, $ix = 0, $length$addr = 0, $r_LPC$addr = 0, $s$addr = 0, $s_ptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $r_LPC$addr = sp + 24 | 0;
 $PredCoef$addr = sp + 20 | 0;
 $s$addr = sp + 16 | 0;
 $length$addr = sp + 12 | 0;
 $ix = sp + 8 | 0;
 $LPC_pred = sp + 4 | 0;
 $s_ptr = sp;
 HEAP32[$r_LPC$addr >> 2] = $r_LPC;
 HEAP32[$PredCoef$addr >> 2] = $PredCoef;
 HEAP32[$s$addr >> 2] = $s;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$ix >> 2] = 6;
 while (1) {
  if ((HEAP32[$ix >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$s_ptr >> 2] = (HEAP32[$s$addr >> 2] | 0) + ((HEAP32[$ix >> 2] | 0) - 1 << 2);
  HEAPF32[$LPC_pred >> 2] = +HEAPF32[HEAP32[$s_ptr >> 2] >> 2] * +HEAPF32[HEAP32[$PredCoef$addr >> 2] >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -4 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 4 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -8 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 8 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -12 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 12 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -16 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 16 >> 2] + +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + -20 >> 2] * +HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + 20 >> 2];
  HEAPF32[(HEAP32[$r_LPC$addr >> 2] | 0) + (HEAP32[$ix >> 2] << 2) >> 2] = +HEAPF32[(HEAP32[$s_ptr >> 2] | 0) + 4 >> 2] - +HEAPF32[$LPC_pred >> 2];
  HEAP32[$ix >> 2] = (HEAP32[$ix >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _alg_unquant($X, $N, $K, $spread, $B, $dec, $gain) {
 $X = $X | 0;
 $N = $N | 0;
 $K = $K | 0;
 $spread = $spread | 0;
 $B = $B | 0;
 $dec = $dec | 0;
 $gain = +$gain;
 var $0 = 0, $16 = 0, $B$addr = 0, $K$addr = 0, $N$addr = 0, $Ryy = 0, $X$addr = 0, $collapse_mask = 0, $dec$addr = 0, $gain$addr = 0, $saved_stack = 0, $spread$addr = 0, $vla = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $X$addr = sp + 36 | 0;
 $N$addr = sp + 32 | 0;
 $K$addr = sp + 28 | 0;
 $spread$addr = sp + 24 | 0;
 $B$addr = sp + 20 | 0;
 $dec$addr = sp + 16 | 0;
 $gain$addr = sp + 12 | 0;
 $Ryy = sp + 8 | 0;
 $collapse_mask = sp + 4 | 0;
 $saved_stack = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$K$addr >> 2] = $K;
 HEAP32[$spread$addr >> 2] = $spread;
 HEAP32[$B$addr >> 2] = $B;
 HEAP32[$dec$addr >> 2] = $dec;
 HEAPF32[$gain$addr >> 2] = $gain;
 $0 = HEAP32[$N$addr >> 2] | 0;
 HEAP32[$saved_stack >> 2] = _llvm_stacksave() | 0;
 $vla = STACKTOP;
 STACKTOP = STACKTOP + ((1 * ($0 << 2) | 0) + 15 & -16) | 0;
 HEAPF32[$Ryy >> 2] = +_decode_pulses($vla, HEAP32[$N$addr >> 2] | 0, HEAP32[$K$addr >> 2] | 0, HEAP32[$dec$addr >> 2] | 0);
 _normalise_residual($vla, HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, +HEAPF32[$Ryy >> 2], +HEAPF32[$gain$addr >> 2]);
 _exp_rotation(HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0, -1, HEAP32[$B$addr >> 2] | 0, HEAP32[$K$addr >> 2] | 0, HEAP32[$spread$addr >> 2] | 0);
 HEAP32[$collapse_mask >> 2] = _extract_collapse_mask($vla, HEAP32[$N$addr >> 2] | 0, HEAP32[$B$addr >> 2] | 0) | 0;
 $16 = HEAP32[$collapse_mask >> 2] | 0;
 _llvm_stackrestore(HEAP32[$saved_stack >> 2] | 0);
 STACKTOP = sp;
 return $16 | 0;
}

function _silk_energy_FLP($data, $dataSize) {
 $data = $data | 0;
 $dataSize = $dataSize | 0;
 var $data$addr = 0, $dataSize$addr = 0, $i = 0, $result = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $data$addr = sp + 16 | 0;
 $dataSize$addr = sp + 12 | 0;
 $i = sp + 8 | 0;
 $result = sp;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$dataSize$addr >> 2] = $dataSize;
 HEAPF64[$result >> 3] = 0.0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$dataSize$addr >> 2] | 0) - 3 | 0)) break;
  HEAPF64[$result >> 3] = +HEAPF64[$result >> 3] + (+HEAPF32[(HEAP32[$data$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 0 << 2) >> 2] * +HEAPF32[(HEAP32[$data$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 0 << 2) >> 2] + +HEAPF32[(HEAP32[$data$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] * +HEAPF32[(HEAP32[$data$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 2) >> 2] + +HEAPF32[(HEAP32[$data$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2] * +HEAPF32[(HEAP32[$data$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 2 << 2) >> 2] + +HEAPF32[(HEAP32[$data$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2] * +HEAPF32[(HEAP32[$data$addr >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 3 << 2) >> 2]);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 4;
 }
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$dataSize$addr >> 2] | 0)) break;
  HEAPF64[$result >> 3] = +HEAPF64[$result >> 3] + +HEAPF32[(HEAP32[$data$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * +HEAPF32[(HEAP32[$data$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return +(+HEAPF64[$result >> 3]);
}

function _opus_custom_mode_create($Fs, $frame_size, $error) {
 $Fs = $Fs | 0;
 $frame_size = $frame_size | 0;
 $error = $error | 0;
 var $22 = 0, $Fs$addr = 0, $error$addr = 0, $frame_size$addr = 0, $i = 0, $j = 0, $retval = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $Fs$addr = sp + 16 | 0;
 $frame_size$addr = sp + 12 | 0;
 $error$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $j = sp;
 HEAP32[$Fs$addr >> 2] = $Fs;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$error$addr >> 2] = $error;
 HEAP32[$i >> 2] = 0;
 L1 : while (1) {
  if ((HEAP32[$i >> 2] | 0) >= 1) {
   label = 12;
   break;
  }
  HEAP32[$j >> 2] = 0;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) >= 4) break;
   if ((HEAP32[$Fs$addr >> 2] | 0) == (HEAP32[HEAP32[2980 + (HEAP32[$i >> 2] << 2) >> 2] >> 2] | 0)) if ((HEAP32[$frame_size$addr >> 2] << HEAP32[$j >> 2] | 0) == (Math_imul(HEAP32[(HEAP32[2980 + (HEAP32[$i >> 2] << 2) >> 2] | 0) + 44 >> 2] | 0, HEAP32[(HEAP32[2980 + (HEAP32[$i >> 2] << 2) >> 2] | 0) + 40 >> 2] | 0) | 0)) {
    label = 7;
    break L1;
   }
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
  }
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 if ((label | 0) == 7) {
  if (HEAP32[$error$addr >> 2] | 0) HEAP32[HEAP32[$error$addr >> 2] >> 2] = 0;
  HEAP32[$retval >> 2] = HEAP32[2980 + (HEAP32[$i >> 2] << 2) >> 2];
  $22 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $22 | 0;
 } else if ((label | 0) == 12) {
  if (HEAP32[$error$addr >> 2] | 0) HEAP32[HEAP32[$error$addr >> 2] >> 2] = -1;
  HEAP32[$retval >> 2] = 0;
  $22 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $22 | 0;
 }
 return 0;
}

function _memcpy(dest, src, num) {
 dest = dest | 0;
 src = src | 0;
 num = num | 0;
 var ret = 0, aligned_dest_end = 0, block_aligned_dest_end = 0, dest_end = 0;
 if ((num | 0) >= 196608) return _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0;
 ret = dest | 0;
 dest_end = dest + num | 0;
 if ((dest & 3) == (src & 3)) {
  while (dest & 3) {
   if (!num) return ret | 0;
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
   dest = dest + 1 | 0;
   src = src + 1 | 0;
   num = num - 1 | 0;
  }
  aligned_dest_end = dest_end & -4 | 0;
  block_aligned_dest_end = aligned_dest_end - 64 | 0;
  while ((dest | 0) <= (block_aligned_dest_end | 0)) {
   SIMD_Int32x4_store(HEAPU8, dest, SIMD_Int32x4_load(HEAPU8, src));
   SIMD_Int32x4_store(HEAPU8, dest + 16, SIMD_Int32x4_load(HEAPU8, src + 16));
   SIMD_Int32x4_store(HEAPU8, dest + 32, SIMD_Int32x4_load(HEAPU8, src + 32));
   SIMD_Int32x4_store(HEAPU8, dest + 48, SIMD_Int32x4_load(HEAPU8, src + 48));
   dest = dest + 64 | 0;
   src = src + 64 | 0;
  }
  while ((dest | 0) < (aligned_dest_end | 0)) {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  }
 } else {
  aligned_dest_end = dest_end - 4 | 0;
  while ((dest | 0) < (aligned_dest_end | 0)) {
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
   HEAP8[dest + 1 >> 0] = HEAP8[src + 1 >> 0] | 0;
   HEAP8[dest + 2 >> 0] = HEAP8[src + 2 >> 0] | 0;
   HEAP8[dest + 3 >> 0] = HEAP8[src + 3 >> 0] | 0;
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  }
 }
 while ((dest | 0) < (dest_end | 0)) {
  HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
  dest = dest + 1 | 0;
  src = src + 1 | 0;
 }
 return ret | 0;
}

function _ec_enc_patch_initial_bits($_this, $_val, $_nbits) {
 $_this = $_this | 0;
 $_val = $_val | 0;
 $_nbits = $_nbits | 0;
 var $14 = 0, $22 = 0, $5 = 0, $_nbits$addr = 0, $_this$addr = 0, $_val$addr = 0, $mask = 0, $shift = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 16 | 0;
 $_val$addr = sp + 12 | 0;
 $_nbits$addr = sp + 8 | 0;
 $shift = sp + 4 | 0;
 $mask = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_val$addr >> 2] = $_val;
 HEAP32[$_nbits$addr >> 2] = $_nbits;
 HEAP32[$shift >> 2] = 8 - (HEAP32[$_nbits$addr >> 2] | 0);
 HEAP32[$mask >> 2] = (1 << HEAP32[$_nbits$addr >> 2]) - 1 << HEAP32[$shift >> 2];
 $5 = HEAP32[$_this$addr >> 2] | 0;
 if ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] | 0) >>> 0 > 0) {
  HEAP8[HEAP32[HEAP32[$_this$addr >> 2] >> 2] >> 0] = (HEAPU8[HEAP32[$5 >> 2] >> 0] | 0) & ~HEAP32[$mask >> 2] | HEAP32[$_val$addr >> 2] << HEAP32[$shift >> 2];
  STACKTOP = sp;
  return;
 }
 $14 = HEAP32[$_this$addr >> 2] | 0;
 if ((HEAP32[$5 + 40 >> 2] | 0) >= 0) {
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2] = HEAP32[$14 + 40 >> 2] & ~HEAP32[$mask >> 2] | HEAP32[$_val$addr >> 2] << HEAP32[$shift >> 2];
  STACKTOP = sp;
  return;
 }
 $22 = HEAP32[$_this$addr >> 2] | 0;
 if ((HEAP32[$14 + 28 >> 2] | 0) >>> 0 <= -2147483648 >>> (HEAP32[$_nbits$addr >> 2] | 0) >>> 0) {
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] = HEAP32[$22 + 32 >> 2] & ~(HEAP32[$mask >> 2] << 23) | HEAP32[$_val$addr >> 2] << 23 + (HEAP32[$shift >> 2] | 0);
  STACKTOP = sp;
  return;
 } else {
  HEAP32[$22 + 44 >> 2] = -1;
  STACKTOP = sp;
  return;
 }
}

function _ec_encode_bin($_this, $_fl, $_fh, $_bits) {
 $_this = $_this | 0;
 $_fl = $_fl | 0;
 $_fh = $_fh | 0;
 $_bits = $_bits | 0;
 var $20 = 0, $_bits$addr = 0, $_fh$addr = 0, $_fl$addr = 0, $_this$addr = 0, $mul4 = 0, $mul8 = 0, $r = 0, $rng9 = 0, $sub2 = 0, $val = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 16 | 0;
 $_fl$addr = sp + 12 | 0;
 $_fh$addr = sp + 8 | 0;
 $_bits$addr = sp + 4 | 0;
 $r = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_fl$addr >> 2] = $_fl;
 HEAP32[$_fh$addr >> 2] = $_fh;
 HEAP32[$_bits$addr >> 2] = $_bits;
 HEAP32[$r >> 2] = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) >>> (HEAP32[$_bits$addr >> 2] | 0);
 if ((HEAP32[$_fl$addr >> 2] | 0) >>> 0 > 0) {
  $sub2 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) - (Math_imul(HEAP32[$r >> 2] | 0, (1 << HEAP32[$_bits$addr >> 2]) - (HEAP32[$_fl$addr >> 2] | 0) | 0) | 0) | 0;
  $val = (HEAP32[$_this$addr >> 2] | 0) + 32 | 0;
  HEAP32[$val >> 2] = (HEAP32[$val >> 2] | 0) + $sub2;
  $mul4 = Math_imul(HEAP32[$r >> 2] | 0, (HEAP32[$_fh$addr >> 2] | 0) - (HEAP32[$_fl$addr >> 2] | 0) | 0) | 0;
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] = $mul4;
  $20 = HEAP32[$_this$addr >> 2] | 0;
  _ec_enc_normalize($20);
  STACKTOP = sp;
  return;
 } else {
  $mul8 = Math_imul(HEAP32[$r >> 2] | 0, (1 << HEAP32[$_bits$addr >> 2]) - (HEAP32[$_fh$addr >> 2] | 0) | 0) | 0;
  $rng9 = (HEAP32[$_this$addr >> 2] | 0) + 28 | 0;
  HEAP32[$rng9 >> 2] = (HEAP32[$rng9 >> 2] | 0) - $mul8;
  $20 = HEAP32[$_this$addr >> 2] | 0;
  _ec_enc_normalize($20);
  STACKTOP = sp;
  return;
 }
}

function _extract_collapse_mask($iy, $N, $B) {
 $iy = $iy | 0;
 $N = $N | 0;
 $B = $B | 0;
 var $17 = 0, $B$addr = 0, $N$addr = 0, $N0 = 0, $collapse_mask = 0, $i = 0, $inc = 0, $inc6 = 0, $iy$addr = 0, $j = 0, $mul = 0, $retval = 0, $tmp = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $retval = sp + 32 | 0;
 $iy$addr = sp + 28 | 0;
 $N$addr = sp + 24 | 0;
 $B$addr = sp + 20 | 0;
 $collapse_mask = sp + 16 | 0;
 $N0 = sp + 12 | 0;
 $i = sp + 8 | 0;
 $j = sp + 4 | 0;
 $tmp = sp;
 HEAP32[$iy$addr >> 2] = $iy;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$B$addr >> 2] = $B;
 if ((HEAP32[$B$addr >> 2] | 0) <= 1) {
  HEAP32[$retval >> 2] = 1;
  $17 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $17 | 0;
 }
 HEAP32[$N0 >> 2] = _celt_udiv_139(HEAP32[$N$addr >> 2] | 0, HEAP32[$B$addr >> 2] | 0) | 0;
 HEAP32[$collapse_mask >> 2] = 0;
 HEAP32[$i >> 2] = 0;
 do {
  HEAP32[$tmp >> 2] = 0;
  HEAP32[$j >> 2] = 0;
  do {
   $mul = Math_imul(HEAP32[$i >> 2] | 0, HEAP32[$N0 >> 2] | 0) | 0;
   HEAP32[$tmp >> 2] = HEAP32[$tmp >> 2] | HEAP32[(HEAP32[$iy$addr >> 2] | 0) + ($mul + (HEAP32[$j >> 2] | 0) << 2) >> 2];
   $inc = (HEAP32[$j >> 2] | 0) + 1 | 0;
   HEAP32[$j >> 2] = $inc;
  } while (($inc | 0) < (HEAP32[$N0 >> 2] | 0));
  HEAP32[$collapse_mask >> 2] = HEAP32[$collapse_mask >> 2] | ((HEAP32[$tmp >> 2] | 0) != 0 & 1) << HEAP32[$i >> 2];
  $inc6 = (HEAP32[$i >> 2] | 0) + 1 | 0;
  HEAP32[$i >> 2] = $inc6;
 } while (($inc6 | 0) < (HEAP32[$B$addr >> 2] | 0));
 HEAP32[$retval >> 2] = HEAP32[$collapse_mask >> 2];
 $17 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $17 | 0;
}

function _ec_encode($_this, $_fl, $_fh, $_ft) {
 $_this = $_this | 0;
 $_fl = $_fl | 0;
 $_fh = $_fh | 0;
 $_ft = $_ft | 0;
 var $20 = 0, $_fh$addr = 0, $_fl$addr = 0, $_ft$addr = 0, $_this$addr = 0, $mul4 = 0, $mul7 = 0, $r = 0, $rng8 = 0, $sub2 = 0, $val = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 16 | 0;
 $_fl$addr = sp + 12 | 0;
 $_fh$addr = sp + 8 | 0;
 $_ft$addr = sp + 4 | 0;
 $r = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_fl$addr >> 2] = $_fl;
 HEAP32[$_fh$addr >> 2] = $_fh;
 HEAP32[$_ft$addr >> 2] = $_ft;
 HEAP32[$r >> 2] = _celt_udiv_83(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0, HEAP32[$_ft$addr >> 2] | 0) | 0;
 if ((HEAP32[$_fl$addr >> 2] | 0) >>> 0 > 0) {
  $sub2 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) - (Math_imul(HEAP32[$r >> 2] | 0, (HEAP32[$_ft$addr >> 2] | 0) - (HEAP32[$_fl$addr >> 2] | 0) | 0) | 0) | 0;
  $val = (HEAP32[$_this$addr >> 2] | 0) + 32 | 0;
  HEAP32[$val >> 2] = (HEAP32[$val >> 2] | 0) + $sub2;
  $mul4 = Math_imul(HEAP32[$r >> 2] | 0, (HEAP32[$_fh$addr >> 2] | 0) - (HEAP32[$_fl$addr >> 2] | 0) | 0) | 0;
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] = $mul4;
  $20 = HEAP32[$_this$addr >> 2] | 0;
  _ec_enc_normalize($20);
  STACKTOP = sp;
  return;
 } else {
  $mul7 = Math_imul(HEAP32[$r >> 2] | 0, (HEAP32[$_ft$addr >> 2] | 0) - (HEAP32[$_fh$addr >> 2] | 0) | 0) | 0;
  $rng8 = (HEAP32[$_this$addr >> 2] | 0) + 28 | 0;
  HEAP32[$rng8 >> 2] = (HEAP32[$rng8 >> 2] | 0) - $mul7;
  $20 = HEAP32[$_this$addr >> 2] | 0;
  _ec_enc_normalize($20);
  STACKTOP = sp;
  return;
 }
}

function _ec_enc_carry_out($_this, $_c) {
 $_this = $_this | 0;
 $_c = $_c | 0;
 var $_c$addr = 0, $_this$addr = 0, $call = 0, $call7 = 0, $carry = 0, $dec = 0, $error = 0, $error8 = 0, $ext10 = 0, $ext15 = 0, $sym = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp + 12 | 0;
 $_c$addr = sp + 8 | 0;
 $carry = sp + 4 | 0;
 $sym = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_c$addr >> 2] = $_c;
 if ((HEAP32[$_c$addr >> 2] | 0) == 255) {
  $ext15 = (HEAP32[$_this$addr >> 2] | 0) + 36 | 0;
  HEAP32[$ext15 >> 2] = (HEAP32[$ext15 >> 2] | 0) + 1;
  STACKTOP = sp;
  return;
 }
 HEAP32[$carry >> 2] = HEAP32[$_c$addr >> 2] >> 8;
 if ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2] | 0) >= 0) {
  $call = _ec_write_byte(HEAP32[$_this$addr >> 2] | 0, (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2] | 0) + (HEAP32[$carry >> 2] | 0) | 0) | 0;
  $error = (HEAP32[$_this$addr >> 2] | 0) + 44 | 0;
  HEAP32[$error >> 2] = HEAP32[$error >> 2] | $call;
 }
 if ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 36 >> 2] | 0) >>> 0 > 0) {
  HEAP32[$sym >> 2] = 255 + (HEAP32[$carry >> 2] | 0) & 255;
  do {
   $call7 = _ec_write_byte(HEAP32[$_this$addr >> 2] | 0, HEAP32[$sym >> 2] | 0) | 0;
   $error8 = (HEAP32[$_this$addr >> 2] | 0) + 44 | 0;
   HEAP32[$error8 >> 2] = HEAP32[$error8 >> 2] | $call7;
   $ext10 = (HEAP32[$_this$addr >> 2] | 0) + 36 | 0;
   $dec = (HEAP32[$ext10 >> 2] | 0) + -1 | 0;
   HEAP32[$ext10 >> 2] = $dec;
  } while ($dec >>> 0 > 0);
 }
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2] = HEAP32[$_c$addr >> 2] & 255;
 STACKTOP = sp;
 return;
}

function _ec_enc_bits($_this, $_fl, $_bits) {
 $_this = $_this | 0;
 $_fl = $_fl | 0;
 $_bits = $_bits | 0;
 var $_bits$addr = 0, $_fl$addr = 0, $_this$addr = 0, $call = 0, $error = 0, $nbits_total = 0, $used = 0, $window = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 16 | 0;
 $_fl$addr = sp + 12 | 0;
 $_bits$addr = sp + 8 | 0;
 $window = sp + 4 | 0;
 $used = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_fl$addr >> 2] = $_fl;
 HEAP32[$_bits$addr >> 2] = $_bits;
 HEAP32[$window >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 12 >> 2];
 HEAP32[$used >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 16 >> 2];
 if (((HEAP32[$used >> 2] | 0) + (HEAP32[$_bits$addr >> 2] | 0) | 0) >>> 0 > 32) do {
  $call = _ec_write_byte_at_end(HEAP32[$_this$addr >> 2] | 0, HEAP32[$window >> 2] & 255) | 0;
  $error = (HEAP32[$_this$addr >> 2] | 0) + 44 | 0;
  HEAP32[$error >> 2] = HEAP32[$error >> 2] | $call;
  HEAP32[$window >> 2] = (HEAP32[$window >> 2] | 0) >>> 8;
  HEAP32[$used >> 2] = (HEAP32[$used >> 2] | 0) - 8;
 } while ((HEAP32[$used >> 2] | 0) >= 8);
 HEAP32[$window >> 2] = HEAP32[$window >> 2] | HEAP32[$_fl$addr >> 2] << HEAP32[$used >> 2];
 HEAP32[$used >> 2] = (HEAP32[$used >> 2] | 0) + (HEAP32[$_bits$addr >> 2] | 0);
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 12 >> 2] = HEAP32[$window >> 2];
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 16 >> 2] = HEAP32[$used >> 2];
 $nbits_total = (HEAP32[$_this$addr >> 2] | 0) + 20 | 0;
 HEAP32[$nbits_total >> 2] = (HEAP32[$nbits_total >> 2] | 0) + (HEAP32[$_bits$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _user_bitrate_to_bitrate($st, $frame_size, $max_data_bytes) {
 $st = $st | 0;
 $frame_size = $frame_size | 0;
 $max_data_bytes = $max_data_bytes | 0;
 var $19 = 0, $5 = 0, $frame_size$addr = 0, $max_data_bytes$addr = 0, $mul11 = 0, $retval = 0, $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $retval = sp + 12 | 0;
 $st$addr = sp + 8 | 0;
 $frame_size$addr = sp + 4 | 0;
 $max_data_bytes$addr = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$max_data_bytes$addr >> 2] = $max_data_bytes;
 if (!(HEAP32[$frame_size$addr >> 2] | 0)) HEAP32[$frame_size$addr >> 2] = (HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) / 400 | 0;
 $5 = HEAP32[$st$addr >> 2] | 0;
 if ((HEAP32[(HEAP32[$st$addr >> 2] | 0) + 164 >> 2] | 0) == -1e3) {
  HEAP32[$retval >> 2] = (((HEAP32[$5 + 144 >> 2] | 0) * 60 | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0) + (Math_imul(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0) | 0);
  $19 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $19 | 0;
 }
 if ((HEAP32[$5 + 164 >> 2] | 0) == -1) {
  $mul11 = Math_imul(HEAP32[$max_data_bytes$addr >> 2] << 3, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) | 0;
  HEAP32[$retval >> 2] = ($mul11 | 0) / (HEAP32[$frame_size$addr >> 2] | 0) | 0;
  $19 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $19 | 0;
 } else {
  HEAP32[$retval >> 2] = HEAP32[(HEAP32[$st$addr >> 2] | 0) + 164 >> 2];
  $19 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $19 | 0;
 }
 return 0;
}

function _silk_VAD_Init($psSilk_VAD) {
 $psSilk_VAD = $psSilk_VAD | 0;
 var $7 = 0, $b = 0, $call = 0, $psSilk_VAD$addr = 0, $ret = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psSilk_VAD$addr = sp + 8 | 0;
 $b = sp + 4 | 0;
 $ret = sp;
 HEAP32[$psSilk_VAD$addr >> 2] = $psSilk_VAD;
 HEAP32[$ret >> 2] = 0;
 dest = HEAP32[$psSilk_VAD$addr >> 2] | 0;
 stop = dest + 112 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  $call = _silk_max_32_448(50 / ((HEAP32[$b >> 2] | 0) + 1 | 0) | 0, 1) | 0;
  HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 92 + (HEAP32[$b >> 2] << 2) >> 2] = $call;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 HEAP32[$b >> 2] = 0;
 while (1) {
  $7 = HEAP32[$psSilk_VAD$addr >> 2] | 0;
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] = (HEAP32[$7 + 92 + (HEAP32[$b >> 2] << 2) >> 2] | 0) * 100;
  HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 76 + (HEAP32[$b >> 2] << 2) >> 2] = 2147483647 / (HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 60 + (HEAP32[$b >> 2] << 2) >> 2] | 0) | 0;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 HEAP32[$7 + 108 >> 2] = 15;
 HEAP32[$b >> 2] = 0;
 while (1) {
  if ((HEAP32[$b >> 2] | 0) >= 4) break;
  HEAP32[(HEAP32[$psSilk_VAD$addr >> 2] | 0) + 40 + (HEAP32[$b >> 2] << 2) >> 2] = 25600;
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _silk_k2a_FLP($A, $rc, $order) {
 $A = $A | 0;
 $rc = $rc | 0;
 $order = $order | 0;
 var $A$addr = 0, $k = 0, $n = 0, $order$addr = 0, $rc$addr = 0, $rck = 0, $tmp1 = 0, $tmp2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $A$addr = sp + 28 | 0;
 $rc$addr = sp + 24 | 0;
 $order$addr = sp + 20 | 0;
 $k = sp + 16 | 0;
 $n = sp + 12 | 0;
 $rck = sp + 8 | 0;
 $tmp1 = sp + 4 | 0;
 $tmp2 = sp;
 HEAP32[$A$addr >> 2] = $A;
 HEAP32[$rc$addr >> 2] = $rc;
 HEAP32[$order$addr >> 2] = $order;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
  HEAPF32[$rck >> 2] = +HEAPF32[(HEAP32[$rc$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2];
  HEAP32[$n >> 2] = 0;
  while (1) {
   if ((HEAP32[$n >> 2] | 0) >= ((HEAP32[$k >> 2] | 0) + 1 >> 1 | 0)) break;
   HEAPF32[$tmp1 >> 2] = +HEAPF32[(HEAP32[$A$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2];
   HEAPF32[$tmp2 >> 2] = +HEAPF32[(HEAP32[$A$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - (HEAP32[$n >> 2] | 0) - 1 << 2) >> 2];
   HEAPF32[(HEAP32[$A$addr >> 2] | 0) + (HEAP32[$n >> 2] << 2) >> 2] = +HEAPF32[$tmp1 >> 2] + +HEAPF32[$tmp2 >> 2] * +HEAPF32[$rck >> 2];
   HEAPF32[(HEAP32[$A$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - (HEAP32[$n >> 2] | 0) - 1 << 2) >> 2] = +HEAPF32[$tmp2 >> 2] + +HEAPF32[$tmp1 >> 2] * +HEAPF32[$rck >> 2];
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
  }
  HEAPF32[(HEAP32[$A$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = -+HEAPF32[$rck >> 2];
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _combine_and_check($pulses_comb, $pulses_in, $max_pulses, $len) {
 $pulses_comb = $pulses_comb | 0;
 $pulses_in = $pulses_in | 0;
 $max_pulses = $max_pulses | 0;
 $len = $len | 0;
 var $14 = 0, $k = 0, $len$addr = 0, $max_pulses$addr = 0, $pulses_comb$addr = 0, $pulses_in$addr = 0, $retval = 0, $sum = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 24 | 0;
 $pulses_comb$addr = sp + 20 | 0;
 $pulses_in$addr = sp + 16 | 0;
 $max_pulses$addr = sp + 12 | 0;
 $len$addr = sp + 8 | 0;
 $k = sp + 4 | 0;
 $sum = sp;
 HEAP32[$pulses_comb$addr >> 2] = $pulses_comb;
 HEAP32[$pulses_in$addr >> 2] = $pulses_in;
 HEAP32[$max_pulses$addr >> 2] = $max_pulses;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) {
   label = 6;
   break;
  }
  HEAP32[$sum >> 2] = (HEAP32[(HEAP32[$pulses_in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1 << 2) >> 2] | 0) + (HEAP32[(HEAP32[$pulses_in$addr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 1 << 2) >> 2] | 0);
  if ((HEAP32[$sum >> 2] | 0) > (HEAP32[$max_pulses$addr >> 2] | 0)) {
   label = 4;
   break;
  }
  HEAP32[(HEAP32[$pulses_comb$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = HEAP32[$sum >> 2];
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 if ((label | 0) == 4) {
  HEAP32[$retval >> 2] = 1;
  $14 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $14 | 0;
 } else if ((label | 0) == 6) {
  HEAP32[$retval >> 2] = 0;
  $14 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $14 | 0;
 }
 return 0;
}

function _silk_CNG_exc($exc_Q14, $exc_buf_Q14, $length, $rand_seed) {
 $exc_Q14 = $exc_Q14 | 0;
 $exc_buf_Q14 = $exc_buf_Q14 | 0;
 $length = $length | 0;
 $rand_seed = $rand_seed | 0;
 var $7 = 0, $exc_Q14$addr = 0, $exc_buf_Q14$addr = 0, $exc_mask = 0, $i = 0, $idx = 0, $length$addr = 0, $rand_seed$addr = 0, $seed = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $exc_Q14$addr = sp + 28 | 0;
 $exc_buf_Q14$addr = sp + 24 | 0;
 $length$addr = sp + 20 | 0;
 $rand_seed$addr = sp + 16 | 0;
 $seed = sp + 12 | 0;
 $i = sp + 8 | 0;
 $idx = sp + 4 | 0;
 $exc_mask = sp;
 HEAP32[$exc_Q14$addr >> 2] = $exc_Q14;
 HEAP32[$exc_buf_Q14$addr >> 2] = $exc_buf_Q14;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$rand_seed$addr >> 2] = $rand_seed;
 HEAP32[$exc_mask >> 2] = 255;
 while (1) {
  if ((HEAP32[$exc_mask >> 2] | 0) <= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$exc_mask >> 2] = HEAP32[$exc_mask >> 2] >> 1;
 }
 HEAP32[$seed >> 2] = HEAP32[HEAP32[$rand_seed$addr >> 2] >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  $7 = HEAP32[$seed >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$length$addr >> 2] | 0)) break;
  HEAP32[$seed >> 2] = 907633515 + (Math_imul($7, 196314165) | 0);
  HEAP32[$idx >> 2] = HEAP32[$seed >> 2] >> 24 & HEAP32[$exc_mask >> 2];
  HEAP32[(HEAP32[$exc_Q14$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = HEAP32[(HEAP32[$exc_buf_Q14$addr >> 2] | 0) + (HEAP32[$idx >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[HEAP32[$rand_seed$addr >> 2] >> 2] = $7;
 STACKTOP = sp;
 return;
}

function _ec_dec_bits($_this, $_bits) {
 $_this = $_this | 0;
 $_bits = $_bits | 0;
 var $_bits$addr = 0, $_this$addr = 0, $available = 0, $call = 0, $nbits_total = 0, $ret = 0, $window = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 16 | 0;
 $_bits$addr = sp + 12 | 0;
 $window = sp + 8 | 0;
 $available = sp + 4 | 0;
 $ret = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_bits$addr >> 2] = $_bits;
 HEAP32[$window >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 12 >> 2];
 HEAP32[$available >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 16 >> 2];
 if ((HEAP32[$available >> 2] | 0) >>> 0 < (HEAP32[$_bits$addr >> 2] | 0) >>> 0) do {
  $call = _ec_read_byte_from_end(HEAP32[$_this$addr >> 2] | 0) | 0;
  HEAP32[$window >> 2] = HEAP32[$window >> 2] | $call << HEAP32[$available >> 2];
  HEAP32[$available >> 2] = (HEAP32[$available >> 2] | 0) + 8;
 } while ((HEAP32[$available >> 2] | 0) <= 24);
 HEAP32[$ret >> 2] = HEAP32[$window >> 2] & (1 << HEAP32[$_bits$addr >> 2]) - 1;
 HEAP32[$window >> 2] = (HEAP32[$window >> 2] | 0) >>> (HEAP32[$_bits$addr >> 2] | 0);
 HEAP32[$available >> 2] = (HEAP32[$available >> 2] | 0) - (HEAP32[$_bits$addr >> 2] | 0);
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 12 >> 2] = HEAP32[$window >> 2];
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 16 >> 2] = HEAP32[$available >> 2];
 $nbits_total = (HEAP32[$_this$addr >> 2] | 0) + 20 | 0;
 HEAP32[$nbits_total >> 2] = (HEAP32[$nbits_total >> 2] | 0) + (HEAP32[$_bits$addr >> 2] | 0);
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _silk_LTP_scale_ctrl_FLP($psEnc, $psEncCtrl, $condCoding) {
 $psEnc = $psEnc | 0;
 $psEncCtrl = $psEncCtrl | 0;
 $condCoding = $condCoding | 0;
 var $$sink = 0, $1 = 0, $cond18 = 0.0, $condCoding$addr = 0, $psEnc$addr = 0, $psEncCtrl$addr = 0, $round_loss = 0, $sCmn$sink = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psEnc$addr = sp + 12 | 0;
 $psEncCtrl$addr = sp + 8 | 0;
 $condCoding$addr = sp + 4 | 0;
 $round_loss = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$psEncCtrl$addr >> 2] = $psEncCtrl;
 HEAP32[$condCoding$addr >> 2] = $condCoding;
 $1 = HEAP32[$psEnc$addr >> 2] | 0;
 if (!(HEAP32[$condCoding$addr >> 2] | 0)) {
  HEAP32[$round_loss >> 2] = (HEAP32[$1 + 4612 >> 2] | 0) + (HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5740 >> 2] | 0);
  if (+(HEAP32[$round_loss >> 2] | 0) * +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 708 >> 2] * .10000000149011612 > 2.0) $cond18 = 2.0; else if (+(HEAP32[$round_loss >> 2] | 0) * +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 708 >> 2] * .10000000149011612 < 0.0) $cond18 = 0.0; else $cond18 = +(HEAP32[$round_loss >> 2] | 0) * +HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 708 >> 2] * .10000000149011612;
  $$sink = ~~$cond18;
  $sCmn$sink = HEAP32[$psEnc$addr >> 2] | 0;
 } else {
  $$sink = 0;
  $sCmn$sink = $1;
 }
 HEAP8[$sCmn$sink + 4732 + 33 >> 0] = $$sink;
 HEAPF32[(HEAP32[$psEncCtrl$addr >> 2] | 0) + 224 >> 2] = +(HEAP16[22964 + (HEAP8[(HEAP32[$psEnc$addr >> 2] | 0) + 4732 + 33 >> 0] << 1) >> 1] | 0) / 16384.0;
 STACKTOP = sp;
 return;
}

function _ec_dec_update($_this, $_fl, $_fh, $_ft) {
 $_this = $_this | 0;
 $_fl = $_fl | 0;
 $_fh = $_fh | 0;
 $_ft = $_ft | 0;
 var $14 = 0, $15 = 0, $8 = 0, $_fh$addr = 0, $_fl$addr = 0, $_ft$addr = 0, $_this$addr = 0, $cond = 0, $rng6 = 0, $s = 0, $val = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 16 | 0;
 $_fl$addr = sp + 12 | 0;
 $_fh$addr = sp + 8 | 0;
 $_ft$addr = sp + 4 | 0;
 $s = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_fl$addr >> 2] = $_fl;
 HEAP32[$_fh$addr >> 2] = $_fh;
 HEAP32[$_ft$addr >> 2] = $_ft;
 HEAP32[$s >> 2] = Math_imul(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 36 >> 2] | 0, (HEAP32[$_ft$addr >> 2] | 0) - (HEAP32[$_fh$addr >> 2] | 0) | 0) | 0;
 $val = (HEAP32[$_this$addr >> 2] | 0) + 32 | 0;
 HEAP32[$val >> 2] = (HEAP32[$val >> 2] | 0) - (HEAP32[$s >> 2] | 0);
 $8 = HEAP32[$_this$addr >> 2] | 0;
 if ((HEAP32[$_fl$addr >> 2] | 0) >>> 0 > 0) {
  $cond = Math_imul(HEAP32[$8 + 36 >> 2] | 0, (HEAP32[$_fh$addr >> 2] | 0) - (HEAP32[$_fl$addr >> 2] | 0) | 0) | 0;
  $14 = HEAP32[$_this$addr >> 2] | 0;
  $rng6 = $14 + 28 | 0;
  HEAP32[$rng6 >> 2] = $cond;
  $15 = HEAP32[$_this$addr >> 2] | 0;
  _ec_dec_normalize($15);
  STACKTOP = sp;
  return;
 } else {
  $cond = (HEAP32[$8 + 28 >> 2] | 0) - (HEAP32[$s >> 2] | 0) | 0;
  $14 = HEAP32[$_this$addr >> 2] | 0;
  $rng6 = $14 + 28 | 0;
  HEAP32[$rng6 >> 2] = $cond;
  $15 = HEAP32[$_this$addr >> 2] | 0;
  _ec_dec_normalize($15);
  STACKTOP = sp;
  return;
 }
}

function _ec_dec_bit_logp($_this, $_logp) {
 $_this = $_this | 0;
 $_logp = $_logp | 0;
 var $16 = 0, $17 = 0, $18 = 0, $_logp$addr = 0, $_this$addr = 0, $cond = 0, $d = 0, $r = 0, $ret = 0, $rng4 = 0, $s = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 20 | 0;
 $_logp$addr = sp + 16 | 0;
 $r = sp + 12 | 0;
 $d = sp + 8 | 0;
 $s = sp + 4 | 0;
 $ret = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_logp$addr >> 2] = $_logp;
 HEAP32[$r >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2];
 HEAP32[$d >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$s >> 2] = (HEAP32[$r >> 2] | 0) >>> (HEAP32[$_logp$addr >> 2] | 0);
 HEAP32[$ret >> 2] = (HEAP32[$d >> 2] | 0) >>> 0 < (HEAP32[$s >> 2] | 0) >>> 0 & 1;
 if (!(HEAP32[$ret >> 2] | 0)) HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] = (HEAP32[$d >> 2] | 0) - (HEAP32[$s >> 2] | 0);
 if (HEAP32[$ret >> 2] | 0) {
  $cond = HEAP32[$s >> 2] | 0;
  $16 = HEAP32[$_this$addr >> 2] | 0;
  $rng4 = $16 + 28 | 0;
  HEAP32[$rng4 >> 2] = $cond;
  $17 = HEAP32[$_this$addr >> 2] | 0;
  _ec_dec_normalize($17);
  $18 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $18 | 0;
 } else {
  $cond = (HEAP32[$r >> 2] | 0) - (HEAP32[$s >> 2] | 0) | 0;
  $16 = HEAP32[$_this$addr >> 2] | 0;
  $rng4 = $16 + 28 | 0;
  HEAP32[$rng4 >> 2] = $cond;
  $17 = HEAP32[$_this$addr >> 2] | 0;
  _ec_dec_normalize($17);
  $18 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 return 0;
}

function _tansig_approx($x) {
 $x = +$x;
 var $20 = 0.0, $dy = 0, $i = 0, $retval = 0, $sign = 0, $x$addr = 0, $y = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $x$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $y = sp + 8 | 0;
 $dy = sp + 4 | 0;
 $sign = sp;
 HEAPF32[$x$addr >> 2] = $x;
 HEAPF32[$sign >> 2] = 1.0;
 if (!(+HEAPF32[$x$addr >> 2] < 8.0)) {
  HEAPF32[$retval >> 2] = 1.0;
  $20 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$20;
 }
 if (!(+HEAPF32[$x$addr >> 2] > -8.0)) {
  HEAPF32[$retval >> 2] = -1.0;
  $20 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$20;
 }
 if (+HEAPF32[$x$addr >> 2] != +HEAPF32[$x$addr >> 2]) {
  HEAPF32[$retval >> 2] = 0.0;
  $20 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$20;
 }
 if (+HEAPF32[$x$addr >> 2] < 0.0) {
  HEAPF32[$x$addr >> 2] = -+HEAPF32[$x$addr >> 2];
  HEAPF32[$sign >> 2] = -1.0;
 }
 HEAP32[$i >> 2] = ~~+Math_floor(+(+HEAPF32[$x$addr >> 2] * 25.0 + .5));
 HEAPF32[$x$addr >> 2] = +HEAPF32[$x$addr >> 2] - +(HEAP32[$i >> 2] | 0) * .03999999910593033;
 HEAPF32[$y >> 2] = +HEAPF32[1916 + (HEAP32[$i >> 2] << 2) >> 2];
 HEAPF32[$dy >> 2] = 1.0 - +HEAPF32[$y >> 2] * +HEAPF32[$y >> 2];
 HEAPF32[$y >> 2] = +HEAPF32[$y >> 2] + +HEAPF32[$x$addr >> 2] * +HEAPF32[$dy >> 2] * (1.0 - +HEAPF32[$y >> 2] * +HEAPF32[$x$addr >> 2]);
 HEAPF32[$retval >> 2] = +HEAPF32[$sign >> 2] * +HEAPF32[$y >> 2];
 $20 = +HEAPF32[$retval >> 2];
 STACKTOP = sp;
 return +$20;
}

function _opus_cpu_feature_check($cpu_feature) {
 $cpu_feature = $cpu_feature | 0;
 var $$sink = 0, $$sink1 = 0, $HW_AVX19 = 0, $cpu_feature$addr = 0, $info = 0, $nIds = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $cpu_feature$addr = sp + 24 | 0;
 $info = sp + 8 | 0;
 $nIds = sp;
 HEAP32[$cpu_feature$addr >> 2] = $cpu_feature;
 HEAP32[$info >> 2] = 0;
 HEAP32[$info + 4 >> 2] = 0;
 HEAP32[$info + 8 >> 2] = 0;
 HEAP32[$info + 12 >> 2] = 0;
 HEAP32[$nIds >> 2] = 0;
 _cpuid($info, 0);
 HEAP32[$nIds >> 2] = HEAP32[$info >> 2];
 if ((HEAP32[$nIds >> 2] | 0) >>> 0 >= 1) {
  _cpuid($info, 1);
  HEAP32[HEAP32[$cpu_feature$addr >> 2] >> 2] = (HEAP32[$info + 12 >> 2] & 33554432 | 0) != 0 & 1;
  HEAP32[(HEAP32[$cpu_feature$addr >> 2] | 0) + 4 >> 2] = (HEAP32[$info + 12 >> 2] & 67108864 | 0) != 0 & 1;
  HEAP32[(HEAP32[$cpu_feature$addr >> 2] | 0) + 8 >> 2] = (HEAP32[$info + 8 >> 2] & 524288 | 0) != 0 & 1;
  $$sink = (HEAP32[$info + 8 >> 2] & 268435456 | 0) != 0 & 1;
  $$sink1 = HEAP32[$cpu_feature$addr >> 2] | 0;
  $HW_AVX19 = $$sink1 + 12 | 0;
  HEAP32[$HW_AVX19 >> 2] = $$sink;
  STACKTOP = sp;
  return;
 } else {
  HEAP32[HEAP32[$cpu_feature$addr >> 2] >> 2] = 0;
  HEAP32[(HEAP32[$cpu_feature$addr >> 2] | 0) + 4 >> 2] = 0;
  HEAP32[(HEAP32[$cpu_feature$addr >> 2] | 0) + 8 >> 2] = 0;
  $$sink = 0;
  $$sink1 = HEAP32[$cpu_feature$addr >> 2] | 0;
  $HW_AVX19 = $$sink1 + 12 | 0;
  HEAP32[$HW_AVX19 >> 2] = $$sink;
  STACKTOP = sp;
  return;
 }
}

function _silk_bwexpander($ar, $d, $chirp_Q16) {
 $ar = $ar | 0;
 $d = $d | 0;
 $chirp_Q16 = $chirp_Q16 | 0;
 var $3 = 0, $4 = 0, $ar$addr = 0, $chirp_Q16$addr = 0, $chirp_minus_one_Q16 = 0, $conv17 = 0, $conv3 = 0, $d$addr = 0, $i = 0, $shr8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $ar$addr = sp + 16 | 0;
 $d$addr = sp + 12 | 0;
 $chirp_Q16$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $chirp_minus_one_Q16 = sp;
 HEAP32[$ar$addr >> 2] = $ar;
 HEAP32[$d$addr >> 2] = $d;
 HEAP32[$chirp_Q16$addr >> 2] = $chirp_Q16;
 HEAP32[$chirp_minus_one_Q16 >> 2] = (HEAP32[$chirp_Q16$addr >> 2] | 0) - 65536;
 HEAP32[$i >> 2] = 0;
 while (1) {
  $3 = HEAP32[$chirp_Q16$addr >> 2] | 0;
  $4 = HEAP32[$ar$addr >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$d$addr >> 2] | 0) - 1 | 0)) break;
  $conv3 = ((Math_imul($3, HEAP16[$4 + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0) >> 15) + 1 >> 1 & 65535;
  HEAP16[(HEAP32[$ar$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $conv3;
  $shr8 = ((Math_imul(HEAP32[$chirp_Q16$addr >> 2] | 0, HEAP32[$chirp_minus_one_Q16 >> 2] | 0) | 0) >> 15) + 1 >> 1;
  HEAP32[$chirp_Q16$addr >> 2] = (HEAP32[$chirp_Q16$addr >> 2] | 0) + $shr8;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 $conv17 = ((Math_imul($3, HEAP16[$4 + ((HEAP32[$d$addr >> 2] | 0) - 1 << 1) >> 1] | 0) | 0) >> 15) + 1 >> 1 & 65535;
 HEAP16[(HEAP32[$ar$addr >> 2] | 0) + ((HEAP32[$d$addr >> 2] | 0) - 1 << 1) >> 1] = $conv17;
 STACKTOP = sp;
 return;
}

function _silk_process_NLSFs_FLP($psEncC, $PredCoef, $NLSF_Q15, $prev_NLSF_Q15) {
 $psEncC = $psEncC | 0;
 $PredCoef = $PredCoef | 0;
 $NLSF_Q15 = $NLSF_Q15 | 0;
 $prev_NLSF_Q15 = $prev_NLSF_Q15 | 0;
 var $7 = 0, $NLSF_Q15$addr = 0, $PredCoef$addr = 0, $PredCoef_Q12 = 0, $i = 0, $j = 0, $prev_NLSF_Q15$addr = 0, $psEncC$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $psEncC$addr = sp + 20 | 0;
 $PredCoef$addr = sp + 16 | 0;
 $NLSF_Q15$addr = sp + 12 | 0;
 $prev_NLSF_Q15$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $j = sp;
 $PredCoef_Q12 = sp + 24 | 0;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$PredCoef$addr >> 2] = $PredCoef;
 HEAP32[$NLSF_Q15$addr >> 2] = $NLSF_Q15;
 HEAP32[$prev_NLSF_Q15$addr >> 2] = $prev_NLSF_Q15;
 _silk_process_NLSFs(HEAP32[$psEncC$addr >> 2] | 0, $PredCoef_Q12, HEAP32[$NLSF_Q15$addr >> 2] | 0, HEAP32[$prev_NLSF_Q15$addr >> 2] | 0);
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= 2) break;
  HEAP32[$i >> 2] = 0;
  while (1) {
   $7 = HEAP32[$j >> 2] | 0;
   if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4636 >> 2] | 0)) break;
   HEAPF32[(HEAP32[$PredCoef$addr >> 2] | 0) + (HEAP32[$j >> 2] << 6) + (HEAP32[$i >> 2] << 2) >> 2] = +(HEAP16[$PredCoef_Q12 + ($7 << 5) + (HEAP32[$i >> 2] << 1) >> 1] | 0) * .000244140625;
   HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
  }
  HEAP32[$j >> 2] = $7 + 1;
 }
 STACKTOP = sp;
 return;
}

function _ec_dec_icdf($_this, $_icdf, $_ftb) {
 $_this = $_this | 0;
 $_icdf = $_icdf | 0;
 $_ftb = $_ftb | 0;
 var $7 = 0, $8 = 0, $_ftb$addr = 0, $_icdf$addr = 0, $_this$addr = 0, $d = 0, $inc = 0, $r = 0, $ret = 0, $s = 0, $t = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 28 | 0;
 $_icdf$addr = sp + 24 | 0;
 $_ftb$addr = sp + 20 | 0;
 $r = sp + 16 | 0;
 $d = sp + 12 | 0;
 $s = sp + 8 | 0;
 $t = sp + 4 | 0;
 $ret = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_icdf$addr >> 2] = $_icdf;
 HEAP32[$_ftb$addr >> 2] = $_ftb;
 HEAP32[$s >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2];
 HEAP32[$d >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$r >> 2] = (HEAP32[$s >> 2] | 0) >>> (HEAP32[$_ftb$addr >> 2] | 0);
 HEAP32[$ret >> 2] = -1;
 do {
  HEAP32[$t >> 2] = HEAP32[$s >> 2];
  $7 = HEAP32[$r >> 2] | 0;
  $8 = HEAP32[$_icdf$addr >> 2] | 0;
  $inc = (HEAP32[$ret >> 2] | 0) + 1 | 0;
  HEAP32[$ret >> 2] = $inc;
  HEAP32[$s >> 2] = Math_imul($7, HEAPU8[$8 + $inc >> 0] | 0) | 0;
 } while ((HEAP32[$d >> 2] | 0) >>> 0 < (HEAP32[$s >> 2] | 0) >>> 0);
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] = (HEAP32[$d >> 2] | 0) - (HEAP32[$s >> 2] | 0);
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] = (HEAP32[$t >> 2] | 0) - (HEAP32[$s >> 2] | 0);
 _ec_dec_normalize(HEAP32[$_this$addr >> 2] | 0);
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _init_caps($m, $cap, $LM, $C) {
 $m = $m | 0;
 $cap = $cap | 0;
 $LM = $LM | 0;
 $C = $C | 0;
 var $C$addr = 0, $LM$addr = 0, $N = 0, $cap$addr = 0, $i = 0, $m$addr = 0, $mul12 = 0, $mul7 = 0, $shr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $m$addr = sp + 20 | 0;
 $cap$addr = sp + 16 | 0;
 $LM$addr = sp + 12 | 0;
 $C$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $N = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$cap$addr >> 2] = $cap;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0)) break;
  HEAP32[$N >> 2] = (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + ((HEAP32[$i >> 2] | 0) + 1 << 1) >> 1] | 0) - (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 32 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) << HEAP32[$LM$addr >> 2];
  $mul7 = Math_imul(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0, (HEAP32[$LM$addr >> 2] << 1) + (HEAP32[$C$addr >> 2] | 0) - 1 | 0) | 0;
  $mul12 = Math_imul((HEAPU8[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 92 + 12 >> 2] | 0) + ($mul7 + (HEAP32[$i >> 2] | 0)) >> 0] | 0) + 64 | 0, HEAP32[$C$addr >> 2] | 0) | 0;
  $shr = (Math_imul($mul12, HEAP32[$N >> 2] | 0) | 0) >> 2;
  HEAP32[(HEAP32[$cap$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $shr;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _decode_split($p_child1, $p_child2, $psRangeDec, $p, $shell_table) {
 $p_child1 = $p_child1 | 0;
 $p_child2 = $p_child2 | 0;
 $psRangeDec = $psRangeDec | 0;
 $p = $p | 0;
 $shell_table = $shell_table | 0;
 var $$sink = 0, $$sink1 = 0, $conv = 0, $p$addr = 0, $p_child1$addr = 0, $p_child2$addr = 0, $psRangeDec$addr = 0, $shell_table$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $p_child1$addr = sp + 16 | 0;
 $p_child2$addr = sp + 12 | 0;
 $psRangeDec$addr = sp + 8 | 0;
 $p$addr = sp + 4 | 0;
 $shell_table$addr = sp;
 HEAP32[$p_child1$addr >> 2] = $p_child1;
 HEAP32[$p_child2$addr >> 2] = $p_child2;
 HEAP32[$psRangeDec$addr >> 2] = $psRangeDec;
 HEAP32[$p$addr >> 2] = $p;
 HEAP32[$shell_table$addr >> 2] = $shell_table;
 if ((HEAP32[$p$addr >> 2] | 0) > 0) {
  $conv = (_ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, (HEAP32[$shell_table$addr >> 2] | 0) + (HEAPU8[33368 + (HEAP32[$p$addr >> 2] | 0) >> 0] | 0) | 0, 8) | 0) & 65535;
  HEAP16[HEAP32[$p_child1$addr >> 2] >> 1] = $conv;
  $$sink = (HEAP32[$p$addr >> 2] | 0) - (HEAP16[HEAP32[$p_child1$addr >> 2] >> 1] | 0) & 65535;
  $$sink1 = HEAP32[$p_child2$addr >> 2] | 0;
  HEAP16[$$sink1 >> 1] = $$sink;
  STACKTOP = sp;
  return;
 } else {
  HEAP16[HEAP32[$p_child1$addr >> 2] >> 1] = 0;
  $$sink = 0;
  $$sink1 = HEAP32[$p_child2$addr >> 2] | 0;
  HEAP16[$$sink1 >> 1] = $$sink;
  STACKTOP = sp;
  return;
 }
}

function _silk_autocorrelation_FLP($results, $inputData, $inputDataSize, $correlationCount) {
 $results = $results | 0;
 $inputData = $inputData | 0;
 $inputDataSize = $inputDataSize | 0;
 $correlationCount = $correlationCount | 0;
 var $conv = 0.0, $correlationCount$addr = 0, $i = 0, $inputData$addr = 0, $inputDataSize$addr = 0, $results$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $results$addr = sp + 16 | 0;
 $inputData$addr = sp + 12 | 0;
 $inputDataSize$addr = sp + 8 | 0;
 $correlationCount$addr = sp + 4 | 0;
 $i = sp;
 HEAP32[$results$addr >> 2] = $results;
 HEAP32[$inputData$addr >> 2] = $inputData;
 HEAP32[$inputDataSize$addr >> 2] = $inputDataSize;
 HEAP32[$correlationCount$addr >> 2] = $correlationCount;
 if ((HEAP32[$correlationCount$addr >> 2] | 0) > (HEAP32[$inputDataSize$addr >> 2] | 0)) HEAP32[$correlationCount$addr >> 2] = HEAP32[$inputDataSize$addr >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$correlationCount$addr >> 2] | 0)) break;
  $conv = +_silk_inner_product_FLP(HEAP32[$inputData$addr >> 2] | 0, (HEAP32[$inputData$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) | 0, (HEAP32[$inputDataSize$addr >> 2] | 0) - (HEAP32[$i >> 2] | 0) | 0);
  HEAPF32[(HEAP32[$results$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = $conv;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _opus_packet_get_samples_per_frame($data, $Fs) {
 $data = $data | 0;
 $Fs = $Fs | 0;
 var $10 = 0, $12 = 0, $Fs$addr = 0, $audiosize = 0, $conv10 = 0, $conv2 = 0, $data$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $data$addr = sp + 8 | 0;
 $Fs$addr = sp + 4 | 0;
 $audiosize = sp;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$Fs$addr >> 2] = $Fs;
 $conv2 = HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0;
 if ((HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0) & 128 | 0) {
  HEAP32[$audiosize >> 2] = $conv2 >> 3 & 3;
  HEAP32[$audiosize >> 2] = (HEAP32[$Fs$addr >> 2] << HEAP32[$audiosize >> 2] | 0) / 400 | 0;
  $12 = HEAP32[$audiosize >> 2] | 0;
  STACKTOP = sp;
  return $12 | 0;
 }
 $conv10 = HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0;
 if (($conv2 & 96 | 0) == 96) {
  HEAP32[$audiosize >> 2] = (HEAP32[$Fs$addr >> 2] | 0) / (($conv10 & 8 | 0 ? 50 : 100) | 0) | 0;
  $12 = HEAP32[$audiosize >> 2] | 0;
  STACKTOP = sp;
  return $12 | 0;
 }
 HEAP32[$audiosize >> 2] = $conv10 >> 3 & 3;
 $10 = HEAP32[$Fs$addr >> 2] | 0;
 if ((HEAP32[$audiosize >> 2] | 0) == 3) {
  HEAP32[$audiosize >> 2] = ($10 * 60 | 0) / 1e3 | 0;
  $12 = HEAP32[$audiosize >> 2] | 0;
  STACKTOP = sp;
  return $12 | 0;
 } else {
  HEAP32[$audiosize >> 2] = ($10 << HEAP32[$audiosize >> 2] | 0) / 100 | 0;
  $12 = HEAP32[$audiosize >> 2] | 0;
  STACKTOP = sp;
  return $12 | 0;
 }
 return 0;
}

function _silk_PLC($psDec, $psDecCtrl, $frame, $lost, $arch) {
 $psDec = $psDec | 0;
 $psDecCtrl = $psDecCtrl | 0;
 $frame = $frame | 0;
 $lost = $lost | 0;
 $arch = $arch | 0;
 var $10 = 0, $9 = 0, $arch$addr = 0, $frame$addr = 0, $lossCnt = 0, $lost$addr = 0, $psDec$addr = 0, $psDecCtrl$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $psDec$addr = sp + 16 | 0;
 $psDecCtrl$addr = sp + 12 | 0;
 $frame$addr = sp + 8 | 0;
 $lost$addr = sp + 4 | 0;
 $arch$addr = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$psDecCtrl$addr >> 2] = $psDecCtrl;
 HEAP32[$frame$addr >> 2] = $frame;
 HEAP32[$lost$addr >> 2] = $lost;
 HEAP32[$arch$addr >> 2] = $arch;
 if ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2] | 0) != (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 80 >> 2] | 0)) {
  _silk_PLC_Reset(HEAP32[$psDec$addr >> 2] | 0);
  HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 80 >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2316 >> 2];
 }
 $9 = HEAP32[$psDec$addr >> 2] | 0;
 $10 = HEAP32[$psDecCtrl$addr >> 2] | 0;
 if (HEAP32[$lost$addr >> 2] | 0) {
  _silk_PLC_conceal($9, $10, HEAP32[$frame$addr >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
  $lossCnt = (HEAP32[$psDec$addr >> 2] | 0) + 4160 | 0;
  HEAP32[$lossCnt >> 2] = (HEAP32[$lossCnt >> 2] | 0) + 1;
  STACKTOP = sp;
  return;
 } else {
  _silk_PLC_update($9, $10);
  STACKTOP = sp;
  return;
 }
}

function _silk_sigm_Q15($in_Q5) {
 $in_Q5 = $in_Q5 | 0;
 var $1 = 0, $15 = 0, $in_Q5$addr = 0, $ind = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $retval = sp + 8 | 0;
 $in_Q5$addr = sp + 4 | 0;
 $ind = sp;
 HEAP32[$in_Q5$addr >> 2] = $in_Q5;
 $1 = HEAP32[$in_Q5$addr >> 2] | 0;
 if ((HEAP32[$in_Q5$addr >> 2] | 0) < 0) {
  HEAP32[$in_Q5$addr >> 2] = 0 - $1;
  if ((HEAP32[$in_Q5$addr >> 2] | 0) >= 192) {
   HEAP32[$retval >> 2] = 0;
   $15 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $15 | 0;
  } else {
   HEAP32[$ind >> 2] = HEAP32[$in_Q5$addr >> 2] >> 5;
   HEAP32[$retval >> 2] = (HEAP32[20740 + (HEAP32[$ind >> 2] << 2) >> 2] | 0) - (Math_imul((HEAP32[20764 + (HEAP32[$ind >> 2] << 2) >> 2] & 65535) << 16 >> 16, (HEAP32[$in_Q5$addr >> 2] & 31) << 16 >> 16) | 0);
   $15 = HEAP32[$retval >> 2] | 0;
   STACKTOP = sp;
   return $15 | 0;
  }
 } else if (($1 | 0) >= 192) {
  HEAP32[$retval >> 2] = 32767;
  $15 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $15 | 0;
 } else {
  HEAP32[$ind >> 2] = HEAP32[$in_Q5$addr >> 2] >> 5;
  HEAP32[$retval >> 2] = (HEAP32[20788 + (HEAP32[$ind >> 2] << 2) >> 2] | 0) + (Math_imul((HEAP32[20764 + (HEAP32[$ind >> 2] << 2) >> 2] & 65535) << 16 >> 16, (HEAP32[$in_Q5$addr >> 2] & 31) << 16 >> 16) | 0);
  $15 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $15 | 0;
 }
 return 0;
}

function _opus_encode_float($st, $pcm, $analysis_frame_size, $data, $out_data_bytes) {
 $st = $st | 0;
 $pcm = $pcm | 0;
 $analysis_frame_size = $analysis_frame_size | 0;
 $data = $data | 0;
 $out_data_bytes = $out_data_bytes | 0;
 var $analysis_frame_size$addr = 0, $call1 = 0, $data$addr = 0, $frame_size = 0, $out_data_bytes$addr = 0, $pcm$addr = 0, $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $st$addr = sp + 20 | 0;
 $pcm$addr = sp + 16 | 0;
 $analysis_frame_size$addr = sp + 12 | 0;
 $data$addr = sp + 8 | 0;
 $out_data_bytes$addr = sp + 4 | 0;
 $frame_size = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$analysis_frame_size$addr >> 2] = $analysis_frame_size;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$out_data_bytes$addr >> 2] = $out_data_bytes;
 HEAP32[$frame_size >> 2] = _frame_size_select(HEAP32[$analysis_frame_size$addr >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 156 >> 2] | 0, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 144 >> 2] | 0) | 0;
 $call1 = _opus_encode_native(HEAP32[$st$addr >> 2] | 0, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$frame_size >> 2] | 0, HEAP32[$data$addr >> 2] | 0, HEAP32[$out_data_bytes$addr >> 2] | 0, 24, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$analysis_frame_size$addr >> 2] | 0, 0, -2, HEAP32[(HEAP32[$st$addr >> 2] | 0) + 112 >> 2] | 0, 1, 1) | 0;
 STACKTOP = sp;
 return $call1 | 0;
}

function _opus_fft_c($st, $fin, $fout) {
 $st = $st | 0;
 $fin = $fin | 0;
 $fout = $fout | 0;
 var $arrayidx = 0, $fin$addr = 0, $fout$addr = 0, $i = 0, $scale = 0, $st$addr = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $st$addr = sp + 24 | 0;
 $fin$addr = sp + 20 | 0;
 $fout$addr = sp + 16 | 0;
 $i = sp + 12 | 0;
 $scale = sp + 8 | 0;
 $x = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$fin$addr >> 2] = $fin;
 HEAP32[$fout$addr >> 2] = $fout;
 HEAPF32[$scale >> 2] = +HEAPF32[(HEAP32[$st$addr >> 2] | 0) + 4 >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[HEAP32[$st$addr >> 2] >> 2] | 0)) break;
  $arrayidx = (HEAP32[$fin$addr >> 2] | 0) + (HEAP32[$i >> 2] << 3) | 0;
  HEAP32[$x >> 2] = HEAP32[$arrayidx >> 2];
  HEAP32[$x + 4 >> 2] = HEAP32[$arrayidx + 4 >> 2];
  HEAPF32[(HEAP32[$fout$addr >> 2] | 0) + (HEAP16[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << 3) >> 2] = +HEAPF32[$scale >> 2] * +HEAPF32[$x >> 2];
  HEAPF32[(HEAP32[$fout$addr >> 2] | 0) + (HEAP16[(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 44 >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] << 3) + 4 >> 2] = +HEAPF32[$scale >> 2] * +HEAPF32[$x + 4 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _opus_fft_impl(HEAP32[$st$addr >> 2] | 0, HEAP32[$fout$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _decode_pulses($_y, $_n, $_k, $_dec) {
 $_y = $_y | 0;
 $_n = $_n | 0;
 $_k = $_k | 0;
 $_dec = $_dec | 0;
 var $0 = 0, $1 = 0, $_dec$addr = 0, $_k$addr = 0, $_n$addr = 0, $_y$addr = 0, $call = 0, $call23 = 0.0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_y$addr = sp + 12 | 0;
 $_n$addr = sp + 8 | 0;
 $_k$addr = sp + 4 | 0;
 $_dec$addr = sp;
 HEAP32[$_y$addr >> 2] = $_y;
 HEAP32[$_n$addr >> 2] = $_n;
 HEAP32[$_k$addr >> 2] = $_k;
 HEAP32[$_dec$addr >> 2] = $_dec;
 $0 = HEAP32[$_n$addr >> 2] | 0;
 $1 = HEAP32[$_k$addr >> 2] | 0;
 $call = _ec_dec_uint(HEAP32[$_dec$addr >> 2] | 0, (HEAP32[(HEAP32[15496 + (((HEAP32[$_n$addr >> 2] | 0) < (HEAP32[$_k$addr >> 2] | 0) ? HEAP32[$_n$addr >> 2] | 0 : HEAP32[$_k$addr >> 2] | 0) << 2) >> 2] | 0) + (((HEAP32[$_n$addr >> 2] | 0) > (HEAP32[$_k$addr >> 2] | 0) ? HEAP32[$_n$addr >> 2] | 0 : HEAP32[$_k$addr >> 2] | 0) << 2) >> 2] | 0) + (HEAP32[(HEAP32[15496 + (((HEAP32[$_n$addr >> 2] | 0) < ((HEAP32[$_k$addr >> 2] | 0) + 1 | 0) ? HEAP32[$_n$addr >> 2] | 0 : (HEAP32[$_k$addr >> 2] | 0) + 1 | 0) << 2) >> 2] | 0) + (((HEAP32[$_n$addr >> 2] | 0) > ((HEAP32[$_k$addr >> 2] | 0) + 1 | 0) ? HEAP32[$_n$addr >> 2] | 0 : (HEAP32[$_k$addr >> 2] | 0) + 1 | 0) << 2) >> 2] | 0) | 0) | 0;
 $call23 = +_cwrsi($0, $1, $call, HEAP32[$_y$addr >> 2] | 0);
 STACKTOP = sp;
 return +$call23;
}

function _silk_setup_LBRR($psEncC, $encControl) {
 $psEncC = $psEncC | 0;
 $encControl = $encControl | 0;
 var $$sink = 0, $13 = 0, $8 = 0, $LBRR_in_previous_packet = 0, $call = 0, $call$sink = 0, $encControl$addr = 0, $psEncC$addr = 0, $ret = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psEncC$addr = sp + 12 | 0;
 $encControl$addr = sp + 8 | 0;
 $LBRR_in_previous_packet = sp + 4 | 0;
 $ret = sp;
 HEAP32[$psEncC$addr >> 2] = $psEncC;
 HEAP32[$encControl$addr >> 2] = $encControl;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$LBRR_in_previous_packet >> 2] = HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 6088 >> 2];
 HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 6088 >> 2] = HEAP32[(HEAP32[$encControl$addr >> 2] | 0) + 44 >> 2];
 if (!(HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 6088 >> 2] | 0)) {
  $13 = HEAP32[$ret >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 $8 = HEAP32[$psEncC$addr >> 2] | 0;
 if (!(HEAP32[$LBRR_in_previous_packet >> 2] | 0)) {
  $$sink = $8;
  $call$sink = 7;
 } else {
  $call = _silk_max_int_232(7 - (((HEAP32[$8 + 4612 >> 2] >> 16) * 26214 | 0) + ((HEAP32[(HEAP32[$psEncC$addr >> 2] | 0) + 4612 >> 2] & 65535) * 26214 >> 16)) | 0, 2) | 0;
  $$sink = HEAP32[$psEncC$addr >> 2] | 0;
  $call$sink = $call;
 }
 HEAP32[$$sink + 6092 >> 2] = $call$sink;
 $13 = HEAP32[$ret >> 2] | 0;
 STACKTOP = sp;
 return $13 | 0;
}

function _renormalise_vector($X, $N, $gain, $arch) {
 $X = $X | 0;
 $N = $N | 0;
 $gain = +$gain;
 $arch = $arch | 0;
 var $E = 0, $N$addr = 0, $X$addr = 0, $arch$addr = 0, $div = 0.0, $g = 0, $gain$addr = 0, $i = 0, $t = 0, $xptr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $X$addr = sp + 32 | 0;
 $N$addr = sp + 28 | 0;
 $gain$addr = sp + 24 | 0;
 $arch$addr = sp + 20 | 0;
 $i = sp + 16 | 0;
 $E = sp + 12 | 0;
 $g = sp + 8 | 0;
 $t = sp + 4 | 0;
 $xptr = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N$addr >> 2] = $N;
 HEAPF32[$gain$addr >> 2] = $gain;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAPF32[$E >> 2] = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$X$addr >> 2] | 0, HEAP32[$X$addr >> 2] | 0, HEAP32[$N$addr >> 2] | 0) + 1.0000000036274937e-15;
 HEAPF32[$t >> 2] = +HEAPF32[$E >> 2];
 $div = 1.0 / +Math_sqrt(+(+HEAPF32[$t >> 2]));
 HEAPF32[$g >> 2] = $div * +HEAPF32[$gain$addr >> 2];
 HEAP32[$xptr >> 2] = HEAP32[$X$addr >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAPF32[HEAP32[$xptr >> 2] >> 2] = +HEAPF32[$g >> 2] * +HEAPF32[HEAP32[$xptr >> 2] >> 2];
  HEAP32[$xptr >> 2] = (HEAP32[$xptr >> 2] | 0) + 4;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _ec_dec_init($_this, $_buf, $_storage) {
 $_this = $_this | 0;
 $_buf = $_buf | 0;
 $_storage = $_storage | 0;
 var $_buf$addr = 0, $_storage$addr = 0, $_this$addr = 0, $call = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp + 8 | 0;
 $_buf$addr = sp + 4 | 0;
 $_storage$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_buf$addr >> 2] = $_buf;
 HEAP32[$_storage$addr >> 2] = $_storage;
 HEAP32[HEAP32[$_this$addr >> 2] >> 2] = HEAP32[$_buf$addr >> 2];
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] = HEAP32[$_storage$addr >> 2];
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 12 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 16 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] = 9;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] = 128;
 $call = _ec_read_byte(HEAP32[$_this$addr >> 2] | 0) | 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2] = $call;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) - 1 - (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2] >> 1);
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 44 >> 2] = 0;
 _ec_dec_normalize(HEAP32[$_this$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_InitEncoder($encState, $arch, $encStatus) {
 $encState = $encState | 0;
 $arch = $arch | 0;
 $encStatus = $encStatus | 0;
 var $3 = 0, $arch$addr = 0, $call = 0, $call1 = 0, $encState$addr = 0, $encStatus$addr = 0, $n = 0, $psEnc = 0, $ret = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $encState$addr = sp + 20 | 0;
 $arch$addr = sp + 16 | 0;
 $encStatus$addr = sp + 12 | 0;
 $psEnc = sp + 8 | 0;
 $n = sp + 4 | 0;
 $ret = sp;
 HEAP32[$encState$addr >> 2] = $encState;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$encStatus$addr >> 2] = $encStatus;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$psEnc >> 2] = HEAP32[$encState$addr >> 2];
 _memset(HEAP32[$psEnc >> 2] | 0, 0, 20208) | 0;
 HEAP32[$n >> 2] = 0;
 while (1) {
  $3 = HEAP32[$psEnc >> 2] | 0;
  if ((HEAP32[$n >> 2] | 0) >= 2) break;
  $call = _silk_init_encoder($3 + ((HEAP32[$n >> 2] | 0) * 10060 | 0) | 0, HEAP32[$arch$addr >> 2] | 0) | 0;
  HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 HEAP32[$3 + 20184 >> 2] = 1;
 HEAP32[(HEAP32[$psEnc >> 2] | 0) + 20188 >> 2] = 1;
 $call1 = _silk_QueryEncoder(HEAP32[$encState$addr >> 2] | 0, HEAP32[$encStatus$addr >> 2] | 0) | 0;
 HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call1;
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _ec_enc_uint($_this, $_fl, $_ft) {
 $_this = $_this | 0;
 $_fl = $_fl | 0;
 $_ft = $_ft | 0;
 var $_fl$addr = 0, $_ft$addr = 0, $_this$addr = 0, $fl = 0, $ft = 0, $ftb = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 20 | 0;
 $_fl$addr = sp + 16 | 0;
 $_ft$addr = sp + 12 | 0;
 $ft = sp + 8 | 0;
 $fl = sp + 4 | 0;
 $ftb = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_fl$addr >> 2] = $_fl;
 HEAP32[$_ft$addr >> 2] = $_ft;
 HEAP32[$_ft$addr >> 2] = (HEAP32[$_ft$addr >> 2] | 0) + -1;
 HEAP32[$ftb >> 2] = 32 - (Math_clz32(HEAP32[$_ft$addr >> 2] | 0) | 0);
 if ((HEAP32[$ftb >> 2] | 0) > 8) {
  HEAP32[$ftb >> 2] = (HEAP32[$ftb >> 2] | 0) - 8;
  HEAP32[$ft >> 2] = ((HEAP32[$_ft$addr >> 2] | 0) >>> (HEAP32[$ftb >> 2] | 0)) + 1;
  HEAP32[$fl >> 2] = (HEAP32[$_fl$addr >> 2] | 0) >>> (HEAP32[$ftb >> 2] | 0);
  _ec_encode(HEAP32[$_this$addr >> 2] | 0, HEAP32[$fl >> 2] | 0, (HEAP32[$fl >> 2] | 0) + 1 | 0, HEAP32[$ft >> 2] | 0);
  _ec_enc_bits(HEAP32[$_this$addr >> 2] | 0, HEAP32[$_fl$addr >> 2] & (1 << HEAP32[$ftb >> 2]) - 1, HEAP32[$ftb >> 2] | 0);
  STACKTOP = sp;
  return;
 } else {
  _ec_encode(HEAP32[$_this$addr >> 2] | 0, HEAP32[$_fl$addr >> 2] | 0, (HEAP32[$_fl$addr >> 2] | 0) + 1 | 0, (HEAP32[$_ft$addr >> 2] | 0) + 1 | 0);
  STACKTOP = sp;
  return;
 }
}

function _parse_size($data, $len, $size) {
 $data = $data | 0;
 $len = $len | 0;
 $size = $size | 0;
 var $14 = 0, $data$addr = 0, $len$addr = 0, $retval = 0, $size$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $retval = sp + 12 | 0;
 $data$addr = sp + 8 | 0;
 $len$addr = sp + 4 | 0;
 $size$addr = sp;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$size$addr >> 2] = $size;
 if ((HEAP32[$len$addr >> 2] | 0) < 1) {
  HEAP16[HEAP32[$size$addr >> 2] >> 1] = -1;
  HEAP32[$retval >> 2] = -1;
  $14 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $14 | 0;
 }
 if ((HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0 | 0) < 252) {
  HEAP16[HEAP32[$size$addr >> 2] >> 1] = HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0;
  HEAP32[$retval >> 2] = 1;
  $14 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $14 | 0;
 }
 if ((HEAP32[$len$addr >> 2] | 0) < 2) {
  HEAP16[HEAP32[$size$addr >> 2] >> 1] = -1;
  HEAP32[$retval >> 2] = -1;
  $14 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $14 | 0;
 } else {
  HEAP16[HEAP32[$size$addr >> 2] >> 1] = ((HEAPU8[(HEAP32[$data$addr >> 2] | 0) + 1 >> 0] | 0) << 2) + (HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0);
  HEAP32[$retval >> 2] = 2;
  $14 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $14 | 0;
 }
 return 0;
}

function _celt_decoder_init($st, $sampling_rate, $channels) {
 $st = $st | 0;
 $sampling_rate = $sampling_rate | 0;
 $channels = $channels | 0;
 var $0 = 0, $8 = 0, $call = 0, $call2 = 0, $channels$addr = 0, $ret = 0, $retval = 0, $sampling_rate$addr = 0, $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $st$addr = sp + 12 | 0;
 $sampling_rate$addr = sp + 8 | 0;
 $channels$addr = sp + 4 | 0;
 $ret = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$sampling_rate$addr >> 2] = $sampling_rate;
 HEAP32[$channels$addr >> 2] = $channels;
 $0 = HEAP32[$st$addr >> 2] | 0;
 $call = _opus_custom_mode_create(48e3, 960, 0) | 0;
 HEAP32[$ret >> 2] = _opus_custom_decoder_init($0, $call, HEAP32[$channels$addr >> 2] | 0) | 0;
 if (HEAP32[$ret >> 2] | 0) {
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $8 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $8 | 0;
 }
 $call2 = _resampling_factor(HEAP32[$sampling_rate$addr >> 2] | 0) | 0;
 HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] = $call2;
 if (!(HEAP32[(HEAP32[$st$addr >> 2] | 0) + 16 >> 2] | 0)) {
  HEAP32[$retval >> 2] = -1;
  $8 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $8 | 0;
 } else {
  HEAP32[$retval >> 2] = 0;
  $8 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $8 | 0;
 }
 return 0;
}

function __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcj($this, $__s, $__n) {
 $this = $this | 0;
 $__s = $__s | 0;
 $__n = $__n | 0;
 var $0 = 0, $__size_$i$i = 0, $cond$i = 0, $cond$i19 = 0, $cond$i25 = 0, $ref$tmp = 0, $tobool$i$i = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ref$tmp = sp;
 $__size_$i$i = $this + 11 | 0;
 $0 = HEAP8[$__size_$i$i >> 0] | 0;
 $tobool$i$i = $0 << 24 >> 24 < 0;
 if ($tobool$i$i) $cond$i = (HEAP32[$this + 8 >> 2] & 2147483647) + -1 | 0; else $cond$i = 10;
 do if ($cond$i >>> 0 < $__n >>> 0) {
  if ($tobool$i$i) $cond$i25 = HEAP32[$this + 4 >> 2] | 0; else $cond$i25 = $0 & 255;
  __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE21__grow_by_and_replaceEjjjjjjPKc($this, $cond$i, $__n - $cond$i | 0, $cond$i25, 0, $cond$i25, $__n, $__s);
 } else {
  if ($tobool$i$i) $cond$i19 = HEAP32[$this >> 2] | 0; else $cond$i19 = $this;
  __ZNSt3__211char_traitsIcE4moveEPcPKcj($cond$i19, $__s, $__n) | 0;
  HEAP8[$ref$tmp >> 0] = 0;
  __ZNSt3__211char_traitsIcE6assignERcRKc($cond$i19 + $__n | 0, $ref$tmp);
  if ((HEAP8[$__size_$i$i >> 0] | 0) < 0) {
   HEAP32[$this + 4 >> 2] = $__n;
   break;
  } else {
   HEAP8[$__size_$i$i >> 0] = $__n;
   break;
  }
 } while (0);
 STACKTOP = sp;
 return $this | 0;
}

function _celt_encoder_init($st, $sampling_rate, $channels, $arch) {
 $st = $st | 0;
 $sampling_rate = $sampling_rate | 0;
 $channels = $channels | 0;
 $arch = $arch | 0;
 var $0 = 0, $7 = 0, $arch$addr = 0, $call = 0, $call2 = 0, $channels$addr = 0, $ret = 0, $retval = 0, $sampling_rate$addr = 0, $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $st$addr = sp + 16 | 0;
 $sampling_rate$addr = sp + 12 | 0;
 $channels$addr = sp + 8 | 0;
 $arch$addr = sp + 4 | 0;
 $ret = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$sampling_rate$addr >> 2] = $sampling_rate;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$arch$addr >> 2] = $arch;
 $0 = HEAP32[$st$addr >> 2] | 0;
 $call = _opus_custom_mode_create(48e3, 960, 0) | 0;
 HEAP32[$ret >> 2] = _opus_custom_encoder_init_arch($0, $call, HEAP32[$channels$addr >> 2] | 0, HEAP32[$arch$addr >> 2] | 0) | 0;
 if (HEAP32[$ret >> 2] | 0) {
  HEAP32[$retval >> 2] = HEAP32[$ret >> 2];
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 } else {
  $call2 = _resampling_factor(HEAP32[$sampling_rate$addr >> 2] | 0) | 0;
  HEAP32[(HEAP32[$st$addr >> 2] | 0) + 28 >> 2] = $call2;
  HEAP32[$retval >> 2] = 0;
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 }
 return 0;
}

function _opus_decode_float($st, $data, $len, $pcm, $frame_size, $decode_fec) {
 $st = $st | 0;
 $data = $data | 0;
 $len = $len | 0;
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $decode_fec = $decode_fec | 0;
 var $7 = 0, $data$addr = 0, $decode_fec$addr = 0, $frame_size$addr = 0, $len$addr = 0, $pcm$addr = 0, $retval = 0, $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 24 | 0;
 $st$addr = sp + 20 | 0;
 $data$addr = sp + 16 | 0;
 $len$addr = sp + 12 | 0;
 $pcm$addr = sp + 8 | 0;
 $frame_size$addr = sp + 4 | 0;
 $decode_fec$addr = sp;
 HEAP32[$st$addr >> 2] = $st;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$decode_fec$addr >> 2] = $decode_fec;
 if ((HEAP32[$frame_size$addr >> 2] | 0) <= 0) {
  HEAP32[$retval >> 2] = -1;
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 } else {
  HEAP32[$retval >> 2] = _opus_decode_native(HEAP32[$st$addr >> 2] | 0, HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$frame_size$addr >> 2] | 0, HEAP32[$decode_fec$addr >> 2] | 0, 0, 0, 0) | 0;
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 }
 return 0;
}

function _encode_pulses($_y, $_n, $_k, $_enc) {
 $_y = $_y | 0;
 $_n = $_n | 0;
 $_k = $_k | 0;
 $_enc = $_enc | 0;
 var $0 = 0, $_enc$addr = 0, $_k$addr = 0, $_n$addr = 0, $_y$addr = 0, $call = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_y$addr = sp + 12 | 0;
 $_n$addr = sp + 8 | 0;
 $_k$addr = sp + 4 | 0;
 $_enc$addr = sp;
 HEAP32[$_y$addr >> 2] = $_y;
 HEAP32[$_n$addr >> 2] = $_n;
 HEAP32[$_k$addr >> 2] = $_k;
 HEAP32[$_enc$addr >> 2] = $_enc;
 $0 = HEAP32[$_enc$addr >> 2] | 0;
 $call = _icwrs(HEAP32[$_n$addr >> 2] | 0, HEAP32[$_y$addr >> 2] | 0) | 0;
 _ec_enc_uint($0, $call, (HEAP32[(HEAP32[15496 + (((HEAP32[$_n$addr >> 2] | 0) < (HEAP32[$_k$addr >> 2] | 0) ? HEAP32[$_n$addr >> 2] | 0 : HEAP32[$_k$addr >> 2] | 0) << 2) >> 2] | 0) + (((HEAP32[$_n$addr >> 2] | 0) > (HEAP32[$_k$addr >> 2] | 0) ? HEAP32[$_n$addr >> 2] | 0 : HEAP32[$_k$addr >> 2] | 0) << 2) >> 2] | 0) + (HEAP32[(HEAP32[15496 + (((HEAP32[$_n$addr >> 2] | 0) < ((HEAP32[$_k$addr >> 2] | 0) + 1 | 0) ? HEAP32[$_n$addr >> 2] | 0 : (HEAP32[$_k$addr >> 2] | 0) + 1 | 0) << 2) >> 2] | 0) + (((HEAP32[$_n$addr >> 2] | 0) > ((HEAP32[$_k$addr >> 2] | 0) + 1 | 0) ? HEAP32[$_n$addr >> 2] | 0 : (HEAP32[$_k$addr >> 2] | 0) + 1 | 0) << 2) >> 2] | 0) | 0);
 STACKTOP = sp;
 return;
}

function _silk_LPC_inverse_pred_gain_c($A_Q12, $order) {
 $A_Q12 = $A_Q12 | 0;
 $order = $order | 0;
 var $13 = 0, $A_Q12$addr = 0, $Atmp_QA = 0, $DC_resp = 0, $k = 0, $order$addr = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $retval = sp + 116 | 0;
 $A_Q12$addr = sp + 112 | 0;
 $order$addr = sp + 108 | 0;
 $k = sp + 104 | 0;
 $Atmp_QA = sp + 8 | 0;
 $DC_resp = sp;
 HEAP32[$A_Q12$addr >> 2] = $A_Q12;
 HEAP32[$order$addr >> 2] = $order;
 HEAP32[$DC_resp >> 2] = 0;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$order$addr >> 2] | 0)) break;
  HEAP32[$DC_resp >> 2] = (HEAP32[$DC_resp >> 2] | 0) + (HEAP16[(HEAP32[$A_Q12$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] | 0);
  HEAP32[$Atmp_QA + (HEAP32[$k >> 2] << 2) >> 2] = HEAP16[(HEAP32[$A_Q12$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] << 12;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 if ((HEAP32[$DC_resp >> 2] | 0) >= 4096) {
  HEAP32[$retval >> 2] = 0;
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  HEAP32[$retval >> 2] = _LPC_inverse_pred_gain_QA_c($Atmp_QA, HEAP32[$order$addr >> 2] | 0) | 0;
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0;
}

function _celt_maxabs16_55($x, $len) {
 $x = $x | 0;
 $len = $len | 0;
 var $2 = 0.0, $cond = 0.0, $cond9 = 0.0, $i = 0, $len$addr = 0, $maxval = 0, $minval = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $x$addr = sp + 16 | 0;
 $len$addr = sp + 12 | 0;
 $i = sp + 8 | 0;
 $maxval = sp + 4 | 0;
 $minval = sp;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$len$addr >> 2] = $len;
 HEAPF32[$maxval >> 2] = 0.0;
 HEAPF32[$minval >> 2] = 0.0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  $2 = +HEAPF32[$maxval >> 2];
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  if ($2 > +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $cond = +HEAPF32[$maxval >> 2]; else $cond = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$maxval >> 2] = $cond;
  if (+HEAPF32[$minval >> 2] < +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $cond9 = +HEAPF32[$minval >> 2]; else $cond9 = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$minval >> 2] = $cond9;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return +($2 > -+HEAPF32[$minval >> 2] ? +HEAPF32[$maxval >> 2] : -+HEAPF32[$minval >> 2]);
}

function _celt_maxabs16($x, $len) {
 $x = $x | 0;
 $len = $len | 0;
 var $2 = 0.0, $cond = 0.0, $cond9 = 0.0, $i = 0, $len$addr = 0, $maxval = 0, $minval = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $x$addr = sp + 16 | 0;
 $len$addr = sp + 12 | 0;
 $i = sp + 8 | 0;
 $maxval = sp + 4 | 0;
 $minval = sp;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$len$addr >> 2] = $len;
 HEAPF32[$maxval >> 2] = 0.0;
 HEAPF32[$minval >> 2] = 0.0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  $2 = +HEAPF32[$maxval >> 2];
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  if ($2 > +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $cond = +HEAPF32[$maxval >> 2]; else $cond = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$maxval >> 2] = $cond;
  if (+HEAPF32[$minval >> 2] < +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]) $cond9 = +HEAPF32[$minval >> 2]; else $cond9 = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAPF32[$minval >> 2] = $cond9;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return +($2 > -+HEAPF32[$minval >> 2] ? +HEAPF32[$maxval >> 2] : -+HEAPF32[$minval >> 2]);
}

function _opus_encoder_get_size($channels) {
 $channels = $channels | 0;
 var $7 = 0, $call6 = 0, $celtEncSizeBytes = 0, $channels$addr = 0, $ret = 0, $retval = 0, $silkEncSizeBytes = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $channels$addr = sp + 12 | 0;
 $silkEncSizeBytes = sp + 8 | 0;
 $celtEncSizeBytes = sp + 4 | 0;
 $ret = sp;
 HEAP32[$channels$addr >> 2] = $channels;
 if ((HEAP32[$channels$addr >> 2] | 0) < 1 | (HEAP32[$channels$addr >> 2] | 0) > 2) {
  HEAP32[$retval >> 2] = 0;
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 }
 HEAP32[$ret >> 2] = _silk_Get_Encoder_Size($silkEncSizeBytes) | 0;
 if (HEAP32[$ret >> 2] | 0) {
  HEAP32[$retval >> 2] = 0;
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 } else {
  HEAP32[$silkEncSizeBytes >> 2] = _align_7(HEAP32[$silkEncSizeBytes >> 2] | 0) | 0;
  HEAP32[$celtEncSizeBytes >> 2] = _celt_encoder_get_size(HEAP32[$channels$addr >> 2] | 0) | 0;
  $call6 = _align_7(18136) | 0;
  HEAP32[$retval >> 2] = $call6 + (HEAP32[$silkEncSizeBytes >> 2] | 0) + (HEAP32[$celtEncSizeBytes >> 2] | 0);
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 }
 return 0;
}

function _resampling_factor($rate) {
 $rate = $rate | 0;
 var $0 = 0, $rate$addr = 0, $ret = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $rate$addr = sp + 4 | 0;
 $ret = sp;
 HEAP32[$rate$addr >> 2] = $rate;
 $0 = HEAP32[$rate$addr >> 2] | 0;
 L1 : do if (($0 | 0) < 16e3) if (($0 | 0) < 12e3) {
  switch ($0 | 0) {
  case 8e3:
   break;
  default:
   {
    label = 7;
    break L1;
   }
  }
  HEAP32[$ret >> 2] = 6;
  break;
 } else {
  switch ($0 | 0) {
  case 12e3:
   break;
  default:
   {
    label = 7;
    break L1;
   }
  }
  HEAP32[$ret >> 2] = 4;
  break;
 } else {
  if (($0 | 0) < 24e3) {
   switch ($0 | 0) {
   case 16e3:
    break;
   default:
    {
     label = 7;
     break L1;
    }
   }
   HEAP32[$ret >> 2] = 3;
   break;
  }
  if (($0 | 0) < 48e3) {
   switch ($0 | 0) {
   case 24e3:
    break;
   default:
    {
     label = 7;
     break L1;
    }
   }
   HEAP32[$ret >> 2] = 2;
   break;
  } else {
   switch ($0 | 0) {
   case 48e3:
    break;
   default:
    {
     label = 7;
     break L1;
    }
   }
   HEAP32[$ret >> 2] = 1;
   break;
  }
 } while (0);
 if ((label | 0) == 7) HEAP32[$ret >> 2] = 0;
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _opus_decoder_get_size($channels) {
 $channels = $channels | 0;
 var $7 = 0, $call6 = 0, $celtDecSizeBytes = 0, $channels$addr = 0, $ret = 0, $retval = 0, $silkDecSizeBytes = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $channels$addr = sp + 12 | 0;
 $silkDecSizeBytes = sp + 8 | 0;
 $celtDecSizeBytes = sp + 4 | 0;
 $ret = sp;
 HEAP32[$channels$addr >> 2] = $channels;
 if ((HEAP32[$channels$addr >> 2] | 0) < 1 | (HEAP32[$channels$addr >> 2] | 0) > 2) {
  HEAP32[$retval >> 2] = 0;
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 }
 HEAP32[$ret >> 2] = _silk_Get_Decoder_Size($silkDecSizeBytes) | 0;
 if (HEAP32[$ret >> 2] | 0) {
  HEAP32[$retval >> 2] = 0;
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 } else {
  HEAP32[$silkDecSizeBytes >> 2] = _align(HEAP32[$silkDecSizeBytes >> 2] | 0) | 0;
  HEAP32[$celtDecSizeBytes >> 2] = _celt_decoder_get_size(HEAP32[$channels$addr >> 2] | 0) | 0;
  $call6 = _align(88) | 0;
  HEAP32[$retval >> 2] = $call6 + (HEAP32[$silkDecSizeBytes >> 2] | 0) + (HEAP32[$celtDecSizeBytes >> 2] | 0);
  $7 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 }
 return 0;
}

function _strlen($s) {
 $s = $s | 0;
 var $$pn = 0, $0 = 0, $3 = 0, $5 = 0, $incdec$ptr = 0, $incdec$ptr1323 = 0, $s$addr$0$lcssa = 0, $s$addr$015 = 0, $s$addr$1$lcssa = 0, $sub$ptr$lhs$cast15$sink = 0, $w$0 = 0, label = 0;
 $0 = $s;
 L1 : do if (!($0 & 3)) {
  $s$addr$0$lcssa = $s;
  label = 4;
 } else {
  $5 = $0;
  $s$addr$015 = $s;
  while (1) {
   if (!(HEAP8[$s$addr$015 >> 0] | 0)) {
    $sub$ptr$lhs$cast15$sink = $5;
    break L1;
   }
   $incdec$ptr = $s$addr$015 + 1 | 0;
   $5 = $incdec$ptr;
   if (!($5 & 3)) {
    $s$addr$0$lcssa = $incdec$ptr;
    label = 4;
    break;
   } else $s$addr$015 = $incdec$ptr;
  }
 } while (0);
 if ((label | 0) == 4) {
  $w$0 = $s$addr$0$lcssa;
  while (1) {
   $3 = HEAP32[$w$0 >> 2] | 0;
   if (!(($3 & -2139062144 ^ -2139062144) & $3 + -16843009)) $w$0 = $w$0 + 4 | 0; else break;
  }
  if (!(($3 & 255) << 24 >> 24)) $s$addr$1$lcssa = $w$0; else {
   $$pn = $w$0;
   while (1) {
    $incdec$ptr1323 = $$pn + 1 | 0;
    if (!(HEAP8[$incdec$ptr1323 >> 0] | 0)) {
     $s$addr$1$lcssa = $incdec$ptr1323;
     break;
    } else $$pn = $incdec$ptr1323;
   }
  }
  $sub$ptr$lhs$cast15$sink = $s$addr$1$lcssa;
 }
 return $sub$ptr$lhs$cast15$sink - $0 | 0;
}

function _bitexact_log2tan($isin, $icos) {
 $isin = $isin | 0;
 $icos = $icos | 0;
 var $add16 = 0, $icos$addr = 0, $isin$addr = 0, $lc = 0, $ls = 0, $sub30 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $isin$addr = sp + 12 | 0;
 $icos$addr = sp + 8 | 0;
 $lc = sp + 4 | 0;
 $ls = sp;
 HEAP32[$isin$addr >> 2] = $isin;
 HEAP32[$icos$addr >> 2] = $icos;
 HEAP32[$lc >> 2] = 32 - (Math_clz32(HEAP32[$icos$addr >> 2] | 0) | 0);
 HEAP32[$ls >> 2] = 32 - (Math_clz32(HEAP32[$isin$addr >> 2] | 0) | 0);
 HEAP32[$icos$addr >> 2] = HEAP32[$icos$addr >> 2] << 15 - (HEAP32[$lc >> 2] | 0);
 HEAP32[$isin$addr >> 2] = HEAP32[$isin$addr >> 2] << 15 - (HEAP32[$ls >> 2] | 0);
 $add16 = ((HEAP32[$ls >> 2] | 0) - (HEAP32[$lc >> 2] | 0) << 11) + (16384 + (Math_imul((HEAP32[$isin$addr >> 2] & 65535) << 16 >> 16, ((16384 + (Math_imul((HEAP32[$isin$addr >> 2] & 65535) << 16 >> 16, -2597) | 0) >> 15) + 7932 & 65535) << 16 >> 16) | 0) >> 15) | 0;
 $sub30 = $add16 - (16384 + (Math_imul((HEAP32[$icos$addr >> 2] & 65535) << 16 >> 16, ((16384 + (Math_imul((HEAP32[$icos$addr >> 2] & 65535) << 16 >> 16, -2597) | 0) >> 15) + 7932 & 65535) << 16 >> 16) | 0) >> 15) | 0;
 STACKTOP = sp;
 return $sub30 | 0;
}

function _silk_interpolate($xi, $x0, $x1, $ifact_Q2, $d) {
 $xi = $xi | 0;
 $x0 = $x0 | 0;
 $x1 = $x1 | 0;
 $ifact_Q2 = $ifact_Q2 | 0;
 $d = $d | 0;
 var $conv9 = 0, $d$addr = 0, $i = 0, $ifact_Q2$addr = 0, $x0$addr = 0, $x1$addr = 0, $xi$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $xi$addr = sp + 20 | 0;
 $x0$addr = sp + 16 | 0;
 $x1$addr = sp + 12 | 0;
 $ifact_Q2$addr = sp + 8 | 0;
 $d$addr = sp + 4 | 0;
 $i = sp;
 HEAP32[$xi$addr >> 2] = $xi;
 HEAP32[$x0$addr >> 2] = $x0;
 HEAP32[$x1$addr >> 2] = $x1;
 HEAP32[$ifact_Q2$addr >> 2] = $ifact_Q2;
 HEAP32[$d$addr >> 2] = $d;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$d$addr >> 2] | 0)) break;
  $conv9 = (HEAP16[(HEAP32[$x0$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) + ((Math_imul(((HEAP16[(HEAP32[$x1$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) - (HEAP16[(HEAP32[$x0$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) & 65535) << 16 >> 16, (HEAP32[$ifact_Q2$addr >> 2] & 65535) << 16 >> 16) | 0) >> 2) & 65535;
  HEAP16[(HEAP32[$xi$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] = $conv9;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _median_of_3($x) {
 $x = $x | 0;
 var $20 = 0.0, $4 = 0, $retval = 0, $t0 = 0, $t1 = 0, $t2 = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $x$addr = sp + 12 | 0;
 $t0 = sp + 8 | 0;
 $t1 = sp + 4 | 0;
 $t2 = sp;
 HEAP32[$x$addr >> 2] = $x;
 $4 = HEAP32[$x$addr >> 2] | 0;
 if (+HEAPF32[HEAP32[$x$addr >> 2] >> 2] > +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 4 >> 2]) {
  HEAPF32[$t0 >> 2] = +HEAPF32[$4 + 4 >> 2];
  HEAPF32[$t1 >> 2] = +HEAPF32[HEAP32[$x$addr >> 2] >> 2];
 } else {
  HEAPF32[$t0 >> 2] = +HEAPF32[$4 >> 2];
  HEAPF32[$t1 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 4 >> 2];
 }
 HEAPF32[$t2 >> 2] = +HEAPF32[(HEAP32[$x$addr >> 2] | 0) + 8 >> 2];
 if (+HEAPF32[$t1 >> 2] < +HEAPF32[$t2 >> 2]) {
  HEAPF32[$retval >> 2] = +HEAPF32[$t1 >> 2];
  $20 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$20;
 }
 if (+HEAPF32[$t0 >> 2] < +HEAPF32[$t2 >> 2]) {
  HEAPF32[$retval >> 2] = +HEAPF32[$t2 >> 2];
  $20 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$20;
 } else {
  HEAPF32[$retval >> 2] = +HEAPF32[$t0 >> 2];
  $20 = +HEAPF32[$retval >> 2];
  STACKTOP = sp;
  return +$20;
 }
 return +(0.0);
}

function _ec_write_byte_at_end($_this, $_value) {
 $_this = $_this | 0;
 $_value = $_value | 0;
 var $10 = 0, $13 = 0, $8 = 0, $_this$addr = 0, $_value$addr = 0, $conv = 0, $end_offs2 = 0, $inc = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $retval = sp + 8 | 0;
 $_this$addr = sp + 4 | 0;
 $_value$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_value$addr >> 2] = $_value;
 if (((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] | 0) + (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0) | 0) >>> 0 >= (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0) >>> 0) {
  HEAP32[$retval >> 2] = -1;
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  $conv = HEAP32[$_value$addr >> 2] & 255;
  $8 = HEAP32[HEAP32[$_this$addr >> 2] >> 2] | 0;
  $10 = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0;
  $end_offs2 = (HEAP32[$_this$addr >> 2] | 0) + 8 | 0;
  $inc = (HEAP32[$end_offs2 >> 2] | 0) + 1 | 0;
  HEAP32[$end_offs2 >> 2] = $inc;
  HEAP8[$8 + ($10 - $inc) >> 0] = $conv;
  HEAP32[$retval >> 2] = 0;
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0;
}

function _silk_ROR32_548($a32, $rot) {
 $a32 = $a32 | 0;
 $rot = $rot | 0;
 var $13 = 0, $6 = 0, $a32$addr = 0, $m = 0, $r = 0, $retval = 0, $rot$addr = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $a32$addr = sp + 16 | 0;
 $rot$addr = sp + 12 | 0;
 $x = sp + 8 | 0;
 $r = sp + 4 | 0;
 $m = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$rot$addr >> 2] = $rot;
 HEAP32[$x >> 2] = HEAP32[$a32$addr >> 2];
 HEAP32[$r >> 2] = HEAP32[$rot$addr >> 2];
 HEAP32[$m >> 2] = 0 - (HEAP32[$rot$addr >> 2] | 0);
 if (!(HEAP32[$rot$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = HEAP32[$a32$addr >> 2];
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 $6 = HEAP32[$x >> 2] | 0;
 if ((HEAP32[$rot$addr >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = $6 << HEAP32[$m >> 2] | (HEAP32[$x >> 2] | 0) >>> (32 - (HEAP32[$m >> 2] | 0) | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  HEAP32[$retval >> 2] = $6 << 32 - (HEAP32[$r >> 2] | 0) | (HEAP32[$x >> 2] | 0) >>> (HEAP32[$r >> 2] | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0;
}

function _silk_ROR32_458($a32, $rot) {
 $a32 = $a32 | 0;
 $rot = $rot | 0;
 var $13 = 0, $6 = 0, $a32$addr = 0, $m = 0, $r = 0, $retval = 0, $rot$addr = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $a32$addr = sp + 16 | 0;
 $rot$addr = sp + 12 | 0;
 $x = sp + 8 | 0;
 $r = sp + 4 | 0;
 $m = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$rot$addr >> 2] = $rot;
 HEAP32[$x >> 2] = HEAP32[$a32$addr >> 2];
 HEAP32[$r >> 2] = HEAP32[$rot$addr >> 2];
 HEAP32[$m >> 2] = 0 - (HEAP32[$rot$addr >> 2] | 0);
 if (!(HEAP32[$rot$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = HEAP32[$a32$addr >> 2];
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 $6 = HEAP32[$x >> 2] | 0;
 if ((HEAP32[$rot$addr >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = $6 << HEAP32[$m >> 2] | (HEAP32[$x >> 2] | 0) >>> (32 - (HEAP32[$m >> 2] | 0) | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  HEAP32[$retval >> 2] = $6 << 32 - (HEAP32[$r >> 2] | 0) | (HEAP32[$x >> 2] | 0) >>> (HEAP32[$r >> 2] | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0;
}

function _silk_ROR32_441($a32, $rot) {
 $a32 = $a32 | 0;
 $rot = $rot | 0;
 var $13 = 0, $6 = 0, $a32$addr = 0, $m = 0, $r = 0, $retval = 0, $rot$addr = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $a32$addr = sp + 16 | 0;
 $rot$addr = sp + 12 | 0;
 $x = sp + 8 | 0;
 $r = sp + 4 | 0;
 $m = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$rot$addr >> 2] = $rot;
 HEAP32[$x >> 2] = HEAP32[$a32$addr >> 2];
 HEAP32[$r >> 2] = HEAP32[$rot$addr >> 2];
 HEAP32[$m >> 2] = 0 - (HEAP32[$rot$addr >> 2] | 0);
 if (!(HEAP32[$rot$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = HEAP32[$a32$addr >> 2];
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 $6 = HEAP32[$x >> 2] | 0;
 if ((HEAP32[$rot$addr >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = $6 << HEAP32[$m >> 2] | (HEAP32[$x >> 2] | 0) >>> (32 - (HEAP32[$m >> 2] | 0) | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  HEAP32[$retval >> 2] = $6 << 32 - (HEAP32[$r >> 2] | 0) | (HEAP32[$x >> 2] | 0) >>> (HEAP32[$r >> 2] | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0;
}

function _silk_ROR32_344($a32, $rot) {
 $a32 = $a32 | 0;
 $rot = $rot | 0;
 var $13 = 0, $6 = 0, $a32$addr = 0, $m = 0, $r = 0, $retval = 0, $rot$addr = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $a32$addr = sp + 16 | 0;
 $rot$addr = sp + 12 | 0;
 $x = sp + 8 | 0;
 $r = sp + 4 | 0;
 $m = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$rot$addr >> 2] = $rot;
 HEAP32[$x >> 2] = HEAP32[$a32$addr >> 2];
 HEAP32[$r >> 2] = HEAP32[$rot$addr >> 2];
 HEAP32[$m >> 2] = 0 - (HEAP32[$rot$addr >> 2] | 0);
 if (!(HEAP32[$rot$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = HEAP32[$a32$addr >> 2];
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 $6 = HEAP32[$x >> 2] | 0;
 if ((HEAP32[$rot$addr >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = $6 << HEAP32[$m >> 2] | (HEAP32[$x >> 2] | 0) >>> (32 - (HEAP32[$m >> 2] | 0) | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  HEAP32[$retval >> 2] = $6 << 32 - (HEAP32[$r >> 2] | 0) | (HEAP32[$x >> 2] | 0) >>> (HEAP32[$r >> 2] | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0;
}

function _silk_ROR32_278($a32, $rot) {
 $a32 = $a32 | 0;
 $rot = $rot | 0;
 var $13 = 0, $6 = 0, $a32$addr = 0, $m = 0, $r = 0, $retval = 0, $rot$addr = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $a32$addr = sp + 16 | 0;
 $rot$addr = sp + 12 | 0;
 $x = sp + 8 | 0;
 $r = sp + 4 | 0;
 $m = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$rot$addr >> 2] = $rot;
 HEAP32[$x >> 2] = HEAP32[$a32$addr >> 2];
 HEAP32[$r >> 2] = HEAP32[$rot$addr >> 2];
 HEAP32[$m >> 2] = 0 - (HEAP32[$rot$addr >> 2] | 0);
 if (!(HEAP32[$rot$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = HEAP32[$a32$addr >> 2];
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 $6 = HEAP32[$x >> 2] | 0;
 if ((HEAP32[$rot$addr >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = $6 << HEAP32[$m >> 2] | (HEAP32[$x >> 2] | 0) >>> (32 - (HEAP32[$m >> 2] | 0) | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  HEAP32[$retval >> 2] = $6 << 32 - (HEAP32[$r >> 2] | 0) | (HEAP32[$x >> 2] | 0) >>> (HEAP32[$r >> 2] | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0;
}

function _silk_insertion_sort_increasing_all_values_int16($a, $L) {
 $a = $a | 0;
 $L = $L | 0;
 var $L$addr = 0, $a$addr = 0, $i = 0, $j = 0, $value = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $a$addr = sp + 16 | 0;
 $L$addr = sp + 12 | 0;
 $value = sp + 8 | 0;
 $i = sp + 4 | 0;
 $j = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$L$addr >> 2] = $L;
 HEAP32[$i >> 2] = 1;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$L$addr >> 2] | 0)) break;
  HEAP32[$value >> 2] = HEAP16[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1];
  HEAP32[$j >> 2] = (HEAP32[$i >> 2] | 0) - 1;
  while (1) {
   if ((HEAP32[$j >> 2] | 0) < 0) break;
   if ((HEAP32[$value >> 2] | 0) >= (HEAP16[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0)) break;
   HEAP16[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] = HEAP16[(HEAP32[$a$addr >> 2] | 0) + (HEAP32[$j >> 2] << 1) >> 1] | 0;
   HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + -1;
  }
  HEAP16[(HEAP32[$a$addr >> 2] | 0) + ((HEAP32[$j >> 2] | 0) + 1 << 1) >> 1] = HEAP32[$value >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _silk_ROR32($a32, $rot) {
 $a32 = $a32 | 0;
 $rot = $rot | 0;
 var $13 = 0, $6 = 0, $a32$addr = 0, $m = 0, $r = 0, $retval = 0, $rot$addr = 0, $x = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 20 | 0;
 $a32$addr = sp + 16 | 0;
 $rot$addr = sp + 12 | 0;
 $x = sp + 8 | 0;
 $r = sp + 4 | 0;
 $m = sp;
 HEAP32[$a32$addr >> 2] = $a32;
 HEAP32[$rot$addr >> 2] = $rot;
 HEAP32[$x >> 2] = HEAP32[$a32$addr >> 2];
 HEAP32[$r >> 2] = HEAP32[$rot$addr >> 2];
 HEAP32[$m >> 2] = 0 - (HEAP32[$rot$addr >> 2] | 0);
 if (!(HEAP32[$rot$addr >> 2] | 0)) {
  HEAP32[$retval >> 2] = HEAP32[$a32$addr >> 2];
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 $6 = HEAP32[$x >> 2] | 0;
 if ((HEAP32[$rot$addr >> 2] | 0) < 0) {
  HEAP32[$retval >> 2] = $6 << HEAP32[$m >> 2] | (HEAP32[$x >> 2] | 0) >>> (32 - (HEAP32[$m >> 2] | 0) | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  HEAP32[$retval >> 2] = $6 << 32 - (HEAP32[$r >> 2] | 0) | (HEAP32[$x >> 2] | 0) >>> (HEAP32[$r >> 2] | 0);
  $13 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0;
}

function _silk_corrVector_FLP($x, $t, $L, $Order, $Xt) {
 $x = $x | 0;
 $t = $t | 0;
 $L = $L | 0;
 $Order = $Order | 0;
 $Xt = $Xt | 0;
 var $L$addr = 0, $Order$addr = 0, $Xt$addr = 0, $conv = 0.0, $lag = 0, $ptr1 = 0, $t$addr = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $x$addr = sp + 24 | 0;
 $t$addr = sp + 20 | 0;
 $L$addr = sp + 16 | 0;
 $Order$addr = sp + 12 | 0;
 $Xt$addr = sp + 8 | 0;
 $lag = sp + 4 | 0;
 $ptr1 = sp;
 HEAP32[$x$addr >> 2] = $x;
 HEAP32[$t$addr >> 2] = $t;
 HEAP32[$L$addr >> 2] = $L;
 HEAP32[$Order$addr >> 2] = $Order;
 HEAP32[$Xt$addr >> 2] = $Xt;
 HEAP32[$ptr1 >> 2] = (HEAP32[$x$addr >> 2] | 0) + ((HEAP32[$Order$addr >> 2] | 0) - 1 << 2);
 HEAP32[$lag >> 2] = 0;
 while (1) {
  if ((HEAP32[$lag >> 2] | 0) >= (HEAP32[$Order$addr >> 2] | 0)) break;
  $conv = +_silk_inner_product_FLP(HEAP32[$ptr1 >> 2] | 0, HEAP32[$t$addr >> 2] | 0, HEAP32[$L$addr >> 2] | 0);
  HEAPF32[(HEAP32[$Xt$addr >> 2] | 0) + (HEAP32[$lag >> 2] << 2) >> 2] = $conv;
  HEAP32[$ptr1 >> 2] = (HEAP32[$ptr1 >> 2] | 0) + -4;
  HEAP32[$lag >> 2] = (HEAP32[$lag >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _ec_enc_init($_this, $_buf, $_size) {
 $_this = $_this | 0;
 $_buf = $_buf | 0;
 $_size = $_size | 0;
 var $_buf$addr = 0, $_size$addr = 0, $_this$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp + 8 | 0;
 $_buf$addr = sp + 4 | 0;
 $_size$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_buf$addr >> 2] = $_buf;
 HEAP32[$_size$addr >> 2] = $_size;
 HEAP32[HEAP32[$_this$addr >> 2] >> 2] = HEAP32[$_buf$addr >> 2];
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 12 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 16 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] = 33;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] = -2147483648;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2] = -1;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 36 >> 2] = 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] = HEAP32[$_size$addr >> 2];
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 44 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _normalise_residual($iy, $X, $N, $Ryy, $gain) {
 $iy = $iy | 0;
 $X = $X | 0;
 $N = $N | 0;
 $Ryy = +$Ryy;
 $gain = +$gain;
 var $N$addr = 0, $Ryy$addr = 0, $X$addr = 0, $div = 0.0, $g = 0, $gain$addr = 0, $i = 0, $inc = 0, $iy$addr = 0, $t = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $iy$addr = sp + 28 | 0;
 $X$addr = sp + 24 | 0;
 $N$addr = sp + 20 | 0;
 $Ryy$addr = sp + 16 | 0;
 $gain$addr = sp + 12 | 0;
 $i = sp + 8 | 0;
 $t = sp + 4 | 0;
 $g = sp;
 HEAP32[$iy$addr >> 2] = $iy;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$N$addr >> 2] = $N;
 HEAPF32[$Ryy$addr >> 2] = $Ryy;
 HEAPF32[$gain$addr >> 2] = $gain;
 HEAPF32[$t >> 2] = +HEAPF32[$Ryy$addr >> 2];
 $div = 1.0 / +Math_sqrt(+(+HEAPF32[$t >> 2]));
 HEAPF32[$g >> 2] = $div * +HEAPF32[$gain$addr >> 2];
 HEAP32[$i >> 2] = 0;
 do {
  HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +HEAPF32[$g >> 2] * +(HEAP32[(HEAP32[$iy$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] | 0);
  $inc = (HEAP32[$i >> 2] | 0) + 1 | 0;
  HEAP32[$i >> 2] = $inc;
 } while (($inc | 0) < (HEAP32[$N$addr >> 2] | 0));
 STACKTOP = sp;
 return;
}

function _silk_A2NLSF_trans_poly($p, $dd) {
 $p = $p | 0;
 $dd = $dd | 0;
 var $5 = 0, $arrayidx4 = 0, $arrayidx8 = 0, $dd$addr = 0, $k = 0, $n = 0, $p$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $p$addr = sp + 12 | 0;
 $dd$addr = sp + 8 | 0;
 $k = sp + 4 | 0;
 $n = sp;
 HEAP32[$p$addr >> 2] = $p;
 HEAP32[$dd$addr >> 2] = $dd;
 HEAP32[$k >> 2] = 2;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) > (HEAP32[$dd$addr >> 2] | 0)) break;
  HEAP32[$n >> 2] = HEAP32[$dd$addr >> 2];
  while (1) {
   $5 = HEAP32[$p$addr >> 2] | 0;
   if ((HEAP32[$n >> 2] | 0) <= (HEAP32[$k >> 2] | 0)) break;
   $arrayidx4 = (HEAP32[$p$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) - 2 << 2) | 0;
   HEAP32[$arrayidx4 >> 2] = (HEAP32[$arrayidx4 >> 2] | 0) - (HEAP32[$5 + (HEAP32[$n >> 2] << 2) >> 2] | 0);
   HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + -1;
  }
  $arrayidx8 = (HEAP32[$p$addr >> 2] | 0) + ((HEAP32[$k >> 2] | 0) - 2 << 2) | 0;
  HEAP32[$arrayidx8 >> 2] = (HEAP32[$arrayidx8 >> 2] | 0) - (HEAP32[$5 + (HEAP32[$k >> 2] << 2) >> 2] << 1);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _pulses2bits($m, $band, $LM, $pulses) {
 $m = $m | 0;
 $band = $band | 0;
 $LM = $LM | 0;
 $pulses = $pulses | 0;
 var $LM$addr = 0, $band$addr = 0, $cache = 0, $cond = 0, $m$addr = 0, $mul = 0, $pulses$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $m$addr = sp + 16 | 0;
 $band$addr = sp + 12 | 0;
 $LM$addr = sp + 8 | 0;
 $pulses$addr = sp + 4 | 0;
 $cache = sp;
 HEAP32[$m$addr >> 2] = $m;
 HEAP32[$band$addr >> 2] = $band;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAP32[$pulses$addr >> 2] = $pulses;
 HEAP32[$LM$addr >> 2] = (HEAP32[$LM$addr >> 2] | 0) + 1;
 $mul = Math_imul(HEAP32[$LM$addr >> 2] | 0, HEAP32[(HEAP32[$m$addr >> 2] | 0) + 8 >> 2] | 0) | 0;
 HEAP32[$cache >> 2] = (HEAP32[(HEAP32[$m$addr >> 2] | 0) + 92 + 8 >> 2] | 0) + (HEAP16[(HEAP32[(HEAP32[$m$addr >> 2] | 0) + 92 + 4 >> 2] | 0) + ($mul + (HEAP32[$band$addr >> 2] | 0) << 1) >> 1] | 0);
 if (!(HEAP32[$pulses$addr >> 2] | 0)) {
  $cond = 0;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = (HEAPU8[(HEAP32[$cache >> 2] | 0) + (HEAP32[$pulses$addr >> 2] | 0) >> 0] | 0) + 1 | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _ec_enc_bit_logp($_this, $_val, $_logp) {
 $_this = $_this | 0;
 $_val = $_val | 0;
 $_logp = $_logp | 0;
 var $_logp$addr = 0, $_this$addr = 0, $_val$addr = 0, $l = 0, $r = 0, $s = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 20 | 0;
 $_val$addr = sp + 16 | 0;
 $_logp$addr = sp + 12 | 0;
 $r = sp + 8 | 0;
 $s = sp + 4 | 0;
 $l = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_val$addr >> 2] = $_val;
 HEAP32[$_logp$addr >> 2] = $_logp;
 HEAP32[$r >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2];
 HEAP32[$l >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2];
 HEAP32[$s >> 2] = (HEAP32[$r >> 2] | 0) >>> (HEAP32[$_logp$addr >> 2] | 0);
 HEAP32[$r >> 2] = (HEAP32[$r >> 2] | 0) - (HEAP32[$s >> 2] | 0);
 if (HEAP32[$_val$addr >> 2] | 0) HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] = (HEAP32[$l >> 2] | 0) + (HEAP32[$r >> 2] | 0);
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] = HEAP32[$_val$addr >> 2] | 0 ? HEAP32[$s >> 2] | 0 : HEAP32[$r >> 2] | 0;
 _ec_enc_normalize(HEAP32[$_this$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _silk_inner_prod_aligned_scale($inVec1, $inVec2, $scale, $len) {
 $inVec1 = $inVec1 | 0;
 $inVec2 = $inVec2 | 0;
 $scale = $scale | 0;
 $len = $len | 0;
 var $2 = 0, $i = 0, $inVec1$addr = 0, $inVec2$addr = 0, $len$addr = 0, $mul = 0, $scale$addr = 0, $sum = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $inVec1$addr = sp + 20 | 0;
 $inVec2$addr = sp + 16 | 0;
 $scale$addr = sp + 12 | 0;
 $len$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $sum = sp;
 HEAP32[$inVec1$addr >> 2] = $inVec1;
 HEAP32[$inVec2$addr >> 2] = $inVec2;
 HEAP32[$scale$addr >> 2] = $scale;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$sum >> 2] = 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  $2 = HEAP32[$sum >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  $mul = Math_imul(HEAP16[(HEAP32[$inVec1$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0, HEAP16[(HEAP32[$inVec2$addr >> 2] | 0) + (HEAP32[$i >> 2] << 1) >> 1] | 0) | 0;
  HEAP32[$sum >> 2] = $2 + ($mul >> HEAP32[$scale$addr >> 2]);
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return $2 | 0;
}

function _silk_bwexpander_FLP($ar, $d, $chirp) {
 $ar = $ar | 0;
 $d = $d | 0;
 $chirp = +$chirp;
 var $3 = 0.0, $4 = 0, $ar$addr = 0, $arrayidx = 0, $arrayidx3 = 0, $cfac = 0, $chirp$addr = 0, $d$addr = 0, $i = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $ar$addr = sp + 16 | 0;
 $d$addr = sp + 12 | 0;
 $chirp$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $cfac = sp;
 HEAP32[$ar$addr >> 2] = $ar;
 HEAP32[$d$addr >> 2] = $d;
 HEAPF32[$chirp$addr >> 2] = $chirp;
 HEAPF32[$cfac >> 2] = +HEAPF32[$chirp$addr >> 2];
 HEAP32[$i >> 2] = 0;
 while (1) {
  $3 = +HEAPF32[$cfac >> 2];
  $4 = HEAP32[$ar$addr >> 2] | 0;
  if ((HEAP32[$i >> 2] | 0) >= ((HEAP32[$d$addr >> 2] | 0) - 1 | 0)) break;
  $arrayidx = $4 + (HEAP32[$i >> 2] << 2) | 0;
  HEAPF32[$arrayidx >> 2] = +HEAPF32[$arrayidx >> 2] * $3;
  HEAPF32[$cfac >> 2] = +HEAPF32[$cfac >> 2] * +HEAPF32[$chirp$addr >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 $arrayidx3 = $4 + ((HEAP32[$d$addr >> 2] | 0) - 1 << 2) | 0;
 HEAPF32[$arrayidx3 >> 2] = +HEAPF32[$arrayidx3 >> 2] * $3;
 STACKTOP = sp;
 return;
}

function _silk_SQRT_APPROX_545($x) {
 $x = $x | 0;
 var $11 = 0, $frac_Q7 = 0, $lz = 0, $mul8 = 0, $retval = 0, $x$addr = 0, $y = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $x$addr = sp + 12 | 0;
 $y = sp + 8 | 0;
 $lz = sp + 4 | 0;
 $frac_Q7 = sp;
 HEAP32[$x$addr >> 2] = $x;
 if ((HEAP32[$x$addr >> 2] | 0) <= 0) {
  HEAP32[$retval >> 2] = 0;
  $11 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $11 | 0;
 }
 _silk_CLZ_FRAC_546(HEAP32[$x$addr >> 2] | 0, $lz, $frac_Q7);
 if (HEAP32[$lz >> 2] & 1 | 0) HEAP32[$y >> 2] = 32768; else HEAP32[$y >> 2] = 46214;
 HEAP32[$y >> 2] = HEAP32[$y >> 2] >> (HEAP32[$lz >> 2] >> 1);
 $mul8 = Math_imul(HEAP32[$y >> 2] >> 16, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0;
 HEAP32[$y >> 2] = (HEAP32[$y >> 2] | 0) + ($mul8 + ((Math_imul(HEAP32[$y >> 2] & 65535, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$retval >> 2] = HEAP32[$y >> 2];
 $11 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $11 | 0;
}

function _silk_SQRT_APPROX_454($x) {
 $x = $x | 0;
 var $11 = 0, $frac_Q7 = 0, $lz = 0, $mul8 = 0, $retval = 0, $x$addr = 0, $y = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $x$addr = sp + 12 | 0;
 $y = sp + 8 | 0;
 $lz = sp + 4 | 0;
 $frac_Q7 = sp;
 HEAP32[$x$addr >> 2] = $x;
 if ((HEAP32[$x$addr >> 2] | 0) <= 0) {
  HEAP32[$retval >> 2] = 0;
  $11 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $11 | 0;
 }
 _silk_CLZ_FRAC_456(HEAP32[$x$addr >> 2] | 0, $lz, $frac_Q7);
 if (HEAP32[$lz >> 2] & 1 | 0) HEAP32[$y >> 2] = 32768; else HEAP32[$y >> 2] = 46214;
 HEAP32[$y >> 2] = HEAP32[$y >> 2] >> (HEAP32[$lz >> 2] >> 1);
 $mul8 = Math_imul(HEAP32[$y >> 2] >> 16, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0;
 HEAP32[$y >> 2] = (HEAP32[$y >> 2] | 0) + ($mul8 + ((Math_imul(HEAP32[$y >> 2] & 65535, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$retval >> 2] = HEAP32[$y >> 2];
 $11 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $11 | 0;
}

function _silk_SQRT_APPROX_439($x) {
 $x = $x | 0;
 var $11 = 0, $frac_Q7 = 0, $lz = 0, $mul8 = 0, $retval = 0, $x$addr = 0, $y = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $x$addr = sp + 12 | 0;
 $y = sp + 8 | 0;
 $lz = sp + 4 | 0;
 $frac_Q7 = sp;
 HEAP32[$x$addr >> 2] = $x;
 if ((HEAP32[$x$addr >> 2] | 0) <= 0) {
  HEAP32[$retval >> 2] = 0;
  $11 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $11 | 0;
 }
 _silk_CLZ_FRAC_440(HEAP32[$x$addr >> 2] | 0, $lz, $frac_Q7);
 if (HEAP32[$lz >> 2] & 1 | 0) HEAP32[$y >> 2] = 32768; else HEAP32[$y >> 2] = 46214;
 HEAP32[$y >> 2] = HEAP32[$y >> 2] >> (HEAP32[$lz >> 2] >> 1);
 $mul8 = Math_imul(HEAP32[$y >> 2] >> 16, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0;
 HEAP32[$y >> 2] = (HEAP32[$y >> 2] | 0) + ($mul8 + ((Math_imul(HEAP32[$y >> 2] & 65535, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$retval >> 2] = HEAP32[$y >> 2];
 $11 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $11 | 0;
}

function _silk_SQRT_APPROX_341($x) {
 $x = $x | 0;
 var $11 = 0, $frac_Q7 = 0, $lz = 0, $mul8 = 0, $retval = 0, $x$addr = 0, $y = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $x$addr = sp + 12 | 0;
 $y = sp + 8 | 0;
 $lz = sp + 4 | 0;
 $frac_Q7 = sp;
 HEAP32[$x$addr >> 2] = $x;
 if ((HEAP32[$x$addr >> 2] | 0) <= 0) {
  HEAP32[$retval >> 2] = 0;
  $11 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $11 | 0;
 }
 _silk_CLZ_FRAC_342(HEAP32[$x$addr >> 2] | 0, $lz, $frac_Q7);
 if (HEAP32[$lz >> 2] & 1 | 0) HEAP32[$y >> 2] = 32768; else HEAP32[$y >> 2] = 46214;
 HEAP32[$y >> 2] = HEAP32[$y >> 2] >> (HEAP32[$lz >> 2] >> 1);
 $mul8 = Math_imul(HEAP32[$y >> 2] >> 16, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0;
 HEAP32[$y >> 2] = (HEAP32[$y >> 2] | 0) + ($mul8 + ((Math_imul(HEAP32[$y >> 2] & 65535, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$retval >> 2] = HEAP32[$y >> 2];
 $11 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $11 | 0;
}

function _silk_SQRT_APPROX($x) {
 $x = $x | 0;
 var $11 = 0, $frac_Q7 = 0, $lz = 0, $mul8 = 0, $retval = 0, $x$addr = 0, $y = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 16 | 0;
 $x$addr = sp + 12 | 0;
 $y = sp + 8 | 0;
 $lz = sp + 4 | 0;
 $frac_Q7 = sp;
 HEAP32[$x$addr >> 2] = $x;
 if ((HEAP32[$x$addr >> 2] | 0) <= 0) {
  HEAP32[$retval >> 2] = 0;
  $11 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $11 | 0;
 }
 _silk_CLZ_FRAC_276(HEAP32[$x$addr >> 2] | 0, $lz, $frac_Q7);
 if (HEAP32[$lz >> 2] & 1 | 0) HEAP32[$y >> 2] = 32768; else HEAP32[$y >> 2] = 46214;
 HEAP32[$y >> 2] = HEAP32[$y >> 2] >> (HEAP32[$lz >> 2] >> 1);
 $mul8 = Math_imul(HEAP32[$y >> 2] >> 16, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0;
 HEAP32[$y >> 2] = (HEAP32[$y >> 2] | 0) + ($mul8 + ((Math_imul(HEAP32[$y >> 2] & 65535, (((HEAP32[$frac_Q7 >> 2] & 65535) << 16 >> 16) * 213 & 65535) << 16 >> 16) | 0) >> 16));
 HEAP32[$retval >> 2] = HEAP32[$y >> 2];
 $11 = HEAP32[$retval >> 2] | 0;
 STACKTOP = sp;
 return $11 | 0;
}

function _silk_NLSF2A_FLP($pAR, $NLSF_Q15, $LPC_order, $arch) {
 $pAR = $pAR | 0;
 $NLSF_Q15 = $NLSF_Q15 | 0;
 $LPC_order = $LPC_order | 0;
 $arch = $arch | 0;
 var $LPC_order$addr = 0, $NLSF_Q15$addr = 0, $a_fix_Q12 = 0, $arch$addr = 0, $i = 0, $pAR$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $pAR$addr = sp + 16 | 0;
 $NLSF_Q15$addr = sp + 12 | 0;
 $LPC_order$addr = sp + 8 | 0;
 $arch$addr = sp + 4 | 0;
 $i = sp;
 $a_fix_Q12 = sp + 24 | 0;
 HEAP32[$pAR$addr >> 2] = $pAR;
 HEAP32[$NLSF_Q15$addr >> 2] = $NLSF_Q15;
 HEAP32[$LPC_order$addr >> 2] = $LPC_order;
 HEAP32[$arch$addr >> 2] = $arch;
 _silk_NLSF2A($a_fix_Q12, HEAP32[$NLSF_Q15$addr >> 2] | 0, HEAP32[$LPC_order$addr >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$LPC_order$addr >> 2] | 0)) break;
  HEAPF32[(HEAP32[$pAR$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] = +(HEAP16[$a_fix_Q12 + (HEAP32[$i >> 2] << 1) >> 1] | 0) * .000244140625;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _ec_dec_normalize($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $call = 0, $nbits_total = 0, $rng1 = 0, $sym = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp + 4 | 0;
 $sym = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 while (1) {
  if ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) >>> 0 > 8388608) break;
  $nbits_total = (HEAP32[$_this$addr >> 2] | 0) + 20 | 0;
  HEAP32[$nbits_total >> 2] = (HEAP32[$nbits_total >> 2] | 0) + 8;
  $rng1 = (HEAP32[$_this$addr >> 2] | 0) + 28 | 0;
  HEAP32[$rng1 >> 2] = HEAP32[$rng1 >> 2] << 8;
  HEAP32[$sym >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2];
  $call = _ec_read_byte(HEAP32[$_this$addr >> 2] | 0) | 0;
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2] = $call;
  HEAP32[$sym >> 2] = (HEAP32[$sym >> 2] << 8 | HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 40 >> 2]) >> 1;
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] << 8) + (255 & ~HEAP32[$sym >> 2]) & 2147483647;
 }
 STACKTOP = sp;
 return;
}

function _is_digital_silence($pcm, $frame_size, $channels, $lsb_depth) {
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $channels = $channels | 0;
 $lsb_depth = $lsb_depth | 0;
 var $channels$addr = 0, $frame_size$addr = 0, $lsb_depth$addr = 0, $pcm$addr = 0, $sample_max = 0, $silence = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $pcm$addr = sp + 20 | 0;
 $frame_size$addr = sp + 16 | 0;
 $channels$addr = sp + 12 | 0;
 $lsb_depth$addr = sp + 8 | 0;
 $silence = sp + 4 | 0;
 $sample_max = sp;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$lsb_depth$addr >> 2] = $lsb_depth;
 HEAP32[$silence >> 2] = 0;
 HEAPF32[$sample_max >> 2] = 0.0;
 HEAPF32[$sample_max >> 2] = +_celt_maxabs16(HEAP32[$pcm$addr >> 2] | 0, Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0);
 HEAP32[$silence >> 2] = +HEAPF32[$sample_max >> 2] <= 1.0 / +(1 << HEAP32[$lsb_depth$addr >> 2] | 0) & 1;
 STACKTOP = sp;
 return HEAP32[$silence >> 2] | 0;
}

function _ec_write_byte($_this, $_value) {
 $_this = $_this | 0;
 $_value = $_value | 0;
 var $10 = 0, $11 = 0, $8 = 0, $_this$addr = 0, $_value$addr = 0, $conv = 0, $offs1 = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $retval = sp + 8 | 0;
 $_this$addr = sp + 4 | 0;
 $_value$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_value$addr >> 2] = $_value;
 if (((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] | 0) + (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0) | 0) >>> 0 >= (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0) >>> 0) {
  HEAP32[$retval >> 2] = -1;
  $11 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $11 | 0;
 } else {
  $conv = HEAP32[$_value$addr >> 2] & 255;
  $8 = HEAP32[HEAP32[$_this$addr >> 2] >> 2] | 0;
  $offs1 = (HEAP32[$_this$addr >> 2] | 0) + 24 | 0;
  $10 = HEAP32[$offs1 >> 2] | 0;
  HEAP32[$offs1 >> 2] = $10 + 1;
  HEAP8[$8 + $10 >> 0] = $conv;
  HEAP32[$retval >> 2] = 0;
  $11 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $11 | 0;
 }
 return 0;
}

function _silk_float2short_array_325($out, $in, $length) {
 $out = $out | 0;
 $in = $in | 0;
 $length = $length | 0;
 var $cond10 = 0, $in$addr = 0, $k = 0, $length$addr = 0, $out$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $out$addr = sp + 12 | 0;
 $in$addr = sp + 8 | 0;
 $length$addr = sp + 4 | 0;
 $k = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$k >> 2] = (HEAP32[$length$addr >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) < 0) break;
  if ((_lrintf(+HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2]) | 0) > 32767) $cond10 = 32767; else if ((_lrintf(+HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2]) | 0) < -32768) $cond10 = -32768; else $cond10 = _lrintf(+HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2]) | 0;
  HEAP16[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $cond10;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return;
}

function _warped_gain($coefs, $lambda, $order) {
 $coefs = $coefs | 0;
 $lambda = +$lambda;
 $order = $order | 0;
 var $coefs$addr = 0, $gain = 0, $i = 0, $lambda$addr = 0, $mul = 0.0, $order$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $coefs$addr = sp + 16 | 0;
 $lambda$addr = sp + 12 | 0;
 $order$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $gain = sp;
 HEAP32[$coefs$addr >> 2] = $coefs;
 HEAPF32[$lambda$addr >> 2] = $lambda;
 HEAP32[$order$addr >> 2] = $order;
 HEAPF32[$lambda$addr >> 2] = -+HEAPF32[$lambda$addr >> 2];
 HEAPF32[$gain >> 2] = +HEAPF32[(HEAP32[$coefs$addr >> 2] | 0) + ((HEAP32[$order$addr >> 2] | 0) - 1 << 2) >> 2];
 HEAP32[$i >> 2] = (HEAP32[$order$addr >> 2] | 0) - 2;
 while (1) {
  $mul = +HEAPF32[$lambda$addr >> 2] * +HEAPF32[$gain >> 2];
  if ((HEAP32[$i >> 2] | 0) < 0) break;
  HEAPF32[$gain >> 2] = $mul + +HEAPF32[(HEAP32[$coefs$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return +(1.0 / (1.0 - $mul));
}

function _silk_float2short_array($out, $in, $length) {
 $out = $out | 0;
 $in = $in | 0;
 $length = $length | 0;
 var $cond10 = 0, $in$addr = 0, $k = 0, $length$addr = 0, $out$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $out$addr = sp + 12 | 0;
 $in$addr = sp + 8 | 0;
 $length$addr = sp + 4 | 0;
 $k = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$k >> 2] = (HEAP32[$length$addr >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) < 0) break;
  if ((_lrintf(+HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2]) | 0) > 32767) $cond10 = 32767; else if ((_lrintf(+HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2]) | 0) < -32768) $cond10 = -32768; else $cond10 = _lrintf(+HEAPF32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2]) | 0;
  HEAP16[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] = $cond10;
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return;
}

function _stereo_split($X, $Y, $N) {
 $X = $X | 0;
 $Y = $Y | 0;
 $N = $N | 0;
 var $N$addr = 0, $X$addr = 0, $Y$addr = 0, $j = 0, $l = 0, $r = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $X$addr = sp + 20 | 0;
 $Y$addr = sp + 16 | 0;
 $N$addr = sp + 12 | 0;
 $j = sp + 8 | 0;
 $r = sp + 4 | 0;
 $l = sp;
 HEAP32[$X$addr >> 2] = $X;
 HEAP32[$Y$addr >> 2] = $Y;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$j >> 2] = 0;
 while (1) {
  if ((HEAP32[$j >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  HEAPF32[$l >> 2] = +HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] * .7071067690849304;
  HEAPF32[$r >> 2] = +HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] * .7071067690849304;
  HEAPF32[(HEAP32[$X$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$l >> 2] + +HEAPF32[$r >> 2];
  HEAPF32[(HEAP32[$Y$addr >> 2] | 0) + (HEAP32[$j >> 2] << 2) >> 2] = +HEAPF32[$r >> 2] - +HEAPF32[$l >> 2];
  HEAP32[$j >> 2] = (HEAP32[$j >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _opus_select_arch() {
 var $1 = 0, $3 = 0, $5 = 0, $7 = 0, $arch = 0, $cpu_feature = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $retval = sp + 24 | 0;
 $cpu_feature = sp + 8 | 0;
 $arch = sp;
 _opus_cpu_feature_check($cpu_feature);
 HEAP32[$arch >> 2] = 0;
 $1 = HEAP32[$arch >> 2] | 0;
 do if (HEAP32[$cpu_feature >> 2] | 0) {
  HEAP32[$arch >> 2] = $1 + 1;
  $3 = HEAP32[$arch >> 2] | 0;
  if (!(HEAP32[$cpu_feature + 4 >> 2] | 0)) {
   HEAP32[$retval >> 2] = $3;
   break;
  }
  HEAP32[$arch >> 2] = $3 + 1;
  $5 = HEAP32[$arch >> 2] | 0;
  if (!(HEAP32[$cpu_feature + 8 >> 2] | 0)) {
   HEAP32[$retval >> 2] = $5;
   break;
  }
  HEAP32[$arch >> 2] = $5 + 1;
  $7 = HEAP32[$arch >> 2] | 0;
  if (HEAP32[$cpu_feature + 12 >> 2] | 0) {
   HEAP32[$arch >> 2] = $7 + 1;
   HEAP32[$retval >> 2] = HEAP32[$arch >> 2];
   break;
  } else {
   HEAP32[$retval >> 2] = $7;
   break;
  }
 } else HEAP32[$retval >> 2] = $1; while (0);
 STACKTOP = sp;
 return HEAP32[$retval >> 2] | 0;
}

function _silk_CNG_Reset($psDec) {
 $psDec = $psDec | 0;
 var $NLSF_acc_Q15 = 0, $NLSF_step_Q15 = 0, $i = 0, $psDec$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psDec$addr = sp + 12 | 0;
 $i = sp + 8 | 0;
 $NLSF_step_Q15 = sp + 4 | 0;
 $NLSF_acc_Q15 = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[$NLSF_step_Q15 >> 2] = 32767 / ((HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0) + 1 | 0) | 0;
 HEAP32[$NLSF_acc_Q15 >> 2] = 0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2340 >> 2] | 0)) break;
  HEAP32[$NLSF_acc_Q15 >> 2] = (HEAP32[$NLSF_acc_Q15 >> 2] | 0) + (HEAP32[$NLSF_step_Q15 >> 2] | 0);
  HEAP16[(HEAP32[$psDec$addr >> 2] | 0) + 2772 + 1280 + (HEAP32[$i >> 2] << 1) >> 1] = HEAP32[$NLSF_acc_Q15 >> 2];
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2772 + 1376 >> 2] = 0;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2772 + 1380 >> 2] = 3176576;
 STACKTOP = sp;
 return;
}

function _l1_metric($tmp, $N, $LM, $bias) {
 $tmp = $tmp | 0;
 $N = $N | 0;
 $LM = $LM | 0;
 $bias = +$bias;
 var $L1 = 0, $LM$addr = 0, $N$addr = 0, $bias$addr = 0, $conv1 = 0.0, $i = 0, $tmp$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $tmp$addr = sp + 20 | 0;
 $N$addr = sp + 16 | 0;
 $LM$addr = sp + 12 | 0;
 $bias$addr = sp + 8 | 0;
 $i = sp + 4 | 0;
 $L1 = sp;
 HEAP32[$tmp$addr >> 2] = $tmp;
 HEAP32[$N$addr >> 2] = $N;
 HEAP32[$LM$addr >> 2] = $LM;
 HEAPF32[$bias$addr >> 2] = $bias;
 HEAPF32[$L1 >> 2] = 0.0;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$N$addr >> 2] | 0)) break;
  $conv1 = +Math_abs(+(+HEAPF32[(HEAP32[$tmp$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2]));
  HEAPF32[$L1 >> 2] = +HEAPF32[$L1 >> 2] + $conv1;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 HEAPF32[$L1 >> 2] = +HEAPF32[$L1 >> 2] + +(HEAP32[$LM$addr >> 2] | 0) * +HEAPF32[$bias$addr >> 2] * +HEAPF32[$L1 >> 2];
 STACKTOP = sp;
 return +(+HEAPF32[$L1 >> 2]);
}

function _silk_stereo_encode_pred($psRangeEnc, $ix) {
 $psRangeEnc = $psRangeEnc | 0;
 $ix = $ix | 0;
 var $ix$addr = 0, $n = 0, $psRangeEnc$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psRangeEnc$addr = sp + 8 | 0;
 $ix$addr = sp + 4 | 0;
 $n = sp;
 HEAP32[$psRangeEnc$addr >> 2] = $psRangeEnc;
 HEAP32[$ix$addr >> 2] = $ix;
 HEAP32[$n >> 2] = ((HEAP8[(HEAP32[$ix$addr >> 2] | 0) + 2 >> 0] | 0) * 5 | 0) + (HEAP8[(HEAP32[$ix$addr >> 2] | 0) + 3 + 2 >> 0] | 0);
 _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$n >> 2] | 0, 32179, 8);
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= 2) break;
  _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$ix$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 3 | 0) >> 0] | 0, 32232, 8);
  _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[(HEAP32[$ix$addr >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 3 | 0) + 1 >> 0] | 0, 32239, 8);
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _memset(ptr, value, num) {
 ptr = ptr | 0;
 value = value | 0;
 num = num | 0;
 var end = 0, aligned_end = 0, block_aligned_end = 0, value4 = 0, value16 = SIMD_Int32x4(0, 0, 0, 0);
 end = ptr + num | 0;
 value = value & 255;
 if ((num | 0) >= 67) {
  while (ptr & 3) {
   HEAP8[ptr >> 0] = value;
   ptr = ptr + 1 | 0;
  }
  aligned_end = end & -4 | 0;
  block_aligned_end = aligned_end - 64 | 0;
  value4 = value | value << 8 | value << 16 | value << 24;
  value16 = SIMD_Int32x4_splat(value4);
  while ((ptr | 0) <= (block_aligned_end | 0)) {
   SIMD_Int32x4_store(HEAPU8, ptr, value16);
   SIMD_Int32x4_store(HEAPU8, ptr + 16, value16);
   SIMD_Int32x4_store(HEAPU8, ptr + 32, value16);
   SIMD_Int32x4_store(HEAPU8, ptr + 48, value16);
   ptr = ptr + 64 | 0;
  }
  while ((ptr | 0) < (aligned_end | 0)) {
   HEAP32[ptr >> 2] = value4;
   ptr = ptr + 4 | 0;
  }
 }
 while ((ptr | 0) < (end | 0)) {
  HEAP8[ptr >> 0] = value;
  ptr = ptr + 1 | 0;
 }
 return end - num | 0;
}

function _opus_packet_get_bandwidth($data) {
 $data = $data | 0;
 var $7 = 0, $add = 0, $bandwidth = 0, $conv13 = 0, $conv2 = 0, $data$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $data$addr = sp + 4 | 0;
 $bandwidth = sp;
 HEAP32[$data$addr >> 2] = $data;
 $conv2 = HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0;
 if ((HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0) & 128 | 0) {
  $add = 1102 + ($conv2 >> 5 & 3) | 0;
  HEAP32[$bandwidth >> 2] = $add;
  HEAP32[$bandwidth >> 2] = (HEAP32[$bandwidth >> 2] | 0) == 1102 ? 1101 : $add;
  $7 = HEAP32[$bandwidth >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 }
 $conv13 = HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0;
 if (($conv2 & 96 | 0) == 96) {
  HEAP32[$bandwidth >> 2] = $conv13 & 16 | 0 ? 1105 : 1104;
  $7 = HEAP32[$bandwidth >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 } else {
  HEAP32[$bandwidth >> 2] = 1101 + ($conv13 >> 5 & 3);
  $7 = HEAP32[$bandwidth >> 2] | 0;
  STACKTOP = sp;
  return $7 | 0;
 }
 return 0;
}

function _silk_A2NLSF_FLP($NLSF_Q15, $pAR, $LPC_order) {
 $NLSF_Q15 = $NLSF_Q15 | 0;
 $pAR = $pAR | 0;
 $LPC_order = $LPC_order | 0;
 var $LPC_order$addr = 0, $NLSF_Q15$addr = 0, $a_fix_Q16 = 0, $call = 0, $i = 0, $pAR$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $NLSF_Q15$addr = sp + 76 | 0;
 $pAR$addr = sp + 72 | 0;
 $LPC_order$addr = sp + 68 | 0;
 $i = sp + 64 | 0;
 $a_fix_Q16 = sp;
 HEAP32[$NLSF_Q15$addr >> 2] = $NLSF_Q15;
 HEAP32[$pAR$addr >> 2] = $pAR;
 HEAP32[$LPC_order$addr >> 2] = $LPC_order;
 HEAP32[$i >> 2] = 0;
 while (1) {
  if ((HEAP32[$i >> 2] | 0) >= (HEAP32[$LPC_order$addr >> 2] | 0)) break;
  $call = _silk_float2int(+HEAPF32[(HEAP32[$pAR$addr >> 2] | 0) + (HEAP32[$i >> 2] << 2) >> 2] * 65536.0) | 0;
  HEAP32[$a_fix_Q16 + (HEAP32[$i >> 2] << 2) >> 2] = $call;
  HEAP32[$i >> 2] = (HEAP32[$i >> 2] | 0) + 1;
 }
 _silk_A2NLSF(HEAP32[$NLSF_Q15$addr >> 2] | 0, $a_fix_Q16, HEAP32[$LPC_order$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _isqrt32($_val) {
 $_val = $_val | 0;
 var $_val$addr = 0, $b = 0, $bshift = 0, $g = 0, $t = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_val$addr = sp + 16 | 0;
 $b = sp + 12 | 0;
 $g = sp + 8 | 0;
 $bshift = sp + 4 | 0;
 $t = sp;
 HEAP32[$_val$addr >> 2] = $_val;
 HEAP32[$g >> 2] = 0;
 HEAP32[$bshift >> 2] = 32 - (Math_clz32(HEAP32[$_val$addr >> 2] | 0) | 0) - 1 >> 1;
 HEAP32[$b >> 2] = 1 << HEAP32[$bshift >> 2];
 do {
  HEAP32[$t >> 2] = (HEAP32[$g >> 2] << 1) + (HEAP32[$b >> 2] | 0) << HEAP32[$bshift >> 2];
  if ((HEAP32[$t >> 2] | 0) >>> 0 <= (HEAP32[$_val$addr >> 2] | 0) >>> 0) {
   HEAP32[$g >> 2] = (HEAP32[$g >> 2] | 0) + (HEAP32[$b >> 2] | 0);
   HEAP32[$_val$addr >> 2] = (HEAP32[$_val$addr >> 2] | 0) - (HEAP32[$t >> 2] | 0);
  }
  HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) >>> 1;
  HEAP32[$bshift >> 2] = (HEAP32[$bshift >> 2] | 0) + -1;
 } while ((HEAP32[$bshift >> 2] | 0) >= 0);
 STACKTOP = sp;
 return HEAP32[$g >> 2] | 0;
}

function _compute_frame_energy($pcm, $frame_size, $channels, $arch) {
 $pcm = $pcm | 0;
 $frame_size = $frame_size | 0;
 $channels = $channels | 0;
 $arch = $arch | 0;
 var $arch$addr = 0, $call = 0.0, $channels$addr = 0, $frame_size$addr = 0, $len = 0, $pcm$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $pcm$addr = sp + 16 | 0;
 $frame_size$addr = sp + 12 | 0;
 $channels$addr = sp + 8 | 0;
 $arch$addr = sp + 4 | 0;
 $len = sp;
 HEAP32[$pcm$addr >> 2] = $pcm;
 HEAP32[$frame_size$addr >> 2] = $frame_size;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$len >> 2] = Math_imul(HEAP32[$frame_size$addr >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
 $call = +FUNCTION_TABLE_diii[HEAP32[_CELT_INNER_PROD_IMPL + ((HEAP32[$arch$addr >> 2] & 7) << 2) >> 2] & 0](HEAP32[$pcm$addr >> 2] | 0, HEAP32[$pcm$addr >> 2] | 0, HEAP32[$len >> 2] | 0);
 STACKTOP = sp;
 return +($call / +(HEAP32[$len >> 2] | 0));
}

function _opus_packet_get_nb_frames($packet, $len) {
 $packet = $packet | 0;
 $len = $len | 0;
 var $count = 0, $len$addr = 0, $packet$addr = 0, $retval = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $retval = sp + 12 | 0;
 $packet$addr = sp + 8 | 0;
 $len$addr = sp + 4 | 0;
 $count = sp;
 HEAP32[$packet$addr >> 2] = $packet;
 HEAP32[$len$addr >> 2] = $len;
 do if ((HEAP32[$len$addr >> 2] | 0) < 1) HEAP32[$retval >> 2] = -1; else {
  HEAP32[$count >> 2] = (HEAPU8[HEAP32[$packet$addr >> 2] >> 0] | 0) & 3;
  if (!(HEAP32[$count >> 2] | 0)) {
   HEAP32[$retval >> 2] = 1;
   break;
  }
  if ((HEAP32[$count >> 2] | 0) != 3) {
   HEAP32[$retval >> 2] = 2;
   break;
  }
  if ((HEAP32[$len$addr >> 2] | 0) < 2) {
   HEAP32[$retval >> 2] = -4;
   break;
  } else {
   HEAP32[$retval >> 2] = (HEAPU8[(HEAP32[$packet$addr >> 2] | 0) + 1 >> 0] | 0) & 63;
   break;
  }
 } while (0);
 STACKTOP = sp;
 return HEAP32[$retval >> 2] | 0;
}

function _silk_init_encoder($psEnc, $arch) {
 $psEnc = $psEnc | 0;
 $arch = $arch | 0;
 var $arch$addr = 0, $call8 = 0, $psEnc$addr = 0, $ret = 0, $shl = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psEnc$addr = sp + 8 | 0;
 $arch$addr = sp + 4 | 0;
 $ret = sp;
 HEAP32[$psEnc$addr >> 2] = $psEnc;
 HEAP32[$arch$addr >> 2] = $arch;
 HEAP32[$ret >> 2] = 0;
 _memset(HEAP32[$psEnc$addr >> 2] | 0, 0, 10060) | 0;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 5088 >> 2] = HEAP32[$arch$addr >> 2];
 $shl = (_silk_lin2log(3932160) | 0) - 2048 << 8;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 8 >> 2] = $shl;
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 12 >> 2] = HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 8 >> 2];
 HEAP32[(HEAP32[$psEnc$addr >> 2] | 0) + 4660 >> 2] = 1;
 $call8 = _silk_VAD_Init((HEAP32[$psEnc$addr >> 2] | 0) + 32 | 0) | 0;
 HEAP32[$ret >> 2] = (HEAP32[$ret >> 2] | 0) + $call8;
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _ec_tell_frac($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $b = 0, $l = 0, $nbits = 0, $r = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $_this$addr = sp + 16 | 0;
 $nbits = sp + 12 | 0;
 $r = sp + 8 | 0;
 $l = sp + 4 | 0;
 $b = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$nbits >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] << 3;
 HEAP32[$l >> 2] = 32 - (Math_clz32(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0);
 HEAP32[$r >> 2] = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) >>> ((HEAP32[$l >> 2] | 0) - 16 | 0);
 HEAP32[$b >> 2] = ((HEAP32[$r >> 2] | 0) >>> 12) - 8;
 HEAP32[$b >> 2] = (HEAP32[$b >> 2] | 0) + ((HEAP32[$r >> 2] | 0) >>> 0 > (HEAP32[2948 + (HEAP32[$b >> 2] << 2) >> 2] | 0) >>> 0 & 1);
 HEAP32[$l >> 2] = (HEAP32[$l >> 2] << 3) + (HEAP32[$b >> 2] | 0);
 STACKTOP = sp;
 return (HEAP32[$nbits >> 2] | 0) - (HEAP32[$l >> 2] | 0) | 0;
}

function _silk_InitDecoder($decState) {
 $decState = $decState | 0;
 var $channel_state = 0, $decState$addr = 0, $n = 0, $ret = 0, $sStereo = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $decState$addr = sp + 12 | 0;
 $n = sp + 8 | 0;
 $ret = sp + 4 | 0;
 $channel_state = sp;
 HEAP32[$decState$addr >> 2] = $decState;
 HEAP32[$ret >> 2] = 0;
 HEAP32[$channel_state >> 2] = HEAP32[$decState$addr >> 2];
 HEAP32[$n >> 2] = 0;
 while (1) {
  if ((HEAP32[$n >> 2] | 0) >= 2) break;
  HEAP32[$ret >> 2] = _silk_init_decoder((HEAP32[$channel_state >> 2] | 0) + ((HEAP32[$n >> 2] | 0) * 4264 | 0) | 0) | 0;
  HEAP32[$n >> 2] = (HEAP32[$n >> 2] | 0) + 1;
 }
 $sStereo = (HEAP32[$decState$addr >> 2] | 0) + 8528 | 0;
 HEAP32[$sStereo >> 2] = 0;
 HEAP32[$sStereo + 4 >> 2] = 0;
 HEAP32[$sStereo + 8 >> 2] = 0;
 HEAP32[(HEAP32[$decState$addr >> 2] | 0) + 8548 >> 2] = 0;
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _celt_plc_pitch_search($decode_mem, $C, $arch) {
 $decode_mem = $decode_mem | 0;
 $C = $C | 0;
 $arch = $arch | 0;
 var $C$addr = 0, $arch$addr = 0, $decode_mem$addr = 0, $lp_pitch_buf = 0, $pitch_index = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 4112 | 0;
 $decode_mem$addr = sp + 4108 | 0;
 $C$addr = sp + 4104 | 0;
 $arch$addr = sp + 4100 | 0;
 $pitch_index = sp + 4096 | 0;
 $lp_pitch_buf = sp;
 HEAP32[$decode_mem$addr >> 2] = $decode_mem;
 HEAP32[$C$addr >> 2] = $C;
 HEAP32[$arch$addr >> 2] = $arch;
 _pitch_downsample(HEAP32[$decode_mem$addr >> 2] | 0, $lp_pitch_buf, 2048, HEAP32[$C$addr >> 2] | 0, HEAP32[$arch$addr >> 2] | 0);
 _pitch_search($lp_pitch_buf + 1440 | 0, $lp_pitch_buf, 1328, 620, $pitch_index, HEAP32[$arch$addr >> 2] | 0);
 HEAP32[$pitch_index >> 2] = 720 - (HEAP32[$pitch_index >> 2] | 0);
 STACKTOP = sp;
 return HEAP32[$pitch_index >> 2] | 0;
}

function _ec_decode($_this, $_ft) {
 $_this = $_this | 0;
 $_ft = $_ft | 0;
 var $_ft$addr = 0, $_this$addr = 0, $call = 0, $s = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp + 8 | 0;
 $_ft$addr = sp + 4 | 0;
 $s = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_ft$addr >> 2] = $_ft;
 $call = _celt_udiv(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0, HEAP32[$_ft$addr >> 2] | 0) | 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 36 >> 2] = $call;
 HEAP32[$s >> 2] = ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] | 0) >>> 0) / ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 36 >> 2] | 0) >>> 0) | 0;
 STACKTOP = sp;
 return (HEAP32[$_ft$addr >> 2] | 0) - ((HEAP32[$s >> 2] | 0) + 1 + ((HEAP32[$_ft$addr >> 2] | 0) - ((HEAP32[$s >> 2] | 0) + 1) & 0 - ((HEAP32[$_ft$addr >> 2] | 0) >>> 0 < ((HEAP32[$s >> 2] | 0) + 1 | 0) >>> 0 & 1))) | 0;
}

function _encode_split($psRangeEnc, $p_child1, $p, $shell_table) {
 $psRangeEnc = $psRangeEnc | 0;
 $p_child1 = $p_child1 | 0;
 $p = $p | 0;
 $shell_table = $shell_table | 0;
 var $p$addr = 0, $p_child1$addr = 0, $psRangeEnc$addr = 0, $shell_table$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psRangeEnc$addr = sp + 12 | 0;
 $p_child1$addr = sp + 8 | 0;
 $p$addr = sp + 4 | 0;
 $shell_table$addr = sp;
 HEAP32[$psRangeEnc$addr >> 2] = $psRangeEnc;
 HEAP32[$p_child1$addr >> 2] = $p_child1;
 HEAP32[$p$addr >> 2] = $p;
 HEAP32[$shell_table$addr >> 2] = $shell_table;
 if ((HEAP32[$p$addr >> 2] | 0) <= 0) {
  STACKTOP = sp;
  return;
 }
 _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP32[$p_child1$addr >> 2] | 0, (HEAP32[$shell_table$addr >> 2] | 0) + (HEAPU8[33368 + (HEAP32[$p$addr >> 2] | 0) >> 0] | 0) | 0, 8);
 STACKTOP = sp;
 return;
}

function _ec_decode_bin($_this, $_bits) {
 $_this = $_this | 0;
 $_bits = $_bits | 0;
 var $_bits$addr = 0, $_this$addr = 0, $s = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp + 8 | 0;
 $_bits$addr = sp + 4 | 0;
 $s = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_bits$addr >> 2] = $_bits;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 36 >> 2] = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) >>> (HEAP32[$_bits$addr >> 2] | 0);
 HEAP32[$s >> 2] = ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] | 0) >>> 0) / ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 36 >> 2] | 0) >>> 0) | 0;
 STACKTOP = sp;
 return (1 << HEAP32[$_bits$addr >> 2]) - ((HEAP32[$s >> 2] | 0) + 1 + ((1 << HEAP32[$_bits$addr >> 2]) - ((HEAP32[$s >> 2] | 0) + 1) & 0 - (1 << HEAP32[$_bits$addr >> 2] >>> 0 < ((HEAP32[$s >> 2] | 0) + 1 | 0) >>> 0 & 1))) | 0;
}

function _encode_size($size, $data) {
 $size = $size | 0;
 $data = $data | 0;
 var $1 = 0, $8 = 0, $data$addr = 0, $retval = 0, $size$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $retval = sp + 8 | 0;
 $size$addr = sp + 4 | 0;
 $data$addr = sp;
 HEAP32[$size$addr >> 2] = $size;
 HEAP32[$data$addr >> 2] = $data;
 $1 = HEAP32[$size$addr >> 2] | 0;
 if ((HEAP32[$size$addr >> 2] | 0) < 252) {
  HEAP8[HEAP32[$data$addr >> 2] >> 0] = $1;
  HEAP32[$retval >> 2] = 1;
  $8 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $8 | 0;
 } else {
  HEAP8[HEAP32[$data$addr >> 2] >> 0] = 252 + ($1 & 3);
  HEAP8[(HEAP32[$data$addr >> 2] | 0) + 1 >> 0] = (HEAP32[$size$addr >> 2] | 0) - (HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0) >> 2;
  HEAP32[$retval >> 2] = 2;
  $8 = HEAP32[$retval >> 2] | 0;
  STACKTOP = sp;
  return $8 | 0;
 }
 return 0;
}

function _compute_channel_weights($Ex, $Ey, $w) {
 $Ex = +$Ex;
 $Ey = +$Ey;
 $w = $w | 0;
 var $Ex$addr = 0, $Ey$addr = 0, $minE = 0, $w$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $Ex$addr = sp + 12 | 0;
 $Ey$addr = sp + 8 | 0;
 $w$addr = sp + 4 | 0;
 $minE = sp;
 HEAPF32[$Ex$addr >> 2] = $Ex;
 HEAPF32[$Ey$addr >> 2] = $Ey;
 HEAP32[$w$addr >> 2] = $w;
 HEAPF32[$minE >> 2] = +HEAPF32[$Ex$addr >> 2] < +HEAPF32[$Ey$addr >> 2] ? +HEAPF32[$Ex$addr >> 2] : +HEAPF32[$Ey$addr >> 2];
 HEAPF32[$Ex$addr >> 2] = +HEAPF32[$Ex$addr >> 2] + +HEAPF32[$minE >> 2] / 3.0;
 HEAPF32[$Ey$addr >> 2] = +HEAPF32[$Ey$addr >> 2] + +HEAPF32[$minE >> 2] / 3.0;
 HEAPF32[HEAP32[$w$addr >> 2] >> 2] = +HEAPF32[$Ex$addr >> 2];
 HEAPF32[(HEAP32[$w$addr >> 2] | 0) + 4 >> 2] = +HEAPF32[$Ey$addr >> 2];
 STACKTOP = sp;
 return;
}

function _ec_enc_normalize($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $nbits_total = 0, $rng3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 while (1) {
  if ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) >>> 0 > 8388608) break;
  _ec_enc_carry_out(HEAP32[$_this$addr >> 2] | 0, (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] | 0) >>> 23);
  HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 32 >> 2] << 8 & 2147483647;
  $rng3 = (HEAP32[$_this$addr >> 2] | 0) + 28 | 0;
  HEAP32[$rng3 >> 2] = HEAP32[$rng3 >> 2] << 8;
  $nbits_total = (HEAP32[$_this$addr >> 2] | 0) + 20 | 0;
  HEAP32[$nbits_total >> 2] = (HEAP32[$nbits_total >> 2] | 0) + 8;
 }
 STACKTOP = sp;
 return;
}

function _combine_pulses($out, $in, $len) {
 $out = $out | 0;
 $in = $in | 0;
 $len = $len | 0;
 var $in$addr = 0, $k = 0, $len$addr = 0, $out$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $out$addr = sp + 12 | 0;
 $in$addr = sp + 8 | 0;
 $len$addr = sp + 4 | 0;
 $k = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$len$addr >> 2] | 0)) break;
  HEAP32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = (HEAP32[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1 << 2) >> 2] | 0) + (HEAP32[(HEAP32[$in$addr >> 2] | 0) + ((HEAP32[$k >> 2] << 1) + 1 << 2) >> 2] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return;
}

function _ec_enc_shrink($_this, $_size) {
 $_this = $_this | 0;
 $_size = $_size | 0;
 var $_size$addr = 0, $_this$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp + 4 | 0;
 $_size$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 HEAP32[$_size$addr >> 2] = $_size;
 _memmove((HEAP32[HEAP32[$_this$addr >> 2] >> 2] | 0) + (HEAP32[$_size$addr >> 2] | 0) + (0 - (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0)) | 0, (HEAP32[HEAP32[$_this$addr >> 2] >> 2] | 0) + (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0) + (0 - (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0)) | 0, (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0) + 0 | 0) | 0;
 HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] = HEAP32[$_size$addr >> 2];
 STACKTOP = sp;
 return;
}

function _ec_read_byte_from_end($_this) {
 $_this = $_this | 0;
 var $5 = 0, $7 = 0, $_this$addr = 0, $cond = 0, $end_offs2 = 0, $inc = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 if ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 8 >> 2] | 0) >>> 0 >= (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0) >>> 0) {
  $cond = 0;
  STACKTOP = sp;
  return $cond | 0;
 }
 $5 = HEAP32[HEAP32[$_this$addr >> 2] >> 2] | 0;
 $7 = HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0;
 $end_offs2 = (HEAP32[$_this$addr >> 2] | 0) + 8 | 0;
 $inc = (HEAP32[$end_offs2 >> 2] | 0) + 1 | 0;
 HEAP32[$end_offs2 >> 2] = $inc;
 $cond = HEAPU8[$5 + ($7 - $inc) >> 0] | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_short2float_array_326($out, $in, $length) {
 $out = $out | 0;
 $in = $in | 0;
 $length = $length | 0;
 var $in$addr = 0, $k = 0, $length$addr = 0, $out$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $out$addr = sp + 12 | 0;
 $in$addr = sp + 8 | 0;
 $length$addr = sp + 4 | 0;
 $k = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$k >> 2] = (HEAP32[$length$addr >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) < 0) break;
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = +(HEAP16[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return;
}

function _silk_short2float_array_285($out, $in, $length) {
 $out = $out | 0;
 $in = $in | 0;
 $length = $length | 0;
 var $in$addr = 0, $k = 0, $length$addr = 0, $out$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $out$addr = sp + 12 | 0;
 $in$addr = sp + 8 | 0;
 $length$addr = sp + 4 | 0;
 $k = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$k >> 2] = (HEAP32[$length$addr >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) < 0) break;
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = +(HEAP16[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return;
}

function _silk_short2float_array($out, $in, $length) {
 $out = $out | 0;
 $in = $in | 0;
 $length = $length | 0;
 var $in$addr = 0, $k = 0, $length$addr = 0, $out$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $out$addr = sp + 12 | 0;
 $in$addr = sp + 8 | 0;
 $length$addr = sp + 4 | 0;
 $k = sp;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$length$addr >> 2] = $length;
 HEAP32[$k >> 2] = (HEAP32[$length$addr >> 2] | 0) - 1;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) < 0) break;
  HEAPF32[(HEAP32[$out$addr >> 2] | 0) + (HEAP32[$k >> 2] << 2) >> 2] = +(HEAP16[(HEAP32[$in$addr >> 2] | 0) + (HEAP32[$k >> 2] << 1) >> 1] | 0);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + -1;
 }
 STACKTOP = sp;
 return;
}

function _silk_CLZ_FRAC_546($in, $lz, $frac_Q7) {
 $in = $in | 0;
 $lz = $lz | 0;
 $frac_Q7 = $frac_Q7 | 0;
 var $and = 0, $frac_Q7$addr = 0, $in$addr = 0, $lz$addr = 0, $lzeros = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in$addr = sp + 12 | 0;
 $lz$addr = sp + 8 | 0;
 $frac_Q7$addr = sp + 4 | 0;
 $lzeros = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$lz$addr >> 2] = $lz;
 HEAP32[$frac_Q7$addr >> 2] = $frac_Q7;
 HEAP32[$lzeros >> 2] = _silk_CLZ32_547(HEAP32[$in$addr >> 2] | 0) | 0;
 HEAP32[HEAP32[$lz$addr >> 2] >> 2] = HEAP32[$lzeros >> 2];
 $and = (_silk_ROR32_548(HEAP32[$in$addr >> 2] | 0, 24 - (HEAP32[$lzeros >> 2] | 0) | 0) | 0) & 127;
 HEAP32[HEAP32[$frac_Q7$addr >> 2] >> 2] = $and;
 STACKTOP = sp;
 return;
}

function _silk_CLZ_FRAC_456($in, $lz, $frac_Q7) {
 $in = $in | 0;
 $lz = $lz | 0;
 $frac_Q7 = $frac_Q7 | 0;
 var $and = 0, $frac_Q7$addr = 0, $in$addr = 0, $lz$addr = 0, $lzeros = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in$addr = sp + 12 | 0;
 $lz$addr = sp + 8 | 0;
 $frac_Q7$addr = sp + 4 | 0;
 $lzeros = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$lz$addr >> 2] = $lz;
 HEAP32[$frac_Q7$addr >> 2] = $frac_Q7;
 HEAP32[$lzeros >> 2] = _silk_CLZ32_457(HEAP32[$in$addr >> 2] | 0) | 0;
 HEAP32[HEAP32[$lz$addr >> 2] >> 2] = HEAP32[$lzeros >> 2];
 $and = (_silk_ROR32_458(HEAP32[$in$addr >> 2] | 0, 24 - (HEAP32[$lzeros >> 2] | 0) | 0) | 0) & 127;
 HEAP32[HEAP32[$frac_Q7$addr >> 2] >> 2] = $and;
 STACKTOP = sp;
 return;
}

function _silk_CLZ_FRAC_440($in, $lz, $frac_Q7) {
 $in = $in | 0;
 $lz = $lz | 0;
 $frac_Q7 = $frac_Q7 | 0;
 var $and = 0, $frac_Q7$addr = 0, $in$addr = 0, $lz$addr = 0, $lzeros = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in$addr = sp + 12 | 0;
 $lz$addr = sp + 8 | 0;
 $frac_Q7$addr = sp + 4 | 0;
 $lzeros = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$lz$addr >> 2] = $lz;
 HEAP32[$frac_Q7$addr >> 2] = $frac_Q7;
 HEAP32[$lzeros >> 2] = _silk_CLZ32_436(HEAP32[$in$addr >> 2] | 0) | 0;
 HEAP32[HEAP32[$lz$addr >> 2] >> 2] = HEAP32[$lzeros >> 2];
 $and = (_silk_ROR32_441(HEAP32[$in$addr >> 2] | 0, 24 - (HEAP32[$lzeros >> 2] | 0) | 0) | 0) & 127;
 HEAP32[HEAP32[$frac_Q7$addr >> 2] >> 2] = $and;
 STACKTOP = sp;
 return;
}

function _silk_CLZ_FRAC_342($in, $lz, $frac_Q7) {
 $in = $in | 0;
 $lz = $lz | 0;
 $frac_Q7 = $frac_Q7 | 0;
 var $and = 0, $frac_Q7$addr = 0, $in$addr = 0, $lz$addr = 0, $lzeros = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in$addr = sp + 12 | 0;
 $lz$addr = sp + 8 | 0;
 $frac_Q7$addr = sp + 4 | 0;
 $lzeros = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$lz$addr >> 2] = $lz;
 HEAP32[$frac_Q7$addr >> 2] = $frac_Q7;
 HEAP32[$lzeros >> 2] = _silk_CLZ32_343(HEAP32[$in$addr >> 2] | 0) | 0;
 HEAP32[HEAP32[$lz$addr >> 2] >> 2] = HEAP32[$lzeros >> 2];
 $and = (_silk_ROR32_344(HEAP32[$in$addr >> 2] | 0, 24 - (HEAP32[$lzeros >> 2] | 0) | 0) | 0) & 127;
 HEAP32[HEAP32[$frac_Q7$addr >> 2] >> 2] = $and;
 STACKTOP = sp;
 return;
}

function _silk_CLZ_FRAC_276($in, $lz, $frac_Q7) {
 $in = $in | 0;
 $lz = $lz | 0;
 $frac_Q7 = $frac_Q7 | 0;
 var $and = 0, $frac_Q7$addr = 0, $in$addr = 0, $lz$addr = 0, $lzeros = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in$addr = sp + 12 | 0;
 $lz$addr = sp + 8 | 0;
 $frac_Q7$addr = sp + 4 | 0;
 $lzeros = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$lz$addr >> 2] = $lz;
 HEAP32[$frac_Q7$addr >> 2] = $frac_Q7;
 HEAP32[$lzeros >> 2] = _silk_CLZ32_277(HEAP32[$in$addr >> 2] | 0) | 0;
 HEAP32[HEAP32[$lz$addr >> 2] >> 2] = HEAP32[$lzeros >> 2];
 $and = (_silk_ROR32_278(HEAP32[$in$addr >> 2] | 0, 24 - (HEAP32[$lzeros >> 2] | 0) | 0) | 0) & 127;
 HEAP32[HEAP32[$frac_Q7$addr >> 2] >> 2] = $and;
 STACKTOP = sp;
 return;
}

function _silk_gains_ID($ind, $nb_subfr) {
 $ind = $ind | 0;
 $nb_subfr = $nb_subfr | 0;
 var $gainsID = 0, $ind$addr = 0, $k = 0, $nb_subfr$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ind$addr = sp + 12 | 0;
 $nb_subfr$addr = sp + 8 | 0;
 $k = sp + 4 | 0;
 $gainsID = sp;
 HEAP32[$ind$addr >> 2] = $ind;
 HEAP32[$nb_subfr$addr >> 2] = $nb_subfr;
 HEAP32[$gainsID >> 2] = 0;
 HEAP32[$k >> 2] = 0;
 while (1) {
  if ((HEAP32[$k >> 2] | 0) >= (HEAP32[$nb_subfr$addr >> 2] | 0)) break;
  HEAP32[$gainsID >> 2] = (HEAP8[(HEAP32[$ind$addr >> 2] | 0) + (HEAP32[$k >> 2] | 0) >> 0] | 0) + (HEAP32[$gainsID >> 2] << 8);
  HEAP32[$k >> 2] = (HEAP32[$k >> 2] | 0) + 1;
 }
 STACKTOP = sp;
 return HEAP32[$gainsID >> 2] | 0;
}

function _silk_CLZ_FRAC($in, $lz, $frac_Q7) {
 $in = $in | 0;
 $lz = $lz | 0;
 $frac_Q7 = $frac_Q7 | 0;
 var $and = 0, $frac_Q7$addr = 0, $in$addr = 0, $lz$addr = 0, $lzeros = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in$addr = sp + 12 | 0;
 $lz$addr = sp + 8 | 0;
 $frac_Q7$addr = sp + 4 | 0;
 $lzeros = sp;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$lz$addr >> 2] = $lz;
 HEAP32[$frac_Q7$addr >> 2] = $frac_Q7;
 HEAP32[$lzeros >> 2] = _silk_CLZ32_235(HEAP32[$in$addr >> 2] | 0) | 0;
 HEAP32[HEAP32[$lz$addr >> 2] >> 2] = HEAP32[$lzeros >> 2];
 $and = (_silk_ROR32(HEAP32[$in$addr >> 2] | 0, 24 - (HEAP32[$lzeros >> 2] | 0) | 0) | 0) & 127;
 HEAP32[HEAP32[$frac_Q7$addr >> 2] >> 2] = $and;
 STACKTOP = sp;
 return;
}

function _opus_custom_encoder_get_size($mode, $channels) {
 $mode = $mode | 0;
 $channels = $channels | 0;
 var $add = 0, $channels$addr = 0, $mode$addr = 0, $size = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $mode$addr = sp + 8 | 0;
 $channels$addr = sp + 4 | 0;
 $size = sp;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$channels$addr >> 2] = $channels;
 $add = 248 + ((Math_imul(HEAP32[$channels$addr >> 2] | 0, HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 4 >> 2] | 0) | 0) - 1 << 2) | 0;
 HEAP32[$size >> 2] = $add + (HEAP32[$channels$addr >> 2] << 10 << 2) + ((Math_imul(HEAP32[$channels$addr >> 2] << 2, HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 8 >> 2] | 0) | 0) << 2);
 STACKTOP = sp;
 return HEAP32[$size >> 2] | 0;
}

function _bitexact_cos($x) {
 $x = $x | 0;
 var $tmp = 0, $x$addr = 0, $x2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $x$addr = sp + 6 | 0;
 $tmp = sp;
 $x2 = sp + 4 | 0;
 HEAP16[$x$addr >> 1] = $x;
 HEAP32[$tmp >> 2] = 4096 + (Math_imul(HEAP16[$x$addr >> 1] | 0, HEAP16[$x$addr >> 1] | 0) | 0) >> 13;
 HEAP16[$x2 >> 1] = HEAP32[$tmp >> 2];
 HEAP16[$x2 >> 1] = 32767 - (HEAP16[$x2 >> 1] | 0) + (16384 + (Math_imul(HEAP16[$x2 >> 1] | 0, ((16384 + (Math_imul(HEAP16[$x2 >> 1] | 0, (8277 + (16384 + (Math_imul(-626, HEAP16[$x2 >> 1] | 0) | 0) >> 15) & 65535) << 16 >> 16) | 0) >> 15) + -7651 & 65535) << 16 >> 16) | 0) >> 15);
 STACKTOP = sp;
 return 1 + (HEAP16[$x2 >> 1] | 0) & 65535 | 0;
}

function _silk_resampler_private_up2_HQ_wrapper($SS, $out, $in, $len) {
 $SS = $SS | 0;
 $out = $out | 0;
 $in = $in | 0;
 $len = $len | 0;
 var $S = 0, $SS$addr = 0, $in$addr = 0, $len$addr = 0, $out$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $SS$addr = sp + 16 | 0;
 $out$addr = sp + 12 | 0;
 $in$addr = sp + 8 | 0;
 $len$addr = sp + 4 | 0;
 $S = sp;
 HEAP32[$SS$addr >> 2] = $SS;
 HEAP32[$out$addr >> 2] = $out;
 HEAP32[$in$addr >> 2] = $in;
 HEAP32[$len$addr >> 2] = $len;
 HEAP32[$S >> 2] = HEAP32[$SS$addr >> 2];
 _silk_resampler_private_up2_HQ(HEAP32[$S >> 2] | 0, HEAP32[$out$addr >> 2] | 0, HEAP32[$in$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _opus_custom_decoder_get_size($mode, $channels) {
 $mode = $mode | 0;
 $channels = $channels | 0;
 var $add2 = 0, $channels$addr = 0, $mode$addr = 0, $size = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $mode$addr = sp + 8 | 0;
 $channels$addr = sp + 4 | 0;
 $size = sp;
 HEAP32[$mode$addr >> 2] = $mode;
 HEAP32[$channels$addr >> 2] = $channels;
 $add2 = 96 + ((Math_imul(HEAP32[$channels$addr >> 2] | 0, 2048 + (HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 4 >> 2] | 0) | 0) | 0) - 1 << 2) | 0;
 HEAP32[$size >> 2] = $add2 + ((HEAP32[$channels$addr >> 2] | 0) * 24 << 2) + (HEAP32[(HEAP32[$mode$addr >> 2] | 0) + 8 >> 2] << 3 << 2);
 STACKTOP = sp;
 return HEAP32[$size >> 2] | 0;
}

function _silk_lin2log($inLin) {
 $inLin = $inLin | 0;
 var $add6 = 0, $frac_Q7 = 0, $inLin$addr = 0, $lz = 0, $mul1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $inLin$addr = sp + 8 | 0;
 $lz = sp + 4 | 0;
 $frac_Q7 = sp;
 HEAP32[$inLin$addr >> 2] = $inLin;
 _silk_CLZ_FRAC(HEAP32[$inLin$addr >> 2] | 0, $lz, $frac_Q7);
 $mul1 = ((Math_imul(HEAP32[$frac_Q7 >> 2] | 0, 128 - (HEAP32[$frac_Q7 >> 2] | 0) | 0) | 0) >> 16) * 179 | 0;
 $add6 = (HEAP32[$frac_Q7 >> 2] | 0) + ($mul1 + (((Math_imul(HEAP32[$frac_Q7 >> 2] | 0, 128 - (HEAP32[$frac_Q7 >> 2] | 0) | 0) | 0) & 65535) * 179 >> 16)) | 0;
 STACKTOP = sp;
 return $add6 + (31 - (HEAP32[$lz >> 2] | 0) << 7) | 0;
}

function _ec_read_byte($_this) {
 $_this = $_this | 0;
 var $5 = 0, $7 = 0, $_this$addr = 0, $cond = 0, $offs1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 if ((HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] | 0) >>> 0 >= (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 4 >> 2] | 0) >>> 0) {
  $cond = 0;
  STACKTOP = sp;
  return $cond | 0;
 }
 $5 = HEAP32[HEAP32[$_this$addr >> 2] >> 2] | 0;
 $offs1 = (HEAP32[$_this$addr >> 2] | 0) + 24 | 0;
 $7 = HEAP32[$offs1 >> 2] | 0;
 HEAP32[$offs1 >> 2] = $7 + 1;
 $cond = HEAPU8[$5 + $7 >> 0] | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _sbrk(increment) {
 increment = increment | 0;
 var oldDynamicTop = 0, newDynamicTop = 0;
 increment = increment + 15 & -16 | 0;
 oldDynamicTop = HEAP32[DYNAMICTOP_PTR >> 2] | 0;
 newDynamicTop = oldDynamicTop + increment | 0;
 if ((increment | 0) > 0 & (newDynamicTop | 0) < (oldDynamicTop | 0) | (newDynamicTop | 0) < 0) {
  abortOnCannotGrowMemory() | 0;
  ___setErrNo(12);
  return -1;
 }
 HEAP32[DYNAMICTOP_PTR >> 2] = newDynamicTop;
 if ((newDynamicTop | 0) > (getTotalMemory() | 0)) if (!(enlargeMemory() | 0)) {
  HEAP32[DYNAMICTOP_PTR >> 2] = oldDynamicTop;
  ___setErrNo(12);
  return -1;
 }
 return oldDynamicTop | 0;
}

function _silk_PLC_Reset($psDec) {
 $psDec = $psDec | 0;
 var $psDec$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psDec$addr = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 >> 2] = HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2328 >> 2] << 7;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 72 >> 2] = 65536;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 72 + 4 >> 2] = 65536;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 88 >> 2] = 20;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4172 + 84 >> 2] = 2;
 STACKTOP = sp;
 return;
}

function _silk_stereo_decode_mid_only($psRangeDec, $decode_only_mid) {
 $psRangeDec = $psRangeDec | 0;
 $decode_only_mid = $decode_only_mid | 0;
 var $call = 0, $decode_only_mid$addr = 0, $psRangeDec$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psRangeDec$addr = sp + 4 | 0;
 $decode_only_mid$addr = sp;
 HEAP32[$psRangeDec$addr >> 2] = $psRangeDec;
 HEAP32[$decode_only_mid$addr >> 2] = $decode_only_mid;
 $call = _ec_dec_icdf(HEAP32[$psRangeDec$addr >> 2] | 0, 32204, 8) | 0;
 HEAP32[HEAP32[$decode_only_mid$addr >> 2] >> 2] = $call;
 STACKTOP = sp;
 return;
}

function _codec_opus_createNativeHandle($channelCount) {
 $channelCount = $channelCount | 0;
 var $call = 0;
 $call = __Znwj(24) | 0;
 HEAP32[$call >> 2] = 0;
 HEAP32[$call + 4 >> 2] = 0;
 HEAP32[$call + 8 >> 2] = 0;
 HEAP32[$call + 12 >> 2] = 0;
 HEAP32[$call + 16 >> 2] = 0;
 HEAP32[$call + 20 >> 2] = 1;
 __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc($call, 25342) | 0;
 HEAP32[$call + 16 >> 2] = _opus_decoder_create(48e3, $channelCount, 0) | 0;
 HEAP32[$call + 12 >> 2] = _opus_encoder_create(48e3, $channelCount, 2048, 0) | 0;
 return $call | 0;
}

function _silk_init_decoder($psDec) {
 $psDec = $psDec | 0;
 var $call = 0, $psDec$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psDec$addr = sp;
 HEAP32[$psDec$addr >> 2] = $psDec;
 _memset(HEAP32[$psDec$addr >> 2] | 0, 0, 4264) | 0;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 2376 >> 2] = 1;
 HEAP32[HEAP32[$psDec$addr >> 2] >> 2] = 65536;
 $call = _opus_select_arch() | 0;
 HEAP32[(HEAP32[$psDec$addr >> 2] | 0) + 4168 >> 2] = $call;
 _silk_CNG_Reset(HEAP32[$psDec$addr >> 2] | 0);
 _silk_PLC_Reset(HEAP32[$psDec$addr >> 2] | 0);
 STACKTOP = sp;
 return 0;
}

function _codec_opus_changeApplication($handle, $type) {
 $handle = $handle | 0;
 $type = $type | 0;
 var $0 = 0, $retval$0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 switch ($type | 0) {
 case 2048:
 case 2049:
 case 2051:
  break;
 default:
  {
   $retval$0 = 1;
   STACKTOP = sp;
   return $retval$0 | 0;
  }
 }
 $0 = HEAP32[$handle + 12 >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = $type;
 $retval$0 = _opus_encoder_ctl($0, 4e3, $vararg_buffer) | 0;
 STACKTOP = sp;
 return $retval$0 | 0;
}

function _opus_repacketizer_cat($rp, $data, $len) {
 $rp = $rp | 0;
 $data = $data | 0;
 $len = $len | 0;
 var $call = 0, $data$addr = 0, $len$addr = 0, $rp$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $rp$addr = sp + 8 | 0;
 $data$addr = sp + 4 | 0;
 $len$addr = sp;
 HEAP32[$rp$addr >> 2] = $rp;
 HEAP32[$data$addr >> 2] = $data;
 HEAP32[$len$addr >> 2] = $len;
 $call = _opus_repacketizer_cat_impl(HEAP32[$rp$addr >> 2] | 0, HEAP32[$data$addr >> 2] | 0, HEAP32[$len$addr >> 2] | 0, 0) | 0;
 STACKTOP = sp;
 return $call | 0;
}

function _tonality_analysis_init($tonal, $Fs) {
 $tonal = $tonal | 0;
 $Fs = $Fs | 0;
 var $Fs$addr = 0, $call = 0, $tonal$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $tonal$addr = sp + 4 | 0;
 $Fs$addr = sp;
 HEAP32[$tonal$addr >> 2] = $tonal;
 HEAP32[$Fs$addr >> 2] = $Fs;
 $call = _opus_select_arch() | 0;
 HEAP32[HEAP32[$tonal$addr >> 2] >> 2] = $call;
 HEAP32[(HEAP32[$tonal$addr >> 2] | 0) + 8 >> 2] = HEAP32[$Fs$addr >> 2];
 _tonality_analysis_reset(HEAP32[$tonal$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _opus_packet_get_mode($data) {
 $data = $data | 0;
 var $data$addr = 0, $mode = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $data$addr = sp + 4 | 0;
 $mode = sp;
 HEAP32[$data$addr >> 2] = $data;
 do if ((HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0) & 128 | 0) HEAP32[$mode >> 2] = 1002; else if (((HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0) & 96 | 0) == 96) {
  HEAP32[$mode >> 2] = 1001;
  break;
 } else {
  HEAP32[$mode >> 2] = 1e3;
  break;
 } while (0);
 STACKTOP = sp;
 return HEAP32[$mode >> 2] | 0;
}

function ___muldi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $x_sroa_0_0_extract_trunc = 0, $y_sroa_0_0_extract_trunc = 0, $1$0 = 0, $1$1 = 0;
 $x_sroa_0_0_extract_trunc = $a$0;
 $y_sroa_0_0_extract_trunc = $b$0;
 $1$0 = ___muldsi3($x_sroa_0_0_extract_trunc, $y_sroa_0_0_extract_trunc) | 0;
 $1$1 = tempRet0;
 return (tempRet0 = (Math_imul($a$1, $y_sroa_0_0_extract_trunc) | 0) + (Math_imul($b$1, $x_sroa_0_0_extract_trunc) | 0) + $1$1 | $1$1 & 0, $1$0 | 0 | 0) | 0;
}

function _silk_stereo_encode_mid_only($psRangeEnc, $mid_only_flag) {
 $psRangeEnc = $psRangeEnc | 0;
 $mid_only_flag = $mid_only_flag | 0;
 var $mid_only_flag$addr = 0, $psRangeEnc$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $psRangeEnc$addr = sp;
 $mid_only_flag$addr = sp + 4 | 0;
 HEAP32[$psRangeEnc$addr >> 2] = $psRangeEnc;
 HEAP8[$mid_only_flag$addr >> 0] = $mid_only_flag;
 _ec_enc_icdf(HEAP32[$psRangeEnc$addr >> 2] | 0, HEAP8[$mid_only_flag$addr >> 0] | 0, 32204, 8);
 STACKTOP = sp;
 return;
}

function _ec_laplace_get_freq1($fs0, $decay) {
 $fs0 = $fs0 | 0;
 $decay = $decay | 0;
 var $decay$addr = 0, $fs0$addr = 0, $ft = 0, $shr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $fs0$addr = sp + 8 | 0;
 $decay$addr = sp + 4 | 0;
 $ft = sp;
 HEAP32[$fs0$addr >> 2] = $fs0;
 HEAP32[$decay$addr >> 2] = $decay;
 HEAP32[$ft >> 2] = 32736 - (HEAP32[$fs0$addr >> 2] | 0);
 $shr = (Math_imul(HEAP32[$ft >> 2] | 0, 16384 - (HEAP32[$decay$addr >> 2] | 0) | 0) | 0) >>> 15;
 STACKTOP = sp;
 return $shr | 0;
}

function _FLOAT2INT16_12($x) {
 $x = +$x;
 var $conv = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $x$addr = sp;
 HEAPF32[$x$addr >> 2] = $x;
 HEAPF32[$x$addr >> 2] = +HEAPF32[$x$addr >> 2] * 32768.0;
 HEAPF32[$x$addr >> 2] = +HEAPF32[$x$addr >> 2] > -32768.0 ? +HEAPF32[$x$addr >> 2] : -32768.0;
 HEAPF32[$x$addr >> 2] = +HEAPF32[$x$addr >> 2] < 32767.0 ? +HEAPF32[$x$addr >> 2] : 32767.0;
 $conv = (_lrintf(+HEAPF32[$x$addr >> 2]) | 0) & 65535;
 STACKTOP = sp;
 return $conv | 0;
}

function _codec_opus_deleteNativeHandle($codec) {
 $codec = $codec | 0;
 var $0 = 0, $1 = 0, $decoder = 0, $encoder = 0;
 if (!$codec) return;
 $decoder = $codec + 16 | 0;
 $0 = HEAP32[$decoder >> 2] | 0;
 if ($0 | 0) _opus_decoder_destroy($0);
 HEAP32[$decoder >> 2] = 0;
 $encoder = $codec + 12 | 0;
 $1 = HEAP32[$encoder >> 2] | 0;
 if ($1 | 0) _opus_encoder_destroy($1);
 HEAP32[$encoder >> 2] = 0;
 if ((HEAP8[$codec + 11 >> 0] | 0) < 0) __ZdlPv(HEAP32[$codec >> 2] | 0);
 __ZdlPv($codec);
 return;
}

function _compute_pitch_gain($xy, $xx, $yy) {
 $xy = +$xy;
 $xx = +$xx;
 $yy = +$yy;
 var $div = 0.0, $xx$addr = 0, $xy$addr = 0, $yy$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $xy$addr = sp + 8 | 0;
 $xx$addr = sp + 4 | 0;
 $yy$addr = sp;
 HEAPF32[$xy$addr >> 2] = $xy;
 HEAPF32[$xx$addr >> 2] = $xx;
 HEAPF32[$yy$addr >> 2] = $yy;
 $div = +HEAPF32[$xy$addr >> 2] / +Math_sqrt(+(+HEAPF32[$xx$addr >> 2] * +HEAPF32[$yy$addr >> 2] + 1.0));
 STACKTOP = sp;
 return +$div;
}

function runPostSets() {}
function ___muldsi3($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $1 = 0, $2 = 0, $3 = 0, $6 = 0, $8 = 0, $11 = 0, $12 = 0;
 $1 = $a & 65535;
 $2 = $b & 65535;
 $3 = Math_imul($2, $1) | 0;
 $6 = $a >>> 16;
 $8 = ($3 >>> 16) + (Math_imul($2, $6) | 0) | 0;
 $11 = $b >>> 16;
 $12 = Math_imul($11, $1) | 0;
 return (tempRet0 = ($8 >>> 16) + (Math_imul($11, $6) | 0) + ((($8 & 65535) + $12 | 0) >>> 16) | 0, $8 + $12 << 16 | $3 & 65535 | 0) | 0;
}

function _celt_encoder_get_size($channels) {
 $channels = $channels | 0;
 var $call1 = 0, $channels$addr = 0, $mode = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $channels$addr = sp + 4 | 0;
 $mode = sp;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$mode >> 2] = _opus_custom_mode_create(48e3, 960, 0) | 0;
 $call1 = _opus_custom_encoder_get_size(HEAP32[$mode >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
 STACKTOP = sp;
 return $call1 | 0;
}

function _celt_decoder_get_size($channels) {
 $channels = $channels | 0;
 var $call1 = 0, $channels$addr = 0, $mode = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $channels$addr = sp + 4 | 0;
 $mode = sp;
 HEAP32[$channels$addr >> 2] = $channels;
 HEAP32[$mode >> 2] = _opus_custom_mode_create(48e3, 960, 0) | 0;
 $call1 = _opus_custom_decoder_get_size(HEAP32[$mode >> 2] | 0, HEAP32[$channels$addr >> 2] | 0) | 0;
 STACKTOP = sp;
 return $call1 | 0;
}

function _align_7($i) {
 $i = $i | 0;
 var $alignment = 0, $i$addr = 0, $mul = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $i$addr = sp + 4 | 0;
 $alignment = sp;
 HEAP32[$i$addr >> 2] = $i;
 HEAP32[$alignment >> 2] = 4;
 $mul = Math_imul((((HEAP32[$i$addr >> 2] | 0) + (HEAP32[$alignment >> 2] | 0) - 1 | 0) >>> 0) / ((HEAP32[$alignment >> 2] | 0) >>> 0) | 0, HEAP32[$alignment >> 2] | 0) | 0;
 STACKTOP = sp;
 return $mul | 0;
}

function _align($i) {
 $i = $i | 0;
 var $alignment = 0, $i$addr = 0, $mul = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $i$addr = sp + 4 | 0;
 $alignment = sp;
 HEAP32[$i$addr >> 2] = $i;
 HEAP32[$alignment >> 2] = 4;
 $mul = Math_imul((((HEAP32[$i$addr >> 2] | 0) + (HEAP32[$alignment >> 2] | 0) - 1 | 0) >>> 0) / ((HEAP32[$alignment >> 2] | 0) >>> 0) | 0, HEAP32[$alignment >> 2] | 0) | 0;
 STACKTOP = sp;
 return $mul | 0;
}

function _memmove(dest, src, num) {
 dest = dest | 0;
 src = src | 0;
 num = num | 0;
 var ret = 0;
 if ((src | 0) < (dest | 0) & (dest | 0) < (src + num | 0)) {
  ret = dest;
  src = src + num | 0;
  dest = dest + num | 0;
  while ((num | 0) > 0) {
   dest = dest - 1 | 0;
   src = src - 1 | 0;
   num = num - 1 | 0;
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
  }
  dest = ret;
 } else _memcpy(dest, src, num) | 0;
 return dest | 0;
}

function _tonality_analysis_reset($tonal) {
 $tonal = $tonal | 0;
 var $start = 0, $tonal$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $tonal$addr = sp + 4 | 0;
 $start = sp;
 HEAP32[$tonal$addr >> 2] = $tonal;
 HEAP32[$start >> 2] = (HEAP32[$tonal$addr >> 2] | 0) + 12;
 _memset(HEAP32[$start >> 2] | 0, 0, 14e3 - ((HEAP32[$start >> 2] | 0) - (HEAP32[$tonal$addr >> 2] | 0)) | 0) | 0;
 STACKTOP = sp;
 return;
}

function _silk_Get_Encoder_Size($encSizeBytes) {
 $encSizeBytes = $encSizeBytes | 0;
 var $encSizeBytes$addr = 0, $ret = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $encSizeBytes$addr = sp + 4 | 0;
 $ret = sp;
 HEAP32[$encSizeBytes$addr >> 2] = $encSizeBytes;
 HEAP32[$ret >> 2] = 0;
 HEAP32[HEAP32[$encSizeBytes$addr >> 2] >> 2] = 20208;
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function _silk_Get_Decoder_Size($decSizeBytes) {
 $decSizeBytes = $decSizeBytes | 0;
 var $decSizeBytes$addr = 0, $ret = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $decSizeBytes$addr = sp + 4 | 0;
 $ret = sp;
 HEAP32[$decSizeBytes$addr >> 2] = $decSizeBytes;
 HEAP32[$ret >> 2] = 0;
 HEAP32[HEAP32[$decSizeBytes$addr >> 2] >> 2] = 8552;
 STACKTOP = sp;
 return HEAP32[$ret >> 2] | 0;
}

function __Znwj($size) {
 $size = $size | 0;
 var $$size = 0, $call = 0, $call$lcssa = 0, $call2 = 0;
 $$size = ($size | 0) == 0 ? 1 : $size;
 while (1) {
  $call = _malloc($$size) | 0;
  if ($call | 0) {
   $call$lcssa = $call;
   break;
  }
  $call2 = __ZSt15get_new_handlerv() | 0;
  if (!$call2) {
   $call$lcssa = 0;
   break;
  }
  FUNCTION_TABLE_v[$call2 & 0]();
 }
 return $call$lcssa | 0;
}

function _get_pulses($i) {
 $i = $i | 0;
 var $1 = 0, $cond = 0, $i$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $i$addr = sp;
 HEAP32[$i$addr >> 2] = $i;
 $1 = HEAP32[$i$addr >> 2] | 0;
 if ((HEAP32[$i$addr >> 2] | 0) < 8) {
  $cond = $1;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 8 + ($1 & 7) << (HEAP32[$i$addr >> 2] >> 3) - 1;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_559($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_553($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_547($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_527($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_487($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_457($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_436($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_427($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_420($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_343($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_277($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_CLZ32_235($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_max_16($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 2 | 0;
 $b$addr = sp;
 HEAP16[$a$addr >> 1] = $a;
 HEAP16[$b$addr >> 1] = $b;
 STACKTOP = sp;
 return ((HEAP16[$a$addr >> 1] | 0) > (HEAP16[$b$addr >> 1] | 0) ? HEAP16[$a$addr >> 1] | 0 : HEAP16[$b$addr >> 1] | 0) & 65535 | 0;
}

function _silk_CLZ32($in32) {
 $in32 = $in32 | 0;
 var $cond = 0, $in32$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $in32$addr = sp;
 HEAP32[$in32$addr >> 2] = $in32;
 if (!(HEAP32[$in32$addr >> 2] | 0)) {
  $cond = 32;
  STACKTOP = sp;
  return $cond | 0;
 }
 $cond = 32 - (32 - (Math_clz32(HEAP32[$in32$addr >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $cond | 0;
}

function _silk_min_int_500($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_int_451($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_int_433($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_int_423($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_int_407($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_int_340($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_int_329($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_int_287($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_int_499($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_int_495($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_int_459($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_int_432($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_int_410($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_int_328($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_int_274($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_int_232($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}
function _silk_min_int_496($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_32_470($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_32_434($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_32_528($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_32_448($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_int($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_int($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_min_32($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) < (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _silk_max_32($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $a$addr = 0, $b$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $a$addr = sp + 4 | 0;
 $b$addr = sp;
 HEAP32[$a$addr >> 2] = $a;
 HEAP32[$b$addr >> 2] = $b;
 STACKTOP = sp;
 return ((HEAP32[$a$addr >> 2] | 0) > (HEAP32[$b$addr >> 2] | 0) ? HEAP32[$a$addr >> 2] | 0 : HEAP32[$b$addr >> 2] | 0) | 0;
}

function _ec_tell_286($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $sub1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 $sub1 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] | 0) - (32 - (Math_clz32(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $sub1 | 0;
}

function _ec_tell_157($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $sub1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 $sub1 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] | 0) - (32 - (Math_clz32(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $sub1 | 0;
}

function _ec_tell_123($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $sub1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 $sub1 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] | 0) - (32 - (Math_clz32(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $sub1 | 0;
}

function _ec_tell_64($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $sub1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 $sub1 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] | 0) - (32 - (Math_clz32(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $sub1 | 0;
}

function _ec_tell_54($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $sub1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 $sub1 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] | 0) - (32 - (Math_clz32(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $sub1 | 0;
}

function _ec_tell_13($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $sub1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 $sub1 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] | 0) - (32 - (Math_clz32(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $sub1 | 0;
}

function _ec_tell($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, $sub1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 $sub1 = (HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 20 >> 2] | 0) - (32 - (Math_clz32(HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 28 >> 2] | 0) | 0)) | 0;
 STACKTOP = sp;
 return $sub1 | 0;
}

function _celt_udiv_365($n, $d) {
 $n = $n | 0;
 $d = $d | 0;
 var $d$addr = 0, $n$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $n$addr = sp + 4 | 0;
 $d$addr = sp;
 HEAP32[$n$addr >> 2] = $n;
 HEAP32[$d$addr >> 2] = $d;
 STACKTOP = sp;
 return ((HEAP32[$n$addr >> 2] | 0) >>> 0) / ((HEAP32[$d$addr >> 2] | 0) >>> 0) | 0 | 0;
}

function _celt_udiv_139($n, $d) {
 $n = $n | 0;
 $d = $d | 0;
 var $d$addr = 0, $n$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $n$addr = sp + 4 | 0;
 $d$addr = sp;
 HEAP32[$n$addr >> 2] = $n;
 HEAP32[$d$addr >> 2] = $d;
 STACKTOP = sp;
 return ((HEAP32[$n$addr >> 2] | 0) >>> 0) / ((HEAP32[$d$addr >> 2] | 0) >>> 0) | 0 | 0;
}

function _celt_udiv_138($n, $d) {
 $n = $n | 0;
 $d = $d | 0;
 var $d$addr = 0, $n$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $n$addr = sp + 4 | 0;
 $d$addr = sp;
 HEAP32[$n$addr >> 2] = $n;
 HEAP32[$d$addr >> 2] = $d;
 STACKTOP = sp;
 return ((HEAP32[$n$addr >> 2] | 0) >>> 0) / ((HEAP32[$d$addr >> 2] | 0) >>> 0) | 0 | 0;
}

function _celt_udiv_110($n, $d) {
 $n = $n | 0;
 $d = $d | 0;
 var $d$addr = 0, $n$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $n$addr = sp + 4 | 0;
 $d$addr = sp;
 HEAP32[$n$addr >> 2] = $n;
 HEAP32[$d$addr >> 2] = $d;
 STACKTOP = sp;
 return ((HEAP32[$n$addr >> 2] | 0) >>> 0) / ((HEAP32[$d$addr >> 2] | 0) >>> 0) | 0 | 0;
}

function _celt_udiv_83($n, $d) {
 $n = $n | 0;
 $d = $d | 0;
 var $d$addr = 0, $n$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $n$addr = sp + 4 | 0;
 $d$addr = sp;
 HEAP32[$n$addr >> 2] = $n;
 HEAP32[$d$addr >> 2] = $d;
 STACKTOP = sp;
 return ((HEAP32[$n$addr >> 2] | 0) >>> 0) / ((HEAP32[$d$addr >> 2] | 0) >>> 0) | 0 | 0;
}

function _celt_udiv($n, $d) {
 $n = $n | 0;
 $d = $d | 0;
 var $d$addr = 0, $n$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $n$addr = sp + 4 | 0;
 $d$addr = sp;
 HEAP32[$n$addr >> 2] = $n;
 HEAP32[$d$addr >> 2] = $d;
 STACKTOP = sp;
 return ((HEAP32[$n$addr >> 2] | 0) >>> 0) / ((HEAP32[$d$addr >> 2] | 0) >>> 0) | 0 | 0;
}

function _codec_opus_decode($handle, $buffer, $length, $maxLength) {
 $handle = $handle | 0;
 $buffer = $buffer | 0;
 $length = $length | 0;
 $maxLength = $maxLength | 0;
 return _opus_decode_float(HEAP32[$handle + 16 >> 2] | 0, $buffer, $length, $buffer, ($maxLength >>> 2 >>> 0) / ((HEAP32[$handle + 20 >> 2] | 0) >>> 0) | 0, 0) | 0;
}

function _celt_sudiv($n, $d) {
 $n = $n | 0;
 $d = $d | 0;
 var $d$addr = 0, $n$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $n$addr = sp + 4 | 0;
 $d$addr = sp;
 HEAP32[$n$addr >> 2] = $n;
 HEAP32[$d$addr >> 2] = $d;
 STACKTOP = sp;
 return (HEAP32[$n$addr >> 2] | 0) / (HEAP32[$d$addr >> 2] | 0) | 0 | 0;
}

function _codec_opus_encode($handle, $buffer, $length, $maxLength) {
 $handle = $handle | 0;
 $buffer = $buffer | 0;
 $length = $length | 0;
 $maxLength = $maxLength | 0;
 return _opus_encode_float(HEAP32[$handle + 12 >> 2] | 0, $buffer, ($length >>> 0) / ((HEAP32[$handle + 20 >> 2] | 0) >>> 0) | 0, $buffer, $maxLength) | 0;
}

function _celt_lcg_rand($seed) {
 $seed = $seed | 0;
 var $add = 0, $seed$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $seed$addr = sp;
 HEAP32[$seed$addr >> 2] = $seed;
 $add = (Math_imul(1664525, HEAP32[$seed$addr >> 2] | 0) | 0) + 1013904223 | 0;
 STACKTOP = sp;
 return $add | 0;
}

function __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKc($this, $__s) {
 $this = $this | 0;
 $__s = $__s | 0;
 return __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6assignEPKcj($this, $__s, __ZNSt3__211char_traitsIcE6lengthEPKc($__s) | 0) | 0;
}

function _opus_packet_get_nb_channels($data) {
 $data = $data | 0;
 var $data$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $data$addr = sp;
 HEAP32[$data$addr >> 2] = $data;
 STACKTOP = sp;
 return ((HEAPU8[HEAP32[$data$addr >> 2] >> 0] | 0) & 4 | 0 ? 2 : 1) | 0;
}

function _bitshift64Ashr(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 if ((bits | 0) < 32) {
  tempRet0 = high >> bits;
  return low >>> bits | (high & (1 << bits) - 1) << 32 - bits;
 }
 tempRet0 = (high | 0) < 0 ? -1 : 0;
 return high >> bits - 32 | 0;
}

function _opus_repacketizer_init($rp) {
 $rp = $rp | 0;
 var $rp$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $rp$addr = sp;
 HEAP32[$rp$addr >> 2] = $rp;
 HEAP32[(HEAP32[$rp$addr >> 2] | 0) + 4 >> 2] = 0;
 STACKTOP = sp;
 return HEAP32[$rp$addr >> 2] | 0;
}

function _opus_alloc_10($size) {
 $size = $size | 0;
 var $call = 0, $size$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $size$addr = sp;
 HEAP32[$size$addr >> 2] = $size;
 $call = _malloc(HEAP32[$size$addr >> 2] | 0) | 0;
 STACKTOP = sp;
 return $call | 0;
}

function _opus_alloc($size) {
 $size = $size | 0;
 var $call = 0, $size$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $size$addr = sp;
 HEAP32[$size$addr >> 2] = $size;
 $call = _malloc(HEAP32[$size$addr >> 2] | 0) | 0;
 STACKTOP = sp;
 return $call | 0;
}

function dynCall_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 a5 = a5 | 0;
 a6 = a6 | 0;
 a7 = a7 | 0;
 FUNCTION_TABLE_viiiiiii[index & 1](a1 | 0, a2 | 0, a3 | 0, a4 | 0, a5 | 0, a6 | 0, a7 | 0);
}

function _silk_sigmoid_302($x) {
 $x = +$x;
 var $conv1 = 0.0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $x$addr = sp;
 HEAPF32[$x$addr >> 2] = $x;
 $conv1 = 1.0 / (+Math_exp(+-+HEAPF32[$x$addr >> 2]) + 1.0);
 STACKTOP = sp;
 return +$conv1;
}

function _ec_get_error_68($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 STACKTOP = sp;
 return HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 44 >> 2] | 0;
}

function _ec_range_bytes($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 STACKTOP = sp;
 return HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 24 >> 2] | 0;
}

function _sigmoid_approx($x) {
 $x = +$x;
 var $add = 0.0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $x$addr = sp;
 HEAPF32[$x$addr >> 2] = $x;
 $add = +_tansig_approx(+HEAPF32[$x$addr >> 2] * .5) * .5 + .5;
 STACKTOP = sp;
 return +$add;
}

function _silk_sigmoid($x) {
 $x = +$x;
 var $conv1 = 0.0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $x$addr = sp;
 HEAPF32[$x$addr >> 2] = $x;
 $conv1 = 1.0 / (+Math_exp(+-+HEAPF32[$x$addr >> 2]) + 1.0);
 STACKTOP = sp;
 return +$conv1;
}

function _ec_get_error($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 STACKTOP = sp;
 return HEAP32[(HEAP32[$_this$addr >> 2] | 0) + 44 >> 2] | 0;
}

function _silk_log2_327($x) {
 $x = +$x;
 var $conv = 0.0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $x$addr = sp;
 HEAPF64[$x$addr >> 3] = $x;
 $conv = +_log10(+HEAPF64[$x$addr >> 3]) * 3.32192809488736;
 STACKTOP = sp;
 return +$conv;
}

function _silk_log2($x) {
 $x = +$x;
 var $conv = 0.0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $x$addr = sp;
 HEAPF64[$x$addr >> 3] = $x;
 $conv = +_log10(+HEAPF64[$x$addr >> 3]) * 3.32192809488736;
 STACKTOP = sp;
 return +$conv;
}

function dynCall_viiiiddd(index, a1, a2, a3, a4, a5, a6, a7) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 a5 = +a5;
 a6 = +a6;
 a7 = +a7;
 FUNCTION_TABLE_viiiiddd[index & 0](a1 | 0, a2 | 0, a3 | 0, a4 | 0, +a5, +a6, +a7);
}

function _ec_get_buffer($_this) {
 $_this = $_this | 0;
 var $_this$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $_this$addr = sp;
 HEAP32[$_this$addr >> 2] = $_this;
 STACKTOP = sp;
 return HEAP32[HEAP32[$_this$addr >> 2] >> 2] | 0;
}

function _silk_float2int($x) {
 $x = +$x;
 var $call = 0, $x$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $x$addr = sp;
 HEAPF32[$x$addr >> 2] = $x;
 $call = _lrintf(+HEAPF32[$x$addr >> 2]) | 0;
 STACKTOP = sp;
 return $call | 0;
}

function dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 a5 = a5 | 0;
 a6 = a6 | 0;
 FUNCTION_TABLE_viiiiii[index & 0](a1 | 0, a2 | 0, a3 | 0, a4 | 0, a5 | 0, a6 | 0);
}

function _opus_encoder_destroy($st) {
 $st = $st | 0;
 var $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $st$addr = sp;
 HEAP32[$st$addr >> 2] = $st;
 _opus_free_11(HEAP32[$st$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _cpuid($CPUInfo, $InfoType) {
 $CPUInfo = $CPUInfo | 0;
 $InfoType = $InfoType | 0;
 var sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 HEAP32[sp + 4 >> 2] = $CPUInfo;
 HEAP32[sp >> 2] = $InfoType;
 STACKTOP = sp;
 return;
}

function _opus_decoder_destroy($st) {
 $st = $st | 0;
 var $st$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $st$addr = sp;
 HEAP32[$st$addr >> 2] = $st;
 _opus_free(HEAP32[$st$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _opus_free_11($ptr) {
 $ptr = $ptr | 0;
 var $ptr$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ptr$addr = sp;
 HEAP32[$ptr$addr >> 2] = $ptr;
 _free(HEAP32[$ptr$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function _opus_free($ptr) {
 $ptr = $ptr | 0;
 var $ptr$addr = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ptr$addr = sp;
 HEAP32[$ptr$addr >> 2] = $ptr;
 _free(HEAP32[$ptr$addr >> 2] | 0);
 STACKTOP = sp;
 return;
}

function dynCall_diiiii(index, a1, a2, a3, a4, a5) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 a5 = a5 | 0;
 return +FUNCTION_TABLE_diiiii[index & 0](a1 | 0, a2 | 0, a3 | 0, a4 | 0, a5 | 0);
}

function __ZNSt3__211char_traitsIcE4moveEPcPKcj($__s1, $__s2, $__n) {
 $__s1 = $__s1 | 0;
 $__s2 = $__s2 | 0;
 $__n = $__n | 0;
 if ($__n | 0) _memmove($__s1 | 0, $__s2 | 0, $__n | 0) | 0;
 return $__s1 | 0;
}

function __ZNSt3__211char_traitsIcE4copyEPcPKcj($__s1, $__s2, $__n) {
 $__s1 = $__s1 | 0;
 $__s2 = $__s2 | 0;
 $__n = $__n | 0;
 if ($__n | 0) _memcpy($__s1 | 0, $__s2 | 0, $__n | 0) | 0;
 return $__s1 | 0;
}

function dynCall_viiii(index, a1, a2, a3, a4) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 FUNCTION_TABLE_viiii[index & 0](a1 | 0, a2 | 0, a3 | 0, a4 | 0);
}

function _i64Add(a, b, c, d) {
 a = a | 0;
 b = b | 0;
 c = c | 0;
 d = d | 0;
 var l = 0;
 l = a + c >>> 0;
 return (tempRet0 = b + d + (l >>> 0 < a >>> 0 | 0) >>> 0, l | 0) | 0;
}

function dynCall_diii(index, a1, a2, a3) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return +FUNCTION_TABLE_diii[index & 0](a1 | 0, a2 | 0, a3 | 0);
}
function stackAlloc(size) {
 size = size | 0;
 var ret = 0;
 ret = STACKTOP;
 STACKTOP = STACKTOP + size | 0;
 STACKTOP = STACKTOP + 15 & -16;
 return ret | 0;
}

function __ZNSt3__211char_traitsIcE6assignERcRKc($__c1, $__c2) {
 $__c1 = $__c1 | 0;
 $__c2 = $__c2 | 0;
 HEAP8[$__c1 >> 0] = HEAP8[$__c2 >> 0] | 0;
 return;
}

function establishStackSpace(stackBase, stackMax) {
 stackBase = stackBase | 0;
 stackMax = stackMax | 0;
 STACKTOP = stackBase;
 STACK_MAX = stackMax;
}

function b7(p0, p1, p2, p3, p4, p5, p6) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = p4 | 0;
 p5 = p5 | 0;
 p6 = p6 | 0;
 abort(7);
}

function dynCall_iii(index, a1, a2) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 return FUNCTION_TABLE_iii[index & 3](a1 | 0, a2 | 0) | 0;
}

function b5(p0, p1, p2, p3, p4, p5, p6) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = +p4;
 p5 = +p5;
 p6 = +p6;
 abort(5);
}

function setThrew(threw, value) {
 threw = threw | 0;
 value = value | 0;
 if (!__THREW__) {
  __THREW__ = threw;
  threwValue = value;
 }
}

function b6(p0, p1, p2, p3, p4, p5) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = p4 | 0;
 p5 = p5 | 0;
 abort(6);
}

function b1(p0, p1, p2, p3, p4) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = p4 | 0;
 abort(1);
 return 0.0;
}

function __ZNKSt3__221__basic_string_commonILb1EE20__throw_length_errorEv($this) {
 $this = $this | 0;
 _abort();
}

function __ZSt15get_new_handlerv() {
 var $0 = 0;
 $0 = HEAP32[9e3] | 0;
 HEAP32[9e3] = $0 + 0;
 return $0 | 0;
}

function _rintf(f) {
 f = +f;
 return f - +Math_floor(f) != .5 ? +_round(f) : +_round(f / 2.0) * 2.0;
}

function __ZNSt3__211char_traitsIcE6lengthEPKc($__s) {
 $__s = $__s | 0;
 return _strlen($__s) | 0;
}

function b4(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 abort(4);
}

function b0(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 abort(0);
 return 0.0;
}

function _round(d) {
 d = +d;
 return d >= 0.0 ? +Math_floor(d + .5) : +Math_ceil(d - .5);
}

function dynCall_v(index) {
 index = index | 0;
 FUNCTION_TABLE_v[index & 0]();
}

function b2(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 abort(2);
 return 0;
}

function setTempRet0(value) {
 value = value | 0;
 tempRet0 = value;
}

function __ZdlPv($ptr) {
 $ptr = $ptr | 0;
 _free($ptr);
 return;
}

function stackRestore(top) {
 top = top | 0;
 STACKTOP = top;
}

function _lrintf($x) {
 $x = +$x;
 return ~~+_rintf(+$x) | 0;
}

function getTempRet0() {
 return tempRet0 | 0;
}

function ___errno_location() {
 return 35996;
}

function stackSave() {
 return STACKTOP | 0;
}

function __opus_false() {
 return 0;
}

function b3() {
 abort(3);
}

// EMSCRIPTEN_END_FUNCS
var FUNCTION_TABLE_diii = [b0];
var FUNCTION_TABLE_diiiii = [b1];
var FUNCTION_TABLE_iii = [b2,_silk_VAD_GetSA_Q8_c,_silk_VAD_GetSA_Q8_sse4_1,b2];
var FUNCTION_TABLE_v = [b3];
var FUNCTION_TABLE_viiii = [b4];
var FUNCTION_TABLE_viiiiddd = [b5];
var FUNCTION_TABLE_viiiiii = [b6];
var FUNCTION_TABLE_viiiiiii = [b7,_downmix_float];

  return { ___errno_location: ___errno_location, ___muldi3: ___muldi3, _bitshift64Ashr: _bitshift64Ashr, _codec_opus_changeApplication: _codec_opus_changeApplication, _codec_opus_createNativeHandle: _codec_opus_createNativeHandle, _codec_opus_decode: _codec_opus_decode, _codec_opus_deleteNativeHandle: _codec_opus_deleteNativeHandle, _codec_opus_encode: _codec_opus_encode, _free: _free, _i64Add: _i64Add, _malloc: _malloc, _memcpy: _memcpy, _memmove: _memmove, _memset: _memset, _rintf: _rintf, _sbrk: _sbrk, dynCall_diii: dynCall_diii, dynCall_diiiii: dynCall_diiiii, dynCall_iii: dynCall_iii, dynCall_v: dynCall_v, dynCall_viiii: dynCall_viiii, dynCall_viiiiddd: dynCall_viiiiddd, dynCall_viiiiii: dynCall_viiiiii, dynCall_viiiiiii: dynCall_viiiiiii, establishStackSpace: establishStackSpace, getTempRet0: getTempRet0, runPostSets: runPostSets, setTempRet0: setTempRet0, setThrew: setThrew, stackAlloc: stackAlloc, stackRestore: stackRestore, stackSave: stackSave };
})
// EMSCRIPTEN_END_ASM
(Module.asmGlobalArg, Module.asmLibraryArg, buffer);

var ___errno_location = Module["___errno_location"] = asm["___errno_location"];
var ___muldi3 = Module["___muldi3"] = asm["___muldi3"];
var _bitshift64Ashr = Module["_bitshift64Ashr"] = asm["_bitshift64Ashr"];
var _codec_opus_changeApplication = Module["_codec_opus_changeApplication"] = asm["_codec_opus_changeApplication"];
var _codec_opus_createNativeHandle = Module["_codec_opus_createNativeHandle"] = asm["_codec_opus_createNativeHandle"];
var _codec_opus_decode = Module["_codec_opus_decode"] = asm["_codec_opus_decode"];
var _codec_opus_deleteNativeHandle = Module["_codec_opus_deleteNativeHandle"] = asm["_codec_opus_deleteNativeHandle"];
var _codec_opus_encode = Module["_codec_opus_encode"] = asm["_codec_opus_encode"];
var _free = Module["_free"] = asm["_free"];
var _i64Add = Module["_i64Add"] = asm["_i64Add"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _memmove = Module["_memmove"] = asm["_memmove"];
var _memset = Module["_memset"] = asm["_memset"];
var _rintf = Module["_rintf"] = asm["_rintf"];
var _sbrk = Module["_sbrk"] = asm["_sbrk"];
var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
var getTempRet0 = Module["getTempRet0"] = asm["getTempRet0"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var setTempRet0 = Module["setTempRet0"] = asm["setTempRet0"];
var setThrew = Module["setThrew"] = asm["setThrew"];
var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
var stackRestore = Module["stackRestore"] = asm["stackRestore"];
var stackSave = Module["stackSave"] = asm["stackSave"];
var dynCall_diii = Module["dynCall_diii"] = asm["dynCall_diii"];
var dynCall_diiiii = Module["dynCall_diiiii"] = asm["dynCall_diiiii"];
var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];
var dynCall_v = Module["dynCall_v"] = asm["dynCall_v"];
var dynCall_viiii = Module["dynCall_viiii"] = asm["dynCall_viiii"];
var dynCall_viiiiddd = Module["dynCall_viiiiddd"] = asm["dynCall_viiiiddd"];
var dynCall_viiiiii = Module["dynCall_viiiiii"] = asm["dynCall_viiiiii"];
var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = asm["dynCall_viiiiiii"];
;



// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;



Module["ccall"] = ccall;
Module["cwrap"] = cwrap;





























































if (memoryInitializer) {
  if (!isDataURI(memoryInitializer)) {
    if (typeof Module['locateFile'] === 'function') {
      memoryInitializer = Module['locateFile'](memoryInitializer);
    } else if (Module['memoryInitializerPrefixURL']) {
      memoryInitializer = Module['memoryInitializerPrefixURL'] + memoryInitializer;
    }
  }
  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
    var data = Module['readBinary'](memoryInitializer);
    HEAPU8.set(data, GLOBAL_BASE);
  } else {
    addRunDependency('memory initializer');
    var applyMemoryInitializer = function(data) {
      if (data.byteLength) data = new Uint8Array(data);
      HEAPU8.set(data, GLOBAL_BASE);
      // Delete the typed array that contains the large blob of the memory initializer request response so that
      // we won't keep unnecessary memory lying around. However, keep the XHR object itself alive so that e.g.
      // its .status field can still be accessed later.
      if (Module['memoryInitializerRequest']) delete Module['memoryInitializerRequest'].response;
      removeRunDependency('memory initializer');
    }
    function doBrowserLoad() {
      Module['readAsync'](memoryInitializer, applyMemoryInitializer, function() {
        throw 'could not load memory initializer ' + memoryInitializer;
      });
    }
    if (Module['memoryInitializerRequest']) {
      // a network request has already been created, just use that
      function useRequest() {
        var request = Module['memoryInitializerRequest'];
        var response = request.response;
        if (request.status !== 200 && request.status !== 0) {
            // If you see this warning, the issue may be that you are using locateFile or memoryInitializerPrefixURL, and defining them in JS. That
            // means that the HTML file doesn't know about them, and when it tries to create the mem init request early, does it to the wrong place.
            // Look in your browser's devtools network console to see what's going on.
            console.warn('a problem seems to have happened with Module.memoryInitializerRequest, status: ' + request.status + ', retrying ' + memoryInitializer);
            doBrowserLoad();
            return;
        }
        applyMemoryInitializer(response);
      }
      if (Module['memoryInitializerRequest'].response) {
        setTimeout(useRequest, 0); // it's already here; but, apply it asynchronously
      } else {
        Module['memoryInitializerRequest'].addEventListener('load', useRequest); // wait for it
      }
    } else {
      // fetch it from the network ourselves
      doBrowserLoad();
    }
  }
}



/**
 * @constructor
 * @extends {Error}
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var initialStackTop;
var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun']) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}





/** @type {function(Array=)} */
function run(args) {
  args = args || Module['arguments'];

  if (runDependencies > 0) {
    return;
  }


  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return;

    ensureInitRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();


    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = run;


function exit(status, implicit) {

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && Module['noExitRuntime'] && status === 0) {
    return;
  }

  if (Module['noExitRuntime']) {
  } else {

    ABORT = true;
    EXITSTATUS = status;
    STACKTOP = initialStackTop;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  if (ENVIRONMENT_IS_NODE) {
    process['exit'](status);
  }
  Module['quit'](status, new ExitStatus(status));
}
Module['exit'] = exit;

var abortDecorators = [];

function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  if (what !== undefined) {
    Module.print(what);
    Module.printErr(what);
    what = JSON.stringify(what)
  } else {
    what = '';
  }

  ABORT = true;
  EXITSTATUS = 1;

  throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';
}
Module['abort'] = abort;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}


Module["noExitRuntime"] = true;

run();

// {{POST_RUN_ADDITIONS}}





// {{MODULE_ADDITIONS}}






